// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/api/corepb/v1/cp_edge.proto

package corepb

import (
	bytes "bytes"
	fmt "fmt"
	typespb "gimletlabs.ai/gimlet/src/common/typespb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "go.opentelemetry.io/proto/otlp/metrics/v1"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExecutionGraphState int32

const (
	EXECUTION_GRAPH_STATE_UNKNOWN          ExecutionGraphState = 0
	EXECUTION_GRAPH_STATE_UPDATE_REQUESTED ExecutionGraphState = 10
	EXECUTION_GRAPH_STATE_DOWNLOADING      ExecutionGraphState = 20
	EXECUTION_GRAPH_STATE_COMPILING        ExecutionGraphState = 30
	EXECUTION_GRAPH_STATE_READY            ExecutionGraphState = 40
	EXECUTION_GRAPH_STATE_DEPLOYED         ExecutionGraphState = 50
	EXECUTION_GRAPH_STATE_TERMINATING      ExecutionGraphState = 60
	EXECUTION_GRAPH_STATE_FAILED           ExecutionGraphState = 100
)

var ExecutionGraphState_name = map[int32]string{
	0:   "EXECUTION_GRAPH_STATE_UNKNOWN",
	10:  "EXECUTION_GRAPH_STATE_UPDATE_REQUESTED",
	20:  "EXECUTION_GRAPH_STATE_DOWNLOADING",
	30:  "EXECUTION_GRAPH_STATE_COMPILING",
	40:  "EXECUTION_GRAPH_STATE_READY",
	50:  "EXECUTION_GRAPH_STATE_DEPLOYED",
	60:  "EXECUTION_GRAPH_STATE_TERMINATING",
	100: "EXECUTION_GRAPH_STATE_FAILED",
}

var ExecutionGraphState_value = map[string]int32{
	"EXECUTION_GRAPH_STATE_UNKNOWN":          0,
	"EXECUTION_GRAPH_STATE_UPDATE_REQUESTED": 10,
	"EXECUTION_GRAPH_STATE_DOWNLOADING":      20,
	"EXECUTION_GRAPH_STATE_COMPILING":        30,
	"EXECUTION_GRAPH_STATE_READY":            40,
	"EXECUTION_GRAPH_STATE_DEPLOYED":         50,
	"EXECUTION_GRAPH_STATE_TERMINATING":      60,
	"EXECUTION_GRAPH_STATE_FAILED":           100,
}

func (ExecutionGraphState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{0}
}

type EdgeCPTopic int32

const (
	EDGE_CP_TOPIC_UNKNOWN       EdgeCPTopic = 0
	EDGE_CP_TOPIC_STATUS        EdgeCPTopic = 1
	EDGE_CP_TOPIC_VIDEO         EdgeCPTopic = 2
	EDGE_CP_TOPIC_EXEC          EdgeCPTopic = 3
	EDGE_CP_TOPIC_METRICS       EdgeCPTopic = 4
	EDGE_CP_TOPIC_FILE_TRANSFER EdgeCPTopic = 5
	EDGE_CP_TOPIC_INFO          EdgeCPTopic = 6
)

var EdgeCPTopic_name = map[int32]string{
	0: "EDGE_CP_TOPIC_UNKNOWN",
	1: "EDGE_CP_TOPIC_STATUS",
	2: "EDGE_CP_TOPIC_VIDEO",
	3: "EDGE_CP_TOPIC_EXEC",
	4: "EDGE_CP_TOPIC_METRICS",
	5: "EDGE_CP_TOPIC_FILE_TRANSFER",
	6: "EDGE_CP_TOPIC_INFO",
}

var EdgeCPTopic_value = map[string]int32{
	"EDGE_CP_TOPIC_UNKNOWN":       0,
	"EDGE_CP_TOPIC_STATUS":        1,
	"EDGE_CP_TOPIC_VIDEO":         2,
	"EDGE_CP_TOPIC_EXEC":          3,
	"EDGE_CP_TOPIC_METRICS":       4,
	"EDGE_CP_TOPIC_FILE_TRANSFER": 5,
	"EDGE_CP_TOPIC_INFO":          6,
}

func (EdgeCPTopic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{1}
}

type CPEdgeTopic int32

const (
	CP_EDGE_TOPIC_UNKNOWN       CPEdgeTopic = 0
	CP_EDGE_TOPIC_STATUS        CPEdgeTopic = 1
	CP_EDGE_TOPIC_VIDEO         CPEdgeTopic = 2
	CP_EDGE_TOPIC_EXEC          CPEdgeTopic = 3
	CP_EDGE_TOPIC_METRICS       CPEdgeTopic = 4
	CP_EDGE_TOPIC_FILE_TRANSFER CPEdgeTopic = 5
	CP_EDGE_TOPIC_INFO          CPEdgeTopic = 6
)

var CPEdgeTopic_name = map[int32]string{
	0: "CP_EDGE_TOPIC_UNKNOWN",
	1: "CP_EDGE_TOPIC_STATUS",
	2: "CP_EDGE_TOPIC_VIDEO",
	3: "CP_EDGE_TOPIC_EXEC",
	4: "CP_EDGE_TOPIC_METRICS",
	5: "CP_EDGE_TOPIC_FILE_TRANSFER",
	6: "CP_EDGE_TOPIC_INFO",
}

var CPEdgeTopic_value = map[string]int32{
	"CP_EDGE_TOPIC_UNKNOWN":       0,
	"CP_EDGE_TOPIC_STATUS":        1,
	"CP_EDGE_TOPIC_VIDEO":         2,
	"CP_EDGE_TOPIC_EXEC":          3,
	"CP_EDGE_TOPIC_METRICS":       4,
	"CP_EDGE_TOPIC_FILE_TRANSFER": 5,
	"CP_EDGE_TOPIC_INFO":          6,
}

func (CPEdgeTopic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{2}
}

type DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType int32

const (
	MODEL_RUNTIME_TYPE_UNKNOWN  DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType = 0
	MODEL_RUNTIME_TYPE_TENSORRT DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType = 1
	MODEL_RUNTIME_TYPE_OPENVINO DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType = 2
)

var DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType_name = map[int32]string{
	0: "MODEL_RUNTIME_TYPE_UNKNOWN",
	1: "MODEL_RUNTIME_TYPE_TENSORRT",
	2: "MODEL_RUNTIME_TYPE_OPENVINO",
}

var DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType_value = map[string]int32{
	"MODEL_RUNTIME_TYPE_UNKNOWN":  0,
	"MODEL_RUNTIME_TYPE_TENSORRT": 1,
	"MODEL_RUNTIME_TYPE_OPENVINO": 2,
}

func (DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17, 0, 0}
}

type DeviceCapabilities_CameraInfo_CameraDriver int32

const (
	CAMERA_DRIVER_UNKNOWN DeviceCapabilities_CameraInfo_CameraDriver = 0
	CAMERA_DRIVER_ARGUS   DeviceCapabilities_CameraInfo_CameraDriver = 1
	CAMERA_DRIVER_V4L2    DeviceCapabilities_CameraInfo_CameraDriver = 2
)

var DeviceCapabilities_CameraInfo_CameraDriver_name = map[int32]string{
	0: "CAMERA_DRIVER_UNKNOWN",
	1: "CAMERA_DRIVER_ARGUS",
	2: "CAMERA_DRIVER_V4L2",
}

var DeviceCapabilities_CameraInfo_CameraDriver_value = map[string]int32{
	"CAMERA_DRIVER_UNKNOWN": 0,
	"CAMERA_DRIVER_ARGUS":   1,
	"CAMERA_DRIVER_V4L2":    2,
}

func (DeviceCapabilities_CameraInfo_CameraDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17, 1, 0}
}

type EdgeHeartbeat struct {
	SeqID int64 `protobuf:"varint,1,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
}

func (m *EdgeHeartbeat) Reset()      { *m = EdgeHeartbeat{} }
func (*EdgeHeartbeat) ProtoMessage() {}
func (*EdgeHeartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{0}
}
func (m *EdgeHeartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeHeartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeHeartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeHeartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeHeartbeat.Merge(m, src)
}
func (m *EdgeHeartbeat) XXX_Size() int {
	return m.Size()
}
func (m *EdgeHeartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeHeartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeHeartbeat proto.InternalMessageInfo

func (m *EdgeHeartbeat) GetSeqID() int64 {
	if m != nil {
		return m.SeqID
	}
	return 0
}

type EdgeHeartbeatAck struct {
	SeqID int64 `protobuf:"varint,1,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
}

func (m *EdgeHeartbeatAck) Reset()      { *m = EdgeHeartbeatAck{} }
func (*EdgeHeartbeatAck) ProtoMessage() {}
func (*EdgeHeartbeatAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{1}
}
func (m *EdgeHeartbeatAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeHeartbeatAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeHeartbeatAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeHeartbeatAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeHeartbeatAck.Merge(m, src)
}
func (m *EdgeHeartbeatAck) XXX_Size() int {
	return m.Size()
}
func (m *EdgeHeartbeatAck) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeHeartbeatAck.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeHeartbeatAck proto.InternalMessageInfo

func (m *EdgeHeartbeatAck) GetSeqID() int64 {
	if m != nil {
		return m.SeqID
	}
	return 0
}

type PhysicalPipelineSpecUpdate struct {
	PhysicalPipelineID *typespb.UUID         `protobuf:"bytes,1,opt,name=physical_pipeline_id,json=physicalPipelineId,proto3" json:"physical_pipeline_id,omitempty"`
	Version            int64                 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Spec               *PhysicalPipelineSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *PhysicalPipelineSpecUpdate) Reset()      { *m = PhysicalPipelineSpecUpdate{} }
func (*PhysicalPipelineSpecUpdate) ProtoMessage() {}
func (*PhysicalPipelineSpecUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{2}
}
func (m *PhysicalPipelineSpecUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineSpecUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineSpecUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineSpecUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineSpecUpdate.Merge(m, src)
}
func (m *PhysicalPipelineSpecUpdate) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineSpecUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineSpecUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineSpecUpdate proto.InternalMessageInfo

func (m *PhysicalPipelineSpecUpdate) GetPhysicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.PhysicalPipelineID
	}
	return nil
}

func (m *PhysicalPipelineSpecUpdate) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PhysicalPipelineSpecUpdate) GetSpec() *PhysicalPipelineSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type PhysicalPipelineStatusUpdate struct {
	PhysicalPipelineID *typespb.UUID           `protobuf:"bytes,1,opt,name=physical_pipeline_id,json=physicalPipelineId,proto3" json:"physical_pipeline_id,omitempty"`
	Version            int64                   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Status             *PhysicalPipelineStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PhysicalPipelineStatusUpdate) Reset()      { *m = PhysicalPipelineStatusUpdate{} }
func (*PhysicalPipelineStatusUpdate) ProtoMessage() {}
func (*PhysicalPipelineStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{3}
}
func (m *PhysicalPipelineStatusUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineStatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineStatusUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineStatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineStatusUpdate.Merge(m, src)
}
func (m *PhysicalPipelineStatusUpdate) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineStatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineStatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineStatusUpdate proto.InternalMessageInfo

func (m *PhysicalPipelineStatusUpdate) GetPhysicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.PhysicalPipelineID
	}
	return nil
}

func (m *PhysicalPipelineStatusUpdate) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PhysicalPipelineStatusUpdate) GetStatus() *PhysicalPipelineStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type CPRunModel struct {
}

func (m *CPRunModel) Reset()      { *m = CPRunModel{} }
func (*CPRunModel) ProtoMessage() {}
func (*CPRunModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{4}
}
func (m *CPRunModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPRunModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPRunModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPRunModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPRunModel.Merge(m, src)
}
func (m *CPRunModel) XXX_Size() int {
	return m.Size()
}
func (m *CPRunModel) XXX_DiscardUnknown() {
	xxx_messageInfo_CPRunModel.DiscardUnknown(m)
}

var xxx_messageInfo_CPRunModel proto.InternalMessageInfo

type CPRunModelAck struct {
}

func (m *CPRunModelAck) Reset()      { *m = CPRunModelAck{} }
func (*CPRunModelAck) ProtoMessage() {}
func (*CPRunModelAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{5}
}
func (m *CPRunModelAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPRunModelAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPRunModelAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPRunModelAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPRunModelAck.Merge(m, src)
}
func (m *CPRunModelAck) XXX_Size() int {
	return m.Size()
}
func (m *CPRunModelAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CPRunModelAck.DiscardUnknown(m)
}

var xxx_messageInfo_CPRunModelAck proto.InternalMessageInfo

type ExecutionGraphSpec struct {
	Graph   *ExecutionSpec      `protobuf:"bytes,1,opt,name=graph,proto3" json:"graph,omitempty"`
	State   ExecutionGraphState `protobuf:"varint,2,opt,name=state,proto3,enum=gml.internal.api.core.v1.ExecutionGraphState" json:"state,omitempty"`
	Version int64               `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ExecutionGraphSpec) Reset()      { *m = ExecutionGraphSpec{} }
func (*ExecutionGraphSpec) ProtoMessage() {}
func (*ExecutionGraphSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{6}
}
func (m *ExecutionGraphSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphSpec.Merge(m, src)
}
func (m *ExecutionGraphSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphSpec proto.InternalMessageInfo

func (m *ExecutionGraphSpec) GetGraph() *ExecutionSpec {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ExecutionGraphSpec) GetState() ExecutionGraphState {
	if m != nil {
		return m.State
	}
	return EXECUTION_GRAPH_STATE_UNKNOWN
}

func (m *ExecutionGraphSpec) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ExecutionGraphStatus struct {
	State   ExecutionGraphState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.ExecutionGraphState" json:"state,omitempty"`
	Reason  string              `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	Version int64               `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ExecutionGraphStatus) Reset()      { *m = ExecutionGraphStatus{} }
func (*ExecutionGraphStatus) ProtoMessage() {}
func (*ExecutionGraphStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{7}
}
func (m *ExecutionGraphStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphStatus.Merge(m, src)
}
func (m *ExecutionGraphStatus) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphStatus proto.InternalMessageInfo

func (m *ExecutionGraphStatus) GetState() ExecutionGraphState {
	if m != nil {
		return m.State
	}
	return EXECUTION_GRAPH_STATE_UNKNOWN
}

func (m *ExecutionGraphStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ExecutionGraphStatus) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ApplyExecutionGraph struct {
	PhysicalPipelineID *typespb.UUID       `protobuf:"bytes,1,opt,name=physical_pipeline_id,json=physicalPipelineId,proto3" json:"physical_pipeline_id,omitempty"`
	LogicalPipelineID  *typespb.UUID       `protobuf:"bytes,3,opt,name=logical_pipeline_id,json=logicalPipelineId,proto3" json:"logical_pipeline_id,omitempty"`
	Spec               *ExecutionGraphSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *ApplyExecutionGraph) Reset()      { *m = ApplyExecutionGraph{} }
func (*ApplyExecutionGraph) ProtoMessage() {}
func (*ApplyExecutionGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{8}
}
func (m *ApplyExecutionGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyExecutionGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyExecutionGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyExecutionGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyExecutionGraph.Merge(m, src)
}
func (m *ApplyExecutionGraph) XXX_Size() int {
	return m.Size()
}
func (m *ApplyExecutionGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyExecutionGraph.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyExecutionGraph proto.InternalMessageInfo

func (m *ApplyExecutionGraph) GetPhysicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.PhysicalPipelineID
	}
	return nil
}

func (m *ApplyExecutionGraph) GetLogicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.LogicalPipelineID
	}
	return nil
}

func (m *ApplyExecutionGraph) GetSpec() *ExecutionGraphSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type DeleteExecutionGraph struct {
	PhysicalPipelineID *typespb.UUID `protobuf:"bytes,1,opt,name=physical_pipeline_id,json=physicalPipelineId,proto3" json:"physical_pipeline_id,omitempty"`
}

func (m *DeleteExecutionGraph) Reset()      { *m = DeleteExecutionGraph{} }
func (*DeleteExecutionGraph) ProtoMessage() {}
func (*DeleteExecutionGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{9}
}
func (m *DeleteExecutionGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteExecutionGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteExecutionGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteExecutionGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteExecutionGraph.Merge(m, src)
}
func (m *DeleteExecutionGraph) XXX_Size() int {
	return m.Size()
}
func (m *DeleteExecutionGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteExecutionGraph.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteExecutionGraph proto.InternalMessageInfo

func (m *DeleteExecutionGraph) GetPhysicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.PhysicalPipelineID
	}
	return nil
}

type ExecutionGraphStatusUpdate struct {
	PhysicalPipelineID *typespb.UUID         `protobuf:"bytes,1,opt,name=physical_pipeline_id,json=physicalPipelineId,proto3" json:"physical_pipeline_id,omitempty"`
	Status             *ExecutionGraphStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ExecutionGraphStatusUpdate) Reset()      { *m = ExecutionGraphStatusUpdate{} }
func (*ExecutionGraphStatusUpdate) ProtoMessage() {}
func (*ExecutionGraphStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{10}
}
func (m *ExecutionGraphStatusUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphStatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphStatusUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphStatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphStatusUpdate.Merge(m, src)
}
func (m *ExecutionGraphStatusUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphStatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphStatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphStatusUpdate proto.InternalMessageInfo

func (m *ExecutionGraphStatusUpdate) GetPhysicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.PhysicalPipelineID
	}
	return nil
}

func (m *ExecutionGraphStatusUpdate) GetStatus() *ExecutionGraphStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type VideoStreamStart struct {
}

func (m *VideoStreamStart) Reset()      { *m = VideoStreamStart{} }
func (*VideoStreamStart) ProtoMessage() {}
func (*VideoStreamStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{11}
}
func (m *VideoStreamStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamStart.Merge(m, src)
}
func (m *VideoStreamStart) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamStart) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamStart.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamStart proto.InternalMessageInfo

type VideoStreamStop struct {
}

func (m *VideoStreamStop) Reset()      { *m = VideoStreamStop{} }
func (*VideoStreamStop) ProtoMessage() {}
func (*VideoStreamStop) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{12}
}
func (m *VideoStreamStop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamStop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamStop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamStop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamStop.Merge(m, src)
}
func (m *VideoStreamStop) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamStop) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamStop.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamStop proto.InternalMessageInfo

type VideoStreamKeepAlive struct {
}

func (m *VideoStreamKeepAlive) Reset()      { *m = VideoStreamKeepAlive{} }
func (*VideoStreamKeepAlive) ProtoMessage() {}
func (*VideoStreamKeepAlive) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{13}
}
func (m *VideoStreamKeepAlive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamKeepAlive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamKeepAlive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamKeepAlive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamKeepAlive.Merge(m, src)
}
func (m *VideoStreamKeepAlive) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamKeepAlive) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamKeepAlive.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamKeepAlive proto.InternalMessageInfo

type EdgeOTelMetrics struct {
	ResourceMetrics *v1.ResourceMetrics `protobuf:"bytes,1,opt,name=resource_metrics,json=resourceMetrics,proto3" json:"resource_metrics,omitempty"`
}

func (m *EdgeOTelMetrics) Reset()      { *m = EdgeOTelMetrics{} }
func (*EdgeOTelMetrics) ProtoMessage() {}
func (*EdgeOTelMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{14}
}
func (m *EdgeOTelMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeOTelMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeOTelMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeOTelMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeOTelMetrics.Merge(m, src)
}
func (m *EdgeOTelMetrics) XXX_Size() int {
	return m.Size()
}
func (m *EdgeOTelMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeOTelMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeOTelMetrics proto.InternalMessageInfo

func (m *EdgeOTelMetrics) GetResourceMetrics() *v1.ResourceMetrics {
	if m != nil {
		return m.ResourceMetrics
	}
	return nil
}

type FileTransferRequest struct {
	FileID          *typespb.UUID `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	ChunkStartBytes int64         `protobuf:"varint,2,opt,name=chunk_start_bytes,json=chunkStartBytes,proto3" json:"chunk_start_bytes,omitempty"`
	NumBytes        int64         `protobuf:"varint,3,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *FileTransferRequest) Reset()      { *m = FileTransferRequest{} }
func (*FileTransferRequest) ProtoMessage() {}
func (*FileTransferRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{15}
}
func (m *FileTransferRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferRequest.Merge(m, src)
}
func (m *FileTransferRequest) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferRequest proto.InternalMessageInfo

func (m *FileTransferRequest) GetFileID() *typespb.UUID {
	if m != nil {
		return m.FileID
	}
	return nil
}

func (m *FileTransferRequest) GetChunkStartBytes() int64 {
	if m != nil {
		return m.ChunkStartBytes
	}
	return 0
}

func (m *FileTransferRequest) GetNumBytes() int64 {
	if m != nil {
		return m.NumBytes
	}
	return 0
}

type FileTransferResponse struct {
	Status *typespb.Status                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Chunk  *FileTransferResponse_FileChunk `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
	FileID *typespb.UUID                   `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (m *FileTransferResponse) Reset()      { *m = FileTransferResponse{} }
func (*FileTransferResponse) ProtoMessage() {}
func (*FileTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{16}
}
func (m *FileTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferResponse.Merge(m, src)
}
func (m *FileTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferResponse proto.InternalMessageInfo

func (m *FileTransferResponse) GetStatus() *typespb.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *FileTransferResponse) GetChunk() *FileTransferResponse_FileChunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *FileTransferResponse) GetFileID() *typespb.UUID {
	if m != nil {
		return m.FileID
	}
	return nil
}

type FileTransferResponse_FileChunk struct {
	StartBytes int64  `protobuf:"varint,1,opt,name=start_bytes,json=startBytes,proto3" json:"start_bytes,omitempty"`
	Payload    []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *FileTransferResponse_FileChunk) Reset()      { *m = FileTransferResponse_FileChunk{} }
func (*FileTransferResponse_FileChunk) ProtoMessage() {}
func (*FileTransferResponse_FileChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{16, 0}
}
func (m *FileTransferResponse_FileChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferResponse_FileChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferResponse_FileChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferResponse_FileChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferResponse_FileChunk.Merge(m, src)
}
func (m *FileTransferResponse_FileChunk) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferResponse_FileChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferResponse_FileChunk.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferResponse_FileChunk proto.InternalMessageInfo

func (m *FileTransferResponse_FileChunk) GetStartBytes() int64 {
	if m != nil {
		return m.StartBytes
	}
	return 0
}

func (m *FileTransferResponse_FileChunk) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type DeviceCapabilities struct {
	ModelRuntimes []*DeviceCapabilities_ModelRuntimeInfo `protobuf:"bytes,1,rep,name=model_runtimes,json=modelRuntimes,proto3" json:"model_runtimes,omitempty"`
	Cameras       []*DeviceCapabilities_CameraInfo       `protobuf:"bytes,2,rep,name=cameras,proto3" json:"cameras,omitempty"`
}

func (m *DeviceCapabilities) Reset()      { *m = DeviceCapabilities{} }
func (*DeviceCapabilities) ProtoMessage() {}
func (*DeviceCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17}
}
func (m *DeviceCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceCapabilities.Merge(m, src)
}
func (m *DeviceCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *DeviceCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceCapabilities proto.InternalMessageInfo

func (m *DeviceCapabilities) GetModelRuntimes() []*DeviceCapabilities_ModelRuntimeInfo {
	if m != nil {
		return m.ModelRuntimes
	}
	return nil
}

func (m *DeviceCapabilities) GetCameras() []*DeviceCapabilities_CameraInfo {
	if m != nil {
		return m.Cameras
	}
	return nil
}

type DeviceCapabilities_ModelRuntimeInfo struct {
	Type DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType `protobuf:"varint,1,opt,name=type,proto3,enum=gml.internal.api.core.v1.DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType" json:"type,omitempty"`
}

func (m *DeviceCapabilities_ModelRuntimeInfo) Reset()      { *m = DeviceCapabilities_ModelRuntimeInfo{} }
func (*DeviceCapabilities_ModelRuntimeInfo) ProtoMessage() {}
func (*DeviceCapabilities_ModelRuntimeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17, 0}
}
func (m *DeviceCapabilities_ModelRuntimeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceCapabilities_ModelRuntimeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceCapabilities_ModelRuntimeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceCapabilities_ModelRuntimeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceCapabilities_ModelRuntimeInfo.Merge(m, src)
}
func (m *DeviceCapabilities_ModelRuntimeInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceCapabilities_ModelRuntimeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceCapabilities_ModelRuntimeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceCapabilities_ModelRuntimeInfo proto.InternalMessageInfo

func (m *DeviceCapabilities_ModelRuntimeInfo) GetType() DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType {
	if m != nil {
		return m.Type
	}
	return MODEL_RUNTIME_TYPE_UNKNOWN
}

type DeviceCapabilities_CameraInfo struct {
	Driver   DeviceCapabilities_CameraInfo_CameraDriver `protobuf:"varint,1,opt,name=driver,proto3,enum=gml.internal.api.core.v1.DeviceCapabilities_CameraInfo_CameraDriver" json:"driver,omitempty"`
	CameraID string                                     `protobuf:"bytes,2,opt,name=camera_id,json=cameraId,proto3" json:"camera_id,omitempty"`
}

func (m *DeviceCapabilities_CameraInfo) Reset()      { *m = DeviceCapabilities_CameraInfo{} }
func (*DeviceCapabilities_CameraInfo) ProtoMessage() {}
func (*DeviceCapabilities_CameraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17, 1}
}
func (m *DeviceCapabilities_CameraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceCapabilities_CameraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceCapabilities_CameraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceCapabilities_CameraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceCapabilities_CameraInfo.Merge(m, src)
}
func (m *DeviceCapabilities_CameraInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceCapabilities_CameraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceCapabilities_CameraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceCapabilities_CameraInfo proto.InternalMessageInfo

func (m *DeviceCapabilities_CameraInfo) GetDriver() DeviceCapabilities_CameraInfo_CameraDriver {
	if m != nil {
		return m.Driver
	}
	return CAMERA_DRIVER_UNKNOWN
}

func (m *DeviceCapabilities_CameraInfo) GetCameraID() string {
	if m != nil {
		return m.CameraID
	}
	return ""
}

type EdgeCPMetadata struct {
	Topic         EdgeCPTopic      `protobuf:"varint,1,opt,name=topic,proto3,enum=gml.internal.api.core.v1.EdgeCPTopic" json:"topic,omitempty"`
	DeviceID      *typespb.UUID    `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	RecvTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=recv_timestamp,json=recvTimestamp,proto3" json:"recv_timestamp,omitempty"`
}

func (m *EdgeCPMetadata) Reset()      { *m = EdgeCPMetadata{} }
func (*EdgeCPMetadata) ProtoMessage() {}
func (*EdgeCPMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{18}
}
func (m *EdgeCPMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeCPMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeCPMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeCPMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeCPMetadata.Merge(m, src)
}
func (m *EdgeCPMetadata) XXX_Size() int {
	return m.Size()
}
func (m *EdgeCPMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeCPMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeCPMetadata proto.InternalMessageInfo

func (m *EdgeCPMetadata) GetTopic() EdgeCPTopic {
	if m != nil {
		return m.Topic
	}
	return EDGE_CP_TOPIC_UNKNOWN
}

func (m *EdgeCPMetadata) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *EdgeCPMetadata) GetRecvTimestamp() *types.Timestamp {
	if m != nil {
		return m.RecvTimestamp
	}
	return nil
}

type EdgeCPMessage struct {
	Metadata *EdgeCPMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Msg      *types.Any      `protobuf:"bytes,1000,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *EdgeCPMessage) Reset()      { *m = EdgeCPMessage{} }
func (*EdgeCPMessage) ProtoMessage() {}
func (*EdgeCPMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{19}
}
func (m *EdgeCPMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeCPMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeCPMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeCPMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeCPMessage.Merge(m, src)
}
func (m *EdgeCPMessage) XXX_Size() int {
	return m.Size()
}
func (m *EdgeCPMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeCPMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeCPMessage proto.InternalMessageInfo

func (m *EdgeCPMessage) GetMetadata() *EdgeCPMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *EdgeCPMessage) GetMsg() *types.Any {
	if m != nil {
		return m.Msg
	}
	return nil
}

type CPEdgeMetadata struct {
	Topic         CPEdgeTopic      `protobuf:"varint,1,opt,name=topic,proto3,enum=gml.internal.api.core.v1.CPEdgeTopic" json:"topic,omitempty"`
	DeviceID      *typespb.UUID    `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	RecvTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=recv_timestamp,json=recvTimestamp,proto3" json:"recv_timestamp,omitempty"`
}

func (m *CPEdgeMetadata) Reset()      { *m = CPEdgeMetadata{} }
func (*CPEdgeMetadata) ProtoMessage() {}
func (*CPEdgeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{20}
}
func (m *CPEdgeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPEdgeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPEdgeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPEdgeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPEdgeMetadata.Merge(m, src)
}
func (m *CPEdgeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CPEdgeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CPEdgeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CPEdgeMetadata proto.InternalMessageInfo

func (m *CPEdgeMetadata) GetTopic() CPEdgeTopic {
	if m != nil {
		return m.Topic
	}
	return CP_EDGE_TOPIC_UNKNOWN
}

func (m *CPEdgeMetadata) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *CPEdgeMetadata) GetRecvTimestamp() *types.Timestamp {
	if m != nil {
		return m.RecvTimestamp
	}
	return nil
}

type CPEdgeMessage struct {
	Metadata *CPEdgeMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Msg      *types.Any      `protobuf:"bytes,1000,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CPEdgeMessage) Reset()      { *m = CPEdgeMessage{} }
func (*CPEdgeMessage) ProtoMessage() {}
func (*CPEdgeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{21}
}
func (m *CPEdgeMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPEdgeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPEdgeMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPEdgeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPEdgeMessage.Merge(m, src)
}
func (m *CPEdgeMessage) XXX_Size() int {
	return m.Size()
}
func (m *CPEdgeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CPEdgeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CPEdgeMessage proto.InternalMessageInfo

func (m *CPEdgeMessage) GetMetadata() *CPEdgeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CPEdgeMessage) GetMsg() *types.Any {
	if m != nil {
		return m.Msg
	}
	return nil
}

func init() {
	proto.RegisterEnum("gml.internal.api.core.v1.ExecutionGraphState", ExecutionGraphState_name, ExecutionGraphState_value)
	proto.RegisterEnum("gml.internal.api.core.v1.EdgeCPTopic", EdgeCPTopic_name, EdgeCPTopic_value)
	proto.RegisterEnum("gml.internal.api.core.v1.CPEdgeTopic", CPEdgeTopic_name, CPEdgeTopic_value)
	proto.RegisterEnum("gml.internal.api.core.v1.DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType", DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType_name, DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType_value)
	proto.RegisterEnum("gml.internal.api.core.v1.DeviceCapabilities_CameraInfo_CameraDriver", DeviceCapabilities_CameraInfo_CameraDriver_name, DeviceCapabilities_CameraInfo_CameraDriver_value)
	proto.RegisterType((*EdgeHeartbeat)(nil), "gml.internal.api.core.v1.EdgeHeartbeat")
	proto.RegisterType((*EdgeHeartbeatAck)(nil), "gml.internal.api.core.v1.EdgeHeartbeatAck")
	proto.RegisterType((*PhysicalPipelineSpecUpdate)(nil), "gml.internal.api.core.v1.PhysicalPipelineSpecUpdate")
	proto.RegisterType((*PhysicalPipelineStatusUpdate)(nil), "gml.internal.api.core.v1.PhysicalPipelineStatusUpdate")
	proto.RegisterType((*CPRunModel)(nil), "gml.internal.api.core.v1.CPRunModel")
	proto.RegisterType((*CPRunModelAck)(nil), "gml.internal.api.core.v1.CPRunModelAck")
	proto.RegisterType((*ExecutionGraphSpec)(nil), "gml.internal.api.core.v1.ExecutionGraphSpec")
	proto.RegisterType((*ExecutionGraphStatus)(nil), "gml.internal.api.core.v1.ExecutionGraphStatus")
	proto.RegisterType((*ApplyExecutionGraph)(nil), "gml.internal.api.core.v1.ApplyExecutionGraph")
	proto.RegisterType((*DeleteExecutionGraph)(nil), "gml.internal.api.core.v1.DeleteExecutionGraph")
	proto.RegisterType((*ExecutionGraphStatusUpdate)(nil), "gml.internal.api.core.v1.ExecutionGraphStatusUpdate")
	proto.RegisterType((*VideoStreamStart)(nil), "gml.internal.api.core.v1.VideoStreamStart")
	proto.RegisterType((*VideoStreamStop)(nil), "gml.internal.api.core.v1.VideoStreamStop")
	proto.RegisterType((*VideoStreamKeepAlive)(nil), "gml.internal.api.core.v1.VideoStreamKeepAlive")
	proto.RegisterType((*EdgeOTelMetrics)(nil), "gml.internal.api.core.v1.EdgeOTelMetrics")
	proto.RegisterType((*FileTransferRequest)(nil), "gml.internal.api.core.v1.FileTransferRequest")
	proto.RegisterType((*FileTransferResponse)(nil), "gml.internal.api.core.v1.FileTransferResponse")
	proto.RegisterType((*FileTransferResponse_FileChunk)(nil), "gml.internal.api.core.v1.FileTransferResponse.FileChunk")
	proto.RegisterType((*DeviceCapabilities)(nil), "gml.internal.api.core.v1.DeviceCapabilities")
	proto.RegisterType((*DeviceCapabilities_ModelRuntimeInfo)(nil), "gml.internal.api.core.v1.DeviceCapabilities.ModelRuntimeInfo")
	proto.RegisterType((*DeviceCapabilities_CameraInfo)(nil), "gml.internal.api.core.v1.DeviceCapabilities.CameraInfo")
	proto.RegisterType((*EdgeCPMetadata)(nil), "gml.internal.api.core.v1.EdgeCPMetadata")
	proto.RegisterType((*EdgeCPMessage)(nil), "gml.internal.api.core.v1.EdgeCPMessage")
	proto.RegisterType((*CPEdgeMetadata)(nil), "gml.internal.api.core.v1.CPEdgeMetadata")
	proto.RegisterType((*CPEdgeMessage)(nil), "gml.internal.api.core.v1.CPEdgeMessage")
}

func init() { proto.RegisterFile("src/api/corepb/v1/cp_edge.proto", fileDescriptor_fdaf1f89158d2cba) }

var fileDescriptor_fdaf1f89158d2cba = []byte{
	// 1587 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x8f, 0xdb, 0xc6,
	0x19, 0x5e, 0x4a, 0x96, 0xd6, 0xfb, 0xfa, 0x63, 0xb9, 0xb3, 0x8a, 0xa3, 0x28, 0x09, 0xe5, 0xb0,
	0x48, 0xe3, 0x18, 0x09, 0x55, 0x6f, 0x0d, 0xb4, 0x68, 0x1a, 0xa0, 0x5c, 0x91, 0xbb, 0x26, 0xa2,
	0xaf, 0x8c, 0xa8, 0x4d, 0x6d, 0x14, 0x20, 0x28, 0x72, 0x2c, 0x13, 0xe6, 0xd7, 0x92, 0x94, 0x10,
	0x5d, 0x8a, 0x9e, 0x0b, 0x14, 0xed, 0xa1, 0x3f, 0xa2, 0xc7, 0xa2, 0x3f, 0xa0, 0x3d, 0xb6, 0x87,
	0x1e, 0x7c, 0x29, 0x90, 0x4b, 0x17, 0xb5, 0x7c, 0xc9, 0xa1, 0x87, 0xf4, 0x1f, 0x14, 0x33, 0xa4,
	0xb4, 0xe2, 0x4a, 0x72, 0x1c, 0x07, 0x6e, 0x73, 0x5a, 0xcd, 0xbc, 0xcf, 0xfb, 0xbc, 0xf3, 0x3c,
	0xc3, 0x79, 0x67, 0xb0, 0x50, 0x8f, 0x23, 0xab, 0x61, 0x86, 0x4e, 0xc3, 0x0a, 0x22, 0x12, 0x0e,
	0x1b, 0x93, 0x3b, 0x0d, 0x2b, 0x34, 0x88, 0x3d, 0x22, 0x52, 0x18, 0x05, 0x49, 0x80, 0xaa, 0x23,
	0xcf, 0x95, 0x1c, 0x3f, 0x21, 0x91, 0x6f, 0xba, 0x92, 0x19, 0x3a, 0x12, 0x45, 0x4a, 0x93, 0x3b,
	0xb5, 0xca, 0x28, 0x18, 0x05, 0x0c, 0xd4, 0xa0, 0xbf, 0x52, 0x7c, 0xed, 0x6d, 0x4a, 0x68, 0x05,
	0x9e, 0x17, 0xf8, 0x8d, 0x64, 0x1a, 0x92, 0x38, 0x1c, 0x36, 0xc6, 0x63, 0xc7, 0xce, 0xc2, 0xf5,
	0x35, 0xe1, 0x38, 0x31, 0x93, 0x71, 0x9c, 0x01, 0xde, 0x18, 0x05, 0xc1, 0xc8, 0x25, 0x0d, 0x36,
	0x1a, 0x8e, 0x1f, 0x36, 0x4c, 0x7f, 0x3a, 0xcf, 0xbd, 0x18, 0x4a, 0x1c, 0x8f, 0xc4, 0x89, 0xe9,
	0x85, 0x19, 0xe0, 0x83, 0x20, 0x24, 0x7e, 0x42, 0x5c, 0xe2, 0x91, 0x24, 0x9a, 0xa6, 0xb8, 0x06,
	0xfd, 0xed, 0x58, 0x31, 0x55, 0x96, 0xfd, 0xcc, 0xd0, 0xe2, 0xaa, 0x74, 0x2f, 0xb0, 0x89, 0x6b,
	0x90, 0xcf, 0x89, 0x95, 0x62, 0xc4, 0x3b, 0x70, 0x4d, 0xb5, 0x47, 0xe4, 0x1e, 0x31, 0xa3, 0x64,
	0x48, 0xcc, 0x04, 0xdd, 0x84, 0x72, 0x4c, 0x4e, 0x0d, 0xc7, 0xae, 0x72, 0x37, 0xb9, 0x5b, 0xc5,
	0xc3, 0x9d, 0xd9, 0x59, 0xbd, 0xd4, 0x27, 0xa7, 0x9a, 0x82, 0x4b, 0x31, 0x39, 0xd5, 0x6c, 0xf1,
	0x2e, 0xf0, 0xb9, 0x14, 0xd9, 0x7a, 0xfc, 0x02, 0x59, 0xff, 0xe0, 0xa0, 0xd6, 0x7b, 0x34, 0x8d,
	0x1d, 0xcb, 0x74, 0x7b, 0x4e, 0x48, 0x5c, 0xc7, 0x27, 0xfd, 0x90, 0x58, 0x83, 0xd0, 0x36, 0x13,
	0x82, 0xee, 0x43, 0x25, 0xcc, 0xa2, 0x46, 0x98, 0x85, 0xe7, 0x74, 0x57, 0x0e, 0x76, 0x25, 0xba,
	0x49, 0xcc, 0x4e, 0x69, 0x30, 0xd0, 0x94, 0xc3, 0x1b, 0xb3, 0xb3, 0x3a, 0xba, 0x48, 0xa7, 0x29,
	0x18, 0x85, 0x17, 0xe7, 0x6c, 0x54, 0x85, 0xed, 0x09, 0x89, 0x62, 0x27, 0xf0, 0xab, 0x05, 0xba,
	0x38, 0x3c, 0x1f, 0xa2, 0x43, 0xb8, 0x14, 0x87, 0xc4, 0xaa, 0x16, 0x59, 0x11, 0x49, 0xda, 0xf4,
	0x25, 0x48, 0xeb, 0x16, 0x8e, 0x59, 0xae, 0xf8, 0x4f, 0x0e, 0xde, 0x5a, 0x09, 0xb3, 0xfd, 0xfe,
	0x7f, 0x2a, 0xbb, 0x07, 0xe5, 0xf4, 0xa3, 0xcb, 0xb4, 0xfd, 0xe0, 0x1b, 0x68, 0x63, 0x79, 0x38,
	0xcb, 0x17, 0xaf, 0x02, 0x34, 0x7b, 0x78, 0xec, 0xb7, 0xe9, 0x97, 0x23, 0xee, 0xc2, 0xb5, 0xf3,
	0x91, 0x6c, 0x3d, 0x16, 0xff, 0xc4, 0x01, 0x52, 0x3f, 0x27, 0xd6, 0x38, 0x71, 0x02, 0xff, 0x38,
	0x32, 0xc3, 0x47, 0xd4, 0x1b, 0xf4, 0x31, 0x94, 0x46, 0x74, 0x90, 0xa9, 0x7c, 0x6f, 0x73, 0xf9,
	0x45, 0x32, 0xf3, 0x34, 0xcd, 0x42, 0x4d, 0x28, 0xd1, 0xf2, 0x84, 0xc9, 0xba, 0x7e, 0xf0, 0xe1,
	0x0b, 0xa4, 0xa7, 0xb5, 0x69, 0x12, 0x4e, 0x73, 0x97, 0xdd, 0x29, 0xe6, 0xdc, 0x11, 0x7f, 0xc3,
	0x41, 0x65, 0x35, 0x71, 0x1c, 0x9f, 0xd7, 0xe5, 0xbe, 0x45, 0xdd, 0x1b, 0x50, 0x8e, 0x88, 0x19,
	0x67, 0x9b, 0xb2, 0x83, 0xb3, 0xd1, 0x73, 0xd6, 0xf3, 0xeb, 0x02, 0xec, 0xcb, 0x61, 0xe8, 0x4e,
	0xf3, 0xac, 0xaf, 0xf2, 0xd3, 0x39, 0x81, 0x7d, 0x37, 0x18, 0xad, 0x30, 0x17, 0xd7, 0x33, 0xbf,
	0x36, 0x3b, 0xab, 0xef, 0xb5, 0x52, 0xfc, 0x12, 0xf1, 0x9e, 0x7b, 0x61, 0xca, 0x46, 0x3f, 0xcb,
	0x8e, 0x54, 0x81, 0x11, 0x7d, 0xf0, 0xc2, 0x06, 0x9e, 0x1f, 0xa8, 0x53, 0xa8, 0x28, 0xc4, 0x25,
	0x09, 0xf9, 0x9f, 0x99, 0x21, 0xfe, 0x85, 0x83, 0xda, 0xba, 0xef, 0xe1, 0xd5, 0x9f, 0xe0, 0xa3,
	0xc5, 0x39, 0x2d, 0x7c, 0x5d, 0x0f, 0x5a, 0xb7, 0xc0, 0xc5, 0x29, 0x45, 0xc0, 0x9f, 0x38, 0x36,
	0x09, 0xfa, 0x49, 0x44, 0x4c, 0xaf, 0x9f, 0x98, 0x51, 0x22, 0xee, 0xc1, 0x6e, 0x6e, 0x2e, 0x08,
	0xc5, 0x1b, 0x50, 0x59, 0x9a, 0xfa, 0x84, 0x90, 0x50, 0x76, 0x9d, 0x09, 0x11, 0x3d, 0xd8, 0xa5,
	0x2d, 0xbd, 0xab, 0x13, 0xb7, 0x9d, 0x5e, 0x21, 0xe8, 0x01, 0xf0, 0x11, 0x89, 0x83, 0x71, 0x64,
	0x11, 0x23, 0xbb, 0x56, 0x32, 0xc1, 0x0d, 0x29, 0x77, 0x0b, 0xa5, 0x17, 0x89, 0x34, 0xbf, 0x7a,
	0x26, 0x77, 0x24, 0x9c, 0xe5, 0x65, 0x54, 0x78, 0x37, 0xca, 0x4f, 0x88, 0xbf, 0xe7, 0x60, 0xff,
	0xc8, 0x71, 0x89, 0x1e, 0x99, 0x7e, 0xfc, 0x90, 0x44, 0x98, 0x9c, 0x8e, 0x49, 0x9c, 0xa0, 0xbb,
	0xb0, 0xfd, 0xd0, 0x71, 0x9f, 0xe7, 0x2d, 0xcc, 0xce, 0xea, 0x65, 0x9a, 0xaa, 0x29, 0xb8, 0x4c,
	0xb1, 0x9a, 0x8d, 0x6e, 0xc3, 0x9e, 0xf5, 0x68, 0xec, 0x3f, 0x36, 0x62, 0x2a, 0xdb, 0x18, 0x4e,
	0x13, 0x12, 0x67, 0xfd, 0x70, 0x97, 0x05, 0x98, 0x1d, 0x87, 0x74, 0x1a, 0xbd, 0x09, 0x3b, 0xfe,
	0xd8, 0xcb, 0x30, 0xe9, 0x29, 0xbc, 0xec, 0x8f, 0x3d, 0x16, 0x14, 0x7f, 0x5b, 0x80, 0x4a, 0x7e,
	0x59, 0x71, 0x18, 0xf8, 0x31, 0x41, 0xef, 0x2f, 0x76, 0x29, 0x5d, 0xd6, 0xde, 0xd2, 0xb2, 0xf2,
	0x1b, 0x81, 0x3a, 0x50, 0x62, 0x35, 0xb3, 0xfd, 0xfc, 0xf1, 0xe6, 0xfd, 0x5c, 0x57, 0x89, 0x4d,
	0x36, 0x69, 0x3e, 0x4e, 0x69, 0x96, 0x2d, 0x29, 0xbe, 0xb0, 0x25, 0xb5, 0x23, 0xd8, 0x59, 0x30,
	0xa1, 0x3a, 0x5c, 0x59, 0x76, 0x86, 0x5d, 0xd0, 0x18, 0xe2, 0x73, 0x53, 0xaa, 0xb0, 0x1d, 0x9a,
	0x53, 0x37, 0x30, 0x6d, 0xb6, 0xea, 0xab, 0x78, 0x3e, 0x14, 0xff, 0x58, 0x02, 0xa4, 0x90, 0x89,
	0x63, 0x91, 0xa6, 0x19, 0x9a, 0x43, 0xc7, 0x75, 0x12, 0x87, 0xc4, 0xc8, 0x86, 0xeb, 0xe9, 0x43,
	0x22, 0x1a, 0xfb, 0xec, 0x89, 0x52, 0xe5, 0x6e, 0x16, 0x6f, 0x5d, 0x39, 0xf8, 0x78, 0xb3, 0xda,
	0x55, 0x16, 0x89, 0xdd, 0x21, 0x38, 0x65, 0xd0, 0xfc, 0x87, 0x01, 0xbe, 0xe6, 0x2d, 0xcd, 0xc4,
	0xe8, 0x53, 0xd8, 0xb6, 0x4c, 0x8f, 0x44, 0x26, 0xdd, 0x4d, 0x4a, 0xff, 0xa3, 0x6f, 0x44, 0xdf,
	0x64, 0xb9, 0x8c, 0x78, 0xce, 0x53, 0xfb, 0x37, 0x07, 0xfc, 0xc5, 0xb2, 0x68, 0x08, 0x97, 0xa8,
	0x9d, 0x59, 0xcf, 0xef, 0x7c, 0x2b, 0x0d, 0xb9, 0x09, 0x7d, 0x1a, 0x12, 0xcc, 0xb8, 0xc5, 0x24,
	0x5f, 0x97, 0x46, 0x90, 0x00, 0xb5, 0x76, 0x57, 0x51, 0x5b, 0x06, 0x1e, 0x74, 0x74, 0xad, 0xad,
	0x1a, 0xfa, 0xfd, 0x9e, 0x6a, 0x0c, 0x3a, 0x9f, 0x74, 0xba, 0x9f, 0x75, 0xf8, 0x2d, 0x54, 0x87,
	0x37, 0xd7, 0xc4, 0x75, 0xb5, 0xd3, 0xef, 0x62, 0xac, 0xf3, 0xdc, 0x06, 0x40, 0xb7, 0xa7, 0x76,
	0x4e, 0xb4, 0x4e, 0x97, 0x2f, 0xd4, 0xfe, 0xc3, 0x01, 0x9c, 0xdb, 0x80, 0x7e, 0x01, 0x65, 0x3b,
	0x72, 0x26, 0x24, 0xca, 0xa4, 0x2a, 0x2f, 0xe9, 0x67, 0xf6, 0x53, 0x61, 0x5c, 0x38, 0xe3, 0x44,
	0xef, 0xc3, 0x4e, 0x6a, 0x33, 0xfd, 0x56, 0xd9, 0xcd, 0x77, 0x78, 0x75, 0x76, 0x56, 0xbf, 0x9c,
	0xe5, 0x29, 0xf8, 0x72, 0x1a, 0xd6, 0x6c, 0xf1, 0x01, 0x5c, 0x5d, 0xa6, 0x40, 0x6f, 0xc0, 0x6b,
	0x4d, 0xb9, 0xad, 0x62, 0xd9, 0x50, 0xb0, 0x76, 0xa2, 0xe2, 0x25, 0x13, 0x5e, 0x87, 0xfd, 0x7c,
	0x48, 0xc6, 0xc7, 0x83, 0x3e, 0xcf, 0xa1, 0x1b, 0x80, 0xf2, 0x81, 0x93, 0xbb, 0xad, 0x03, 0xbe,
	0x20, 0xfe, 0x9d, 0x83, 0xeb, 0xb4, 0x97, 0x35, 0x7b, 0x6d, 0x92, 0x98, 0xb6, 0x99, 0x98, 0xe8,
	0x23, 0x28, 0x25, 0x41, 0xe8, 0x58, 0x99, 0xec, 0x77, 0x9f, 0xd3, 0x63, 0x59, 0xa2, 0x4e, 0xc1,
	0x38, 0xcd, 0x41, 0x3f, 0x81, 0x1d, 0x9b, 0x99, 0x31, 0x97, 0xb5, 0xe6, 0x08, 0x32, 0x9d, 0xa9,
	0x65, 0x54, 0x67, 0x8a, 0xd7, 0x6c, 0x24, 0xc3, 0xf5, 0x88, 0x58, 0x13, 0x63, 0xf1, 0x8c, 0xcf,
	0xce, 0x70, 0x4d, 0x4a, 0x1f, 0xfa, 0xd2, 0xfc, 0xa1, 0x2f, 0xe9, 0x73, 0x04, 0xbe, 0x46, 0x33,
	0x16, 0x43, 0xf1, 0x97, 0xe9, 0xfb, 0x9c, 0xaa, 0x89, 0x63, 0x73, 0x44, 0x90, 0x02, 0x97, 0xbd,
	0x4c, 0x58, 0xd6, 0x8d, 0x6e, 0x7d, 0x9d, 0x9e, 0xb9, 0x11, 0x78, 0x91, 0x89, 0xde, 0x83, 0xa2,
	0x17, 0x8f, 0xaa, 0x5f, 0x6e, 0x33, 0x86, 0xca, 0xca, 0x7a, 0x64, 0x7f, 0x8a, 0x29, 0x82, 0xd9,
	0xd9, 0xec, 0x51, 0x9e, 0x97, 0xb0, 0x33, 0x4d, 0xfc, 0x8e, 0xd9, 0x39, 0x57, 0xf3, 0x12, 0x76,
	0xe6, 0x8d, 0x78, 0x09, 0x3b, 0x6f, 0xff, 0xb9, 0x00, 0xfb, 0x6b, 0x9e, 0x8e, 0xe8, 0x1d, 0x78,
	0x5b, 0xfd, 0xb9, 0xda, 0x1c, 0xe8, 0x5a, 0xb7, 0x63, 0x1c, 0x63, 0xb9, 0x77, 0xcf, 0xe8, 0xeb,
	0xb2, 0xbe, 0xdc, 0x0e, 0x6e, 0xc3, 0xf7, 0x37, 0x40, 0x7a, 0x0a, 0xfd, 0x83, 0xd5, 0x4f, 0x07,
	0x6a, 0x5f, 0x57, 0x15, 0x1e, 0xd0, 0xbb, 0xf0, 0xce, 0x7a, 0xac, 0xd2, 0xfd, 0xac, 0xd3, 0xea,
	0xca, 0x8a, 0xd6, 0x39, 0xe6, 0x2b, 0xe8, 0x7b, 0x50, 0x5f, 0x0f, 0x6b, 0x76, 0xdb, 0x3d, 0xad,
	0x45, 0x41, 0x02, 0xed, 0x32, 0xeb, 0x41, 0x58, 0x95, 0x95, 0xfb, 0xfc, 0x2d, 0x24, 0x82, 0xb0,
	0xa1, 0x98, 0xda, 0x6b, 0x75, 0xef, 0xab, 0x0a, 0x7f, 0xb0, 0x79, 0x41, 0xba, 0x8a, 0xdb, 0x5a,
	0x47, 0xd6, 0x69, 0xad, 0x9f, 0xa2, 0x9b, 0xf0, 0xd6, 0x7a, 0xd8, 0x91, 0xac, 0xb5, 0x54, 0x85,
	0xb7, 0x6f, 0xff, 0x95, 0x83, 0x2b, 0x4b, 0xa7, 0x94, 0xb6, 0x0e, 0x55, 0x39, 0x56, 0x8d, 0x66,
	0xcf, 0xd0, 0xbb, 0x3d, 0xad, 0xb9, 0x64, 0x58, 0x15, 0x2a, 0xf9, 0x10, 0xa5, 0x62, 0xbd, 0xe3,
	0x75, 0xd8, 0xcf, 0x47, 0x4e, 0x34, 0x45, 0xed, 0xf2, 0x05, 0xda, 0x54, 0xf2, 0x01, 0xba, 0x1a,
	0xbe, 0xb8, 0x5a, 0xa5, 0xad, 0xea, 0x58, 0x6b, 0xf6, 0xf9, 0x4b, 0xcc, 0x9e, 0x5c, 0xe8, 0x48,
	0x6b, 0xa9, 0x86, 0x8e, 0xe5, 0x4e, 0xff, 0x48, 0xc5, 0x7c, 0x69, 0x95, 0x53, 0xeb, 0x1c, 0x75,
	0xf9, 0x32, 0x53, 0xb2, 0x74, 0x40, 0x58, 0x13, 0xec, 0x19, 0x0c, 0xba, 0x46, 0x49, 0x3e, 0xb4,
	0xac, 0x24, 0x1f, 0x59, 0x52, 0x92, 0x0f, 0x9c, 0x2b, 0xc9, 0xcf, 0xe7, 0x94, 0xe4, 0x43, 0x6b,
	0x94, 0xe4, 0x01, 0xa9, 0x92, 0x43, 0xeb, 0xc9, 0x53, 0x61, 0xeb, 0x8b, 0xa7, 0xc2, 0xd6, 0x57,
	0x4f, 0x05, 0xee, 0x57, 0x33, 0x81, 0xfb, 0xc3, 0x4c, 0xe0, 0xfe, 0x36, 0x13, 0xb8, 0x27, 0x33,
	0x81, 0xfb, 0xd7, 0x4c, 0xe0, 0xbe, 0x9c, 0x09, 0x5b, 0x5f, 0xcd, 0x04, 0xee, 0x77, 0xcf, 0x84,
	0xad, 0x27, 0xcf, 0x84, 0xad, 0x2f, 0x9e, 0x09, 0x5b, 0x0f, 0x3e, 0x1c, 0x39, 0x9e, 0x4b, 0x12,
	0xd7, 0x1c, 0xc6, 0x92, 0xe9, 0x34, 0xd2, 0x51, 0x63, 0xe5, 0x5f, 0x16, 0x1f, 0xa5, 0xbf, 0x86,
	0x65, 0x76, 0x98, 0x7e, 0xf8, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x47, 0x46, 0x9c, 0x25, 0xd0,
	0x11, 0x00, 0x00,
}

func (x ExecutionGraphState) String() string {
	s, ok := ExecutionGraphState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x EdgeCPTopic) String() string {
	s, ok := EdgeCPTopic_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CPEdgeTopic) String() string {
	s, ok := CPEdgeTopic_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType) String() string {
	s, ok := DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DeviceCapabilities_CameraInfo_CameraDriver) String() string {
	s, ok := DeviceCapabilities_CameraInfo_CameraDriver_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EdgeHeartbeat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeHeartbeat)
	if !ok {
		that2, ok := that.(EdgeHeartbeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SeqID != that1.SeqID {
		return false
	}
	return true
}
func (this *EdgeHeartbeatAck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeHeartbeatAck)
	if !ok {
		that2, ok := that.(EdgeHeartbeatAck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SeqID != that1.SeqID {
		return false
	}
	return true
}
func (this *PhysicalPipelineSpecUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineSpecUpdate)
	if !ok {
		that2, ok := that.(PhysicalPipelineSpecUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalPipelineID.Equal(that1.PhysicalPipelineID) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *PhysicalPipelineStatusUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineStatusUpdate)
	if !ok {
		that2, ok := that.(PhysicalPipelineStatusUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalPipelineID.Equal(that1.PhysicalPipelineID) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *CPRunModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPRunModel)
	if !ok {
		that2, ok := that.(CPRunModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CPRunModelAck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPRunModelAck)
	if !ok {
		that2, ok := that.(CPRunModelAck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ExecutionGraphSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphSpec)
	if !ok {
		that2, ok := that.(ExecutionGraphSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *ExecutionGraphStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphStatus)
	if !ok {
		that2, ok := that.(ExecutionGraphStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *ApplyExecutionGraph) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplyExecutionGraph)
	if !ok {
		that2, ok := that.(ApplyExecutionGraph)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalPipelineID.Equal(that1.PhysicalPipelineID) {
		return false
	}
	if !this.LogicalPipelineID.Equal(that1.LogicalPipelineID) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *DeleteExecutionGraph) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteExecutionGraph)
	if !ok {
		that2, ok := that.(DeleteExecutionGraph)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalPipelineID.Equal(that1.PhysicalPipelineID) {
		return false
	}
	return true
}
func (this *ExecutionGraphStatusUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphStatusUpdate)
	if !ok {
		that2, ok := that.(ExecutionGraphStatusUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PhysicalPipelineID.Equal(that1.PhysicalPipelineID) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *VideoStreamStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamStart)
	if !ok {
		that2, ok := that.(VideoStreamStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *VideoStreamStop) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamStop)
	if !ok {
		that2, ok := that.(VideoStreamStop)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *VideoStreamKeepAlive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamKeepAlive)
	if !ok {
		that2, ok := that.(VideoStreamKeepAlive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *EdgeOTelMetrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeOTelMetrics)
	if !ok {
		that2, ok := that.(EdgeOTelMetrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResourceMetrics.Equal(that1.ResourceMetrics) {
		return false
	}
	return true
}
func (this *FileTransferRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferRequest)
	if !ok {
		that2, ok := that.(FileTransferRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileID.Equal(that1.FileID) {
		return false
	}
	if this.ChunkStartBytes != that1.ChunkStartBytes {
		return false
	}
	if this.NumBytes != that1.NumBytes {
		return false
	}
	return true
}
func (this *FileTransferResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferResponse)
	if !ok {
		that2, ok := that.(FileTransferResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	if !this.Chunk.Equal(that1.Chunk) {
		return false
	}
	if !this.FileID.Equal(that1.FileID) {
		return false
	}
	return true
}
func (this *FileTransferResponse_FileChunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferResponse_FileChunk)
	if !ok {
		that2, ok := that.(FileTransferResponse_FileChunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartBytes != that1.StartBytes {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *DeviceCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceCapabilities)
	if !ok {
		that2, ok := that.(DeviceCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ModelRuntimes) != len(that1.ModelRuntimes) {
		return false
	}
	for i := range this.ModelRuntimes {
		if !this.ModelRuntimes[i].Equal(that1.ModelRuntimes[i]) {
			return false
		}
	}
	if len(this.Cameras) != len(that1.Cameras) {
		return false
	}
	for i := range this.Cameras {
		if !this.Cameras[i].Equal(that1.Cameras[i]) {
			return false
		}
	}
	return true
}
func (this *DeviceCapabilities_ModelRuntimeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceCapabilities_ModelRuntimeInfo)
	if !ok {
		that2, ok := that.(DeviceCapabilities_ModelRuntimeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *DeviceCapabilities_CameraInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceCapabilities_CameraInfo)
	if !ok {
		that2, ok := that.(DeviceCapabilities_CameraInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Driver != that1.Driver {
		return false
	}
	if this.CameraID != that1.CameraID {
		return false
	}
	return true
}
func (this *EdgeCPMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeCPMetadata)
	if !ok {
		that2, ok := that.(EdgeCPMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.RecvTimestamp.Equal(that1.RecvTimestamp) {
		return false
	}
	return true
}
func (this *EdgeCPMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeCPMessage)
	if !ok {
		that2, ok := that.(EdgeCPMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *CPEdgeMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPEdgeMetadata)
	if !ok {
		that2, ok := that.(CPEdgeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.RecvTimestamp.Equal(that1.RecvTimestamp) {
		return false
	}
	return true
}
func (this *CPEdgeMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPEdgeMessage)
	if !ok {
		that2, ok := that.(CPEdgeMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *EdgeHeartbeat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeHeartbeat{")
	s = append(s, "SeqID: "+fmt.Sprintf("%#v", this.SeqID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeHeartbeatAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeHeartbeatAck{")
	s = append(s, "SeqID: "+fmt.Sprintf("%#v", this.SeqID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineSpecUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.PhysicalPipelineSpecUpdate{")
	if this.PhysicalPipelineID != nil {
		s = append(s, "PhysicalPipelineID: "+fmt.Sprintf("%#v", this.PhysicalPipelineID)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineStatusUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.PhysicalPipelineStatusUpdate{")
	if this.PhysicalPipelineID != nil {
		s = append(s, "PhysicalPipelineID: "+fmt.Sprintf("%#v", this.PhysicalPipelineID)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPRunModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.CPRunModel{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPRunModelAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.CPRunModelAck{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.ExecutionGraphSpec{")
	if this.Graph != nil {
		s = append(s, "Graph: "+fmt.Sprintf("%#v", this.Graph)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.ExecutionGraphStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApplyExecutionGraph) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.ApplyExecutionGraph{")
	if this.PhysicalPipelineID != nil {
		s = append(s, "PhysicalPipelineID: "+fmt.Sprintf("%#v", this.PhysicalPipelineID)+",\n")
	}
	if this.LogicalPipelineID != nil {
		s = append(s, "LogicalPipelineID: "+fmt.Sprintf("%#v", this.LogicalPipelineID)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteExecutionGraph) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DeleteExecutionGraph{")
	if this.PhysicalPipelineID != nil {
		s = append(s, "PhysicalPipelineID: "+fmt.Sprintf("%#v", this.PhysicalPipelineID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphStatusUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ExecutionGraphStatusUpdate{")
	if this.PhysicalPipelineID != nil {
		s = append(s, "PhysicalPipelineID: "+fmt.Sprintf("%#v", this.PhysicalPipelineID)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamStart{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamStop) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamStop{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamKeepAlive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamKeepAlive{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeOTelMetrics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeOTelMetrics{")
	if this.ResourceMetrics != nil {
		s = append(s, "ResourceMetrics: "+fmt.Sprintf("%#v", this.ResourceMetrics)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.FileTransferRequest{")
	if this.FileID != nil {
		s = append(s, "FileID: "+fmt.Sprintf("%#v", this.FileID)+",\n")
	}
	s = append(s, "ChunkStartBytes: "+fmt.Sprintf("%#v", this.ChunkStartBytes)+",\n")
	s = append(s, "NumBytes: "+fmt.Sprintf("%#v", this.NumBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.FileTransferResponse{")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	if this.Chunk != nil {
		s = append(s, "Chunk: "+fmt.Sprintf("%#v", this.Chunk)+",\n")
	}
	if this.FileID != nil {
		s = append(s, "FileID: "+fmt.Sprintf("%#v", this.FileID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferResponse_FileChunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.FileTransferResponse_FileChunk{")
	s = append(s, "StartBytes: "+fmt.Sprintf("%#v", this.StartBytes)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.DeviceCapabilities{")
	if this.ModelRuntimes != nil {
		s = append(s, "ModelRuntimes: "+fmt.Sprintf("%#v", this.ModelRuntimes)+",\n")
	}
	if this.Cameras != nil {
		s = append(s, "Cameras: "+fmt.Sprintf("%#v", this.Cameras)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceCapabilities_ModelRuntimeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DeviceCapabilities_ModelRuntimeInfo{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceCapabilities_CameraInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.DeviceCapabilities_CameraInfo{")
	s = append(s, "Driver: "+fmt.Sprintf("%#v", this.Driver)+",\n")
	s = append(s, "CameraID: "+fmt.Sprintf("%#v", this.CameraID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeCPMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.EdgeCPMetadata{")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.RecvTimestamp != nil {
		s = append(s, "RecvTimestamp: "+fmt.Sprintf("%#v", this.RecvTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeCPMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.EdgeCPMessage{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPEdgeMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.CPEdgeMetadata{")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.RecvTimestamp != nil {
		s = append(s, "RecvTimestamp: "+fmt.Sprintf("%#v", this.RecvTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPEdgeMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.CPEdgeMessage{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCpEdge(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EdgeHeartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeHeartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeHeartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqID != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.SeqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeHeartbeatAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeHeartbeatAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeHeartbeatAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqID != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.SeqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineSpecUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineSpecUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineSpecUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.PhysicalPipelineID != nil {
		{
			size, err := m.PhysicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineStatusUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.PhysicalPipelineID != nil {
		{
			size, err := m.PhysicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPRunModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPRunModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPRunModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CPRunModelAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPRunModelAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPRunModelAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCpEdge(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApplyExecutionGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyExecutionGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyExecutionGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogicalPipelineID != nil {
		{
			size, err := m.LogicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PhysicalPipelineID != nil {
		{
			size, err := m.PhysicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteExecutionGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteExecutionGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteExecutionGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		{
			size, err := m.PhysicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphStatusUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PhysicalPipelineID != nil {
		{
			size, err := m.PhysicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoStreamStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *VideoStreamStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamStop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamStop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *VideoStreamKeepAlive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamKeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamKeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EdgeOTelMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeOTelMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeOTelMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceMetrics != nil {
		{
			size, err := m.ResourceMetrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.ChunkStartBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.ChunkStartBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.FileID != nil {
		{
			size, err := m.FileID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileID != nil {
		{
			size, err := m.FileID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Chunk != nil {
		{
			size, err := m.Chunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferResponse_FileChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferResponse_FileChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferResponse_FileChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCpEdge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.StartBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.StartBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cameras) > 0 {
		for iNdEx := len(m.Cameras) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cameras[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCpEdge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ModelRuntimes) > 0 {
		for iNdEx := len(m.ModelRuntimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModelRuntimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCpEdge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeviceCapabilities_ModelRuntimeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceCapabilities_ModelRuntimeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceCapabilities_ModelRuntimeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceCapabilities_CameraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceCapabilities_CameraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceCapabilities_CameraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CameraID) > 0 {
		i -= len(m.CameraID)
		copy(dAtA[i:], m.CameraID)
		i = encodeVarintCpEdge(dAtA, i, uint64(len(m.CameraID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Driver != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Driver))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCPMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeCPMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCPMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecvTimestamp != nil {
		{
			size, err := m.RecvTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Topic != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCPMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeCPMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCPMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPEdgeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPEdgeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPEdgeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecvTimestamp != nil {
		{
			size, err := m.RecvTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Topic != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPEdgeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPEdgeMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPEdgeMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCpEdge(dAtA []byte, offset int, v uint64) int {
	offset -= sovCpEdge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EdgeHeartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqID != 0 {
		n += 1 + sovCpEdge(uint64(m.SeqID))
	}
	return n
}

func (m *EdgeHeartbeatAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqID != 0 {
		n += 1 + sovCpEdge(uint64(m.SeqID))
	}
	return n
}

func (m *PhysicalPipelineSpecUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		l = m.PhysicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *PhysicalPipelineStatusUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		l = m.PhysicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *CPRunModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CPRunModelAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExecutionGraphSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCpEdge(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	return n
}

func (m *ExecutionGraphStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCpEdge(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	return n
}

func (m *ApplyExecutionGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		l = m.PhysicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.LogicalPipelineID != nil {
		l = m.LogicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *DeleteExecutionGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		l = m.PhysicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *ExecutionGraphStatusUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalPipelineID != nil {
		l = m.PhysicalPipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *VideoStreamStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *VideoStreamStop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *VideoStreamKeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EdgeOTelMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceMetrics != nil {
		l = m.ResourceMetrics.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *FileTransferRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileID != nil {
		l = m.FileID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.ChunkStartBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.ChunkStartBytes))
	}
	if m.NumBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.NumBytes))
	}
	return n
}

func (m *FileTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.FileID != nil {
		l = m.FileID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *FileTransferResponse_FileChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.StartBytes))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *DeviceCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ModelRuntimes) > 0 {
		for _, e := range m.ModelRuntimes {
			l = e.Size()
			n += 1 + l + sovCpEdge(uint64(l))
		}
	}
	if len(m.Cameras) > 0 {
		for _, e := range m.Cameras {
			l = e.Size()
			n += 1 + l + sovCpEdge(uint64(l))
		}
	}
	return n
}

func (m *DeviceCapabilities_ModelRuntimeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCpEdge(uint64(m.Type))
	}
	return n
}

func (m *DeviceCapabilities_CameraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Driver != 0 {
		n += 1 + sovCpEdge(uint64(m.Driver))
	}
	l = len(m.CameraID)
	if l > 0 {
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *EdgeCPMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != 0 {
		n += 1 + sovCpEdge(uint64(m.Topic))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.RecvTimestamp != nil {
		l = m.RecvTimestamp.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *EdgeCPMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 2 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *CPEdgeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != 0 {
		n += 1 + sovCpEdge(uint64(m.Topic))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.RecvTimestamp != nil {
		l = m.RecvTimestamp.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *CPEdgeMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 2 + l + sovCpEdge(uint64(l))
	}
	return n
}

func sovCpEdge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCpEdge(x uint64) (n int) {
	return sovCpEdge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EdgeHeartbeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeHeartbeat{`,
		`SeqID:` + fmt.Sprintf("%v", this.SeqID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeHeartbeatAck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeHeartbeatAck{`,
		`SeqID:` + fmt.Sprintf("%v", this.SeqID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineSpecUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineSpecUpdate{`,
		`PhysicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Spec:` + strings.Replace(fmt.Sprintf("%v", this.Spec), "PhysicalPipelineSpec", "PhysicalPipelineSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineStatusUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineStatusUpdate{`,
		`PhysicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "PhysicalPipelineStatus", "PhysicalPipelineStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPRunModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPRunModel{`,
		`}`,
	}, "")
	return s
}
func (this *CPRunModelAck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPRunModelAck{`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphSpec{`,
		`Graph:` + strings.Replace(fmt.Sprintf("%v", this.Graph), "ExecutionSpec", "ExecutionSpec", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplyExecutionGraph) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplyExecutionGraph{`,
		`PhysicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "ExecutionGraphSpec", "ExecutionGraphSpec", 1) + `,`,
		`LogicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.LogicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteExecutionGraph) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteExecutionGraph{`,
		`PhysicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphStatusUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphStatusUpdate{`,
		`PhysicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PhysicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "ExecutionGraphStatus", "ExecutionGraphStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamStart{`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamStop) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamStop{`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamKeepAlive) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamKeepAlive{`,
		`}`,
	}, "")
	return s
}
func (this *EdgeOTelMetrics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeOTelMetrics{`,
		`ResourceMetrics:` + strings.Replace(fmt.Sprintf("%v", this.ResourceMetrics), "ResourceMetrics", "v1.ResourceMetrics", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferRequest{`,
		`FileID:` + strings.Replace(fmt.Sprintf("%v", this.FileID), "UUID", "typespb.UUID", 1) + `,`,
		`ChunkStartBytes:` + fmt.Sprintf("%v", this.ChunkStartBytes) + `,`,
		`NumBytes:` + fmt.Sprintf("%v", this.NumBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferResponse{`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Status", "typespb.Status", 1) + `,`,
		`Chunk:` + strings.Replace(fmt.Sprintf("%v", this.Chunk), "FileTransferResponse_FileChunk", "FileTransferResponse_FileChunk", 1) + `,`,
		`FileID:` + strings.Replace(fmt.Sprintf("%v", this.FileID), "UUID", "typespb.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferResponse_FileChunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferResponse_FileChunk{`,
		`StartBytes:` + fmt.Sprintf("%v", this.StartBytes) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModelRuntimes := "[]*DeviceCapabilities_ModelRuntimeInfo{"
	for _, f := range this.ModelRuntimes {
		repeatedStringForModelRuntimes += strings.Replace(fmt.Sprintf("%v", f), "DeviceCapabilities_ModelRuntimeInfo", "DeviceCapabilities_ModelRuntimeInfo", 1) + ","
	}
	repeatedStringForModelRuntimes += "}"
	repeatedStringForCameras := "[]*DeviceCapabilities_CameraInfo{"
	for _, f := range this.Cameras {
		repeatedStringForCameras += strings.Replace(fmt.Sprintf("%v", f), "DeviceCapabilities_CameraInfo", "DeviceCapabilities_CameraInfo", 1) + ","
	}
	repeatedStringForCameras += "}"
	s := strings.Join([]string{`&DeviceCapabilities{`,
		`ModelRuntimes:` + repeatedStringForModelRuntimes + `,`,
		`Cameras:` + repeatedStringForCameras + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceCapabilities_ModelRuntimeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceCapabilities_ModelRuntimeInfo{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceCapabilities_CameraInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceCapabilities_CameraInfo{`,
		`Driver:` + fmt.Sprintf("%v", this.Driver) + `,`,
		`CameraID:` + fmt.Sprintf("%v", this.CameraID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeCPMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeCPMetadata{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`RecvTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.RecvTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeCPMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeCPMessage{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "EdgeCPMetadata", "EdgeCPMetadata", 1) + `,`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPEdgeMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPEdgeMetadata{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`RecvTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.RecvTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPEdgeMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPEdgeMessage{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "CPEdgeMetadata", "CPEdgeMetadata", 1) + `,`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCpEdge(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EdgeHeartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeHeartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeHeartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqID", wireType)
			}
			m.SeqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeHeartbeatAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeHeartbeatAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeHeartbeatAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqID", wireType)
			}
			m.SeqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineSpecUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineSpecUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineSpecUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalPipelineID == nil {
				m.PhysicalPipelineID = &typespb.UUID{}
			}
			if err := m.PhysicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PhysicalPipelineSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalPipelineID == nil {
				m.PhysicalPipelineID = &typespb.UUID{}
			}
			if err := m.PhysicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PhysicalPipelineStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPRunModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPRunModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPRunModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPRunModelAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPRunModelAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPRunModelAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &ExecutionSpec{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ExecutionGraphState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ExecutionGraphState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyExecutionGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyExecutionGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyExecutionGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalPipelineID == nil {
				m.PhysicalPipelineID = &typespb.UUID{}
			}
			if err := m.PhysicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ExecutionGraphSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogicalPipelineID == nil {
				m.LogicalPipelineID = &typespb.UUID{}
			}
			if err := m.LogicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteExecutionGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteExecutionGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteExecutionGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalPipelineID == nil {
				m.PhysicalPipelineID = &typespb.UUID{}
			}
			if err := m.PhysicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhysicalPipelineID == nil {
				m.PhysicalPipelineID = &typespb.UUID{}
			}
			if err := m.PhysicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ExecutionGraphStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamKeepAlive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamKeepAlive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamKeepAlive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeOTelMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeOTelMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeOTelMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceMetrics == nil {
				m.ResourceMetrics = &v1.ResourceMetrics{}
			}
			if err := m.ResourceMetrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTransferRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTransferRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileID == nil {
				m.FileID = &typespb.UUID{}
			}
			if err := m.FileID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkStartBytes", wireType)
			}
			m.ChunkStartBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkStartBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &typespb.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &FileTransferResponse_FileChunk{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileID == nil {
				m.FileID = &typespb.UUID{}
			}
			if err := m.FileID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferResponse_FileChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBytes", wireType)
			}
			m.StartBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelRuntimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelRuntimes = append(m.ModelRuntimes, &DeviceCapabilities_ModelRuntimeInfo{})
			if err := m.ModelRuntimes[len(m.ModelRuntimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cameras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cameras = append(m.Cameras, &DeviceCapabilities_CameraInfo{})
			if err := m.Cameras[len(m.Cameras)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceCapabilities_ModelRuntimeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRuntimeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRuntimeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DeviceCapabilities_ModelRuntimeInfo_ModelRuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceCapabilities_CameraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CameraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CameraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			m.Driver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Driver |= DeviceCapabilities_CameraInfo_CameraDriver(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CameraID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeCPMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeCPMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeCPMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= EdgeCPTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvTimestamp == nil {
				m.RecvTimestamp = &types.Timestamp{}
			}
			if err := m.RecvTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeCPMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeCPMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeCPMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &EdgeCPMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &types.Any{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPEdgeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPEdgeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPEdgeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= CPEdgeTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvTimestamp == nil {
				m.RecvTimestamp = &types.Timestamp{}
			}
			if err := m.RecvTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPEdgeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPEdgeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPEdgeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &CPEdgeMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &types.Any{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCpEdge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCpEdge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCpEdge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCpEdge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCpEdge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCpEdge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCpEdge = fmt.Errorf("proto: unexpected end of group")
)
