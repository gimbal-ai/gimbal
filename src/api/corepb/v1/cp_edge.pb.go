// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/api/corepb/v1/cp_edge.proto

package corepb

import (
	bytes "bytes"
	fmt "fmt"
	typespb "gimletlabs.ai/gimlet/src/common/typespb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "go.opentelemetry.io/proto/otlp/metrics/v1"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExecutionGraphState int32

const (
	EXECUTION_GRAPH_STATE_UNKNOWN          ExecutionGraphState = 0
	EXECUTION_GRAPH_STATE_UPDATE_REQUESTED ExecutionGraphState = 10
	EXECUTION_GRAPH_STATE_DOWNLOADING      ExecutionGraphState = 20
	EXECUTION_GRAPH_STATE_COMPILING        ExecutionGraphState = 30
	EXECUTION_GRAPH_STATE_READY            ExecutionGraphState = 40
	EXECUTION_GRAPH_STATE_DEPLOYED         ExecutionGraphState = 50
	EXECUTION_GRAPH_STATE_FAILED           ExecutionGraphState = 100
)

var ExecutionGraphState_name = map[int32]string{
	0:   "EXECUTION_GRAPH_STATE_UNKNOWN",
	10:  "EXECUTION_GRAPH_STATE_UPDATE_REQUESTED",
	20:  "EXECUTION_GRAPH_STATE_DOWNLOADING",
	30:  "EXECUTION_GRAPH_STATE_COMPILING",
	40:  "EXECUTION_GRAPH_STATE_READY",
	50:  "EXECUTION_GRAPH_STATE_DEPLOYED",
	100: "EXECUTION_GRAPH_STATE_FAILED",
}

var ExecutionGraphState_value = map[string]int32{
	"EXECUTION_GRAPH_STATE_UNKNOWN":          0,
	"EXECUTION_GRAPH_STATE_UPDATE_REQUESTED": 10,
	"EXECUTION_GRAPH_STATE_DOWNLOADING":      20,
	"EXECUTION_GRAPH_STATE_COMPILING":        30,
	"EXECUTION_GRAPH_STATE_READY":            40,
	"EXECUTION_GRAPH_STATE_DEPLOYED":         50,
	"EXECUTION_GRAPH_STATE_FAILED":           100,
}

func (ExecutionGraphState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{0}
}

type EdgeCPTopic int32

const (
	EDGE_CP_TOPIC_UNKNOWN       EdgeCPTopic = 0
	EDGE_CP_TOPIC_STATUS        EdgeCPTopic = 1
	EDGE_CP_TOPIC_VIDEO         EdgeCPTopic = 2
	EDGE_CP_TOPIC_EXEC          EdgeCPTopic = 3
	EDGE_CP_TOPIC_METRICS       EdgeCPTopic = 4
	EDGE_CP_TOPIC_FILE_TRANSFER EdgeCPTopic = 5
)

var EdgeCPTopic_name = map[int32]string{
	0: "EDGE_CP_TOPIC_UNKNOWN",
	1: "EDGE_CP_TOPIC_STATUS",
	2: "EDGE_CP_TOPIC_VIDEO",
	3: "EDGE_CP_TOPIC_EXEC",
	4: "EDGE_CP_TOPIC_METRICS",
	5: "EDGE_CP_TOPIC_FILE_TRANSFER",
}

var EdgeCPTopic_value = map[string]int32{
	"EDGE_CP_TOPIC_UNKNOWN":       0,
	"EDGE_CP_TOPIC_STATUS":        1,
	"EDGE_CP_TOPIC_VIDEO":         2,
	"EDGE_CP_TOPIC_EXEC":          3,
	"EDGE_CP_TOPIC_METRICS":       4,
	"EDGE_CP_TOPIC_FILE_TRANSFER": 5,
}

func (EdgeCPTopic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{1}
}

type CPEdgeTopic int32

const (
	CP_EDGE_TOPIC_UNKNOWN       CPEdgeTopic = 0
	CP_EDGE_TOPIC_STATUS        CPEdgeTopic = 1
	CP_EDGE_TOPIC_VIDEO         CPEdgeTopic = 2
	CP_EDGE_TOPIC_EXEC          CPEdgeTopic = 3
	CP_EDGE_TOPIC_METRICS       CPEdgeTopic = 4
	CP_EDGE_TOPIC_FILE_TRANSFER CPEdgeTopic = 5
)

var CPEdgeTopic_name = map[int32]string{
	0: "CP_EDGE_TOPIC_UNKNOWN",
	1: "CP_EDGE_TOPIC_STATUS",
	2: "CP_EDGE_TOPIC_VIDEO",
	3: "CP_EDGE_TOPIC_EXEC",
	4: "CP_EDGE_TOPIC_METRICS",
	5: "CP_EDGE_TOPIC_FILE_TRANSFER",
}

var CPEdgeTopic_value = map[string]int32{
	"CP_EDGE_TOPIC_UNKNOWN":       0,
	"CP_EDGE_TOPIC_STATUS":        1,
	"CP_EDGE_TOPIC_VIDEO":         2,
	"CP_EDGE_TOPIC_EXEC":          3,
	"CP_EDGE_TOPIC_METRICS":       4,
	"CP_EDGE_TOPIC_FILE_TRANSFER": 5,
}

func (CPEdgeTopic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{2}
}

type EdgeHeartbeat struct {
	SeqID int64 `protobuf:"varint,1,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
}

func (m *EdgeHeartbeat) Reset()      { *m = EdgeHeartbeat{} }
func (*EdgeHeartbeat) ProtoMessage() {}
func (*EdgeHeartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{0}
}
func (m *EdgeHeartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeHeartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeHeartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeHeartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeHeartbeat.Merge(m, src)
}
func (m *EdgeHeartbeat) XXX_Size() int {
	return m.Size()
}
func (m *EdgeHeartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeHeartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeHeartbeat proto.InternalMessageInfo

func (m *EdgeHeartbeat) GetSeqID() int64 {
	if m != nil {
		return m.SeqID
	}
	return 0
}

type EdgeHeartbeatAck struct {
	SeqID int64 `protobuf:"varint,1,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
}

func (m *EdgeHeartbeatAck) Reset()      { *m = EdgeHeartbeatAck{} }
func (*EdgeHeartbeatAck) ProtoMessage() {}
func (*EdgeHeartbeatAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{1}
}
func (m *EdgeHeartbeatAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeHeartbeatAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeHeartbeatAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeHeartbeatAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeHeartbeatAck.Merge(m, src)
}
func (m *EdgeHeartbeatAck) XXX_Size() int {
	return m.Size()
}
func (m *EdgeHeartbeatAck) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeHeartbeatAck.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeHeartbeatAck proto.InternalMessageInfo

func (m *EdgeHeartbeatAck) GetSeqID() int64 {
	if m != nil {
		return m.SeqID
	}
	return 0
}

type CPRunModel struct {
}

func (m *CPRunModel) Reset()      { *m = CPRunModel{} }
func (*CPRunModel) ProtoMessage() {}
func (*CPRunModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{2}
}
func (m *CPRunModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPRunModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPRunModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPRunModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPRunModel.Merge(m, src)
}
func (m *CPRunModel) XXX_Size() int {
	return m.Size()
}
func (m *CPRunModel) XXX_DiscardUnknown() {
	xxx_messageInfo_CPRunModel.DiscardUnknown(m)
}

var xxx_messageInfo_CPRunModel proto.InternalMessageInfo

type CPRunModelAck struct {
}

func (m *CPRunModelAck) Reset()      { *m = CPRunModelAck{} }
func (*CPRunModelAck) ProtoMessage() {}
func (*CPRunModelAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{3}
}
func (m *CPRunModelAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPRunModelAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPRunModelAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPRunModelAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPRunModelAck.Merge(m, src)
}
func (m *CPRunModelAck) XXX_Size() int {
	return m.Size()
}
func (m *CPRunModelAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CPRunModelAck.DiscardUnknown(m)
}

var xxx_messageInfo_CPRunModelAck proto.InternalMessageInfo

type ExecutionGraphSpec struct {
	Graph   *ExecutionGraph     `protobuf:"bytes,1,opt,name=graph,proto3" json:"graph,omitempty"`
	State   ExecutionGraphState `protobuf:"varint,2,opt,name=state,proto3,enum=gml.internal.api.core.v1.ExecutionGraphState" json:"state,omitempty"`
	Version int64               `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ExecutionGraphSpec) Reset()      { *m = ExecutionGraphSpec{} }
func (*ExecutionGraphSpec) ProtoMessage() {}
func (*ExecutionGraphSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{4}
}
func (m *ExecutionGraphSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphSpec.Merge(m, src)
}
func (m *ExecutionGraphSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphSpec proto.InternalMessageInfo

func (m *ExecutionGraphSpec) GetGraph() *ExecutionGraph {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ExecutionGraphSpec) GetState() ExecutionGraphState {
	if m != nil {
		return m.State
	}
	return EXECUTION_GRAPH_STATE_UNKNOWN
}

func (m *ExecutionGraphSpec) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ExecutionGraphStatus struct {
	State   ExecutionGraphState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.ExecutionGraphState" json:"state,omitempty"`
	Reason  string              `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	Version int64               `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ExecutionGraphStatus) Reset()      { *m = ExecutionGraphStatus{} }
func (*ExecutionGraphStatus) ProtoMessage() {}
func (*ExecutionGraphStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{5}
}
func (m *ExecutionGraphStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphStatus.Merge(m, src)
}
func (m *ExecutionGraphStatus) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphStatus proto.InternalMessageInfo

func (m *ExecutionGraphStatus) GetState() ExecutionGraphState {
	if m != nil {
		return m.State
	}
	return EXECUTION_GRAPH_STATE_UNKNOWN
}

func (m *ExecutionGraphStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ExecutionGraphStatus) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ApplyExecutionGraph struct {
	PipelineID *typespb.UUID       `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	Spec       *ExecutionGraphSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *ApplyExecutionGraph) Reset()      { *m = ApplyExecutionGraph{} }
func (*ApplyExecutionGraph) ProtoMessage() {}
func (*ApplyExecutionGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{6}
}
func (m *ApplyExecutionGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyExecutionGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyExecutionGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyExecutionGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyExecutionGraph.Merge(m, src)
}
func (m *ApplyExecutionGraph) XXX_Size() int {
	return m.Size()
}
func (m *ApplyExecutionGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyExecutionGraph.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyExecutionGraph proto.InternalMessageInfo

func (m *ApplyExecutionGraph) GetPipelineID() *typespb.UUID {
	if m != nil {
		return m.PipelineID
	}
	return nil
}

func (m *ApplyExecutionGraph) GetSpec() *ExecutionGraphSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

type DeleteExecutionGraph struct {
	PipelineID *typespb.UUID `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
}

func (m *DeleteExecutionGraph) Reset()      { *m = DeleteExecutionGraph{} }
func (*DeleteExecutionGraph) ProtoMessage() {}
func (*DeleteExecutionGraph) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{7}
}
func (m *DeleteExecutionGraph) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteExecutionGraph) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteExecutionGraph.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteExecutionGraph) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteExecutionGraph.Merge(m, src)
}
func (m *DeleteExecutionGraph) XXX_Size() int {
	return m.Size()
}
func (m *DeleteExecutionGraph) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteExecutionGraph.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteExecutionGraph proto.InternalMessageInfo

func (m *DeleteExecutionGraph) GetPipelineID() *typespb.UUID {
	if m != nil {
		return m.PipelineID
	}
	return nil
}

type ExecutionGraphStatusUpdate struct {
	PipelineID *typespb.UUID         `protobuf:"bytes,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	Status     *ExecutionGraphStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ExecutionGraphStatusUpdate) Reset()      { *m = ExecutionGraphStatusUpdate{} }
func (*ExecutionGraphStatusUpdate) ProtoMessage() {}
func (*ExecutionGraphStatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{8}
}
func (m *ExecutionGraphStatusUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionGraphStatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionGraphStatusUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionGraphStatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionGraphStatusUpdate.Merge(m, src)
}
func (m *ExecutionGraphStatusUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionGraphStatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionGraphStatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionGraphStatusUpdate proto.InternalMessageInfo

func (m *ExecutionGraphStatusUpdate) GetPipelineID() *typespb.UUID {
	if m != nil {
		return m.PipelineID
	}
	return nil
}

func (m *ExecutionGraphStatusUpdate) GetStatus() *ExecutionGraphStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type VideoStreamStart struct {
}

func (m *VideoStreamStart) Reset()      { *m = VideoStreamStart{} }
func (*VideoStreamStart) ProtoMessage() {}
func (*VideoStreamStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{9}
}
func (m *VideoStreamStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamStart.Merge(m, src)
}
func (m *VideoStreamStart) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamStart) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamStart.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamStart proto.InternalMessageInfo

type VideoStreamStop struct {
}

func (m *VideoStreamStop) Reset()      { *m = VideoStreamStop{} }
func (*VideoStreamStop) ProtoMessage() {}
func (*VideoStreamStop) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{10}
}
func (m *VideoStreamStop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamStop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamStop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamStop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamStop.Merge(m, src)
}
func (m *VideoStreamStop) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamStop) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamStop.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamStop proto.InternalMessageInfo

type VideoStreamKeepAlive struct {
}

func (m *VideoStreamKeepAlive) Reset()      { *m = VideoStreamKeepAlive{} }
func (*VideoStreamKeepAlive) ProtoMessage() {}
func (*VideoStreamKeepAlive) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{11}
}
func (m *VideoStreamKeepAlive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoStreamKeepAlive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoStreamKeepAlive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoStreamKeepAlive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoStreamKeepAlive.Merge(m, src)
}
func (m *VideoStreamKeepAlive) XXX_Size() int {
	return m.Size()
}
func (m *VideoStreamKeepAlive) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoStreamKeepAlive.DiscardUnknown(m)
}

var xxx_messageInfo_VideoStreamKeepAlive proto.InternalMessageInfo

type EdgeOTelMetrics struct {
	ResourceMetrics *v1.ResourceMetrics `protobuf:"bytes,1,opt,name=resource_metrics,json=resourceMetrics,proto3" json:"resource_metrics,omitempty"`
}

func (m *EdgeOTelMetrics) Reset()      { *m = EdgeOTelMetrics{} }
func (*EdgeOTelMetrics) ProtoMessage() {}
func (*EdgeOTelMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{12}
}
func (m *EdgeOTelMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeOTelMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeOTelMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeOTelMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeOTelMetrics.Merge(m, src)
}
func (m *EdgeOTelMetrics) XXX_Size() int {
	return m.Size()
}
func (m *EdgeOTelMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeOTelMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeOTelMetrics proto.InternalMessageInfo

func (m *EdgeOTelMetrics) GetResourceMetrics() *v1.ResourceMetrics {
	if m != nil {
		return m.ResourceMetrics
	}
	return nil
}

type FileTransferRequest struct {
	FileID          *typespb.UUID `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	ChunkStartBytes int64         `protobuf:"varint,2,opt,name=chunk_start_bytes,json=chunkStartBytes,proto3" json:"chunk_start_bytes,omitempty"`
	NumBytes        int64         `protobuf:"varint,3,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *FileTransferRequest) Reset()      { *m = FileTransferRequest{} }
func (*FileTransferRequest) ProtoMessage() {}
func (*FileTransferRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{13}
}
func (m *FileTransferRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferRequest.Merge(m, src)
}
func (m *FileTransferRequest) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferRequest proto.InternalMessageInfo

func (m *FileTransferRequest) GetFileID() *typespb.UUID {
	if m != nil {
		return m.FileID
	}
	return nil
}

func (m *FileTransferRequest) GetChunkStartBytes() int64 {
	if m != nil {
		return m.ChunkStartBytes
	}
	return 0
}

func (m *FileTransferRequest) GetNumBytes() int64 {
	if m != nil {
		return m.NumBytes
	}
	return 0
}

type FileTransferResponse struct {
	Code  typespb.Code                    `protobuf:"varint,1,opt,name=code,proto3,enum=gml.types.Code" json:"code,omitempty"`
	Chunk *FileTransferResponse_FileChunk `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
}

func (m *FileTransferResponse) Reset()      { *m = FileTransferResponse{} }
func (*FileTransferResponse) ProtoMessage() {}
func (*FileTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{14}
}
func (m *FileTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferResponse.Merge(m, src)
}
func (m *FileTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferResponse proto.InternalMessageInfo

func (m *FileTransferResponse) GetCode() typespb.Code {
	if m != nil {
		return m.Code
	}
	return typespb.CODE_OK
}

func (m *FileTransferResponse) GetChunk() *FileTransferResponse_FileChunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

type FileTransferResponse_FileChunk struct {
	StartBytes int64  `protobuf:"varint,1,opt,name=start_bytes,json=startBytes,proto3" json:"start_bytes,omitempty"`
	Payload    []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *FileTransferResponse_FileChunk) Reset()      { *m = FileTransferResponse_FileChunk{} }
func (*FileTransferResponse_FileChunk) ProtoMessage() {}
func (*FileTransferResponse_FileChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{14, 0}
}
func (m *FileTransferResponse_FileChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTransferResponse_FileChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTransferResponse_FileChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTransferResponse_FileChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTransferResponse_FileChunk.Merge(m, src)
}
func (m *FileTransferResponse_FileChunk) XXX_Size() int {
	return m.Size()
}
func (m *FileTransferResponse_FileChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTransferResponse_FileChunk.DiscardUnknown(m)
}

var xxx_messageInfo_FileTransferResponse_FileChunk proto.InternalMessageInfo

func (m *FileTransferResponse_FileChunk) GetStartBytes() int64 {
	if m != nil {
		return m.StartBytes
	}
	return 0
}

func (m *FileTransferResponse_FileChunk) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EdgeCPMetadata struct {
	Topic         EdgeCPTopic      `protobuf:"varint,1,opt,name=topic,proto3,enum=gml.internal.api.core.v1.EdgeCPTopic" json:"topic,omitempty"`
	DeviceID      *typespb.UUID    `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	RecvTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=recv_timestamp,json=recvTimestamp,proto3" json:"recv_timestamp,omitempty"`
}

func (m *EdgeCPMetadata) Reset()      { *m = EdgeCPMetadata{} }
func (*EdgeCPMetadata) ProtoMessage() {}
func (*EdgeCPMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{15}
}
func (m *EdgeCPMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeCPMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeCPMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeCPMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeCPMetadata.Merge(m, src)
}
func (m *EdgeCPMetadata) XXX_Size() int {
	return m.Size()
}
func (m *EdgeCPMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeCPMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeCPMetadata proto.InternalMessageInfo

func (m *EdgeCPMetadata) GetTopic() EdgeCPTopic {
	if m != nil {
		return m.Topic
	}
	return EDGE_CP_TOPIC_UNKNOWN
}

func (m *EdgeCPMetadata) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *EdgeCPMetadata) GetRecvTimestamp() *types.Timestamp {
	if m != nil {
		return m.RecvTimestamp
	}
	return nil
}

type EdgeCPMessage struct {
	Metadata *EdgeCPMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Msg      *types.Any      `protobuf:"bytes,1000,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *EdgeCPMessage) Reset()      { *m = EdgeCPMessage{} }
func (*EdgeCPMessage) ProtoMessage() {}
func (*EdgeCPMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{16}
}
func (m *EdgeCPMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeCPMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EdgeCPMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EdgeCPMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeCPMessage.Merge(m, src)
}
func (m *EdgeCPMessage) XXX_Size() int {
	return m.Size()
}
func (m *EdgeCPMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeCPMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeCPMessage proto.InternalMessageInfo

func (m *EdgeCPMessage) GetMetadata() *EdgeCPMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *EdgeCPMessage) GetMsg() *types.Any {
	if m != nil {
		return m.Msg
	}
	return nil
}

type CPEdgeMetadata struct {
	Topic         CPEdgeTopic      `protobuf:"varint,1,opt,name=topic,proto3,enum=gml.internal.api.core.v1.CPEdgeTopic" json:"topic,omitempty"`
	DeviceID      *typespb.UUID    `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	RecvTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=recv_timestamp,json=recvTimestamp,proto3" json:"recv_timestamp,omitempty"`
}

func (m *CPEdgeMetadata) Reset()      { *m = CPEdgeMetadata{} }
func (*CPEdgeMetadata) ProtoMessage() {}
func (*CPEdgeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{17}
}
func (m *CPEdgeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPEdgeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPEdgeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPEdgeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPEdgeMetadata.Merge(m, src)
}
func (m *CPEdgeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CPEdgeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CPEdgeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CPEdgeMetadata proto.InternalMessageInfo

func (m *CPEdgeMetadata) GetTopic() CPEdgeTopic {
	if m != nil {
		return m.Topic
	}
	return CP_EDGE_TOPIC_UNKNOWN
}

func (m *CPEdgeMetadata) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *CPEdgeMetadata) GetRecvTimestamp() *types.Timestamp {
	if m != nil {
		return m.RecvTimestamp
	}
	return nil
}

type CPEdgeMessage struct {
	Metadata *CPEdgeMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Msg      *types.Any      `protobuf:"bytes,1000,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CPEdgeMessage) Reset()      { *m = CPEdgeMessage{} }
func (*CPEdgeMessage) ProtoMessage() {}
func (*CPEdgeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_fdaf1f89158d2cba, []int{18}
}
func (m *CPEdgeMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPEdgeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPEdgeMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPEdgeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPEdgeMessage.Merge(m, src)
}
func (m *CPEdgeMessage) XXX_Size() int {
	return m.Size()
}
func (m *CPEdgeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CPEdgeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CPEdgeMessage proto.InternalMessageInfo

func (m *CPEdgeMessage) GetMetadata() *CPEdgeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CPEdgeMessage) GetMsg() *types.Any {
	if m != nil {
		return m.Msg
	}
	return nil
}

func init() {
	proto.RegisterEnum("gml.internal.api.core.v1.ExecutionGraphState", ExecutionGraphState_name, ExecutionGraphState_value)
	proto.RegisterEnum("gml.internal.api.core.v1.EdgeCPTopic", EdgeCPTopic_name, EdgeCPTopic_value)
	proto.RegisterEnum("gml.internal.api.core.v1.CPEdgeTopic", CPEdgeTopic_name, CPEdgeTopic_value)
	proto.RegisterType((*EdgeHeartbeat)(nil), "gml.internal.api.core.v1.EdgeHeartbeat")
	proto.RegisterType((*EdgeHeartbeatAck)(nil), "gml.internal.api.core.v1.EdgeHeartbeatAck")
	proto.RegisterType((*CPRunModel)(nil), "gml.internal.api.core.v1.CPRunModel")
	proto.RegisterType((*CPRunModelAck)(nil), "gml.internal.api.core.v1.CPRunModelAck")
	proto.RegisterType((*ExecutionGraphSpec)(nil), "gml.internal.api.core.v1.ExecutionGraphSpec")
	proto.RegisterType((*ExecutionGraphStatus)(nil), "gml.internal.api.core.v1.ExecutionGraphStatus")
	proto.RegisterType((*ApplyExecutionGraph)(nil), "gml.internal.api.core.v1.ApplyExecutionGraph")
	proto.RegisterType((*DeleteExecutionGraph)(nil), "gml.internal.api.core.v1.DeleteExecutionGraph")
	proto.RegisterType((*ExecutionGraphStatusUpdate)(nil), "gml.internal.api.core.v1.ExecutionGraphStatusUpdate")
	proto.RegisterType((*VideoStreamStart)(nil), "gml.internal.api.core.v1.VideoStreamStart")
	proto.RegisterType((*VideoStreamStop)(nil), "gml.internal.api.core.v1.VideoStreamStop")
	proto.RegisterType((*VideoStreamKeepAlive)(nil), "gml.internal.api.core.v1.VideoStreamKeepAlive")
	proto.RegisterType((*EdgeOTelMetrics)(nil), "gml.internal.api.core.v1.EdgeOTelMetrics")
	proto.RegisterType((*FileTransferRequest)(nil), "gml.internal.api.core.v1.FileTransferRequest")
	proto.RegisterType((*FileTransferResponse)(nil), "gml.internal.api.core.v1.FileTransferResponse")
	proto.RegisterType((*FileTransferResponse_FileChunk)(nil), "gml.internal.api.core.v1.FileTransferResponse.FileChunk")
	proto.RegisterType((*EdgeCPMetadata)(nil), "gml.internal.api.core.v1.EdgeCPMetadata")
	proto.RegisterType((*EdgeCPMessage)(nil), "gml.internal.api.core.v1.EdgeCPMessage")
	proto.RegisterType((*CPEdgeMetadata)(nil), "gml.internal.api.core.v1.CPEdgeMetadata")
	proto.RegisterType((*CPEdgeMessage)(nil), "gml.internal.api.core.v1.CPEdgeMessage")
}

func init() { proto.RegisterFile("src/api/corepb/v1/cp_edge.proto", fileDescriptor_fdaf1f89158d2cba) }

var fileDescriptor_fdaf1f89158d2cba = []byte{
	// 1233 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcb, 0x6e, 0xdb, 0xd6,
	0x16, 0x15, 0xed, 0xc8, 0x8f, 0xad, 0xc4, 0x66, 0x8e, 0x75, 0x73, 0x15, 0xe7, 0x86, 0x72, 0x18,
	0xe4, 0x5e, 0xc3, 0x48, 0x28, 0xd8, 0x37, 0x83, 0xa2, 0x01, 0x8a, 0xc8, 0x22, 0xed, 0x10, 0xb1,
	0x25, 0xf5, 0x48, 0xca, 0x6b, 0x42, 0x50, 0xe4, 0x8e, 0x42, 0x84, 0x2f, 0x93, 0x94, 0x10, 0x4d,
	0x8a, 0xfe, 0x40, 0x81, 0x0e, 0x0a, 0x14, 0xfd, 0x81, 0xa2, 0xb3, 0x0e, 0xfa, 0x13, 0x1d, 0x74,
	0x10, 0xa0, 0x93, 0x8c, 0x8c, 0x46, 0x99, 0x64, 0x98, 0x4f, 0x28, 0x0e, 0x49, 0xd9, 0x62, 0x2c,
	0x07, 0x6e, 0xd2, 0x41, 0x47, 0xe2, 0x39, 0x7b, 0xad, 0x7d, 0xd6, 0xda, 0xfb, 0x3c, 0x04, 0xe5,
	0x30, 0x30, 0x2a, 0xba, 0x6f, 0x55, 0x0c, 0x2f, 0x40, 0xbf, 0x5b, 0x19, 0x6c, 0x56, 0x0c, 0x5f,
	0x43, 0xb3, 0x87, 0x92, 0x1f, 0x78, 0x91, 0x47, 0x4a, 0x3d, 0xc7, 0x96, 0x2c, 0x37, 0xc2, 0xc0,
	0xd5, 0x6d, 0x49, 0xf7, 0x2d, 0x89, 0x21, 0xa5, 0xc1, 0xe6, 0x6a, 0xb1, 0xe7, 0xf5, 0xbc, 0x18,
	0x54, 0x61, 0x5f, 0x09, 0x7e, 0xf5, 0x2a, 0x4b, 0x68, 0x78, 0x8e, 0xe3, 0xb9, 0x95, 0x68, 0xe8,
	0x63, 0xe8, 0x77, 0x2b, 0xfd, 0xbe, 0x65, 0xa6, 0xe1, 0xf2, 0x94, 0x70, 0x18, 0xe9, 0x51, 0x3f,
	0x4c, 0x01, 0x97, 0x7b, 0x9e, 0xd7, 0xb3, 0xb1, 0x12, 0x8f, 0xba, 0xfd, 0xa7, 0x15, 0xdd, 0x1d,
	0x8e, 0xb9, 0xef, 0x87, 0x22, 0xcb, 0xc1, 0x30, 0xd2, 0x1d, 0x3f, 0x05, 0xdc, 0xf4, 0x7c, 0x74,
	0x23, 0xb4, 0xd1, 0xc1, 0x28, 0x18, 0x26, 0xb8, 0x0a, 0xfb, 0xb6, 0x8c, 0x90, 0x39, 0x4b, 0x3f,
	0x53, 0xb4, 0x78, 0xd2, 0xba, 0xe3, 0x99, 0x68, 0x6b, 0xf8, 0x02, 0x8d, 0x04, 0x23, 0x6e, 0xc2,
	0x05, 0xc5, 0xec, 0xe1, 0x3d, 0xd4, 0x83, 0xa8, 0x8b, 0x7a, 0x44, 0xd6, 0x60, 0x2e, 0xc4, 0x03,
	0xcd, 0x32, 0x4b, 0xdc, 0x1a, 0xb7, 0x3e, 0xbb, 0xbd, 0x38, 0x3a, 0x2c, 0xe7, 0x5b, 0x78, 0xa0,
	0xca, 0x34, 0x1f, 0xe2, 0x81, 0x6a, 0x8a, 0xb7, 0x81, 0xcf, 0x50, 0xaa, 0xc6, 0xf3, 0x33, 0xb0,
	0xce, 0x03, 0xd4, 0x9a, 0xb4, 0xef, 0xee, 0x33, 0x05, 0xe2, 0x32, 0x5c, 0x38, 0x1e, 0x55, 0x8d,
	0xe7, 0xe2, 0x2f, 0x1c, 0x10, 0xe5, 0x05, 0x1a, 0xfd, 0xc8, 0xf2, 0xdc, 0xdd, 0x40, 0xf7, 0x9f,
	0xb5, 0x7c, 0x34, 0xc8, 0x17, 0x90, 0xef, 0xb1, 0x41, 0x9c, 0xb6, 0xb0, 0xb5, 0x2e, 0x9d, 0xd6,
	0x2c, 0x29, 0x4b, 0xa6, 0x09, 0x8d, 0xd4, 0x20, 0xcf, 0x8a, 0x8f, 0xa5, 0x99, 0x35, 0x6e, 0x7d,
	0x69, 0xeb, 0xd6, 0x59, 0xf9, 0x2d, 0x46, 0xa2, 0x09, 0x97, 0x94, 0x60, 0x7e, 0x80, 0x41, 0x68,
	0x79, 0x6e, 0x69, 0x96, 0xb9, 0xa3, 0xe3, 0xa1, 0xf8, 0x0d, 0x07, 0xc5, 0x93, 0xc4, 0x7e, 0x78,
	0xbc, 0x2e, 0xf7, 0x09, 0xeb, 0x5e, 0x82, 0xb9, 0x00, 0xf5, 0xd0, 0x73, 0x63, 0xf5, 0x8b, 0x34,
	0x1d, 0x7d, 0x40, 0xcf, 0x0f, 0x1c, 0xac, 0x54, 0x7d, 0xdf, 0x1e, 0x66, 0xb3, 0x92, 0xbb, 0x50,
	0xf0, 0x2d, 0x1f, 0x6d, 0xcb, 0xc5, 0x71, 0x8f, 0x0a, 0x5b, 0xcb, 0xb1, 0xa8, 0x78, 0x8f, 0x4a,
	0x9d, 0x8e, 0x2a, 0x6f, 0x2f, 0x8d, 0x0e, 0xcb, 0xd0, 0x4c, 0x71, 0xaa, 0x4c, 0x61, 0xcc, 0x51,
	0x4d, 0x72, 0x17, 0xce, 0x85, 0x3e, 0x1a, 0xb1, 0x92, 0xc2, 0xd6, 0xcd, 0x33, 0xfb, 0xf1, 0xd1,
	0xa0, 0x31, 0x53, 0x7c, 0x04, 0x45, 0x19, 0x6d, 0x8c, 0xf0, 0xef, 0xd6, 0x26, 0xfe, 0xc8, 0xc1,
	0xea, 0xb4, 0x2e, 0x74, 0x7c, 0x93, 0x95, 0xf1, 0xd3, 0xcd, 0xef, 0xc0, 0x5c, 0x72, 0x84, 0x53,
	0xfb, 0xd2, 0x5f, 0x69, 0x67, 0x3f, 0xa4, 0x29, 0x5b, 0x24, 0xc0, 0x3f, 0xb0, 0x4c, 0xf4, 0x5a,
	0x51, 0x80, 0xba, 0xd3, 0x8a, 0xf4, 0x20, 0x12, 0x2f, 0xc2, 0x72, 0x66, 0xce, 0xf3, 0xc5, 0x4b,
	0x50, 0x9c, 0x98, 0xba, 0x8f, 0xe8, 0x57, 0x6d, 0x6b, 0x80, 0xa2, 0x03, 0xcb, 0xec, 0xe0, 0x35,
	0xda, 0x68, 0xef, 0x27, 0x07, 0x9d, 0x3c, 0x01, 0x3e, 0xc0, 0xd0, 0xeb, 0x07, 0x06, 0x6a, 0xe9,
	0xe1, 0x4f, 0x0d, 0x56, 0xa4, 0xcc, 0x5d, 0x91, 0x1c, 0x77, 0x69, 0x7c, 0x41, 0x0c, 0x36, 0x25,
	0x9a, 0xf2, 0xd2, 0x54, 0x74, 0x39, 0xc8, 0x4e, 0x88, 0xdf, 0x71, 0xb0, 0xb2, 0x63, 0xd9, 0xd8,
	0x0e, 0x74, 0x37, 0x7c, 0x8a, 0x01, 0xc5, 0x83, 0x3e, 0x86, 0x11, 0xb9, 0x0d, 0xf3, 0x4f, 0x2d,
	0xfb, 0x43, 0xb5, 0x84, 0xd1, 0x61, 0x79, 0x8e, 0x51, 0x55, 0x99, 0xce, 0x31, 0xac, 0x6a, 0x92,
	0x0d, 0xb8, 0x68, 0x3c, 0xeb, 0xbb, 0xcf, 0xb5, 0x90, 0xd9, 0xd6, 0xba, 0xc3, 0x08, 0x93, 0x72,
	0xce, 0xd2, 0xe5, 0x38, 0x10, 0x97, 0x63, 0x9b, 0x4d, 0x93, 0x2b, 0xb0, 0xe8, 0xf6, 0x9d, 0x14,
	0x93, 0x6c, 0xf1, 0x05, 0xb7, 0xef, 0xc4, 0x41, 0xf1, 0x77, 0x0e, 0x8a, 0x59, 0x59, 0xa1, 0xef,
	0xb9, 0x21, 0x92, 0xeb, 0x70, 0xce, 0xf0, 0xcc, 0xf1, 0x91, 0x9b, 0x14, 0x55, 0xf3, 0x4c, 0xa4,
	0x71, 0x90, 0xd4, 0x21, 0x1f, 0xaf, 0x96, 0x76, 0xf2, 0xb3, 0xd3, 0x3b, 0x39, 0x6d, 0x8d, 0x78,
	0xb2, 0xc6, 0xf8, 0x34, 0x49, 0xb3, 0xba, 0x03, 0x8b, 0x47, 0x73, 0xa4, 0x0c, 0x85, 0x49, 0x77,
	0xf1, 0x55, 0x48, 0x21, 0x3c, 0x36, 0x56, 0x82, 0x79, 0x5f, 0x1f, 0xda, 0x9e, 0x6e, 0xc6, 0xeb,
	0x9f, 0xa7, 0xe3, 0xa1, 0xf8, 0x1b, 0x07, 0x4b, 0xac, 0xb9, 0xb5, 0xe6, 0x3e, 0x46, 0xba, 0xa9,
	0x47, 0x3a, 0xb9, 0x03, 0xf9, 0xc8, 0xf3, 0x2d, 0x23, 0x35, 0x74, 0xe3, 0x03, 0x9b, 0x2e, 0x26,
	0xb6, 0x19, 0x98, 0x26, 0x1c, 0xf2, 0x39, 0x2c, 0x9a, 0x38, 0xb0, 0x8c, 0xb8, 0x4d, 0x33, 0xd3,
	0xdb, 0x74, 0x7e, 0x74, 0x58, 0x5e, 0x90, 0x63, 0x94, 0x2a, 0xd3, 0x85, 0x04, 0xaf, 0x9a, 0xa4,
	0x0a, 0x4b, 0x01, 0x1a, 0x03, 0xed, 0xe8, 0xf5, 0x89, 0x7b, 0x50, 0xd8, 0x5a, 0x95, 0x92, 0xf7,
	0x49, 0x1a, 0xbf, 0x4f, 0x52, 0x7b, 0x8c, 0xa0, 0x17, 0x18, 0xe3, 0x68, 0x28, 0x7e, 0x95, 0x3c,
	0x2b, 0xcc, 0x4d, 0x18, 0xea, 0x3d, 0x24, 0x32, 0x2c, 0x38, 0xa9, 0xb1, 0x33, 0xdc, 0xe5, 0x99,
	0x42, 0xd0, 0x23, 0x26, 0xf9, 0x1f, 0xcc, 0x3a, 0x61, 0xaf, 0xf4, 0x76, 0x3e, 0xce, 0x50, 0x3c,
	0xa1, 0xa7, 0xea, 0x0e, 0x29, 0x43, 0xc4, 0xe5, 0xac, 0x35, 0x59, 0x9e, 0x8f, 0x28, 0x67, 0x42,
	0xfc, 0x87, 0x95, 0x73, 0xec, 0xe6, 0x23, 0xca, 0x99, 0x2d, 0xc4, 0x47, 0x94, 0x73, 0xe3, 0xfb,
	0x19, 0x58, 0x99, 0xf2, 0x50, 0x91, 0x6b, 0x70, 0x55, 0x79, 0xa4, 0xd4, 0x3a, 0x6d, 0xb5, 0x51,
	0xd7, 0x76, 0x69, 0xb5, 0x79, 0x4f, 0x6b, 0xb5, 0xab, 0x6d, 0x45, 0xeb, 0xd4, 0xef, 0xd7, 0x1b,
	0x0f, 0xeb, 0x7c, 0x8e, 0x6c, 0xc0, 0x7f, 0x4f, 0x81, 0x34, 0x65, 0xf6, 0x43, 0x95, 0x2f, 0x3b,
	0x4a, 0xab, 0xad, 0xc8, 0x3c, 0x90, 0x1b, 0x70, 0x6d, 0x3a, 0x56, 0x6e, 0x3c, 0xac, 0xef, 0x35,
	0xaa, 0xb2, 0x5a, 0xdf, 0xe5, 0x8b, 0xe4, 0x3a, 0x94, 0xa7, 0xc3, 0x6a, 0x8d, 0xfd, 0xa6, 0xba,
	0xc7, 0x40, 0x02, 0x29, 0xc3, 0x95, 0xe9, 0x20, 0xaa, 0x54, 0xe5, 0xc7, 0xfc, 0x3a, 0x11, 0x41,
	0x38, 0x65, 0x31, 0xa5, 0xb9, 0xd7, 0x78, 0xac, 0xc8, 0xfc, 0x16, 0x59, 0x83, 0xff, 0x4c, 0xc7,
	0xec, 0x54, 0xd5, 0x3d, 0x45, 0xe6, 0xcd, 0x8d, 0x9f, 0x39, 0x28, 0x4c, 0x1c, 0x3f, 0x72, 0x19,
	0xfe, 0xa5, 0xc8, 0xbb, 0x8a, 0x56, 0x6b, 0x6a, 0xed, 0x46, 0x53, 0xad, 0x4d, 0x54, 0xa2, 0x04,
	0xc5, 0x6c, 0x88, 0xa5, 0xea, 0xb4, 0x78, 0x8e, 0xfc, 0x1b, 0x56, 0xb2, 0x91, 0x07, 0xaa, 0xac,
	0x34, 0xf8, 0x19, 0x72, 0x09, 0x48, 0x36, 0xc0, 0xd4, 0xf0, 0xb3, 0x27, 0x57, 0xd9, 0x57, 0xda,
	0x54, 0xad, 0xb5, 0xf8, 0x73, 0xb1, 0xef, 0x4c, 0x68, 0x47, 0xdd, 0x53, 0xb4, 0x36, 0xad, 0xd6,
	0x5b, 0x3b, 0x0a, 0xe5, 0xf3, 0xb1, 0xe2, 0x89, 0x1d, 0xce, 0x72, 0xd5, 0x9a, 0x5a, 0xcc, 0x99,
	0xa2, 0x38, 0x1b, 0x9a, 0x54, 0x9c, 0x8d, 0x4c, 0x28, 0xce, 0x06, 0x8e, 0x15, 0x67, 0xe7, 0x33,
	0x8a, 0xb3, 0xa1, 0xf7, 0x14, 0x6f, 0x1b, 0x2f, 0x5f, 0x0b, 0xb9, 0x57, 0xaf, 0x85, 0xdc, 0xbb,
	0xd7, 0x02, 0xf7, 0xf5, 0x48, 0xe0, 0x7e, 0x1a, 0x09, 0xdc, 0xaf, 0x23, 0x81, 0x7b, 0x39, 0x12,
	0xb8, 0x3f, 0x46, 0x02, 0xf7, 0x76, 0x24, 0xe4, 0xde, 0x8d, 0x04, 0xee, 0xdb, 0x37, 0x42, 0xee,
	0xe5, 0x1b, 0x21, 0xf7, 0xea, 0x8d, 0x90, 0x7b, 0x72, 0xab, 0x67, 0x39, 0x36, 0x46, 0xb6, 0xde,
	0x0d, 0x25, 0xdd, 0xaa, 0x24, 0xa3, 0xca, 0x89, 0xbf, 0xc4, 0x77, 0x92, 0xaf, 0xee, 0x5c, 0xbc,
	0xeb, 0xff, 0xff, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x34, 0xe6, 0xf6, 0xb9, 0x30, 0x0c, 0x00,
	0x00,
}

func (x ExecutionGraphState) String() string {
	s, ok := ExecutionGraphState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x EdgeCPTopic) String() string {
	s, ok := EdgeCPTopic_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CPEdgeTopic) String() string {
	s, ok := CPEdgeTopic_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EdgeHeartbeat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeHeartbeat)
	if !ok {
		that2, ok := that.(EdgeHeartbeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SeqID != that1.SeqID {
		return false
	}
	return true
}
func (this *EdgeHeartbeatAck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeHeartbeatAck)
	if !ok {
		that2, ok := that.(EdgeHeartbeatAck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SeqID != that1.SeqID {
		return false
	}
	return true
}
func (this *CPRunModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPRunModel)
	if !ok {
		that2, ok := that.(CPRunModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CPRunModelAck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPRunModelAck)
	if !ok {
		that2, ok := that.(CPRunModelAck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ExecutionGraphSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphSpec)
	if !ok {
		that2, ok := that.(ExecutionGraphSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *ExecutionGraphStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphStatus)
	if !ok {
		that2, ok := that.(ExecutionGraphStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *ApplyExecutionGraph) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplyExecutionGraph)
	if !ok {
		that2, ok := that.(ApplyExecutionGraph)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PipelineID.Equal(that1.PipelineID) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *DeleteExecutionGraph) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteExecutionGraph)
	if !ok {
		that2, ok := that.(DeleteExecutionGraph)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PipelineID.Equal(that1.PipelineID) {
		return false
	}
	return true
}
func (this *ExecutionGraphStatusUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionGraphStatusUpdate)
	if !ok {
		that2, ok := that.(ExecutionGraphStatusUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PipelineID.Equal(that1.PipelineID) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *VideoStreamStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamStart)
	if !ok {
		that2, ok := that.(VideoStreamStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *VideoStreamStop) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamStop)
	if !ok {
		that2, ok := that.(VideoStreamStop)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *VideoStreamKeepAlive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VideoStreamKeepAlive)
	if !ok {
		that2, ok := that.(VideoStreamKeepAlive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *EdgeOTelMetrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeOTelMetrics)
	if !ok {
		that2, ok := that.(EdgeOTelMetrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResourceMetrics.Equal(that1.ResourceMetrics) {
		return false
	}
	return true
}
func (this *FileTransferRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferRequest)
	if !ok {
		that2, ok := that.(FileTransferRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileID.Equal(that1.FileID) {
		return false
	}
	if this.ChunkStartBytes != that1.ChunkStartBytes {
		return false
	}
	if this.NumBytes != that1.NumBytes {
		return false
	}
	return true
}
func (this *FileTransferResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferResponse)
	if !ok {
		that2, ok := that.(FileTransferResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if !this.Chunk.Equal(that1.Chunk) {
		return false
	}
	return true
}
func (this *FileTransferResponse_FileChunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileTransferResponse_FileChunk)
	if !ok {
		that2, ok := that.(FileTransferResponse_FileChunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartBytes != that1.StartBytes {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *EdgeCPMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeCPMetadata)
	if !ok {
		that2, ok := that.(EdgeCPMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.RecvTimestamp.Equal(that1.RecvTimestamp) {
		return false
	}
	return true
}
func (this *EdgeCPMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeCPMessage)
	if !ok {
		that2, ok := that.(EdgeCPMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *CPEdgeMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPEdgeMetadata)
	if !ok {
		that2, ok := that.(CPEdgeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.RecvTimestamp.Equal(that1.RecvTimestamp) {
		return false
	}
	return true
}
func (this *CPEdgeMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CPEdgeMessage)
	if !ok {
		that2, ok := that.(CPEdgeMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Msg.Equal(that1.Msg) {
		return false
	}
	return true
}
func (this *EdgeHeartbeat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeHeartbeat{")
	s = append(s, "SeqID: "+fmt.Sprintf("%#v", this.SeqID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeHeartbeatAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeHeartbeatAck{")
	s = append(s, "SeqID: "+fmt.Sprintf("%#v", this.SeqID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPRunModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.CPRunModel{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPRunModelAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.CPRunModelAck{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.ExecutionGraphSpec{")
	if this.Graph != nil {
		s = append(s, "Graph: "+fmt.Sprintf("%#v", this.Graph)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.ExecutionGraphStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ApplyExecutionGraph) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ApplyExecutionGraph{")
	if this.PipelineID != nil {
		s = append(s, "PipelineID: "+fmt.Sprintf("%#v", this.PipelineID)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteExecutionGraph) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DeleteExecutionGraph{")
	if this.PipelineID != nil {
		s = append(s, "PipelineID: "+fmt.Sprintf("%#v", this.PipelineID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionGraphStatusUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ExecutionGraphStatusUpdate{")
	if this.PipelineID != nil {
		s = append(s, "PipelineID: "+fmt.Sprintf("%#v", this.PipelineID)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamStart{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamStop) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamStop{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoStreamKeepAlive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&corepb.VideoStreamKeepAlive{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeOTelMetrics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.EdgeOTelMetrics{")
	if this.ResourceMetrics != nil {
		s = append(s, "ResourceMetrics: "+fmt.Sprintf("%#v", this.ResourceMetrics)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.FileTransferRequest{")
	if this.FileID != nil {
		s = append(s, "FileID: "+fmt.Sprintf("%#v", this.FileID)+",\n")
	}
	s = append(s, "ChunkStartBytes: "+fmt.Sprintf("%#v", this.ChunkStartBytes)+",\n")
	s = append(s, "NumBytes: "+fmt.Sprintf("%#v", this.NumBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.FileTransferResponse{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.Chunk != nil {
		s = append(s, "Chunk: "+fmt.Sprintf("%#v", this.Chunk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileTransferResponse_FileChunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.FileTransferResponse_FileChunk{")
	s = append(s, "StartBytes: "+fmt.Sprintf("%#v", this.StartBytes)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeCPMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.EdgeCPMetadata{")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.RecvTimestamp != nil {
		s = append(s, "RecvTimestamp: "+fmt.Sprintf("%#v", this.RecvTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeCPMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.EdgeCPMessage{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPEdgeMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.CPEdgeMetadata{")
	s = append(s, "Topic: "+fmt.Sprintf("%#v", this.Topic)+",\n")
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.RecvTimestamp != nil {
		s = append(s, "RecvTimestamp: "+fmt.Sprintf("%#v", this.RecvTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CPEdgeMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.CPEdgeMessage{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCpEdge(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EdgeHeartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeHeartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeHeartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqID != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.SeqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeHeartbeatAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeHeartbeatAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeHeartbeatAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqID != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.SeqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPRunModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPRunModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPRunModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CPRunModelAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPRunModelAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPRunModelAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCpEdge(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApplyExecutionGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyExecutionGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyExecutionGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PipelineID != nil {
		{
			size, err := m.PipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteExecutionGraph) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteExecutionGraph) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteExecutionGraph) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PipelineID != nil {
		{
			size, err := m.PipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionGraphStatusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionGraphStatusUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionGraphStatusUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PipelineID != nil {
		{
			size, err := m.PipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoStreamStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *VideoStreamStop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamStop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamStop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *VideoStreamKeepAlive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoStreamKeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoStreamKeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EdgeOTelMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeOTelMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeOTelMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceMetrics != nil {
		{
			size, err := m.ResourceMetrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.ChunkStartBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.ChunkStartBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.FileID != nil {
		{
			size, err := m.FileID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		{
			size, err := m.Chunk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileTransferResponse_FileChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTransferResponse_FileChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTransferResponse_FileChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCpEdge(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.StartBytes != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.StartBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCPMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeCPMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCPMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecvTimestamp != nil {
		{
			size, err := m.RecvTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Topic != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeCPMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeCPMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeCPMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPEdgeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPEdgeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPEdgeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecvTimestamp != nil {
		{
			size, err := m.RecvTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Topic != 0 {
		i = encodeVarintCpEdge(dAtA, i, uint64(m.Topic))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPEdgeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPEdgeMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPEdgeMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCpEdge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCpEdge(dAtA []byte, offset int, v uint64) int {
	offset -= sovCpEdge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EdgeHeartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqID != 0 {
		n += 1 + sovCpEdge(uint64(m.SeqID))
	}
	return n
}

func (m *EdgeHeartbeatAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqID != 0 {
		n += 1 + sovCpEdge(uint64(m.SeqID))
	}
	return n
}

func (m *CPRunModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CPRunModelAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExecutionGraphSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCpEdge(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	return n
}

func (m *ExecutionGraphStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovCpEdge(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovCpEdge(uint64(m.Version))
	}
	return n
}

func (m *ApplyExecutionGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineID != nil {
		l = m.PipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *DeleteExecutionGraph) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineID != nil {
		l = m.PipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *ExecutionGraphStatusUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineID != nil {
		l = m.PipelineID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *VideoStreamStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *VideoStreamStop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *VideoStreamKeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EdgeOTelMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceMetrics != nil {
		l = m.ResourceMetrics.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *FileTransferRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileID != nil {
		l = m.FileID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.ChunkStartBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.ChunkStartBytes))
	}
	if m.NumBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.NumBytes))
	}
	return n
}

func (m *FileTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovCpEdge(uint64(m.Code))
	}
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *FileTransferResponse_FileChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBytes != 0 {
		n += 1 + sovCpEdge(uint64(m.StartBytes))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *EdgeCPMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != 0 {
		n += 1 + sovCpEdge(uint64(m.Topic))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.RecvTimestamp != nil {
		l = m.RecvTimestamp.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *EdgeCPMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 2 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *CPEdgeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != 0 {
		n += 1 + sovCpEdge(uint64(m.Topic))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.RecvTimestamp != nil {
		l = m.RecvTimestamp.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	return n
}

func (m *CPEdgeMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCpEdge(uint64(l))
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 2 + l + sovCpEdge(uint64(l))
	}
	return n
}

func sovCpEdge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCpEdge(x uint64) (n int) {
	return sovCpEdge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EdgeHeartbeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeHeartbeat{`,
		`SeqID:` + fmt.Sprintf("%v", this.SeqID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeHeartbeatAck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeHeartbeatAck{`,
		`SeqID:` + fmt.Sprintf("%v", this.SeqID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPRunModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPRunModel{`,
		`}`,
	}, "")
	return s
}
func (this *CPRunModelAck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPRunModelAck{`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphSpec{`,
		`Graph:` + strings.Replace(fmt.Sprintf("%v", this.Graph), "ExecutionGraph", "ExecutionGraph", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplyExecutionGraph) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplyExecutionGraph{`,
		`PipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "ExecutionGraphSpec", "ExecutionGraphSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteExecutionGraph) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteExecutionGraph{`,
		`PipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionGraphStatusUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutionGraphStatusUpdate{`,
		`PipelineID:` + strings.Replace(fmt.Sprintf("%v", this.PipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "ExecutionGraphStatus", "ExecutionGraphStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamStart{`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamStop) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamStop{`,
		`}`,
	}, "")
	return s
}
func (this *VideoStreamKeepAlive) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoStreamKeepAlive{`,
		`}`,
	}, "")
	return s
}
func (this *EdgeOTelMetrics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeOTelMetrics{`,
		`ResourceMetrics:` + strings.Replace(fmt.Sprintf("%v", this.ResourceMetrics), "ResourceMetrics", "v1.ResourceMetrics", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferRequest{`,
		`FileID:` + strings.Replace(fmt.Sprintf("%v", this.FileID), "UUID", "typespb.UUID", 1) + `,`,
		`ChunkStartBytes:` + fmt.Sprintf("%v", this.ChunkStartBytes) + `,`,
		`NumBytes:` + fmt.Sprintf("%v", this.NumBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferResponse{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Chunk:` + strings.Replace(fmt.Sprintf("%v", this.Chunk), "FileTransferResponse_FileChunk", "FileTransferResponse_FileChunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileTransferResponse_FileChunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileTransferResponse_FileChunk{`,
		`StartBytes:` + fmt.Sprintf("%v", this.StartBytes) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeCPMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeCPMetadata{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`RecvTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.RecvTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeCPMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EdgeCPMessage{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "EdgeCPMetadata", "EdgeCPMetadata", 1) + `,`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPEdgeMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPEdgeMetadata{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`RecvTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.RecvTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPEdgeMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPEdgeMessage{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "CPEdgeMetadata", "CPEdgeMetadata", 1) + `,`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCpEdge(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EdgeHeartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeHeartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeHeartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqID", wireType)
			}
			m.SeqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeHeartbeatAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeHeartbeatAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeHeartbeatAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqID", wireType)
			}
			m.SeqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPRunModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPRunModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPRunModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPRunModelAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPRunModelAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPRunModelAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &ExecutionGraph{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ExecutionGraphState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ExecutionGraphState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyExecutionGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyExecutionGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyExecutionGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PipelineID == nil {
				m.PipelineID = &typespb.UUID{}
			}
			if err := m.PipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ExecutionGraphSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteExecutionGraph) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteExecutionGraph: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteExecutionGraph: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PipelineID == nil {
				m.PipelineID = &typespb.UUID{}
			}
			if err := m.PipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionGraphStatusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionGraphStatusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionGraphStatusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PipelineID == nil {
				m.PipelineID = &typespb.UUID{}
			}
			if err := m.PipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ExecutionGraphStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamStop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamStop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamStop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoStreamKeepAlive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoStreamKeepAlive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoStreamKeepAlive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeOTelMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeOTelMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeOTelMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceMetrics == nil {
				m.ResourceMetrics = &v1.ResourceMetrics{}
			}
			if err := m.ResourceMetrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTransferRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTransferRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileID == nil {
				m.FileID = &typespb.UUID{}
			}
			if err := m.FileID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkStartBytes", wireType)
			}
			m.ChunkStartBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkStartBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= typespb.Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &FileTransferResponse_FileChunk{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTransferResponse_FileChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBytes", wireType)
			}
			m.StartBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeCPMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeCPMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeCPMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= EdgeCPTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvTimestamp == nil {
				m.RecvTimestamp = &types.Timestamp{}
			}
			if err := m.RecvTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeCPMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeCPMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeCPMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &EdgeCPMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &types.Any{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPEdgeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPEdgeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPEdgeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			m.Topic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topic |= CPEdgeTopic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecvTimestamp == nil {
				m.RecvTimestamp = &types.Timestamp{}
			}
			if err := m.RecvTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPEdgeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPEdgeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPEdgeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &CPEdgeMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCpEdge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCpEdge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &types.Any{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCpEdge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCpEdge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCpEdge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCpEdge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCpEdge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCpEdge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCpEdge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCpEdge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCpEdge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCpEdge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCpEdge = fmt.Errorf("proto: unexpected end of group")
)
