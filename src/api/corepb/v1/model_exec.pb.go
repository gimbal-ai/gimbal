// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/api/corepb/v1/model_exec.proto

package corepb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	typespb "gimletlabs.ai/gimlet/src/common/typespb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	framework "github.com/google/mediapipe/mediapipe/framework"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LogicalPipelineNodeKind int32

const (
	LOGICAL_PIPELINE_NODE_KIND_UNKNOWN                 LogicalPipelineNodeKind = 0
	LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE           LogicalPipelineNodeKind = 10
	LOGICAL_PIPELINE_NODE_KIND_DETECT                  LogicalPipelineNodeKind = 1000
	LOGICAL_PIPELINE_NODE_KIND_CLASSIFY                LogicalPipelineNodeKind = 1001
	LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI            LogicalPipelineNodeKind = 1503
	LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK       LogicalPipelineNodeKind = 2000
	LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK LogicalPipelineNodeKind = 2001
	LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK    LogicalPipelineNodeKind = 2002
	LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK      LogicalPipelineNodeKind = 2003
)

var LogicalPipelineNodeKind_name = map[int32]string{
	0:    "LOGICAL_PIPELINE_NODE_KIND_UNKNOWN",
	10:   "LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE",
	1000: "LOGICAL_PIPELINE_NODE_KIND_DETECT",
	1001: "LOGICAL_PIPELINE_NODE_KIND_CLASSIFY",
	1503: "LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI",
	2000: "LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK",
	2001: "LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK",
	2002: "LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK",
	2003: "LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK",
}

var LogicalPipelineNodeKind_value = map[string]int32{
	"LOGICAL_PIPELINE_NODE_KIND_UNKNOWN":                 0,
	"LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE":           10,
	"LOGICAL_PIPELINE_NODE_KIND_DETECT":                  1000,
	"LOGICAL_PIPELINE_NODE_KIND_CLASSIFY":                1001,
	"LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI":            1503,
	"LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK":       2000,
	"LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK": 2001,
	"LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK":    2002,
	"LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK":      2003,
}

func (LogicalPipelineNodeKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0}
}

type PipelineState int32

const (
	PIPELINE_STATE_UNKNOWN     PipelineState = 0
	PIPELINE_STATE_PENDING     PipelineState = 1
	PIPELINE_STATE_READY       PipelineState = 2
	PIPELINE_STATE_RUNNING     PipelineState = 3
	PIPELINE_STATE_TERMINATING PipelineState = 4
	PIPELINE_STATE_TERMINATED  PipelineState = 5
	PIPELINE_STATE_FAILED      PipelineState = 6
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STATE_UNKNOWN",
	1: "PIPELINE_STATE_PENDING",
	2: "PIPELINE_STATE_READY",
	3: "PIPELINE_STATE_RUNNING",
	4: "PIPELINE_STATE_TERMINATING",
	5: "PIPELINE_STATE_TERMINATED",
	6: "PIPELINE_STATE_FAILED",
}

var PipelineState_value = map[string]int32{
	"PIPELINE_STATE_UNKNOWN":     0,
	"PIPELINE_STATE_PENDING":     1,
	"PIPELINE_STATE_READY":       2,
	"PIPELINE_STATE_RUNNING":     3,
	"PIPELINE_STATE_TERMINATING": 4,
	"PIPELINE_STATE_TERMINATED":  5,
	"PIPELINE_STATE_FAILED":      6,
}

func (PipelineState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1}
}

type BoundingBoxInfo_BoundingBoxFormat int32

const (
	BOUNDING_BOX_FORMAT_UNKNOWN BoundingBoxInfo_BoundingBoxFormat = 0
	BOUNDING_BOX_FORMAT_CXCYWH  BoundingBoxInfo_BoundingBoxFormat = 1
	BOUNDING_BOX_FORMAT_YXYX    BoundingBoxInfo_BoundingBoxFormat = 2
	BOUNDING_BOX_FORMAT_XYXY    BoundingBoxInfo_BoundingBoxFormat = 3
)

var BoundingBoxInfo_BoundingBoxFormat_name = map[int32]string{
	0: "BOUNDING_BOX_FORMAT_UNKNOWN",
	1: "BOUNDING_BOX_FORMAT_CXCYWH",
	2: "BOUNDING_BOX_FORMAT_YXYX",
	3: "BOUNDING_BOX_FORMAT_XYXY",
}

var BoundingBoxInfo_BoundingBoxFormat_value = map[string]int32{
	"BOUNDING_BOX_FORMAT_UNKNOWN": 0,
	"BOUNDING_BOX_FORMAT_CXCYWH":  1,
	"BOUNDING_BOX_FORMAT_YXYX":    2,
	"BOUNDING_BOX_FORMAT_XYXY":    3,
}

func (BoundingBoxInfo_BoundingBoxFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0, 0}
}

type ModelInfo_ModelKind int32

const (
	MODEL_KIND_UNKNOWN     ModelInfo_ModelKind = 0
	MODEL_KIND_TORCH       ModelInfo_ModelKind = 1
	MODEL_KIND_TORCHSCRIPT ModelInfo_ModelKind = 2
	MODEL_KIND_ONNX        ModelInfo_ModelKind = 3
	MODEL_KIND_TFLITE      ModelInfo_ModelKind = 4
	MODEL_KIND_OPENVINO    ModelInfo_ModelKind = 5
)

var ModelInfo_ModelKind_name = map[int32]string{
	0: "MODEL_KIND_UNKNOWN",
	1: "MODEL_KIND_TORCH",
	2: "MODEL_KIND_TORCHSCRIPT",
	3: "MODEL_KIND_ONNX",
	4: "MODEL_KIND_TFLITE",
	5: "MODEL_KIND_OPENVINO",
}

var ModelInfo_ModelKind_value = map[string]int32{
	"MODEL_KIND_UNKNOWN":     0,
	"MODEL_KIND_TORCH":       1,
	"MODEL_KIND_TORCHSCRIPT": 2,
	"MODEL_KIND_ONNX":        3,
	"MODEL_KIND_TFLITE":      4,
	"MODEL_KIND_OPENVINO":    5,
}

func (ModelInfo_ModelKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 0}
}

type ModelInfo_ModelStorageFormat int32

const (
	MODEL_STORAGE_FORMAT_UNKNOWN       ModelInfo_ModelStorageFormat = 0
	MODEL_STORAGE_FORMAT_MLIR_BYTECODE ModelInfo_ModelStorageFormat = 1
	MODEL_STORAGE_FORMAT_MLIR_TEXT     ModelInfo_ModelStorageFormat = 2
	MODEL_STORAGE_FORMAT_PROTOBUF      ModelInfo_ModelStorageFormat = 3
	MODEL_STORAGE_FORMAT_PROTO_TEXT    ModelInfo_ModelStorageFormat = 4
	MODEL_STORAGE_FORMAT_FLATBUFFER    ModelInfo_ModelStorageFormat = 5
	MODEL_STORAGE_FORMAT_OPENVINO      ModelInfo_ModelStorageFormat = 6
)

var ModelInfo_ModelStorageFormat_name = map[int32]string{
	0: "MODEL_STORAGE_FORMAT_UNKNOWN",
	1: "MODEL_STORAGE_FORMAT_MLIR_BYTECODE",
	2: "MODEL_STORAGE_FORMAT_MLIR_TEXT",
	3: "MODEL_STORAGE_FORMAT_PROTOBUF",
	4: "MODEL_STORAGE_FORMAT_PROTO_TEXT",
	5: "MODEL_STORAGE_FORMAT_FLATBUFFER",
	6: "MODEL_STORAGE_FORMAT_OPENVINO",
}

var ModelInfo_ModelStorageFormat_value = map[string]int32{
	"MODEL_STORAGE_FORMAT_UNKNOWN":       0,
	"MODEL_STORAGE_FORMAT_MLIR_BYTECODE": 1,
	"MODEL_STORAGE_FORMAT_MLIR_TEXT":     2,
	"MODEL_STORAGE_FORMAT_PROTOBUF":      3,
	"MODEL_STORAGE_FORMAT_PROTO_TEXT":    4,
	"MODEL_STORAGE_FORMAT_FLATBUFFER":    5,
	"MODEL_STORAGE_FORMAT_OPENVINO":      6,
}

func (ModelInfo_ModelStorageFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 1}
}

type BoundingBoxInfo struct {
	BoxFormat     BoundingBoxInfo_BoundingBoxFormat `protobuf:"varint,1,opt,name=box_format,json=boxFormat,proto3,enum=gml.internal.api.core.v1.BoundingBoxInfo_BoundingBoxFormat" json:"box_format,omitempty"`
	BoxNormalized bool                              `protobuf:"varint,2,opt,name=box_normalized,json=boxNormalized,proto3" json:"box_normalized,omitempty"`
}

func (m *BoundingBoxInfo) Reset()      { *m = BoundingBoxInfo{} }
func (*BoundingBoxInfo) ProtoMessage() {}
func (*BoundingBoxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0}
}
func (m *BoundingBoxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundingBoxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoundingBoxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoundingBoxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingBoxInfo.Merge(m, src)
}
func (m *BoundingBoxInfo) XXX_Size() int {
	return m.Size()
}
func (m *BoundingBoxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingBoxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingBoxInfo proto.InternalMessageInfo

func (m *BoundingBoxInfo) GetBoxFormat() BoundingBoxInfo_BoundingBoxFormat {
	if m != nil {
		return m.BoxFormat
	}
	return BOUNDING_BOX_FORMAT_UNKNOWN
}

func (m *BoundingBoxInfo) GetBoxNormalized() bool {
	if m != nil {
		return m.BoxNormalized
	}
	return false
}

type ModelInfo struct {
	Name        string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind        ModelInfo_ModelKind          `protobuf:"varint,2,opt,name=kind,proto3,enum=gml.internal.api.core.v1.ModelInfo_ModelKind" json:"kind,omitempty"`
	Format      ModelInfo_ModelStorageFormat `protobuf:"varint,3,opt,name=format,proto3,enum=gml.internal.api.core.v1.ModelInfo_ModelStorageFormat" json:"format,omitempty"`
	FileAssets  map[string]*typespb.UUID     `protobuf:"bytes,4,rep,name=file_assets,json=fileAssets,proto3" json:"file_assets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ClassLabels []string                     `protobuf:"bytes,100,rep,name=class_labels,json=classLabels,proto3" json:"class_labels,omitempty"`
	BboxInfo    *BoundingBoxInfo             `protobuf:"bytes,101,opt,name=bbox_info,json=bboxInfo,proto3" json:"bbox_info,omitempty"`
}

func (m *ModelInfo) Reset()      { *m = ModelInfo{} }
func (*ModelInfo) ProtoMessage() {}
func (*ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1}
}
func (m *ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelInfo.Merge(m, src)
}
func (m *ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ModelInfo proto.InternalMessageInfo

func (m *ModelInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelInfo) GetKind() ModelInfo_ModelKind {
	if m != nil {
		return m.Kind
	}
	return MODEL_KIND_UNKNOWN
}

func (m *ModelInfo) GetFormat() ModelInfo_ModelStorageFormat {
	if m != nil {
		return m.Format
	}
	return MODEL_STORAGE_FORMAT_UNKNOWN
}

func (m *ModelInfo) GetFileAssets() map[string]*typespb.UUID {
	if m != nil {
		return m.FileAssets
	}
	return nil
}

func (m *ModelInfo) GetClassLabels() []string {
	if m != nil {
		return m.ClassLabels
	}
	return nil
}

func (m *ModelInfo) GetBboxInfo() *BoundingBoxInfo {
	if m != nil {
		return m.BboxInfo
	}
	return nil
}

type Node struct {
	Name       string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind       LogicalPipelineNodeKind `protobuf:"varint,2,opt,name=kind,proto3,enum=gml.internal.api.core.v1.LogicalPipelineNodeKind" json:"kind,omitempty"`
	Attributes []*NodeAttributes       `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
	Inputs     []*NodeInput            `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs    []*NodeOutput           `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs,omitempty"`
}

func (m *Node) Reset()      { *m = Node{} }
func (*Node) ProtoMessage() {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetKind() LogicalPipelineNodeKind {
	if m != nil {
		return m.Kind
	}
	return LOGICAL_PIPELINE_NODE_KIND_UNKNOWN
}

func (m *Node) GetAttributes() []*NodeAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Node) GetInputs() []*NodeInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Node) GetOutputs() []*NodeOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type ParamRef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ParamRef) Reset()      { *m = ParamRef{} }
func (*ParamRef) ProtoMessage() {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{3}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.Size()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Value struct {
	// Types that are valid to be assigned to Data:
	//	*Value_StringData
	//	*Value_Int64Data
	//	*Value_DoubleData
	//	*Value_BoolData
	//	*Value_LambdaData
	//	*Value_ModelData
	//	*Value_ParamData
	Data isValue_Data `protobuf_oneof:"data"`
}

func (m *Value) Reset()      { *m = Value{} }
func (*Value) ProtoMessage() {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{4}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Data interface {
	isValue_Data()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_StringData struct {
	StringData string `protobuf:"bytes,1,opt,name=string_data,json=stringData,proto3,oneof" json:"string_data,omitempty"`
}
type Value_Int64Data struct {
	Int64Data int64 `protobuf:"varint,2,opt,name=int64_data,json=int64Data,proto3,oneof" json:"int64_data,omitempty"`
}
type Value_DoubleData struct {
	DoubleData float64 `protobuf:"fixed64,3,opt,name=double_data,json=doubleData,proto3,oneof" json:"double_data,omitempty"`
}
type Value_BoolData struct {
	BoolData bool `protobuf:"varint,4,opt,name=bool_data,json=boolData,proto3,oneof" json:"bool_data,omitempty"`
}
type Value_LambdaData struct {
	LambdaData *Value_Lambda `protobuf:"bytes,5,opt,name=lambda_data,json=lambdaData,proto3,oneof" json:"lambda_data,omitempty"`
}
type Value_ModelData struct {
	ModelData *Value_ModelRef `protobuf:"bytes,6,opt,name=model_data,json=modelData,proto3,oneof" json:"model_data,omitempty"`
}
type Value_ParamData struct {
	ParamData *ParamRef `protobuf:"bytes,7,opt,name=param_data,json=paramData,proto3,oneof" json:"param_data,omitempty"`
}

func (*Value_StringData) isValue_Data() {}
func (*Value_Int64Data) isValue_Data()  {}
func (*Value_DoubleData) isValue_Data() {}
func (*Value_BoolData) isValue_Data()   {}
func (*Value_LambdaData) isValue_Data() {}
func (*Value_ModelData) isValue_Data()  {}
func (*Value_ParamData) isValue_Data()  {}

func (m *Value) GetData() isValue_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Value) GetStringData() string {
	if x, ok := m.GetData().(*Value_StringData); ok {
		return x.StringData
	}
	return ""
}

func (m *Value) GetInt64Data() int64 {
	if x, ok := m.GetData().(*Value_Int64Data); ok {
		return x.Int64Data
	}
	return 0
}

func (m *Value) GetDoubleData() float64 {
	if x, ok := m.GetData().(*Value_DoubleData); ok {
		return x.DoubleData
	}
	return 0
}

func (m *Value) GetBoolData() bool {
	if x, ok := m.GetData().(*Value_BoolData); ok {
		return x.BoolData
	}
	return false
}

func (m *Value) GetLambdaData() *Value_Lambda {
	if x, ok := m.GetData().(*Value_LambdaData); ok {
		return x.LambdaData
	}
	return nil
}

func (m *Value) GetModelData() *Value_ModelRef {
	if x, ok := m.GetData().(*Value_ModelData); ok {
		return x.ModelData
	}
	return nil
}

func (m *Value) GetParamData() *ParamRef {
	if x, ok := m.GetData().(*Value_ParamData); ok {
		return x.ParamData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_StringData)(nil),
		(*Value_Int64Data)(nil),
		(*Value_DoubleData)(nil),
		(*Value_BoolData)(nil),
		(*Value_LambdaData)(nil),
		(*Value_ModelData)(nil),
		(*Value_ParamData)(nil),
	}
}

type Value_ModelRef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Value_ModelRef) Reset()      { *m = Value_ModelRef{} }
func (*Value_ModelRef) ProtoMessage() {}
func (*Value_ModelRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{4, 0}
}
func (m *Value_ModelRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value_ModelRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value_ModelRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value_ModelRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value_ModelRef.Merge(m, src)
}
func (m *Value_ModelRef) XXX_Size() int {
	return m.Size()
}
func (m *Value_ModelRef) XXX_DiscardUnknown() {
	xxx_messageInfo_Value_ModelRef.DiscardUnknown(m)
}

var xxx_messageInfo_Value_ModelRef proto.InternalMessageInfo

func (m *Value_ModelRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Value_Lambda struct {
	Inputs  []string `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs []string `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Nodes   []*Node  `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *Value_Lambda) Reset()      { *m = Value_Lambda{} }
func (*Value_Lambda) ProtoMessage() {}
func (*Value_Lambda) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{4, 1}
}
func (m *Value_Lambda) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value_Lambda) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value_Lambda.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value_Lambda) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value_Lambda.Merge(m, src)
}
func (m *Value_Lambda) XXX_Size() int {
	return m.Size()
}
func (m *Value_Lambda) XXX_DiscardUnknown() {
	xxx_messageInfo_Value_Lambda.DiscardUnknown(m)
}

var xxx_messageInfo_Value_Lambda proto.InternalMessageInfo

func (m *Value_Lambda) GetInputs() []string {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Value_Lambda) GetOutputs() []string {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Value_Lambda) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NodeAttributes struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *NodeAttributes) Reset()      { *m = NodeAttributes{} }
func (*NodeAttributes) ProtoMessage() {}
func (*NodeAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{5}
}
func (m *NodeAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAttributes.Merge(m, src)
}
func (m *NodeAttributes) XXX_Size() int {
	return m.Size()
}
func (m *NodeAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAttributes proto.InternalMessageInfo

func (m *NodeAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeAttributes) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type NodeInput struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*NodeInput_ParamValue
	//	*NodeInput_NodeOutputValue
	//	*NodeInput_LambdaInputValue
	Value isNodeInput_Value `protobuf_oneof:"value"`
}

func (m *NodeInput) Reset()      { *m = NodeInput{} }
func (*NodeInput) ProtoMessage() {}
func (*NodeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{6}
}
func (m *NodeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput.Merge(m, src)
}
func (m *NodeInput) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput proto.InternalMessageInfo

type isNodeInput_Value interface {
	isNodeInput_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodeInput_ParamValue struct {
	ParamValue *ParamRef `protobuf:"bytes,2,opt,name=param_value,json=paramValue,proto3,oneof" json:"param_value,omitempty"`
}
type NodeInput_NodeOutputValue struct {
	NodeOutputValue *NodeInput_NodeOutputRef `protobuf:"bytes,3,opt,name=node_output_value,json=nodeOutputValue,proto3,oneof" json:"node_output_value,omitempty"`
}
type NodeInput_LambdaInputValue struct {
	LambdaInputValue *NodeInput_LambdaInputRef `protobuf:"bytes,4,opt,name=lambda_input_value,json=lambdaInputValue,proto3,oneof" json:"lambda_input_value,omitempty"`
}

func (*NodeInput_ParamValue) isNodeInput_Value()       {}
func (*NodeInput_NodeOutputValue) isNodeInput_Value()  {}
func (*NodeInput_LambdaInputValue) isNodeInput_Value() {}

func (m *NodeInput) GetValue() isNodeInput_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *NodeInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeInput) GetParamValue() *ParamRef {
	if x, ok := m.GetValue().(*NodeInput_ParamValue); ok {
		return x.ParamValue
	}
	return nil
}

func (m *NodeInput) GetNodeOutputValue() *NodeInput_NodeOutputRef {
	if x, ok := m.GetValue().(*NodeInput_NodeOutputValue); ok {
		return x.NodeOutputValue
	}
	return nil
}

func (m *NodeInput) GetLambdaInputValue() *NodeInput_LambdaInputRef {
	if x, ok := m.GetValue().(*NodeInput_LambdaInputValue); ok {
		return x.LambdaInputValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NodeInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NodeInput_ParamValue)(nil),
		(*NodeInput_NodeOutputValue)(nil),
		(*NodeInput_LambdaInputValue)(nil),
	}
}

type NodeInput_NodeOutputRef struct {
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeInput_NodeOutputRef) Reset()      { *m = NodeInput_NodeOutputRef{} }
func (*NodeInput_NodeOutputRef) ProtoMessage() {}
func (*NodeInput_NodeOutputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{6, 0}
}
func (m *NodeInput_NodeOutputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput_NodeOutputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput_NodeOutputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput_NodeOutputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput_NodeOutputRef.Merge(m, src)
}
func (m *NodeInput_NodeOutputRef) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput_NodeOutputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput_NodeOutputRef.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput_NodeOutputRef proto.InternalMessageInfo

func (m *NodeInput_NodeOutputRef) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *NodeInput_NodeOutputRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NodeInput_LambdaInputRef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeInput_LambdaInputRef) Reset()      { *m = NodeInput_LambdaInputRef{} }
func (*NodeInput_LambdaInputRef) ProtoMessage() {}
func (*NodeInput_LambdaInputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{6, 1}
}
func (m *NodeInput_LambdaInputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput_LambdaInputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput_LambdaInputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput_LambdaInputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput_LambdaInputRef.Merge(m, src)
}
func (m *NodeInput_LambdaInputRef) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput_LambdaInputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput_LambdaInputRef.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput_LambdaInputRef proto.InternalMessageInfo

func (m *NodeInput_LambdaInputRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NodeOutput struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeOutput) Reset()      { *m = NodeOutput{} }
func (*NodeOutput) ProtoMessage() {}
func (*NodeOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{7}
}
func (m *NodeOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeOutput.Merge(m, src)
}
func (m *NodeOutput) XXX_Size() int {
	return m.Size()
}
func (m *NodeOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeOutput.DiscardUnknown(m)
}

var xxx_messageInfo_NodeOutput proto.InternalMessageInfo

func (m *NodeOutput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Param struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DefaultValue *Value `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (m *Param) Reset()      { *m = Param{} }
func (*Param) ProtoMessage() {}
func (*Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{8}
}
func (m *Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Param.Merge(m, src)
}
func (m *Param) XXX_Size() int {
	return m.Size()
}
func (m *Param) XXX_DiscardUnknown() {
	xxx_messageInfo_Param.DiscardUnknown(m)
}

var xxx_messageInfo_Param proto.InternalMessageInfo

func (m *Param) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Param) GetDefaultValue() *Value {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

type LogicalPipeline struct {
	Params []*Param `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty"`
	Nodes  []*Node  `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *LogicalPipeline) Reset()      { *m = LogicalPipeline{} }
func (*LogicalPipeline) ProtoMessage() {}
func (*LogicalPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{9}
}
func (m *LogicalPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalPipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalPipeline.Merge(m, src)
}
func (m *LogicalPipeline) XXX_Size() int {
	return m.Size()
}
func (m *LogicalPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalPipeline proto.InternalMessageInfo

func (m *LogicalPipeline) GetParams() []*Param {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *LogicalPipeline) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type PipelineDeployment struct {
	ID                *typespb.UUID             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	LogicalPipelineID *typespb.UUID             `protobuf:"bytes,2,opt,name=logical_pipeline_id,json=logicalPipelineId,proto3" json:"logical_pipeline_id,omitempty"`
	FleetID           *typespb.UUID             `protobuf:"bytes,3,opt,name=fleet_id,json=fleetId,proto3" json:"fleet_id,omitempty"`
	CreatedAt         *types.Timestamp          `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt         *types.Timestamp          `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Version           int64                     `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	Spec              *PipelineDeploymentSpec   `protobuf:"bytes,7,opt,name=spec,proto3" json:"spec,omitempty"`
	Status            *PipelineDeploymentStatus `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PipelineDeployment) Reset()      { *m = PipelineDeployment{} }
func (*PipelineDeployment) ProtoMessage() {}
func (*PipelineDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{10}
}
func (m *PipelineDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeployment.Merge(m, src)
}
func (m *PipelineDeployment) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeployment proto.InternalMessageInfo

func (m *PipelineDeployment) GetID() *typespb.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *PipelineDeployment) GetLogicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.LogicalPipelineID
	}
	return nil
}

func (m *PipelineDeployment) GetFleetID() *typespb.UUID {
	if m != nil {
		return m.FleetID
	}
	return nil
}

func (m *PipelineDeployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineDeployment) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *PipelineDeployment) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineDeployment) GetSpec() *PipelineDeploymentSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PipelineDeployment) GetStatus() *PipelineDeploymentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type PipelineDeploymentSpec struct {
	State PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
}

func (m *PipelineDeploymentSpec) Reset()      { *m = PipelineDeploymentSpec{} }
func (*PipelineDeploymentSpec) ProtoMessage() {}
func (*PipelineDeploymentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{11}
}
func (m *PipelineDeploymentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeploymentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeploymentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeploymentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeploymentSpec.Merge(m, src)
}
func (m *PipelineDeploymentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeploymentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeploymentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeploymentSpec proto.InternalMessageInfo

func (m *PipelineDeploymentSpec) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

type PipelineDeploymentStatus struct {
	State PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
}

func (m *PipelineDeploymentStatus) Reset()      { *m = PipelineDeploymentStatus{} }
func (*PipelineDeploymentStatus) ProtoMessage() {}
func (*PipelineDeploymentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{12}
}
func (m *PipelineDeploymentStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeploymentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeploymentStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeploymentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeploymentStatus.Merge(m, src)
}
func (m *PipelineDeploymentStatus) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeploymentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeploymentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeploymentStatus proto.InternalMessageInfo

func (m *PipelineDeploymentStatus) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

type PhysicalPipeline struct {
	ID                   *typespb.UUID           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PipelineDeploymentID *typespb.UUID           `protobuf:"bytes,2,opt,name=pipeline_deployment_id,json=pipelineDeploymentId,proto3" json:"pipeline_deployment_id,omitempty"`
	DeviceID             *typespb.UUID           `protobuf:"bytes,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	CreatedAt            *types.Timestamp        `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt            *types.Timestamp        `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Version              int64                   `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	Spec                 *PhysicalPipelineSpec   `protobuf:"bytes,7,opt,name=spec,proto3" json:"spec,omitempty"`
	Status               *PhysicalPipelineStatus `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PhysicalPipeline) Reset()      { *m = PhysicalPipeline{} }
func (*PhysicalPipeline) ProtoMessage() {}
func (*PhysicalPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{13}
}
func (m *PhysicalPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipeline.Merge(m, src)
}
func (m *PhysicalPipeline) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipeline proto.InternalMessageInfo

func (m *PhysicalPipeline) GetID() *typespb.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *PhysicalPipeline) GetPipelineDeploymentID() *typespb.UUID {
	if m != nil {
		return m.PipelineDeploymentID
	}
	return nil
}

func (m *PhysicalPipeline) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *PhysicalPipeline) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PhysicalPipeline) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *PhysicalPipeline) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PhysicalPipeline) GetSpec() *PhysicalPipelineSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PhysicalPipeline) GetStatus() *PhysicalPipelineStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type PhysicalPipelineSpec struct {
	State PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
}

func (m *PhysicalPipelineSpec) Reset()      { *m = PhysicalPipelineSpec{} }
func (*PhysicalPipelineSpec) ProtoMessage() {}
func (*PhysicalPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{14}
}
func (m *PhysicalPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineSpec.Merge(m, src)
}
func (m *PhysicalPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineSpec proto.InternalMessageInfo

func (m *PhysicalPipelineSpec) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

type PhysicalPipelineStatus struct {
	State PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
}

func (m *PhysicalPipelineStatus) Reset()      { *m = PhysicalPipelineStatus{} }
func (*PhysicalPipelineStatus) ProtoMessage() {}
func (*PhysicalPipelineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{15}
}
func (m *PhysicalPipelineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineStatus.Merge(m, src)
}
func (m *PhysicalPipelineStatus) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineStatus proto.InternalMessageInfo

func (m *PhysicalPipelineStatus) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

type Pipeline struct {
	Nodes []*PipelineNode `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *Pipeline) Reset()      { *m = Pipeline{} }
func (*Pipeline) ProtoMessage() {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{16}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.Size()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetNodes() []*PipelineNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type PipelineNode struct {
	Id      uint64            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type    string            `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Inputs  []*Port           `protobuf:"bytes,3,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs []*Port           `protobuf:"bytes,4,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Attr    map[string]string `protobuf:"bytes,5,rep,name=attr,proto3" json:"attr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PipelineNode) Reset()      { *m = PipelineNode{} }
func (*PipelineNode) ProtoMessage() {}
func (*PipelineNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{17}
}
func (m *PipelineNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineNode.Merge(m, src)
}
func (m *PipelineNode) XXX_Size() int {
	return m.Size()
}
func (m *PipelineNode) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineNode.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineNode proto.InternalMessageInfo

func (m *PipelineNode) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PipelineNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PipelineNode) GetInputs() []*Port {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *PipelineNode) GetOutputs() []*Port {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *PipelineNode) GetAttr() map[string]string {
	if m != nil {
		return m.Attr
	}
	return nil
}

type Port struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Net  string `protobuf:"bytes,2,opt,name=net,proto3" json:"net,omitempty"`
}

func (m *Port) Reset()      { *m = Port{} }
func (*Port) ProtoMessage() {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{18}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Port) GetNet() string {
	if m != nil {
		return m.Net
	}
	return ""
}

type FileResource struct {
	FileID     *typespb.UUID `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	SizeBytes  uint64        `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Sha256Hash string        `protobuf:"bytes,3,opt,name=sha256_hash,json=sha256Hash,proto3" json:"sha256_hash,omitempty"`
}

func (m *FileResource) Reset()      { *m = FileResource{} }
func (*FileResource) ProtoMessage() {}
func (*FileResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{19}
}
func (m *FileResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileResource.Merge(m, src)
}
func (m *FileResource) XXX_Size() int {
	return m.Size()
}
func (m *FileResource) XXX_DiscardUnknown() {
	xxx_messageInfo_FileResource.DiscardUnknown(m)
}

var xxx_messageInfo_FileResource proto.InternalMessageInfo

func (m *FileResource) GetFileID() *typespb.UUID {
	if m != nil {
		return m.FileID
	}
	return nil
}

func (m *FileResource) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileResource) GetSha256Hash() string {
	if m != nil {
		return m.Sha256Hash
	}
	return ""
}

type ExecutionSpec struct {
	Graph     *framework.CalculatorGraphConfig `protobuf:"bytes,1,opt,name=graph,proto3" json:"graph,omitempty"`
	ModelSpec []*ModelSpec                     `protobuf:"bytes,2,rep,name=model_spec,json=modelSpec,proto3" json:"model_spec,omitempty"`
}

func (m *ExecutionSpec) Reset()      { *m = ExecutionSpec{} }
func (*ExecutionSpec) ProtoMessage() {}
func (*ExecutionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{20}
}
func (m *ExecutionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionSpec.Merge(m, src)
}
func (m *ExecutionSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionSpec proto.InternalMessageInfo

func (m *ExecutionSpec) GetGraph() *framework.CalculatorGraphConfig {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ExecutionSpec) GetModelSpec() []*ModelSpec {
	if m != nil {
		return m.ModelSpec
	}
	return nil
}

type ModelSpec struct {
	Name         string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ONNXBlobKey  string             `protobuf:"bytes,2,opt,name=onnx_blob_key,json=onnxBlobKey,proto3" json:"onnx_blob_key,omitempty"`
	ONNXFile     *FileResource      `protobuf:"bytes,3,opt,name=onnx_file,json=onnxFile,proto3" json:"onnx_file,omitempty"`
	Runtime      string             `protobuf:"bytes,50,opt,name=runtime,proto3" json:"runtime,omitempty"`
	TensorRTSpec *TensorRTModelSpec `protobuf:"bytes,100,opt,name=tensorrt_spec,json=tensorrtSpec,proto3" json:"tensorrt_spec,omitempty"`
	OpenVINOSpec *OpenVINOModelSpec `protobuf:"bytes,101,opt,name=openvino_spec,json=openvinoSpec,proto3" json:"openvino_spec,omitempty"`
}

func (m *ModelSpec) Reset()      { *m = ModelSpec{} }
func (*ModelSpec) ProtoMessage() {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{21}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelSpec) GetONNXBlobKey() string {
	if m != nil {
		return m.ONNXBlobKey
	}
	return ""
}

func (m *ModelSpec) GetONNXFile() *FileResource {
	if m != nil {
		return m.ONNXFile
	}
	return nil
}

func (m *ModelSpec) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *ModelSpec) GetTensorRTSpec() *TensorRTModelSpec {
	if m != nil {
		return m.TensorRTSpec
	}
	return nil
}

func (m *ModelSpec) GetOpenVINOSpec() *OpenVINOModelSpec {
	if m != nil {
		return m.OpenVINOSpec
	}
	return nil
}

type TensorRTModelSpec struct {
	OptimizationProfile []*TensorRTOptimizationProfile `protobuf:"bytes,1,rep,name=optimization_profile,json=optimizationProfile,proto3" json:"optimization_profile,omitempty"`
	EngineBlobKey       string                         `protobuf:"bytes,2,opt,name=engine_blob_key,json=engineBlobKey,proto3" json:"engine_blob_key,omitempty"`
	MemPoolLimits       *TensorRTMemPoolLimits         `protobuf:"bytes,3,opt,name=mem_pool_limits,json=memPoolLimits,proto3" json:"mem_pool_limits,omitempty"`
}

func (m *TensorRTModelSpec) Reset()      { *m = TensorRTModelSpec{} }
func (*TensorRTModelSpec) ProtoMessage() {}
func (*TensorRTModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{22}
}
func (m *TensorRTModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTModelSpec.Merge(m, src)
}
func (m *TensorRTModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTModelSpec proto.InternalMessageInfo

func (m *TensorRTModelSpec) GetOptimizationProfile() []*TensorRTOptimizationProfile {
	if m != nil {
		return m.OptimizationProfile
	}
	return nil
}

func (m *TensorRTModelSpec) GetEngineBlobKey() string {
	if m != nil {
		return m.EngineBlobKey
	}
	return ""
}

func (m *TensorRTModelSpec) GetMemPoolLimits() *TensorRTMemPoolLimits {
	if m != nil {
		return m.MemPoolLimits
	}
	return nil
}

type TensorRTOptimizationProfile struct {
	TensorShapeRange []*TensorRTTensorShapeRange `protobuf:"bytes,1,rep,name=tensor_shape_range,json=tensorShapeRange,proto3" json:"tensor_shape_range,omitempty"`
}

func (m *TensorRTOptimizationProfile) Reset()      { *m = TensorRTOptimizationProfile{} }
func (*TensorRTOptimizationProfile) ProtoMessage() {}
func (*TensorRTOptimizationProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{23}
}
func (m *TensorRTOptimizationProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTOptimizationProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTOptimizationProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTOptimizationProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTOptimizationProfile.Merge(m, src)
}
func (m *TensorRTOptimizationProfile) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTOptimizationProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTOptimizationProfile.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTOptimizationProfile proto.InternalMessageInfo

func (m *TensorRTOptimizationProfile) GetTensorShapeRange() []*TensorRTTensorShapeRange {
	if m != nil {
		return m.TensorShapeRange
	}
	return nil
}

type TensorRTTensorShapeRange struct {
	TensorName string  `protobuf:"bytes,1,opt,name=tensor_name,json=tensorName,proto3" json:"tensor_name,omitempty"`
	Dim        []int32 `protobuf:"varint,2,rep,packed,name=dim,proto3" json:"dim,omitempty"`
}

func (m *TensorRTTensorShapeRange) Reset()      { *m = TensorRTTensorShapeRange{} }
func (*TensorRTTensorShapeRange) ProtoMessage() {}
func (*TensorRTTensorShapeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{24}
}
func (m *TensorRTTensorShapeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTTensorShapeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTTensorShapeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTTensorShapeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTTensorShapeRange.Merge(m, src)
}
func (m *TensorRTTensorShapeRange) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTTensorShapeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTTensorShapeRange.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTTensorShapeRange proto.InternalMessageInfo

func (m *TensorRTTensorShapeRange) GetTensorName() string {
	if m != nil {
		return m.TensorName
	}
	return ""
}

func (m *TensorRTTensorShapeRange) GetDim() []int32 {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorRTMemPoolLimits struct {
	Workspace int64 `protobuf:"varint,1,opt,name=workspace,proto3" json:"workspace,omitempty"`
}

func (m *TensorRTMemPoolLimits) Reset()      { *m = TensorRTMemPoolLimits{} }
func (*TensorRTMemPoolLimits) ProtoMessage() {}
func (*TensorRTMemPoolLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{25}
}
func (m *TensorRTMemPoolLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTMemPoolLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTMemPoolLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTMemPoolLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTMemPoolLimits.Merge(m, src)
}
func (m *TensorRTMemPoolLimits) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTMemPoolLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTMemPoolLimits.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTMemPoolLimits proto.InternalMessageInfo

func (m *TensorRTMemPoolLimits) GetWorkspace() int64 {
	if m != nil {
		return m.Workspace
	}
	return 0
}

type OpenVINOModelSpec struct {
	InputShape []*OpenVINOModelSpec_TensorShape `protobuf:"bytes,1,rep,name=input_shape,json=inputShape,proto3" json:"input_shape,omitempty"`
}

func (m *OpenVINOModelSpec) Reset()      { *m = OpenVINOModelSpec{} }
func (*OpenVINOModelSpec) ProtoMessage() {}
func (*OpenVINOModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{26}
}
func (m *OpenVINOModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenVINOModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenVINOModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenVINOModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenVINOModelSpec.Merge(m, src)
}
func (m *OpenVINOModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *OpenVINOModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenVINOModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OpenVINOModelSpec proto.InternalMessageInfo

func (m *OpenVINOModelSpec) GetInputShape() []*OpenVINOModelSpec_TensorShape {
	if m != nil {
		return m.InputShape
	}
	return nil
}

type OpenVINOModelSpec_TensorShape struct {
	Dim []int32 `protobuf:"varint,1,rep,packed,name=dim,proto3" json:"dim,omitempty"`
}

func (m *OpenVINOModelSpec_TensorShape) Reset()      { *m = OpenVINOModelSpec_TensorShape{} }
func (*OpenVINOModelSpec_TensorShape) ProtoMessage() {}
func (*OpenVINOModelSpec_TensorShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{26, 0}
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenVINOModelSpec_TensorShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenVINOModelSpec_TensorShape.Merge(m, src)
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Size() int {
	return m.Size()
}
func (m *OpenVINOModelSpec_TensorShape) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenVINOModelSpec_TensorShape.DiscardUnknown(m)
}

var xxx_messageInfo_OpenVINOModelSpec_TensorShape proto.InternalMessageInfo

func (m *OpenVINOModelSpec_TensorShape) GetDim() []int32 {
	if m != nil {
		return m.Dim
	}
	return nil
}

func init() {
	proto.RegisterEnum("gml.internal.api.core.v1.LogicalPipelineNodeKind", LogicalPipelineNodeKind_name, LogicalPipelineNodeKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.PipelineState", PipelineState_name, PipelineState_value)
	proto.RegisterEnum("gml.internal.api.core.v1.BoundingBoxInfo_BoundingBoxFormat", BoundingBoxInfo_BoundingBoxFormat_name, BoundingBoxInfo_BoundingBoxFormat_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ModelInfo_ModelKind", ModelInfo_ModelKind_name, ModelInfo_ModelKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ModelInfo_ModelStorageFormat", ModelInfo_ModelStorageFormat_name, ModelInfo_ModelStorageFormat_value)
	proto.RegisterType((*BoundingBoxInfo)(nil), "gml.internal.api.core.v1.BoundingBoxInfo")
	proto.RegisterType((*ModelInfo)(nil), "gml.internal.api.core.v1.ModelInfo")
	proto.RegisterMapType((map[string]*typespb.UUID)(nil), "gml.internal.api.core.v1.ModelInfo.FileAssetsEntry")
	proto.RegisterType((*Node)(nil), "gml.internal.api.core.v1.Node")
	proto.RegisterType((*ParamRef)(nil), "gml.internal.api.core.v1.ParamRef")
	proto.RegisterType((*Value)(nil), "gml.internal.api.core.v1.Value")
	proto.RegisterType((*Value_ModelRef)(nil), "gml.internal.api.core.v1.Value.ModelRef")
	proto.RegisterType((*Value_Lambda)(nil), "gml.internal.api.core.v1.Value.Lambda")
	proto.RegisterType((*NodeAttributes)(nil), "gml.internal.api.core.v1.NodeAttributes")
	proto.RegisterType((*NodeInput)(nil), "gml.internal.api.core.v1.NodeInput")
	proto.RegisterType((*NodeInput_NodeOutputRef)(nil), "gml.internal.api.core.v1.NodeInput.NodeOutputRef")
	proto.RegisterType((*NodeInput_LambdaInputRef)(nil), "gml.internal.api.core.v1.NodeInput.LambdaInputRef")
	proto.RegisterType((*NodeOutput)(nil), "gml.internal.api.core.v1.NodeOutput")
	proto.RegisterType((*Param)(nil), "gml.internal.api.core.v1.Param")
	proto.RegisterType((*LogicalPipeline)(nil), "gml.internal.api.core.v1.LogicalPipeline")
	proto.RegisterType((*PipelineDeployment)(nil), "gml.internal.api.core.v1.PipelineDeployment")
	proto.RegisterType((*PipelineDeploymentSpec)(nil), "gml.internal.api.core.v1.PipelineDeploymentSpec")
	proto.RegisterType((*PipelineDeploymentStatus)(nil), "gml.internal.api.core.v1.PipelineDeploymentStatus")
	proto.RegisterType((*PhysicalPipeline)(nil), "gml.internal.api.core.v1.PhysicalPipeline")
	proto.RegisterType((*PhysicalPipelineSpec)(nil), "gml.internal.api.core.v1.PhysicalPipelineSpec")
	proto.RegisterType((*PhysicalPipelineStatus)(nil), "gml.internal.api.core.v1.PhysicalPipelineStatus")
	proto.RegisterType((*Pipeline)(nil), "gml.internal.api.core.v1.Pipeline")
	proto.RegisterType((*PipelineNode)(nil), "gml.internal.api.core.v1.PipelineNode")
	proto.RegisterMapType((map[string]string)(nil), "gml.internal.api.core.v1.PipelineNode.AttrEntry")
	proto.RegisterType((*Port)(nil), "gml.internal.api.core.v1.Port")
	proto.RegisterType((*FileResource)(nil), "gml.internal.api.core.v1.FileResource")
	proto.RegisterType((*ExecutionSpec)(nil), "gml.internal.api.core.v1.ExecutionSpec")
	proto.RegisterType((*ModelSpec)(nil), "gml.internal.api.core.v1.ModelSpec")
	proto.RegisterType((*TensorRTModelSpec)(nil), "gml.internal.api.core.v1.TensorRTModelSpec")
	proto.RegisterType((*TensorRTOptimizationProfile)(nil), "gml.internal.api.core.v1.TensorRTOptimizationProfile")
	proto.RegisterType((*TensorRTTensorShapeRange)(nil), "gml.internal.api.core.v1.TensorRTTensorShapeRange")
	proto.RegisterType((*TensorRTMemPoolLimits)(nil), "gml.internal.api.core.v1.TensorRTMemPoolLimits")
	proto.RegisterType((*OpenVINOModelSpec)(nil), "gml.internal.api.core.v1.OpenVINOModelSpec")
	proto.RegisterType((*OpenVINOModelSpec_TensorShape)(nil), "gml.internal.api.core.v1.OpenVINOModelSpec.TensorShape")
}

func init() {
	proto.RegisterFile("src/api/corepb/v1/model_exec.proto", fileDescriptor_2eacf87cbdc6b8b6)
}

var fileDescriptor_2eacf87cbdc6b8b6 = []byte{
	// 2454 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcb, 0x73, 0xdb, 0xc6,
	0x19, 0x17, 0xf8, 0x92, 0xf8, 0x51, 0x32, 0xa1, 0xb5, 0xec, 0x30, 0x4c, 0x4c, 0xca, 0x48, 0xe2,
	0xa8, 0xa9, 0x43, 0xc6, 0x8a, 0x1f, 0x69, 0xd2, 0x76, 0xca, 0x07, 0x68, 0xa1, 0xa6, 0x48, 0x75,
	0x49, 0xd9, 0x52, 0x7a, 0x40, 0x41, 0x62, 0x45, 0x61, 0x0c, 0x02, 0x18, 0x02, 0x74, 0xa4, 0x5c,
	0x9a, 0xe9, 0xf4, 0xd2, 0xe9, 0x4c, 0x27, 0xd3, 0x63, 0xa7, 0xb7, 0x1e, 0x9a, 0x7f, 0xa4, 0x33,
	0x3d, 0xba, 0xed, 0xa1, 0x39, 0xa9, 0x0d, 0x73, 0x49, 0x6f, 0xb9, 0xb4, 0xc7, 0x4e, 0x67, 0x77,
	0x41, 0x0a, 0xa4, 0xf8, 0x90, 0xc7, 0x97, 0x9e, 0xb4, 0xfb, 0xed, 0xef, 0xfb, 0x7d, 0xfb, 0xbd,
	0x96, 0xbb, 0x10, 0x48, 0x6e, 0xaf, 0x9d, 0xd7, 0x1c, 0x23, 0xdf, 0xb6, 0x7b, 0xc4, 0x69, 0xe5,
	0x9f, 0xdd, 0xc9, 0x77, 0x6d, 0x9d, 0x98, 0x2a, 0x39, 0x21, 0xed, 0x9c, 0xd3, 0xb3, 0x3d, 0x1b,
	0xa5, 0x3a, 0x5d, 0x33, 0x67, 0x58, 0x1e, 0xe9, 0x59, 0x9a, 0x99, 0xd3, 0x1c, 0x23, 0x47, 0xc1,
	0xb9, 0x67, 0x77, 0xd2, 0x1b, 0x1d, 0xbb, 0x63, 0x33, 0x50, 0x9e, 0x8e, 0x38, 0x3e, 0xfd, 0x66,
	0x97, 0xe8, 0x86, 0xe6, 0x18, 0x0e, 0xc9, 0x1f, 0xf5, 0xb4, 0x2e, 0xf9, 0xc4, 0xee, 0x3d, 0xcd,
	0xb7, 0x35, 0xb3, 0xdd, 0x37, 0x35, 0xcf, 0xee, 0xf9, 0xa8, 0x1b, 0xd4, 0x72, 0xdb, 0xee, 0x76,
	0x6d, 0x2b, 0xef, 0x9d, 0x3a, 0xc4, 0x75, 0x5a, 0xf9, 0x7e, 0xdf, 0xd0, 0xfd, 0xe5, 0x6c, 0xc7,
	0xb6, 0x3b, 0x26, 0xc9, 0xb3, 0x59, 0xab, 0x7f, 0x94, 0xf7, 0x8c, 0x2e, 0x71, 0x3d, 0xad, 0xeb,
	0x70, 0x80, 0xf4, 0xc7, 0x10, 0x24, 0x8b, 0x76, 0xdf, 0xd2, 0x0d, 0xab, 0x53, 0xb4, 0x4f, 0x14,
	0xeb, 0xc8, 0x46, 0x1f, 0x03, 0xb4, 0xec, 0x13, 0xf5, 0xc8, 0xee, 0x75, 0x35, 0x2f, 0x25, 0x6c,
	0x0a, 0x5b, 0x57, 0xb6, 0x3f, 0xca, 0xcd, 0xda, 0x7e, 0x6e, 0x42, 0x3d, 0x38, 0xaf, 0x30, 0x0a,
	0x1c, 0x6f, 0x0d, 0x87, 0xe8, 0x2d, 0xb8, 0x42, 0xb9, 0x2d, 0x3a, 0x33, 0x8d, 0x4f, 0x89, 0x9e,
	0x0a, 0x6d, 0x0a, 0x5b, 0x2b, 0x78, 0xad, 0x65, 0x9f, 0xd4, 0x46, 0x42, 0xe9, 0x73, 0x01, 0xd6,
	0x2f, 0xf0, 0xa0, 0x2c, 0xbc, 0x56, 0xac, 0xef, 0xd7, 0xca, 0x4a, 0xed, 0xa1, 0x5a, 0xac, 0x1f,
	0xa8, 0x95, 0x3a, 0xde, 0x2d, 0x34, 0xd5, 0xfd, 0xda, 0xa3, 0x5a, 0xfd, 0x49, 0x4d, 0x5c, 0x42,
	0x19, 0x48, 0x4f, 0x03, 0x94, 0x0e, 0x4a, 0x87, 0x4f, 0x76, 0x44, 0x01, 0xbd, 0x0e, 0xa9, 0x69,
	0xeb, 0x87, 0x07, 0x87, 0x07, 0x62, 0x68, 0xd6, 0xea, 0xc1, 0xe1, 0xc1, 0xa1, 0x18, 0x96, 0xfe,
	0x1d, 0x83, 0xf8, 0x2e, 0x4d, 0x2a, 0x8b, 0x11, 0x82, 0x88, 0xa5, 0x75, 0x09, 0x8b, 0x4e, 0x1c,
	0xb3, 0x31, 0x2a, 0x40, 0xe4, 0xa9, 0x61, 0x71, 0x8f, 0xae, 0x6c, 0xbf, 0x3b, 0x3b, 0x62, 0x23,
	0x1a, 0x3e, 0x7a, 0x64, 0x58, 0x3a, 0x66, 0xaa, 0xa8, 0x06, 0x31, 0x3f, 0xec, 0x61, 0x46, 0x72,
	0xff, 0xd2, 0x24, 0x0d, 0xcf, 0xee, 0x69, 0x1d, 0xe2, 0x47, 0xdc, 0x67, 0x41, 0x4d, 0x48, 0x1c,
	0x19, 0x26, 0x51, 0x35, 0xd7, 0x25, 0x9e, 0x9b, 0x8a, 0x6c, 0x86, 0xb7, 0x12, 0xdb, 0xef, 0x5f,
	0x86, 0xb4, 0x62, 0x98, 0xa4, 0xc0, 0xb4, 0x64, 0xcb, 0xeb, 0x9d, 0x62, 0x38, 0x1a, 0x09, 0xd0,
	0x4d, 0x58, 0x6d, 0x9b, 0x9a, 0xeb, 0xaa, 0xa6, 0xd6, 0x22, 0xa6, 0x9b, 0xd2, 0x37, 0xc3, 0x5b,
	0x71, 0x9c, 0x60, 0xb2, 0x2a, 0x13, 0xa1, 0x0a, 0xc4, 0x5b, 0x34, 0xd1, 0x86, 0x75, 0x64, 0xa7,
	0xc8, 0xa6, 0xb0, 0x95, 0xd8, 0xfe, 0xce, 0xa5, 0x4b, 0x08, 0xaf, 0x50, 0x5d, 0x3a, 0x4a, 0xd7,
	0x20, 0x39, 0xb1, 0x13, 0x24, 0x42, 0xf8, 0x29, 0x39, 0xf5, 0x23, 0x4f, 0x87, 0xe8, 0x2d, 0x88,
	0x3e, 0xd3, 0xcc, 0x3e, 0x61, 0x91, 0x4f, 0x6c, 0x27, 0x99, 0x21, 0xd6, 0x0d, 0xb9, 0xfd, 0x7d,
	0xa5, 0x8c, 0xf9, 0xea, 0x87, 0xa1, 0x0f, 0x04, 0xe9, 0x77, 0x82, 0x9f, 0x45, 0x1a, 0x74, 0x74,
	0x1d, 0xd0, 0x6e, 0xbd, 0x2c, 0x57, 0xd5, 0x47, 0x4a, 0xad, 0x1c, 0xa8, 0xa3, 0x0d, 0x10, 0x03,
	0xf2, 0x66, 0x1d, 0x97, 0x68, 0xf5, 0xa4, 0xe1, 0xfa, 0xa4, 0xb4, 0x51, 0xc2, 0xca, 0x5e, 0x53,
	0x0c, 0xa1, 0xab, 0x90, 0x0c, 0xac, 0xd5, 0x6b, 0xb5, 0x03, 0x31, 0x8c, 0xae, 0xc1, 0x7a, 0x50,
	0xa1, 0x52, 0x55, 0x9a, 0xb2, 0x18, 0x41, 0xaf, 0xc0, 0xd5, 0x20, 0x76, 0x4f, 0xae, 0x3d, 0x56,
	0x6a, 0x75, 0x31, 0x2a, 0xfd, 0x36, 0x04, 0xe8, 0x62, 0x32, 0xd1, 0x26, 0xbc, 0xce, 0xf1, 0x8d,
	0x66, 0x1d, 0x17, 0x1e, 0xca, 0x17, 0xeb, 0xfe, 0x16, 0x48, 0x53, 0x11, 0xbb, 0x55, 0x05, 0xab,
	0xc5, 0xc3, 0xa6, 0x5c, 0xaa, 0x97, 0x65, 0x51, 0x40, 0x12, 0x64, 0x66, 0xe3, 0x9a, 0xf2, 0x01,
	0xf5, 0xe4, 0x26, 0xdc, 0x98, 0x8a, 0xd9, 0xc3, 0xf5, 0x66, 0xbd, 0xb8, 0x5f, 0x11, 0xc3, 0xe8,
	0x0d, 0xc8, 0xce, 0x86, 0x70, 0x9e, 0xc8, 0x4c, 0x50, 0xa5, 0x5a, 0x68, 0x16, 0xf7, 0x2b, 0x15,
	0x19, 0x8b, 0xd1, 0x99, 0xc6, 0x46, 0x41, 0x89, 0x49, 0x5f, 0x84, 0x20, 0x52, 0xb3, 0x75, 0x32,
	0xb5, 0xe5, 0xe4, 0xb1, 0x96, 0xbb, 0x33, 0xbb, 0xc2, 0xaa, 0x76, 0xc7, 0x68, 0x6b, 0xe6, 0x9e,
	0xe1, 0x10, 0xd3, 0xb0, 0x08, 0x25, 0x0c, 0xb4, 0xdd, 0x0e, 0x80, 0xe6, 0x79, 0x3d, 0xa3, 0xd5,
	0xf7, 0x88, 0x9b, 0x0a, 0xb3, 0x2e, 0xd9, 0x9a, 0x4d, 0x46, 0xb5, 0x0b, 0x23, 0x3c, 0x0e, 0xe8,
	0xa2, 0x8f, 0x20, 0x66, 0x58, 0x4e, 0x7f, 0xd4, 0x6b, 0x6f, 0xcc, 0x67, 0x51, 0x28, 0x16, 0xfb,
	0x2a, 0xe8, 0x87, 0xb0, 0x6c, 0xf7, 0x3d, 0xa6, 0x1d, 0x65, 0xda, 0x6f, 0xce, 0xd7, 0xae, 0x33,
	0x30, 0x1e, 0x2a, 0x49, 0x19, 0x58, 0xd9, 0xd3, 0x7a, 0x5a, 0x17, 0x93, 0xa3, 0x69, 0xd1, 0x92,
	0x7e, 0x11, 0x81, 0xe8, 0x63, 0xda, 0x0a, 0xe8, 0x26, 0x24, 0x5c, 0xaf, 0x67, 0x58, 0x1d, 0x55,
	0xd7, 0x3c, 0x8d, 0x83, 0x76, 0x96, 0x30, 0x70, 0x61, 0x59, 0xf3, 0x34, 0x94, 0x05, 0x30, 0x2c,
	0xef, 0xfe, 0x5d, 0x8e, 0xa0, 0x01, 0x0e, 0xef, 0x2c, 0xe1, 0x38, 0x93, 0x31, 0xc0, 0x4d, 0x48,
	0xe8, 0x76, 0xbf, 0x65, 0x12, 0x8e, 0xa0, 0x07, 0x96, 0x40, 0x39, 0xb8, 0x90, 0x41, 0x6e, 0x40,
	0xbc, 0x65, 0xdb, 0x26, 0x07, 0x44, 0xe8, 0x41, 0xbf, 0xb3, 0x84, 0x57, 0xa8, 0x88, 0x2d, 0x2b,
	0x90, 0x30, 0xb5, 0x6e, 0x4b, 0xd7, 0x38, 0x20, 0xca, 0xba, 0xf7, 0xd6, 0x6c, 0x9f, 0xd9, 0xde,
	0x73, 0x55, 0xa6, 0x42, 0x2d, 0x71, 0x65, 0x9f, 0x0a, 0xf8, 0x2f, 0x2e, 0x63, 0x8a, 0x31, 0xa6,
	0xad, 0x45, 0x4c, 0xac, 0xd7, 0x30, 0x39, 0xa2, 0x7e, 0x31, 0x6d, 0x46, 0x55, 0x02, 0x70, 0x68,
	0x14, 0x39, 0xd5, 0x32, 0xa3, 0x92, 0x66, 0x53, 0x0d, 0x23, 0x4e, 0x49, 0x98, 0x1e, 0x25, 0x49,
	0x67, 0x60, 0x65, 0xc8, 0x3e, 0x2d, 0x15, 0x69, 0x07, 0x62, 0xdc, 0x0f, 0x74, 0x7d, 0x54, 0x31,
	0x02, 0x3b, 0x46, 0x87, 0xc5, 0x90, 0x3a, 0x2f, 0x86, 0x10, 0x5b, 0x18, 0x4e, 0xd1, 0x5d, 0x88,
	0x5a, 0xb6, 0x3e, 0x2a, 0xd4, 0xcc, 0xfc, 0x22, 0xc1, 0x1c, 0x5c, 0x8c, 0x41, 0x84, 0x3a, 0x24,
	0xfd, 0x14, 0xae, 0x8c, 0xd7, 0xef, 0xd4, 0xc6, 0xba, 0x37, 0x7e, 0xa4, 0x66, 0x17, 0x84, 0xd2,
	0x3f, 0x62, 0xa5, 0xdf, 0x87, 0x21, 0x3e, 0xaa, 0xeb, 0x19, 0x1d, 0x9b, 0xe0, 0xd1, 0x0d, 0xd2,
	0x5f, 0x2e, 0xbc, 0x3c, 0x2d, 0xbc, 0x80, 0x55, 0x58, 0xa7, 0x6e, 0xa9, 0x3c, 0x26, 0x3e, 0x59,
	0x98, 0x91, 0xdd, 0xb9, 0x44, 0xcb, 0x05, 0xdb, 0x87, 0x71, 0x27, 0xad, 0x91, 0x80, 0x1b, 0x68,
	0x01, 0xf2, 0x6b, 0x93, 0xe5, 0xc3, 0xb7, 0x10, 0x61, 0x16, 0xb6, 0x2f, 0x63, 0x81, 0xa7, 0x97,
	0x37, 0x38, 0x33, 0x21, 0x9a, 0xe7, 0x12, 0x66, 0x23, 0xfd, 0x23, 0x58, 0x1b, 0xdb, 0x07, 0x7a,
	0x0d, 0xe2, 0xcc, 0xab, 0x40, 0xd4, 0x56, 0xa8, 0xa0, 0x46, 0x23, 0x37, 0x8c, 0x66, 0x28, 0x50,
	0x46, 0x6f, 0xc2, 0x95, 0x71, 0x3b, 0xd3, 0x62, 0x5e, 0x5c, 0xf6, 0x93, 0x29, 0x6d, 0x02, 0x9c,
	0x1b, 0x9c, 0x7a, 0x44, 0x68, 0x10, 0x65, 0x11, 0x9f, 0x9a, 0xbb, 0x32, 0xac, 0xe9, 0xe4, 0x48,
	0xeb, 0x9b, 0x9e, 0xfa, 0x42, 0xc5, 0xb1, 0xea, 0x6b, 0xb1, 0x99, 0xf4, 0x99, 0x00, 0xc9, 0x89,
	0xe3, 0x18, 0x3d, 0x80, 0x18, 0x4b, 0x2e, 0x6f, 0x82, 0xb9, 0x94, 0xbc, 0x20, 0x7c, 0xf8, 0x79,
	0x2f, 0x84, 0x5e, 0xa0, 0x17, 0xa4, 0x6f, 0xc3, 0x80, 0x86, 0xb6, 0xcb, 0xc4, 0x31, 0xed, 0xd3,
	0x2e, 0xb1, 0x3c, 0xf4, 0x36, 0x84, 0x0c, 0x9d, 0x79, 0x7c, 0xf1, 0x12, 0x51, 0x8c, 0x0d, 0xce,
	0xb2, 0x21, 0xa5, 0x8c, 0x43, 0x86, 0x8e, 0x1e, 0xc3, 0x55, 0x93, 0x7b, 0xa0, 0x3a, 0x3e, 0x8d,
	0x6a, 0xe8, 0x33, 0xae, 0x1f, 0xc5, 0x6b, 0x83, 0xb3, 0xec, 0xfa, 0x84, 0xc7, 0x4a, 0x19, 0xaf,
	0x9b, 0x13, 0x22, 0x1d, 0x3d, 0x80, 0x95, 0x23, 0x93, 0x10, 0x8f, 0x92, 0x85, 0xa7, 0x93, 0x25,
	0x06, 0x67, 0xd9, 0xe5, 0x0a, 0x05, 0x29, 0x65, 0xbc, 0xcc, 0xd0, 0x8a, 0x8e, 0xbe, 0x07, 0xd0,
	0xee, 0x11, 0xcd, 0x23, 0xba, 0xaa, 0x79, 0x7e, 0x95, 0xa6, 0x73, 0xfc, 0xf2, 0x9f, 0x1b, 0x5e,
	0xfe, 0x73, 0xcd, 0xe1, 0xe5, 0x1f, 0xc7, 0x7d, 0x74, 0xc1, 0xa3, 0xaa, 0x7d, 0x47, 0x1f, 0xaa,
	0x46, 0x17, 0xab, 0xfa, 0xe8, 0x82, 0x47, 0x8f, 0xa8, 0x67, 0xa4, 0xe7, 0x1a, 0xb6, 0xc5, 0x4e,
	0xdc, 0x30, 0x1e, 0x4e, 0x51, 0x19, 0x22, 0xae, 0x43, 0xda, 0xfe, 0xe9, 0xf9, 0xde, 0x9c, 0x6c,
	0x5e, 0xc8, 0x42, 0xc3, 0x21, 0x6d, 0xcc, 0xb4, 0xd1, 0x8f, 0x21, 0xe6, 0x7a, 0x9a, 0xd7, 0x77,
	0x53, 0x2b, 0x8b, 0xfa, 0x6e, 0x0a, 0x0f, 0xd3, 0xc4, 0x3e, 0x83, 0xf4, 0x04, 0xae, 0x4f, 0xb7,
	0x85, 0x7e, 0x00, 0x51, 0x8a, 0x21, 0xfe, 0x4b, 0xe7, 0xed, 0xc5, 0x46, 0x28, 0x35, 0xc1, 0x5c,
	0x4b, 0x3a, 0x84, 0xd4, 0x2c, 0xe3, 0x2f, 0x4b, 0xfd, 0x9f, 0x30, 0x88, 0x7b, 0xc7, 0xa7, 0xee,
	0x58, 0xab, 0x5c, 0xba, 0x48, 0x55, 0xb8, 0x3e, 0x2a, 0x4e, 0x7d, 0xb4, 0xb3, 0x39, 0x75, 0x9a,
	0x1a, 0x9c, 0x65, 0x37, 0x2e, 0xfa, 0xa2, 0x94, 0xf1, 0x86, 0x73, 0x51, 0xaa, 0xa3, 0x0f, 0x21,
	0xae, 0x93, 0x67, 0x46, 0x9b, 0xcc, 0x29, 0xd7, 0xd5, 0xc1, 0x59, 0x76, 0xa5, 0xcc, 0x50, 0x4a,
	0x19, 0xaf, 0x70, 0xfc, 0xff, 0x61, 0xc1, 0x16, 0xc7, 0x0a, 0x36, 0x37, 0x27, 0x51, 0x13, 0xf9,
	0x08, 0x94, 0xeb, 0xce, 0x44, 0xb9, 0xbe, 0xf7, 0x02, 0x2c, 0xe3, 0xc5, 0xba, 0x0f, 0x1b, 0xd3,
	0xec, 0xbc, 0x6c, 0x3d, 0xd1, 0x1e, 0x98, 0x6a, 0xf8, 0x65, 0x89, 0x77, 0x60, 0x65, 0x54, 0x9f,
	0xdf, 0x1f, 0x3f, 0x91, 0x6f, 0x2d, 0xa6, 0x0a, 0x9e, 0xcc, 0x7f, 0x08, 0xc1, 0x6a, 0x50, 0x8e,
	0xae, 0x8c, 0xca, 0x3d, 0xc2, 0xaa, 0x1a, 0x41, 0x84, 0x96, 0xd7, 0xf0, 0x57, 0x90, 0x8e, 0xd1,
	0xfd, 0xd1, 0x15, 0x6a, 0xe1, 0x8d, 0x68, 0xcf, 0xee, 0x9d, 0xdf, 0xb7, 0x3f, 0x38, 0xbf, 0x62,
	0x45, 0x2e, 0xa5, 0x38, 0xba, 0x82, 0x95, 0x21, 0x42, 0x2f, 0xfd, 0xfe, 0x35, 0xfd, 0xbd, 0xcb,
	0xf9, 0x98, 0xa3, 0x77, 0x2e, 0xfe, 0x9a, 0x66, 0xda, 0xe9, 0x07, 0x10, 0x1f, 0x89, 0xa6, 0x3c,
	0x6b, 0x37, 0x82, 0x77, 0xb0, 0x78, 0xf0, 0x15, 0x7b, 0x1b, 0x22, 0x74, 0x3f, 0x53, 0x7f, 0xa4,
	0x45, 0x08, 0x5b, 0xc4, 0xf3, 0x75, 0xe8, 0x50, 0xfa, 0xa5, 0x00, 0xab, 0xf4, 0x11, 0x8d, 0x89,
	0x6b, 0xf7, 0x7b, 0x6d, 0x82, 0xee, 0xc2, 0x32, 0xfb, 0x2a, 0x30, 0xfb, 0x1c, 0x81, 0xc1, 0x59,
	0x36, 0x46, 0x75, 0x94, 0x32, 0x8e, 0x51, 0xac, 0xa2, 0xa3, 0x1b, 0x00, 0xae, 0xf1, 0x29, 0x51,
	0x5b, 0xa7, 0x1e, 0xcb, 0x2e, 0xcd, 0x48, 0x9c, 0x4a, 0x8a, 0x54, 0x80, 0xb2, 0x90, 0x70, 0x8f,
	0xb5, 0xed, 0x7b, 0xf7, 0xd5, 0x63, 0xcd, 0x3d, 0x66, 0xe7, 0x41, 0x1c, 0x03, 0x17, 0xed, 0x68,
	0xee, 0xb1, 0xf4, 0x6b, 0x01, 0xd6, 0xe4, 0x13, 0xd2, 0xee, 0x7b, 0x86, 0x6d, 0xb1, 0x72, 0xbe,
	0x0f, 0xd1, 0x4e, 0x4f, 0x73, 0x8e, 0xfd, 0x5d, 0x6c, 0xe6, 0x46, 0x9f, 0xbc, 0x72, 0xa5, 0xd1,
	0x87, 0xae, 0x87, 0x14, 0x51, 0xb2, 0xad, 0x23, 0xa3, 0x83, 0x39, 0x1c, 0x15, 0x87, 0x97, 0x7d,
	0xd6, 0xb2, 0xa1, 0x45, 0x0f, 0x2d, 0xfe, 0xa4, 0xa6, 0x7d, 0xca, 0x6f, 0xf9, 0x74, 0x28, 0xfd,
	0x2a, 0xec, 0x7f, 0x08, 0x60, 0x3b, 0x99, 0x16, 0xc8, 0xf7, 0x61, 0xcd, 0xb6, 0xac, 0x13, 0xb5,
	0x65, 0xda, 0x2d, 0x95, 0xa6, 0x86, 0x85, 0xb4, 0x98, 0x1c, 0x9c, 0x65, 0x13, 0xf4, 0x81, 0x5f,
	0x34, 0xed, 0xd6, 0x23, 0x72, 0x8a, 0x13, 0x14, 0xe5, 0x4f, 0xd0, 0x4f, 0x20, 0xce, 0x94, 0x68,
	0xcc, 0xfc, 0x33, 0x71, 0x4e, 0x07, 0x04, 0xb3, 0xc2, 0x8f, 0x4a, 0x4a, 0xcc, 0xa4, 0x2b, 0x94,
	0x86, 0x8e, 0xe8, 0xa1, 0xd5, 0xeb, 0x5b, 0x9e, 0xd1, 0x25, 0xa9, 0x6d, 0xb6, 0xbd, 0xe1, 0x14,
	0xb5, 0x60, 0xcd, 0x23, 0x96, 0x6b, 0xf7, 0x7a, 0x1e, 0x0f, 0x85, 0xce, 0x0c, 0x7e, 0x77, 0xb6,
	0xc1, 0x26, 0x83, 0xe3, 0xe6, 0xc8, 0xf3, 0xa2, 0x38, 0x38, 0xcb, 0xae, 0x0e, 0xc5, 0x2c, 0x48,
	0xab, 0x43, 0x4e, 0x16, 0x99, 0x16, 0xac, 0xd9, 0x0e, 0xb1, 0x9e, 0x19, 0x96, 0xcd, 0x6d, 0x90,
	0x45, 0x36, 0xea, 0x0e, 0xb1, 0xe8, 0xdb, 0x7d, 0xc2, 0xc6, 0x50, 0xcc, 0x6d, 0x0c, 0x39, 0x59,
	0x2e, 0xfe, 0x2b, 0xc0, 0xfa, 0x85, 0x9d, 0xa1, 0x63, 0xd8, 0xb0, 0x1d, 0xcf, 0xe8, 0x1a, 0x9f,
	0x6a, 0xb4, 0x62, 0x54, 0xa7, 0x67, 0xb3, 0xa8, 0xf2, 0x1b, 0xe2, 0xbd, 0xc5, 0x4e, 0xd6, 0x03,
	0xda, 0x7b, 0x5c, 0x19, 0x5f, 0xb5, 0x2f, 0x0a, 0xd1, 0x2d, 0x48, 0x12, 0xab, 0x43, 0x7f, 0x27,
	0xc7, 0x73, 0x8d, 0xd7, 0xb8, 0x78, 0x98, 0xdc, 0x27, 0x90, 0xec, 0x92, 0xae, 0xea, 0xd0, 0x27,
	0xad, 0x69, 0x74, 0x0d, 0x76, 0xe0, 0xd0, 0x68, 0xe4, 0x2f, 0x11, 0x71, 0xd2, 0xdd, 0xb3, 0x6d,
	0xb3, 0xca, 0xd4, 0xf0, 0x5a, 0x37, 0x38, 0x95, 0x7e, 0x0e, 0xaf, 0xcd, 0xd9, 0x34, 0xfa, 0x19,
	0x20, 0x9e, 0x13, 0xd5, 0x3d, 0xd6, 0x1c, 0xa2, 0xf6, 0x34, 0xab, 0x33, 0x8c, 0xc3, 0xf6, 0x62,
	0xd3, 0xfc, 0x6f, 0x83, 0xaa, 0x62, 0xaa, 0x89, 0x45, 0x6f, 0x42, 0x22, 0xed, 0x42, 0x6a, 0x16,
	0x9a, 0x36, 0xb6, 0x6f, 0x3d, 0xd0, 0x22, 0xc0, 0x45, 0x35, 0xff, 0xc4, 0xd1, 0x8d, 0x2e, 0xeb,
	0xc3, 0x28, 0xa6, 0x43, 0xe9, 0x1e, 0x5c, 0x9b, 0xea, 0x37, 0x7a, 0x1d, 0xe2, 0x9f, 0xd8, 0xbd,
	0xa7, 0xae, 0xa3, 0xb5, 0x39, 0x53, 0x18, 0x9f, 0x0b, 0xa4, 0xdf, 0x08, 0xb0, 0x7e, 0xa1, 0x7a,
	0xd0, 0x01, 0x24, 0xf8, 0x13, 0x8c, 0x39, 0xef, 0xbb, 0xfd, 0xe0, 0x05, 0xea, 0x2f, 0x17, 0x74,
	0x09, 0x18, 0x17, 0x1b, 0xa7, 0xb3, 0x90, 0x08, 0x2c, 0x0d, 0xfd, 0x10, 0x46, 0x7e, 0xbc, 0xf3,
	0xa7, 0x30, 0xbc, 0x32, 0xe3, 0xcb, 0x11, 0xba, 0x05, 0x52, 0xb5, 0xfe, 0x50, 0x29, 0x15, 0xaa,
	0xea, 0x9e, 0xb2, 0x27, 0x57, 0x95, 0x9a, 0xac, 0xd6, 0xea, 0x65, 0x79, 0xf2, 0x5b, 0xe2, 0x6d,
	0xd8, 0x9a, 0x83, 0x2b, 0x15, 0x76, 0x65, 0x5c, 0x50, 0x1b, 0xf5, 0x7d, 0x5c, 0x92, 0x45, 0x40,
	0xb7, 0xe0, 0xe6, 0x1c, 0x74, 0x59, 0x6e, 0xca, 0xa5, 0xa6, 0xf8, 0xcd, 0x32, 0xda, 0x82, 0x37,
	0xe6, 0xb1, 0x56, 0x0b, 0x8d, 0x86, 0x52, 0x39, 0x14, 0xff, 0xb5, 0x8c, 0x6e, 0xc3, 0xdb, 0x73,
	0x90, 0x95, 0x3a, 0x56, 0xe5, 0x42, 0x69, 0x47, 0xc5, 0x75, 0x45, 0xfc, 0x47, 0x02, 0xdd, 0x81,
	0xdb, 0x73, 0xd0, 0x8f, 0x95, 0xb2, 0x5c, 0x57, 0x1b, 0x4d, 0x2c, 0x17, 0x76, 0xd5, 0x86, 0x52,
	0x7b, 0x24, 0x3e, 0x4f, 0xa2, 0x07, 0xb0, 0xbd, 0x70, 0xcb, 0x4a, 0xbd, 0xd6, 0x50, 0x77, 0xe5,
	0x26, 0x56, 0x4a, 0x0d, 0xae, 0xf8, 0x97, 0x24, 0xba, 0x0b, 0xf9, 0x39, 0x8a, 0xd5, 0x42, 0x53,
	0xae, 0x95, 0x0e, 0xc7, 0xb5, 0xfe, 0x9a, 0x44, 0xdb, 0xf0, 0xee, 0x3c, 0x7f, 0x70, 0x61, 0x57,
	0x1e, 0xd7, 0xf9, 0x5b, 0xf2, 0x9d, 0xbf, 0x0b, 0xb0, 0x36, 0x76, 0x71, 0x41, 0x69, 0xb8, 0x3e,
	0xd2, 0x6e, 0x34, 0x0b, 0x4d, 0x39, 0x90, 0xb1, 0x8b, 0x6b, 0x7b, 0x32, 0xfb, 0xaf, 0x80, 0x28,
	0xa0, 0x14, 0x6c, 0x4c, 0xac, 0x61, 0xb9, 0x50, 0x3e, 0x14, 0x43, 0x53, 0xb4, 0xf0, 0x7e, 0xad,
	0x46, 0xb5, 0xc2, 0x28, 0x03, 0xe9, 0x89, 0xb5, 0xa6, 0x8c, 0x77, 0x95, 0x5a, 0xa1, 0x49, 0xd7,
	0x23, 0xe8, 0x06, 0xbc, 0x3a, 0x63, 0x5d, 0x2e, 0x8b, 0x51, 0xf4, 0x2a, 0x5c, 0x9b, 0x58, 0xae,
	0x14, 0x94, 0xaa, 0x5c, 0x16, 0x63, 0xc5, 0xf6, 0xf3, 0xaf, 0x32, 0x4b, 0x5f, 0x7e, 0x95, 0x59,
	0xfa, 0xf6, 0xab, 0x8c, 0xf0, 0xd9, 0x20, 0x23, 0x7c, 0x31, 0xc8, 0x08, 0x7f, 0x1e, 0x64, 0x84,
	0xe7, 0x83, 0x8c, 0xf0, 0xcf, 0x41, 0x46, 0xf8, 0x66, 0x90, 0x59, 0xfa, 0x76, 0x90, 0x11, 0x3e,
	0xff, 0x3a, 0xb3, 0xf4, 0xfc, 0xeb, 0xcc, 0xd2, 0x97, 0x5f, 0x67, 0x96, 0x3e, 0x7e, 0xb7, 0x63,
	0x74, 0x4d, 0xe2, 0x99, 0x5a, 0xcb, 0xcd, 0x69, 0x46, 0x9e, 0xcf, 0xf2, 0x17, 0xfe, 0x89, 0xf5,
	0x11, 0x1f, 0xb5, 0x62, 0xec, 0x56, 0xfd, 0xfe, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xfb,
	0x34, 0xd7, 0xe7, 0x1a, 0x00, 0x00,
}

func (x LogicalPipelineNodeKind) String() string {
	s, ok := LogicalPipelineNodeKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PipelineState) String() string {
	s, ok := PipelineState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BoundingBoxInfo_BoundingBoxFormat) String() string {
	s, ok := BoundingBoxInfo_BoundingBoxFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ModelInfo_ModelKind) String() string {
	s, ok := ModelInfo_ModelKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ModelInfo_ModelStorageFormat) String() string {
	s, ok := ModelInfo_ModelStorageFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BoundingBoxInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoundingBoxInfo)
	if !ok {
		that2, ok := that.(BoundingBoxInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoxFormat != that1.BoxFormat {
		return false
	}
	if this.BoxNormalized != that1.BoxNormalized {
		return false
	}
	return true
}
func (this *ModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelInfo)
	if !ok {
		that2, ok := that.(ModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if len(this.FileAssets) != len(that1.FileAssets) {
		return false
	}
	for i := range this.FileAssets {
		if !this.FileAssets[i].Equal(that1.FileAssets[i]) {
			return false
		}
	}
	if len(this.ClassLabels) != len(that1.ClassLabels) {
		return false
	}
	for i := range this.ClassLabels {
		if this.ClassLabels[i] != that1.ClassLabels[i] {
			return false
		}
	}
	if !this.BboxInfo.Equal(that1.BboxInfo) {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(that1.Attributes[i]) {
			return false
		}
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if !this.Inputs[i].Equal(that1.Inputs[i]) {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if !this.Outputs[i].Equal(that1.Outputs[i]) {
			return false
		}
	}
	return true
}
func (this *ParamRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParamRef)
	if !ok {
		that2, ok := that.(ParamRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Data == nil {
		if this.Data != nil {
			return false
		}
	} else if this.Data == nil {
		return false
	} else if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *Value_StringData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_StringData)
	if !ok {
		that2, ok := that.(Value_StringData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StringData != that1.StringData {
		return false
	}
	return true
}
func (this *Value_Int64Data) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Int64Data)
	if !ok {
		that2, ok := that.(Value_Int64Data)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int64Data != that1.Int64Data {
		return false
	}
	return true
}
func (this *Value_DoubleData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_DoubleData)
	if !ok {
		that2, ok := that.(Value_DoubleData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoubleData != that1.DoubleData {
		return false
	}
	return true
}
func (this *Value_BoolData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_BoolData)
	if !ok {
		that2, ok := that.(Value_BoolData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoolData != that1.BoolData {
		return false
	}
	return true
}
func (this *Value_LambdaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_LambdaData)
	if !ok {
		that2, ok := that.(Value_LambdaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LambdaData.Equal(that1.LambdaData) {
		return false
	}
	return true
}
func (this *Value_ModelData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ModelData)
	if !ok {
		that2, ok := that.(Value_ModelData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ModelData.Equal(that1.ModelData) {
		return false
	}
	return true
}
func (this *Value_ParamData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ParamData)
	if !ok {
		that2, ok := that.(Value_ParamData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamData.Equal(that1.ParamData) {
		return false
	}
	return true
}
func (this *Value_ModelRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ModelRef)
	if !ok {
		that2, ok := that.(Value_ModelRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Value_Lambda) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Lambda)
	if !ok {
		that2, ok := that.(Value_Lambda)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if this.Inputs[i] != that1.Inputs[i] {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if this.Outputs[i] != that1.Outputs[i] {
			return false
		}
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *NodeAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeAttributes)
	if !ok {
		that2, ok := that.(NodeAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *NodeInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput)
	if !ok {
		that2, ok := that.(NodeInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *NodeInput_ParamValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_ParamValue)
	if !ok {
		that2, ok := that.(NodeInput_ParamValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamValue.Equal(that1.ParamValue) {
		return false
	}
	return true
}
func (this *NodeInput_NodeOutputValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_NodeOutputValue)
	if !ok {
		that2, ok := that.(NodeInput_NodeOutputValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeOutputValue.Equal(that1.NodeOutputValue) {
		return false
	}
	return true
}
func (this *NodeInput_LambdaInputValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_LambdaInputValue)
	if !ok {
		that2, ok := that.(NodeInput_LambdaInputValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LambdaInputValue.Equal(that1.LambdaInputValue) {
		return false
	}
	return true
}
func (this *NodeInput_NodeOutputRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_NodeOutputRef)
	if !ok {
		that2, ok := that.(NodeInput_NodeOutputRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeName != that1.NodeName {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *NodeInput_LambdaInputRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_LambdaInputRef)
	if !ok {
		that2, ok := that.(NodeInput_LambdaInputRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *NodeOutput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeOutput)
	if !ok {
		that2, ok := that.(NodeOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Param) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Param)
	if !ok {
		that2, ok := that.(Param)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.DefaultValue.Equal(that1.DefaultValue) {
		return false
	}
	return true
}
func (this *LogicalPipeline) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogicalPipeline)
	if !ok {
		that2, ok := that.(LogicalPipeline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(that1.Params[i]) {
			return false
		}
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *PipelineDeployment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeployment)
	if !ok {
		that2, ok := that.(PipelineDeployment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.LogicalPipelineID.Equal(that1.LogicalPipelineID) {
		return false
	}
	if !this.FleetID.Equal(that1.FleetID) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *PipelineDeploymentSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeploymentSpec)
	if !ok {
		that2, ok := that.(PipelineDeploymentSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *PipelineDeploymentStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeploymentStatus)
	if !ok {
		that2, ok := that.(PipelineDeploymentStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *PhysicalPipeline) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipeline)
	if !ok {
		that2, ok := that.(PhysicalPipeline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.PipelineDeploymentID.Equal(that1.PipelineDeploymentID) {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *PhysicalPipelineSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineSpec)
	if !ok {
		that2, ok := that.(PhysicalPipelineSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *PhysicalPipelineStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineStatus)
	if !ok {
		that2, ok := that.(PhysicalPipelineStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *Pipeline) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Pipeline)
	if !ok {
		that2, ok := that.(Pipeline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *PipelineNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineNode)
	if !ok {
		that2, ok := that.(PipelineNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if !this.Inputs[i].Equal(that1.Inputs[i]) {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if !this.Outputs[i].Equal(that1.Outputs[i]) {
			return false
		}
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if this.Attr[i] != that1.Attr[i] {
			return false
		}
	}
	return true
}
func (this *Port) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Port)
	if !ok {
		that2, ok := that.(Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Net != that1.Net {
		return false
	}
	return true
}
func (this *FileResource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileResource)
	if !ok {
		that2, ok := that.(FileResource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileID.Equal(that1.FileID) {
		return false
	}
	if this.SizeBytes != that1.SizeBytes {
		return false
	}
	if this.Sha256Hash != that1.Sha256Hash {
		return false
	}
	return true
}
func (this *ExecutionSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionSpec)
	if !ok {
		that2, ok := that.(ExecutionSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if len(this.ModelSpec) != len(that1.ModelSpec) {
		return false
	}
	for i := range this.ModelSpec {
		if !this.ModelSpec[i].Equal(that1.ModelSpec[i]) {
			return false
		}
	}
	return true
}
func (this *ModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelSpec)
	if !ok {
		that2, ok := that.(ModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ONNXBlobKey != that1.ONNXBlobKey {
		return false
	}
	if !this.ONNXFile.Equal(that1.ONNXFile) {
		return false
	}
	if this.Runtime != that1.Runtime {
		return false
	}
	if !this.TensorRTSpec.Equal(that1.TensorRTSpec) {
		return false
	}
	if !this.OpenVINOSpec.Equal(that1.OpenVINOSpec) {
		return false
	}
	return true
}
func (this *TensorRTModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTModelSpec)
	if !ok {
		that2, ok := that.(TensorRTModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OptimizationProfile) != len(that1.OptimizationProfile) {
		return false
	}
	for i := range this.OptimizationProfile {
		if !this.OptimizationProfile[i].Equal(that1.OptimizationProfile[i]) {
			return false
		}
	}
	if this.EngineBlobKey != that1.EngineBlobKey {
		return false
	}
	if !this.MemPoolLimits.Equal(that1.MemPoolLimits) {
		return false
	}
	return true
}
func (this *TensorRTOptimizationProfile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTOptimizationProfile)
	if !ok {
		that2, ok := that.(TensorRTOptimizationProfile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TensorShapeRange) != len(that1.TensorShapeRange) {
		return false
	}
	for i := range this.TensorShapeRange {
		if !this.TensorShapeRange[i].Equal(that1.TensorShapeRange[i]) {
			return false
		}
	}
	return true
}
func (this *TensorRTTensorShapeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTTensorShapeRange)
	if !ok {
		that2, ok := that.(TensorRTTensorShapeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TensorName != that1.TensorName {
		return false
	}
	if len(this.Dim) != len(that1.Dim) {
		return false
	}
	for i := range this.Dim {
		if this.Dim[i] != that1.Dim[i] {
			return false
		}
	}
	return true
}
func (this *TensorRTMemPoolLimits) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTMemPoolLimits)
	if !ok {
		that2, ok := that.(TensorRTMemPoolLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Workspace != that1.Workspace {
		return false
	}
	return true
}
func (this *OpenVINOModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenVINOModelSpec)
	if !ok {
		that2, ok := that.(OpenVINOModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InputShape) != len(that1.InputShape) {
		return false
	}
	for i := range this.InputShape {
		if !this.InputShape[i].Equal(that1.InputShape[i]) {
			return false
		}
	}
	return true
}
func (this *OpenVINOModelSpec_TensorShape) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenVINOModelSpec_TensorShape)
	if !ok {
		that2, ok := that.(OpenVINOModelSpec_TensorShape)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dim) != len(that1.Dim) {
		return false
	}
	for i := range this.Dim {
		if this.Dim[i] != that1.Dim[i] {
			return false
		}
	}
	return true
}
func (this *BoundingBoxInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.BoundingBoxInfo{")
	s = append(s, "BoxFormat: "+fmt.Sprintf("%#v", this.BoxFormat)+",\n")
	s = append(s, "BoxNormalized: "+fmt.Sprintf("%#v", this.BoxNormalized)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&corepb.ModelInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	keysForFileAssets := make([]string, 0, len(this.FileAssets))
	for k, _ := range this.FileAssets {
		keysForFileAssets = append(keysForFileAssets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFileAssets)
	mapStringForFileAssets := "map[string]*typespb.UUID{"
	for _, k := range keysForFileAssets {
		mapStringForFileAssets += fmt.Sprintf("%#v: %#v,", k, this.FileAssets[k])
	}
	mapStringForFileAssets += "}"
	if this.FileAssets != nil {
		s = append(s, "FileAssets: "+mapStringForFileAssets+",\n")
	}
	s = append(s, "ClassLabels: "+fmt.Sprintf("%#v", this.ClassLabels)+",\n")
	if this.BboxInfo != nil {
		s = append(s, "BboxInfo: "+fmt.Sprintf("%#v", this.BboxInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&corepb.Node{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.Inputs != nil {
		s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	}
	if this.Outputs != nil {
		s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ParamRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.ParamRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&corepb.Value{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_StringData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_StringData{` +
		`StringData:` + fmt.Sprintf("%#v", this.StringData) + `}`}, ", ")
	return s
}
func (this *Value_Int64Data) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_Int64Data{` +
		`Int64Data:` + fmt.Sprintf("%#v", this.Int64Data) + `}`}, ", ")
	return s
}
func (this *Value_DoubleData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_DoubleData{` +
		`DoubleData:` + fmt.Sprintf("%#v", this.DoubleData) + `}`}, ", ")
	return s
}
func (this *Value_BoolData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_BoolData{` +
		`BoolData:` + fmt.Sprintf("%#v", this.BoolData) + `}`}, ", ")
	return s
}
func (this *Value_LambdaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_LambdaData{` +
		`LambdaData:` + fmt.Sprintf("%#v", this.LambdaData) + `}`}, ", ")
	return s
}
func (this *Value_ModelData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_ModelData{` +
		`ModelData:` + fmt.Sprintf("%#v", this.ModelData) + `}`}, ", ")
	return s
}
func (this *Value_ParamData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_ParamData{` +
		`ParamData:` + fmt.Sprintf("%#v", this.ParamData) + `}`}, ", ")
	return s
}
func (this *Value_ModelRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.Value_ModelRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Lambda) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.Value_Lambda{")
	s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.NodeAttributes{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&corepb.NodeInput{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput_ParamValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_ParamValue{` +
		`ParamValue:` + fmt.Sprintf("%#v", this.ParamValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_NodeOutputValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_NodeOutputValue{` +
		`NodeOutputValue:` + fmt.Sprintf("%#v", this.NodeOutputValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_LambdaInputValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_LambdaInputValue{` +
		`LambdaInputValue:` + fmt.Sprintf("%#v", this.LambdaInputValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_NodeOutputRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.NodeInput_NodeOutputRef{")
	s = append(s, "NodeName: "+fmt.Sprintf("%#v", this.NodeName)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput_LambdaInputRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.NodeInput_LambdaInputRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeOutput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.NodeOutput{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Param) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.Param{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.DefaultValue != nil {
		s = append(s, "DefaultValue: "+fmt.Sprintf("%#v", this.DefaultValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogicalPipeline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.LogicalPipeline{")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&corepb.PipelineDeployment{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.LogicalPipelineID != nil {
		s = append(s, "LogicalPipelineID: "+fmt.Sprintf("%#v", this.LogicalPipelineID)+",\n")
	}
	if this.FleetID != nil {
		s = append(s, "FleetID: "+fmt.Sprintf("%#v", this.FleetID)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeploymentSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.PipelineDeploymentSpec{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeploymentStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.PipelineDeploymentStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipeline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&corepb.PhysicalPipeline{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.PipelineDeploymentID != nil {
		s = append(s, "PipelineDeploymentID: "+fmt.Sprintf("%#v", this.PipelineDeploymentID)+",\n")
	}
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.PhysicalPipelineSpec{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.PhysicalPipelineStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pipeline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.Pipeline{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&corepb.PipelineNode{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Inputs != nil {
		s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	}
	if this.Outputs != nil {
		s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	}
	keysForAttr := make([]string, 0, len(this.Attr))
	for k, _ := range this.Attr {
		keysForAttr = append(keysForAttr, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttr)
	mapStringForAttr := "map[string]string{"
	for _, k := range keysForAttr {
		mapStringForAttr += fmt.Sprintf("%#v: %#v,", k, this.Attr[k])
	}
	mapStringForAttr += "}"
	if this.Attr != nil {
		s = append(s, "Attr: "+mapStringForAttr+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.Port{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Net: "+fmt.Sprintf("%#v", this.Net)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileResource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.FileResource{")
	if this.FileID != nil {
		s = append(s, "FileID: "+fmt.Sprintf("%#v", this.FileID)+",\n")
	}
	s = append(s, "SizeBytes: "+fmt.Sprintf("%#v", this.SizeBytes)+",\n")
	s = append(s, "Sha256Hash: "+fmt.Sprintf("%#v", this.Sha256Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ExecutionSpec{")
	if this.Graph != nil {
		s = append(s, "Graph: "+fmt.Sprintf("%#v", this.Graph)+",\n")
	}
	if this.ModelSpec != nil {
		s = append(s, "ModelSpec: "+fmt.Sprintf("%#v", this.ModelSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&corepb.ModelSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ONNXBlobKey: "+fmt.Sprintf("%#v", this.ONNXBlobKey)+",\n")
	if this.ONNXFile != nil {
		s = append(s, "ONNXFile: "+fmt.Sprintf("%#v", this.ONNXFile)+",\n")
	}
	s = append(s, "Runtime: "+fmt.Sprintf("%#v", this.Runtime)+",\n")
	if this.TensorRTSpec != nil {
		s = append(s, "TensorRTSpec: "+fmt.Sprintf("%#v", this.TensorRTSpec)+",\n")
	}
	if this.OpenVINOSpec != nil {
		s = append(s, "OpenVINOSpec: "+fmt.Sprintf("%#v", this.OpenVINOSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.TensorRTModelSpec{")
	if this.OptimizationProfile != nil {
		s = append(s, "OptimizationProfile: "+fmt.Sprintf("%#v", this.OptimizationProfile)+",\n")
	}
	s = append(s, "EngineBlobKey: "+fmt.Sprintf("%#v", this.EngineBlobKey)+",\n")
	if this.MemPoolLimits != nil {
		s = append(s, "MemPoolLimits: "+fmt.Sprintf("%#v", this.MemPoolLimits)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTOptimizationProfile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.TensorRTOptimizationProfile{")
	if this.TensorShapeRange != nil {
		s = append(s, "TensorShapeRange: "+fmt.Sprintf("%#v", this.TensorShapeRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTTensorShapeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.TensorRTTensorShapeRange{")
	s = append(s, "TensorName: "+fmt.Sprintf("%#v", this.TensorName)+",\n")
	s = append(s, "Dim: "+fmt.Sprintf("%#v", this.Dim)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTMemPoolLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.TensorRTMemPoolLimits{")
	s = append(s, "Workspace: "+fmt.Sprintf("%#v", this.Workspace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenVINOModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.OpenVINOModelSpec{")
	if this.InputShape != nil {
		s = append(s, "InputShape: "+fmt.Sprintf("%#v", this.InputShape)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenVINOModelSpec_TensorShape) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.OpenVINOModelSpec_TensorShape{")
	s = append(s, "Dim: "+fmt.Sprintf("%#v", this.Dim)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringModelExec(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BoundingBoxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundingBoxInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoundingBoxInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BoxNormalized {
		i--
		if m.BoxNormalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BoxFormat != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.BoxFormat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BboxInfo != nil {
		{
			size, err := m.BboxInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ClassLabels) > 0 {
		for iNdEx := len(m.ClassLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClassLabels[iNdEx])
			copy(dAtA[i:], m.ClassLabels[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.ClassLabels[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.FileAssets) > 0 {
		for k := range m.FileAssets {
			v := m.FileAssets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintModelExec(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModelExec(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModelExec(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Format != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Format))
		i--
		dAtA[i] = 0x18
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_StringData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_StringData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringData)
	copy(dAtA[i:], m.StringData)
	i = encodeVarintModelExec(dAtA, i, uint64(len(m.StringData)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Value_Int64Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int64Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintModelExec(dAtA, i, uint64(m.Int64Data))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_DoubleData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DoubleData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleData))))
	i--
	dAtA[i] = 0x19
	return len(dAtA) - i, nil
}
func (m *Value_BoolData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BoolData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolData {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_LambdaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_LambdaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LambdaData != nil {
		{
			size, err := m.LambdaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Value_ModelData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ModelData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ModelData != nil {
		{
			size, err := m.ModelData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Value_ParamData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ParamData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamData != nil {
		{
			size, err := m.ParamData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Value_ModelRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_ModelRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ModelRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value_Lambda) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Lambda) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Lambda) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Outputs[iNdEx])
			copy(dAtA[i:], m.Outputs[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.Outputs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inputs[iNdEx])
			copy(dAtA[i:], m.Inputs[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.Inputs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput_ParamValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_ParamValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamValue != nil {
		{
			size, err := m.ParamValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_NodeOutputValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_NodeOutputValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeOutputValue != nil {
		{
			size, err := m.NodeOutputValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_LambdaInputValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_LambdaInputValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LambdaInputValue != nil {
		{
			size, err := m.LambdaInputValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_NodeOutputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput_NodeOutputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_NodeOutputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput_LambdaInputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput_LambdaInputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_LambdaInputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultValue != nil {
		{
			size, err := m.DefaultValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogicalPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Version != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x30
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FleetID != nil {
		{
			size, err := m.FleetID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LogicalPipelineID != nil {
		{
			size, err := m.LogicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeploymentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeploymentSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeploymentSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeploymentStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeploymentStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeploymentStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Version != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x30
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineDeploymentID != nil {
		{
			size, err := m.PipelineDeploymentID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *PipelineNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attr) > 0 {
		for k := range m.Attr {
			v := m.Attr[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintModelExec(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModelExec(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModelExec(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Net) > 0 {
		i -= len(m.Net)
		copy(dAtA[i:], m.Net)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Net)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sha256Hash) > 0 {
		i -= len(m.Sha256Hash)
		copy(dAtA[i:], m.Sha256Hash)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Sha256Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.FileID != nil {
		{
			size, err := m.FileID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelSpec) > 0 {
		for iNdEx := len(m.ModelSpec) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModelSpec[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenVINOSpec != nil {
		{
			size, err := m.OpenVINOSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.TensorRTSpec != nil {
		{
			size, err := m.TensorRTSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.ONNXFile != nil {
		{
			size, err := m.ONNXFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ONNXBlobKey) > 0 {
		i -= len(m.ONNXBlobKey)
		copy(dAtA[i:], m.ONNXBlobKey)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.ONNXBlobKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemPoolLimits != nil {
		{
			size, err := m.MemPoolLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EngineBlobKey) > 0 {
		i -= len(m.EngineBlobKey)
		copy(dAtA[i:], m.EngineBlobKey)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.EngineBlobKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OptimizationProfile) > 0 {
		for iNdEx := len(m.OptimizationProfile) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OptimizationProfile[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTOptimizationProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTOptimizationProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTOptimizationProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TensorShapeRange) > 0 {
		for iNdEx := len(m.TensorShapeRange) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TensorShapeRange[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTTensorShapeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTTensorShapeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTTensorShapeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		dAtA32 := make([]byte, len(m.Dim)*10)
		var j31 int
		for _, num1 := range m.Dim {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintModelExec(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TensorName) > 0 {
		i -= len(m.TensorName)
		copy(dAtA[i:], m.TensorName)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.TensorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTMemPoolLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTMemPoolLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTMemPoolLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Workspace != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Workspace))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenVINOModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenVINOModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenVINOModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputShape) > 0 {
		for iNdEx := len(m.InputShape) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputShape[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenVINOModelSpec_TensorShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenVINOModelSpec_TensorShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenVINOModelSpec_TensorShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		dAtA34 := make([]byte, len(m.Dim)*10)
		var j33 int
		for _, num1 := range m.Dim {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintModelExec(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModelExec(dAtA []byte, offset int, v uint64) int {
	offset -= sovModelExec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BoundingBoxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoxFormat != 0 {
		n += 1 + sovModelExec(uint64(m.BoxFormat))
	}
	if m.BoxNormalized {
		n += 2
	}
	return n
}

func (m *ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if m.Format != 0 {
		n += 1 + sovModelExec(uint64(m.Format))
	}
	if len(m.FileAssets) > 0 {
		for k, v := range m.FileAssets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModelExec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModelExec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModelExec(uint64(mapEntrySize))
		}
	}
	if len(m.ClassLabels) > 0 {
		for _, s := range m.ClassLabels {
			l = len(s)
			n += 2 + l + sovModelExec(uint64(l))
		}
	}
	if m.BboxInfo != nil {
		l = m.BboxInfo.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *ParamRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *Value_StringData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringData)
	n += 1 + l + sovModelExec(uint64(l))
	return n
}
func (m *Value_Int64Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovModelExec(uint64(m.Int64Data))
	return n
}
func (m *Value_DoubleData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_BoolData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_LambdaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LambdaData != nil {
		l = m.LambdaData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ModelData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelData != nil {
		l = m.ModelData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ParamData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamData != nil {
		l = m.ParamData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ModelRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Value_Lambda) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Inputs) > 0 {
		for _, s := range m.Inputs {
			l = len(s)
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, s := range m.Outputs {
			l = len(s)
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *NodeAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *NodeInput_ParamValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamValue != nil {
		l = m.ParamValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_NodeOutputValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeOutputValue != nil {
		l = m.NodeOutputValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_LambdaInputValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LambdaInputValue != nil {
		l = m.LambdaInputValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_NodeOutputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeInput_LambdaInputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *LogicalPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *PipelineDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.LogicalPipelineID != nil {
		l = m.LogicalPipelineID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.FleetID != nil {
		l = m.FleetID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovModelExec(uint64(m.Version))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PipelineDeploymentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	return n
}

func (m *PipelineDeploymentStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	return n
}

func (m *PhysicalPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.PipelineDeploymentID != nil {
		l = m.PipelineDeploymentID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovModelExec(uint64(m.Version))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PhysicalPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	return n
}

func (m *PhysicalPipelineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	return n
}

func (m *Pipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *PipelineNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModelExec(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModelExec(uint64(len(k))) + 1 + len(v) + sovModelExec(uint64(len(v)))
			n += mapEntrySize + 1 + sovModelExec(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Net)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *FileResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileID != nil {
		l = m.FileID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovModelExec(uint64(m.SizeBytes))
	}
	l = len(m.Sha256Hash)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *ExecutionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.ModelSpec) > 0 {
		for _, e := range m.ModelSpec {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.ONNXBlobKey)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.ONNXFile != nil {
		l = m.ONNXFile.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 2 + l + sovModelExec(uint64(l))
	}
	if m.TensorRTSpec != nil {
		l = m.TensorRTSpec.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	if m.OpenVINOSpec != nil {
		l = m.OpenVINOSpec.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *TensorRTModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OptimizationProfile) > 0 {
		for _, e := range m.OptimizationProfile {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	l = len(m.EngineBlobKey)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.MemPoolLimits != nil {
		l = m.MemPoolLimits.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *TensorRTOptimizationProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TensorShapeRange) > 0 {
		for _, e := range m.TensorShapeRange {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *TensorRTTensorShapeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TensorName)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.Dim) > 0 {
		l = 0
		for _, e := range m.Dim {
			l += sovModelExec(uint64(e))
		}
		n += 1 + sovModelExec(uint64(l)) + l
	}
	return n
}

func (m *TensorRTMemPoolLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workspace != 0 {
		n += 1 + sovModelExec(uint64(m.Workspace))
	}
	return n
}

func (m *OpenVINOModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InputShape) > 0 {
		for _, e := range m.InputShape {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *OpenVINOModelSpec_TensorShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dim) > 0 {
		l = 0
		for _, e := range m.Dim {
			l += sovModelExec(uint64(e))
		}
		n += 1 + sovModelExec(uint64(l)) + l
	}
	return n
}

func sovModelExec(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModelExec(x uint64) (n int) {
	return sovModelExec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BoundingBoxInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoundingBoxInfo{`,
		`BoxFormat:` + fmt.Sprintf("%v", this.BoxFormat) + `,`,
		`BoxNormalized:` + fmt.Sprintf("%v", this.BoxNormalized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForFileAssets := make([]string, 0, len(this.FileAssets))
	for k, _ := range this.FileAssets {
		keysForFileAssets = append(keysForFileAssets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFileAssets)
	mapStringForFileAssets := "map[string]*typespb.UUID{"
	for _, k := range keysForFileAssets {
		mapStringForFileAssets += fmt.Sprintf("%v: %v,", k, this.FileAssets[k])
	}
	mapStringForFileAssets += "}"
	s := strings.Join([]string{`&ModelInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`FileAssets:` + mapStringForFileAssets + `,`,
		`ClassLabels:` + fmt.Sprintf("%v", this.ClassLabels) + `,`,
		`BboxInfo:` + strings.Replace(this.BboxInfo.String(), "BoundingBoxInfo", "BoundingBoxInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttributes := "[]*NodeAttributes{"
	for _, f := range this.Attributes {
		repeatedStringForAttributes += strings.Replace(f.String(), "NodeAttributes", "NodeAttributes", 1) + ","
	}
	repeatedStringForAttributes += "}"
	repeatedStringForInputs := "[]*NodeInput{"
	for _, f := range this.Inputs {
		repeatedStringForInputs += strings.Replace(f.String(), "NodeInput", "NodeInput", 1) + ","
	}
	repeatedStringForInputs += "}"
	repeatedStringForOutputs := "[]*NodeOutput{"
	for _, f := range this.Outputs {
		repeatedStringForOutputs += strings.Replace(f.String(), "NodeOutput", "NodeOutput", 1) + ","
	}
	repeatedStringForOutputs += "}"
	s := strings.Join([]string{`&Node{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Attributes:` + repeatedStringForAttributes + `,`,
		`Inputs:` + repeatedStringForInputs + `,`,
		`Outputs:` + repeatedStringForOutputs + `,`,
		`}`,
	}, "")
	return s
}
func (this *ParamRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ParamRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_StringData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_StringData{`,
		`StringData:` + fmt.Sprintf("%v", this.StringData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int64Data) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int64Data{`,
		`Int64Data:` + fmt.Sprintf("%v", this.Int64Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_DoubleData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_DoubleData{`,
		`DoubleData:` + fmt.Sprintf("%v", this.DoubleData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_BoolData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_BoolData{`,
		`BoolData:` + fmt.Sprintf("%v", this.BoolData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_LambdaData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_LambdaData{`,
		`LambdaData:` + strings.Replace(fmt.Sprintf("%v", this.LambdaData), "Value_Lambda", "Value_Lambda", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ModelData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ModelData{`,
		`ModelData:` + strings.Replace(fmt.Sprintf("%v", this.ModelData), "Value_ModelRef", "Value_ModelRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ParamData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ParamData{`,
		`ParamData:` + strings.Replace(fmt.Sprintf("%v", this.ParamData), "ParamRef", "ParamRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ModelRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ModelRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Lambda) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&Value_Lambda{`,
		`Inputs:` + fmt.Sprintf("%v", this.Inputs) + `,`,
		`Outputs:` + fmt.Sprintf("%v", this.Outputs) + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeAttributes{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + strings.Replace(this.Value.String(), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_ParamValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_ParamValue{`,
		`ParamValue:` + strings.Replace(fmt.Sprintf("%v", this.ParamValue), "ParamRef", "ParamRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_NodeOutputValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_NodeOutputValue{`,
		`NodeOutputValue:` + strings.Replace(fmt.Sprintf("%v", this.NodeOutputValue), "NodeInput_NodeOutputRef", "NodeInput_NodeOutputRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_LambdaInputValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_LambdaInputValue{`,
		`LambdaInputValue:` + strings.Replace(fmt.Sprintf("%v", this.LambdaInputValue), "NodeInput_LambdaInputRef", "NodeInput_LambdaInputRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_NodeOutputRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_NodeOutputRef{`,
		`NodeName:` + fmt.Sprintf("%v", this.NodeName) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_LambdaInputRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_LambdaInputRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeOutput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeOutput{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Param) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Param{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DefaultValue:` + strings.Replace(this.DefaultValue.String(), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogicalPipeline) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParams := "[]*Param{"
	for _, f := range this.Params {
		repeatedStringForParams += strings.Replace(f.String(), "Param", "Param", 1) + ","
	}
	repeatedStringForParams += "}"
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&LogicalPipeline{`,
		`Params:` + repeatedStringForParams + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeployment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeployment{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "typespb.UUID", 1) + `,`,
		`LogicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.LogicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`FleetID:` + strings.Replace(fmt.Sprintf("%v", this.FleetID), "UUID", "typespb.UUID", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "PipelineDeploymentSpec", "PipelineDeploymentSpec", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "PipelineDeploymentStatus", "PipelineDeploymentStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeploymentSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeploymentSpec{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeploymentStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeploymentStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipeline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipeline{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "typespb.UUID", 1) + `,`,
		`PipelineDeploymentID:` + strings.Replace(fmt.Sprintf("%v", this.PipelineDeploymentID), "UUID", "typespb.UUID", 1) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "PhysicalPipelineSpec", "PhysicalPipelineSpec", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "PhysicalPipelineStatus", "PhysicalPipelineStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineSpec{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Pipeline) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*PipelineNode{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "PipelineNode", "PipelineNode", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&Pipeline{`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineNode) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInputs := "[]*Port{"
	for _, f := range this.Inputs {
		repeatedStringForInputs += strings.Replace(f.String(), "Port", "Port", 1) + ","
	}
	repeatedStringForInputs += "}"
	repeatedStringForOutputs := "[]*Port{"
	for _, f := range this.Outputs {
		repeatedStringForOutputs += strings.Replace(f.String(), "Port", "Port", 1) + ","
	}
	repeatedStringForOutputs += "}"
	keysForAttr := make([]string, 0, len(this.Attr))
	for k, _ := range this.Attr {
		keysForAttr = append(keysForAttr, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttr)
	mapStringForAttr := "map[string]string{"
	for _, k := range keysForAttr {
		mapStringForAttr += fmt.Sprintf("%v: %v,", k, this.Attr[k])
	}
	mapStringForAttr += "}"
	s := strings.Join([]string{`&PipelineNode{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Inputs:` + repeatedStringForInputs + `,`,
		`Outputs:` + repeatedStringForOutputs + `,`,
		`Attr:` + mapStringForAttr + `,`,
		`}`,
	}, "")
	return s
}
func (this *Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Port{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Net:` + fmt.Sprintf("%v", this.Net) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileResource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileResource{`,
		`FileID:` + strings.Replace(fmt.Sprintf("%v", this.FileID), "UUID", "typespb.UUID", 1) + `,`,
		`SizeBytes:` + fmt.Sprintf("%v", this.SizeBytes) + `,`,
		`Sha256Hash:` + fmt.Sprintf("%v", this.Sha256Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModelSpec := "[]*ModelSpec{"
	for _, f := range this.ModelSpec {
		repeatedStringForModelSpec += strings.Replace(f.String(), "ModelSpec", "ModelSpec", 1) + ","
	}
	repeatedStringForModelSpec += "}"
	s := strings.Join([]string{`&ExecutionSpec{`,
		`Graph:` + strings.Replace(fmt.Sprintf("%v", this.Graph), "CalculatorGraphConfig", "framework.CalculatorGraphConfig", 1) + `,`,
		`ModelSpec:` + repeatedStringForModelSpec + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModelSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ONNXBlobKey:` + fmt.Sprintf("%v", this.ONNXBlobKey) + `,`,
		`ONNXFile:` + strings.Replace(this.ONNXFile.String(), "FileResource", "FileResource", 1) + `,`,
		`Runtime:` + fmt.Sprintf("%v", this.Runtime) + `,`,
		`TensorRTSpec:` + strings.Replace(this.TensorRTSpec.String(), "TensorRTModelSpec", "TensorRTModelSpec", 1) + `,`,
		`OpenVINOSpec:` + strings.Replace(this.OpenVINOSpec.String(), "OpenVINOModelSpec", "OpenVINOModelSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOptimizationProfile := "[]*TensorRTOptimizationProfile{"
	for _, f := range this.OptimizationProfile {
		repeatedStringForOptimizationProfile += strings.Replace(f.String(), "TensorRTOptimizationProfile", "TensorRTOptimizationProfile", 1) + ","
	}
	repeatedStringForOptimizationProfile += "}"
	s := strings.Join([]string{`&TensorRTModelSpec{`,
		`OptimizationProfile:` + repeatedStringForOptimizationProfile + `,`,
		`EngineBlobKey:` + fmt.Sprintf("%v", this.EngineBlobKey) + `,`,
		`MemPoolLimits:` + strings.Replace(this.MemPoolLimits.String(), "TensorRTMemPoolLimits", "TensorRTMemPoolLimits", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTOptimizationProfile) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTensorShapeRange := "[]*TensorRTTensorShapeRange{"
	for _, f := range this.TensorShapeRange {
		repeatedStringForTensorShapeRange += strings.Replace(f.String(), "TensorRTTensorShapeRange", "TensorRTTensorShapeRange", 1) + ","
	}
	repeatedStringForTensorShapeRange += "}"
	s := strings.Join([]string{`&TensorRTOptimizationProfile{`,
		`TensorShapeRange:` + repeatedStringForTensorShapeRange + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTTensorShapeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorRTTensorShapeRange{`,
		`TensorName:` + fmt.Sprintf("%v", this.TensorName) + `,`,
		`Dim:` + fmt.Sprintf("%v", this.Dim) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTMemPoolLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorRTMemPoolLimits{`,
		`Workspace:` + fmt.Sprintf("%v", this.Workspace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenVINOModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInputShape := "[]*OpenVINOModelSpec_TensorShape{"
	for _, f := range this.InputShape {
		repeatedStringForInputShape += strings.Replace(fmt.Sprintf("%v", f), "OpenVINOModelSpec_TensorShape", "OpenVINOModelSpec_TensorShape", 1) + ","
	}
	repeatedStringForInputShape += "}"
	s := strings.Join([]string{`&OpenVINOModelSpec{`,
		`InputShape:` + repeatedStringForInputShape + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenVINOModelSpec_TensorShape) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenVINOModelSpec_TensorShape{`,
		`Dim:` + fmt.Sprintf("%v", this.Dim) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringModelExec(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BoundingBoxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundingBoxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundingBoxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxFormat", wireType)
			}
			m.BoxFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoxFormat |= BoundingBoxInfo_BoundingBoxFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxNormalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoxNormalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ModelInfo_ModelKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= ModelInfo_ModelStorageFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileAssets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileAssets == nil {
				m.FileAssets = make(map[string]*typespb.UUID)
			}
			var mapkey string
			var mapvalue *typespb.UUID
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModelExec
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthModelExec
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &typespb.UUID{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModelExec(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthModelExec
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FileAssets[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassLabels = append(m.ClassLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BboxInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BboxInfo == nil {
				m.BboxInfo = &BoundingBoxInfo{}
			}
			if err := m.BboxInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= LogicalPipelineNodeKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &NodeAttributes{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &NodeInput{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &NodeOutput{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Value_StringData{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Data", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = &Value_Int64Data{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Data = &Value_DoubleData{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Data = &Value_BoolData{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Value_Lambda{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_LambdaData{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Value_ModelRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_ModelData{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_ParamData{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_ModelRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Lambda) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lambda: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lambda: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_ParamValue{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOutputValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeInput_NodeOutputRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_NodeOutputValue{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaInputValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeInput_LambdaInputRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_LambdaInputValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput_NodeOutputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeOutputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeOutputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput_LambdaInputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LambdaInputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LambdaInputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &Value{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Param{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &typespb.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogicalPipelineID == nil {
				m.LogicalPipelineID = &typespb.UUID{}
			}
			if err := m.LogicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FleetID == nil {
				m.FleetID = &typespb.UUID{}
			}
			if err := m.FleetID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PipelineDeploymentSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PipelineDeploymentStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeploymentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeploymentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeploymentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeploymentStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeploymentStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeploymentStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &typespb.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineDeploymentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PipelineDeploymentID == nil {
				m.PipelineDeploymentID = &typespb.UUID{}
			}
			if err := m.PipelineDeploymentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PhysicalPipelineSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PhysicalPipelineStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &PipelineNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &Port{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &Port{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModelExec
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModelExec
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModelExec(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthModelExec
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Net = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileID == nil {
				m.FileID = &typespb.UUID{}
			}
			if err := m.FileID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &framework.CalculatorGraphConfig{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelSpec = append(m.ModelSpec, &ModelSpec{})
			if err := m.ModelSpec[len(m.ModelSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ONNXBlobKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ONNXBlobKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ONNXFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ONNXFile == nil {
				m.ONNXFile = &FileResource{}
			}
			if err := m.ONNXFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorRTSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorRTSpec == nil {
				m.TensorRTSpec = &TensorRTModelSpec{}
			}
			if err := m.TensorRTSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenVINOSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenVINOSpec == nil {
				m.OpenVINOSpec = &OpenVINOModelSpec{}
			}
			if err := m.OpenVINOSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizationProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptimizationProfile = append(m.OptimizationProfile, &TensorRTOptimizationProfile{})
			if err := m.OptimizationProfile[len(m.OptimizationProfile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineBlobKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EngineBlobKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPoolLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemPoolLimits == nil {
				m.MemPoolLimits = &TensorRTMemPoolLimits{}
			}
			if err := m.MemPoolLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTOptimizationProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTOptimizationProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTOptimizationProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorShapeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorShapeRange = append(m.TensorShapeRange, &TensorRTTensorShapeRange{})
			if err := m.TensorShapeRange[len(m.TensorShapeRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTTensorShapeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTTensorShapeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTTensorShapeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dim = append(m.Dim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dim) == 0 {
					m.Dim = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dim = append(m.Dim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTMemPoolLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTMemPoolLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTMemPoolLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workspace", wireType)
			}
			m.Workspace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Workspace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenVINOModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenVINOModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenVINOModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputShape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputShape = append(m.InputShape, &OpenVINOModelSpec_TensorShape{})
			if err := m.InputShape[len(m.InputShape)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenVINOModelSpec_TensorShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dim = append(m.Dim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dim) == 0 {
					m.Dim = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dim = append(m.Dim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModelExec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModelExec
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModelExec
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModelExec
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModelExec        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModelExec          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModelExec = fmt.Errorf("proto: unexpected end of group")
)
