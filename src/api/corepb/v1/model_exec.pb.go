// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: src/api/corepb/v1/model_exec.proto

package corepb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	typespb "gimletlabs.ai/gimlet/src/common/typespb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	framework "github.com/google/mediapipe/mediapipe/framework"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LogicalPipelineNodeKind int32

const (
	LOGICAL_PIPELINE_NODE_KIND_UNKNOWN                 LogicalPipelineNodeKind = 0
	LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE           LogicalPipelineNodeKind = 10
	LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SOURCE      LogicalPipelineNodeKind = 11
	LOGICAL_PIPELINE_NODE_KIND_DETECT                  LogicalPipelineNodeKind = 1000
	LOGICAL_PIPELINE_NODE_KIND_CLASSIFY                LogicalPipelineNodeKind = 1001
	LOGICAL_PIPELINE_NODE_KIND_SEGMENT                 LogicalPipelineNodeKind = 1002
	LOGICAL_PIPELINE_NODE_KIND_MULTI_PURPOSE_MODEL     LogicalPipelineNodeKind = 1003
	LOGICAL_PIPELINE_NODE_KIND_REGRESS                 LogicalPipelineNodeKind = 1004
	LOGICAL_PIPELINE_NODE_KIND_TRACK                   LogicalPipelineNodeKind = 1005
	LOGICAL_PIPELINE_NODE_KIND_GENERATE_TOKENS         LogicalPipelineNodeKind = 1006
	LOGICAL_PIPELINE_NODE_KIND_TOKENIZE                LogicalPipelineNodeKind = 1007
	LOGICAL_PIPELINE_NODE_KIND_DETOKENIZE              LogicalPipelineNodeKind = 1008
	LOGICAL_PIPELINE_NODE_KIND_EMBED                   LogicalPipelineNodeKind = 1009
	LOGICAL_PIPELINE_NODE_KIND_TEMPLATE_CHAT_MESSAGE   LogicalPipelineNodeKind = 1010
	LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI            LogicalPipelineNodeKind = 1503
	LOGICAL_PIPELINE_NODE_KIND_VECTOR_SEARCH           LogicalPipelineNodeKind = 1504
	LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK       LogicalPipelineNodeKind = 2000
	LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK LogicalPipelineNodeKind = 2001
	LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK    LogicalPipelineNodeKind = 2002
	LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK      LogicalPipelineNodeKind = 2003
	LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SINK        LogicalPipelineNodeKind = 2004
)

var LogicalPipelineNodeKind_name = map[int32]string{
	0:    "LOGICAL_PIPELINE_NODE_KIND_UNKNOWN",
	10:   "LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE",
	11:   "LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SOURCE",
	1000: "LOGICAL_PIPELINE_NODE_KIND_DETECT",
	1001: "LOGICAL_PIPELINE_NODE_KIND_CLASSIFY",
	1002: "LOGICAL_PIPELINE_NODE_KIND_SEGMENT",
	1003: "LOGICAL_PIPELINE_NODE_KIND_MULTI_PURPOSE_MODEL",
	1004: "LOGICAL_PIPELINE_NODE_KIND_REGRESS",
	1005: "LOGICAL_PIPELINE_NODE_KIND_TRACK",
	1006: "LOGICAL_PIPELINE_NODE_KIND_GENERATE_TOKENS",
	1007: "LOGICAL_PIPELINE_NODE_KIND_TOKENIZE",
	1008: "LOGICAL_PIPELINE_NODE_KIND_DETOKENIZE",
	1009: "LOGICAL_PIPELINE_NODE_KIND_EMBED",
	1010: "LOGICAL_PIPELINE_NODE_KIND_TEMPLATE_CHAT_MESSAGE",
	1503: "LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI",
	1504: "LOGICAL_PIPELINE_NODE_KIND_VECTOR_SEARCH",
	2000: "LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK",
	2001: "LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK",
	2002: "LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK",
	2003: "LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK",
	2004: "LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SINK",
}

var LogicalPipelineNodeKind_value = map[string]int32{
	"LOGICAL_PIPELINE_NODE_KIND_UNKNOWN":                 0,
	"LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE":           10,
	"LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SOURCE":      11,
	"LOGICAL_PIPELINE_NODE_KIND_DETECT":                  1000,
	"LOGICAL_PIPELINE_NODE_KIND_CLASSIFY":                1001,
	"LOGICAL_PIPELINE_NODE_KIND_SEGMENT":                 1002,
	"LOGICAL_PIPELINE_NODE_KIND_MULTI_PURPOSE_MODEL":     1003,
	"LOGICAL_PIPELINE_NODE_KIND_REGRESS":                 1004,
	"LOGICAL_PIPELINE_NODE_KIND_TRACK":                   1005,
	"LOGICAL_PIPELINE_NODE_KIND_GENERATE_TOKENS":         1006,
	"LOGICAL_PIPELINE_NODE_KIND_TOKENIZE":                1007,
	"LOGICAL_PIPELINE_NODE_KIND_DETOKENIZE":              1008,
	"LOGICAL_PIPELINE_NODE_KIND_EMBED":                   1009,
	"LOGICAL_PIPELINE_NODE_KIND_TEMPLATE_CHAT_MESSAGE":   1010,
	"LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI":            1503,
	"LOGICAL_PIPELINE_NODE_KIND_VECTOR_SEARCH":           1504,
	"LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK":       2000,
	"LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK": 2001,
	"LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK":    2002,
	"LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK":      2003,
	"LOGICAL_PIPELINE_NODE_KIND_TEXT_STREAM_SINK":        2004,
}

func (LogicalPipelineNodeKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0}
}

type PipelineState int32

const (
	PIPELINE_STATE_UNKNOWN     PipelineState = 0
	PIPELINE_STATE_PENDING     PipelineState = 1
	PIPELINE_STATE_READY       PipelineState = 2
	PIPELINE_STATE_RUNNING     PipelineState = 3
	PIPELINE_STATE_TERMINATING PipelineState = 4
	PIPELINE_STATE_TERMINATED  PipelineState = 5
	PIPELINE_STATE_FAILED      PipelineState = 6
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STATE_UNKNOWN",
	1: "PIPELINE_STATE_PENDING",
	2: "PIPELINE_STATE_READY",
	3: "PIPELINE_STATE_RUNNING",
	4: "PIPELINE_STATE_TERMINATING",
	5: "PIPELINE_STATE_TERMINATED",
	6: "PIPELINE_STATE_FAILED",
}

var PipelineState_value = map[string]int32{
	"PIPELINE_STATE_UNKNOWN":     0,
	"PIPELINE_STATE_PENDING":     1,
	"PIPELINE_STATE_READY":       2,
	"PIPELINE_STATE_RUNNING":     3,
	"PIPELINE_STATE_TERMINATING": 4,
	"PIPELINE_STATE_TERMINATED":  5,
	"PIPELINE_STATE_FAILED":      6,
}

func (PipelineState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1}
}

type BoundingBoxInfo_BoundingBoxFormat int32

const (
	BOUNDING_BOX_FORMAT_UNKNOWN BoundingBoxInfo_BoundingBoxFormat = 0
	BOUNDING_BOX_FORMAT_CXCYWH  BoundingBoxInfo_BoundingBoxFormat = 1
	BOUNDING_BOX_FORMAT_YXYX    BoundingBoxInfo_BoundingBoxFormat = 2
	BOUNDING_BOX_FORMAT_XYXY    BoundingBoxInfo_BoundingBoxFormat = 3
)

var BoundingBoxInfo_BoundingBoxFormat_name = map[int32]string{
	0: "BOUNDING_BOX_FORMAT_UNKNOWN",
	1: "BOUNDING_BOX_FORMAT_CXCYWH",
	2: "BOUNDING_BOX_FORMAT_YXYX",
	3: "BOUNDING_BOX_FORMAT_XYXY",
}

var BoundingBoxInfo_BoundingBoxFormat_value = map[string]int32{
	"BOUNDING_BOX_FORMAT_UNKNOWN": 0,
	"BOUNDING_BOX_FORMAT_CXCYWH":  1,
	"BOUNDING_BOX_FORMAT_YXYX":    2,
	"BOUNDING_BOX_FORMAT_XYXY":    3,
}

func (BoundingBoxInfo_BoundingBoxFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0, 0}
}

type ImagePreprocessingStep_ImagePreprocessingKind int32

const (
	IMAGE_PREPROCESSING_KIND_UNKNOWN           ImagePreprocessingStep_ImagePreprocessingKind = 0
	IMAGE_PREPROCESSING_KIND_CONVERT_TO_TENSOR ImagePreprocessingStep_ImagePreprocessingKind = 1
	IMAGE_PREPROCESSING_KIND_RESIZE            ImagePreprocessingStep_ImagePreprocessingKind = 2
	IMAGE_PREPROCESSING_KIND_STANDARDIZE       ImagePreprocessingStep_ImagePreprocessingKind = 3
)

var ImagePreprocessingStep_ImagePreprocessingKind_name = map[int32]string{
	0: "IMAGE_PREPROCESSING_KIND_UNKNOWN",
	1: "IMAGE_PREPROCESSING_KIND_CONVERT_TO_TENSOR",
	2: "IMAGE_PREPROCESSING_KIND_RESIZE",
	3: "IMAGE_PREPROCESSING_KIND_STANDARDIZE",
}

var ImagePreprocessingStep_ImagePreprocessingKind_value = map[string]int32{
	"IMAGE_PREPROCESSING_KIND_UNKNOWN":           0,
	"IMAGE_PREPROCESSING_KIND_CONVERT_TO_TENSOR": 1,
	"IMAGE_PREPROCESSING_KIND_RESIZE":            2,
	"IMAGE_PREPROCESSING_KIND_STANDARDIZE":       3,
}

func (ImagePreprocessingStep_ImagePreprocessingKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 0}
}

type ImagePreprocessingStep_ImageResizeParams_ImageResizeKind int32

const (
	IMAGE_RESIZE_KIND_UNKNOWN   ImagePreprocessingStep_ImageResizeParams_ImageResizeKind = 0
	IMAGE_RESIZE_KIND_STRETCH   ImagePreprocessingStep_ImageResizeParams_ImageResizeKind = 1
	IMAGE_RESIZE_KIND_LETTERBOX ImagePreprocessingStep_ImageResizeParams_ImageResizeKind = 2
)

var ImagePreprocessingStep_ImageResizeParams_ImageResizeKind_name = map[int32]string{
	0: "IMAGE_RESIZE_KIND_UNKNOWN",
	1: "IMAGE_RESIZE_KIND_STRETCH",
	2: "IMAGE_RESIZE_KIND_LETTERBOX",
}

var ImagePreprocessingStep_ImageResizeParams_ImageResizeKind_value = map[string]int32{
	"IMAGE_RESIZE_KIND_UNKNOWN":   0,
	"IMAGE_RESIZE_KIND_STRETCH":   1,
	"IMAGE_RESIZE_KIND_LETTERBOX": 2,
}

func (ImagePreprocessingStep_ImageResizeParams_ImageResizeKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 1, 0}
}

type DimensionSemantics_DimensionSemanticsKind int32

const (
	DIMENSION_SEMANTICS_KIND_UNKNOWN                   DimensionSemantics_DimensionSemanticsKind = 0
	DIMENSION_SEMANTICS_KIND_BATCH                     DimensionSemantics_DimensionSemanticsKind = 1
	DIMENSION_SEMANTICS_KIND_IGNORE                    DimensionSemantics_DimensionSemanticsKind = 2
	DIMENSION_SEMANTICS_KIND_IMAGE_CHANNEL             DimensionSemantics_DimensionSemanticsKind = 3
	DIMENSION_SEMANTICS_KIND_IMAGE_HEIGHT              DimensionSemantics_DimensionSemanticsKind = 4
	DIMENSION_SEMANTICS_KIND_IMAGE_WIDTH               DimensionSemantics_DimensionSemanticsKind = 5
	DIMENSION_SEMANTICS_KIND_DETECTION_CANDIDATES      DimensionSemantics_DimensionSemanticsKind = 6
	DIMENSION_SEMANTICS_KIND_DETECTION_OUTPUT          DimensionSemantics_DimensionSemanticsKind = 7
	DIMENSION_SEMANTICS_KIND_CLASS_SCORES              DimensionSemantics_DimensionSemanticsKind = 8
	DIMENSION_SEMANTICS_KIND_SEGMENTATION_MASK_CHANNEL DimensionSemantics_DimensionSemanticsKind = 9
	DIMENSION_SEMANTICS_KIND_CLASS_LABELS              DimensionSemantics_DimensionSemanticsKind = 10
	DIMENSION_SEMANTICS_KIND_REGRESSION_VALUE          DimensionSemantics_DimensionSemanticsKind = 11
	DIMENSION_SEMANTICS_KIND_TOKENS                    DimensionSemantics_DimensionSemanticsKind = 12
	DIMENSION_SEMANTICS_KIND_ATTENTION_MASK            DimensionSemantics_DimensionSemanticsKind = 13
	DIMENSION_SEMANTICS_KIND_VOCAB_LOGITS              DimensionSemantics_DimensionSemanticsKind = 14
	DIMENSION_SEMANTICS_KIND_EMBEDDING                 DimensionSemantics_DimensionSemanticsKind = 15
)

var DimensionSemantics_DimensionSemanticsKind_name = map[int32]string{
	0:  "DIMENSION_SEMANTICS_KIND_UNKNOWN",
	1:  "DIMENSION_SEMANTICS_KIND_BATCH",
	2:  "DIMENSION_SEMANTICS_KIND_IGNORE",
	3:  "DIMENSION_SEMANTICS_KIND_IMAGE_CHANNEL",
	4:  "DIMENSION_SEMANTICS_KIND_IMAGE_HEIGHT",
	5:  "DIMENSION_SEMANTICS_KIND_IMAGE_WIDTH",
	6:  "DIMENSION_SEMANTICS_KIND_DETECTION_CANDIDATES",
	7:  "DIMENSION_SEMANTICS_KIND_DETECTION_OUTPUT",
	8:  "DIMENSION_SEMANTICS_KIND_CLASS_SCORES",
	9:  "DIMENSION_SEMANTICS_KIND_SEGMENTATION_MASK_CHANNEL",
	10: "DIMENSION_SEMANTICS_KIND_CLASS_LABELS",
	11: "DIMENSION_SEMANTICS_KIND_REGRESSION_VALUE",
	12: "DIMENSION_SEMANTICS_KIND_TOKENS",
	13: "DIMENSION_SEMANTICS_KIND_ATTENTION_MASK",
	14: "DIMENSION_SEMANTICS_KIND_VOCAB_LOGITS",
	15: "DIMENSION_SEMANTICS_KIND_EMBEDDING",
}

var DimensionSemantics_DimensionSemanticsKind_value = map[string]int32{
	"DIMENSION_SEMANTICS_KIND_UNKNOWN":                   0,
	"DIMENSION_SEMANTICS_KIND_BATCH":                     1,
	"DIMENSION_SEMANTICS_KIND_IGNORE":                    2,
	"DIMENSION_SEMANTICS_KIND_IMAGE_CHANNEL":             3,
	"DIMENSION_SEMANTICS_KIND_IMAGE_HEIGHT":              4,
	"DIMENSION_SEMANTICS_KIND_IMAGE_WIDTH":               5,
	"DIMENSION_SEMANTICS_KIND_DETECTION_CANDIDATES":      6,
	"DIMENSION_SEMANTICS_KIND_DETECTION_OUTPUT":          7,
	"DIMENSION_SEMANTICS_KIND_CLASS_SCORES":              8,
	"DIMENSION_SEMANTICS_KIND_SEGMENTATION_MASK_CHANNEL": 9,
	"DIMENSION_SEMANTICS_KIND_CLASS_LABELS":              10,
	"DIMENSION_SEMANTICS_KIND_REGRESSION_VALUE":          11,
	"DIMENSION_SEMANTICS_KIND_TOKENS":                    12,
	"DIMENSION_SEMANTICS_KIND_ATTENTION_MASK":            13,
	"DIMENSION_SEMANTICS_KIND_VOCAB_LOGITS":              14,
	"DIMENSION_SEMANTICS_KIND_EMBEDDING":                 15,
}

func (DimensionSemantics_DimensionSemanticsKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 0}
}

type DimensionSemantics_ImageChannelParams_ImageChannelFormat int32

const (
	IMAGE_CHANNEL_FORMAT_UNKNOWN DimensionSemantics_ImageChannelParams_ImageChannelFormat = 0
	IMAGE_CHANNEL_FORMAT_RGB     DimensionSemantics_ImageChannelParams_ImageChannelFormat = 1
	IMAGE_CHANNEL_FORMAT_BGR     DimensionSemantics_ImageChannelParams_ImageChannelFormat = 2
)

var DimensionSemantics_ImageChannelParams_ImageChannelFormat_name = map[int32]string{
	0: "IMAGE_CHANNEL_FORMAT_UNKNOWN",
	1: "IMAGE_CHANNEL_FORMAT_RGB",
	2: "IMAGE_CHANNEL_FORMAT_BGR",
}

var DimensionSemantics_ImageChannelParams_ImageChannelFormat_value = map[string]int32{
	"IMAGE_CHANNEL_FORMAT_UNKNOWN": 0,
	"IMAGE_CHANNEL_FORMAT_RGB":     1,
	"IMAGE_CHANNEL_FORMAT_BGR":     2,
}

func (DimensionSemantics_ImageChannelParams_ImageChannelFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 0, 0}
}

type DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind int32

const (
	SEGMENTATION_MASK_KIND_UNKNOWN     DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind = 0
	SEGMENTATION_MASK_KIND_CLASS_LABEL DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind = 1
	SEGMENTATION_MASK_KIND_BOOL        DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind = 2
	SEGMENTATION_MASK_KIND_SCORE       DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind = 3
)

var DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind_name = map[int32]string{
	0: "SEGMENTATION_MASK_KIND_UNKNOWN",
	1: "SEGMENTATION_MASK_KIND_CLASS_LABEL",
	2: "SEGMENTATION_MASK_KIND_BOOL",
	3: "SEGMENTATION_MASK_KIND_SCORE",
}

var DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind_value = map[string]int32{
	"SEGMENTATION_MASK_KIND_UNKNOWN":     0,
	"SEGMENTATION_MASK_KIND_CLASS_LABEL": 1,
	"SEGMENTATION_MASK_KIND_BOOL":        2,
	"SEGMENTATION_MASK_KIND_SCORE":       3,
}

func (DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 3, 0}
}

type ModelInfo_ModelKind int32

const (
	MODEL_KIND_UNKNOWN               ModelInfo_ModelKind = 0
	MODEL_KIND_TORCH                 ModelInfo_ModelKind = 1
	MODEL_KIND_TORCHSCRIPT           ModelInfo_ModelKind = 2
	MODEL_KIND_ONNX                  ModelInfo_ModelKind = 3
	MODEL_KIND_TFLITE                ModelInfo_ModelKind = 4
	MODEL_KIND_OPENVINO              ModelInfo_ModelKind = 5
	MODEL_KIND_HUGGINGFACE_TOKENIZER ModelInfo_ModelKind = 6
)

var ModelInfo_ModelKind_name = map[int32]string{
	0: "MODEL_KIND_UNKNOWN",
	1: "MODEL_KIND_TORCH",
	2: "MODEL_KIND_TORCHSCRIPT",
	3: "MODEL_KIND_ONNX",
	4: "MODEL_KIND_TFLITE",
	5: "MODEL_KIND_OPENVINO",
	6: "MODEL_KIND_HUGGINGFACE_TOKENIZER",
}

var ModelInfo_ModelKind_value = map[string]int32{
	"MODEL_KIND_UNKNOWN":               0,
	"MODEL_KIND_TORCH":                 1,
	"MODEL_KIND_TORCHSCRIPT":           2,
	"MODEL_KIND_ONNX":                  3,
	"MODEL_KIND_TFLITE":                4,
	"MODEL_KIND_OPENVINO":              5,
	"MODEL_KIND_HUGGINGFACE_TOKENIZER": 6,
}

func (ModelInfo_ModelKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{5, 0}
}

type ModelInfo_ModelStorageFormat int32

const (
	MODEL_STORAGE_FORMAT_UNKNOWN       ModelInfo_ModelStorageFormat = 0
	MODEL_STORAGE_FORMAT_MLIR_BYTECODE ModelInfo_ModelStorageFormat = 1
	MODEL_STORAGE_FORMAT_MLIR_TEXT     ModelInfo_ModelStorageFormat = 2
	MODEL_STORAGE_FORMAT_PROTOBUF      ModelInfo_ModelStorageFormat = 3
	MODEL_STORAGE_FORMAT_PROTO_TEXT    ModelInfo_ModelStorageFormat = 4
	MODEL_STORAGE_FORMAT_FLATBUFFER    ModelInfo_ModelStorageFormat = 5
	MODEL_STORAGE_FORMAT_OPENVINO      ModelInfo_ModelStorageFormat = 6
	MODEL_STORAGE_FORMAT_OPAQUE        ModelInfo_ModelStorageFormat = 7
)

var ModelInfo_ModelStorageFormat_name = map[int32]string{
	0: "MODEL_STORAGE_FORMAT_UNKNOWN",
	1: "MODEL_STORAGE_FORMAT_MLIR_BYTECODE",
	2: "MODEL_STORAGE_FORMAT_MLIR_TEXT",
	3: "MODEL_STORAGE_FORMAT_PROTOBUF",
	4: "MODEL_STORAGE_FORMAT_PROTO_TEXT",
	5: "MODEL_STORAGE_FORMAT_FLATBUFFER",
	6: "MODEL_STORAGE_FORMAT_OPENVINO",
	7: "MODEL_STORAGE_FORMAT_OPAQUE",
}

var ModelInfo_ModelStorageFormat_value = map[string]int32{
	"MODEL_STORAGE_FORMAT_UNKNOWN":       0,
	"MODEL_STORAGE_FORMAT_MLIR_BYTECODE": 1,
	"MODEL_STORAGE_FORMAT_MLIR_TEXT":     2,
	"MODEL_STORAGE_FORMAT_PROTOBUF":      3,
	"MODEL_STORAGE_FORMAT_PROTO_TEXT":    4,
	"MODEL_STORAGE_FORMAT_FLATBUFFER":    5,
	"MODEL_STORAGE_FORMAT_OPENVINO":      6,
	"MODEL_STORAGE_FORMAT_OPAQUE":        7,
}

func (ModelInfo_ModelStorageFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{5, 1}
}

type BoundingBoxInfo struct {
	BoxFormat     BoundingBoxInfo_BoundingBoxFormat `protobuf:"varint,1,opt,name=box_format,json=boxFormat,proto3,enum=gml.internal.api.core.v1.BoundingBoxInfo_BoundingBoxFormat" json:"box_format,omitempty"`
	BoxNormalized bool                              `protobuf:"varint,2,opt,name=box_normalized,json=boxNormalized,proto3" json:"box_normalized,omitempty"`
}

func (m *BoundingBoxInfo) Reset()      { *m = BoundingBoxInfo{} }
func (*BoundingBoxInfo) ProtoMessage() {}
func (*BoundingBoxInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{0}
}
func (m *BoundingBoxInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundingBoxInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoundingBoxInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoundingBoxInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingBoxInfo.Merge(m, src)
}
func (m *BoundingBoxInfo) XXX_Size() int {
	return m.Size()
}
func (m *BoundingBoxInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingBoxInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingBoxInfo proto.InternalMessageInfo

func (m *BoundingBoxInfo) GetBoxFormat() BoundingBoxInfo_BoundingBoxFormat {
	if m != nil {
		return m.BoxFormat
	}
	return BOUNDING_BOX_FORMAT_UNKNOWN
}

func (m *BoundingBoxInfo) GetBoxNormalized() bool {
	if m != nil {
		return m.BoxNormalized
	}
	return false
}

type ImagePreprocessingStep struct {
	Kind              ImagePreprocessingStep_ImagePreprocessingKind  `protobuf:"varint,1,opt,name=kind,proto3,enum=gml.internal.api.core.v1.ImagePreprocessingStep_ImagePreprocessingKind" json:"kind,omitempty"`
	ConversionParams  *ImagePreprocessingStep_ImageConversionParams  `protobuf:"bytes,2,opt,name=conversion_params,json=conversionParams,proto3" json:"conversion_params,omitempty"`
	ResizeParams      *ImagePreprocessingStep_ImageResizeParams      `protobuf:"bytes,3,opt,name=resize_params,json=resizeParams,proto3" json:"resize_params,omitempty"`
	StandardizeParams *ImagePreprocessingStep_ImageStandardizeParams `protobuf:"bytes,4,opt,name=standardize_params,json=standardizeParams,proto3" json:"standardize_params,omitempty"`
}

func (m *ImagePreprocessingStep) Reset()      { *m = ImagePreprocessingStep{} }
func (*ImagePreprocessingStep) ProtoMessage() {}
func (*ImagePreprocessingStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1}
}
func (m *ImagePreprocessingStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePreprocessingStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImagePreprocessingStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImagePreprocessingStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePreprocessingStep.Merge(m, src)
}
func (m *ImagePreprocessingStep) XXX_Size() int {
	return m.Size()
}
func (m *ImagePreprocessingStep) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePreprocessingStep.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePreprocessingStep proto.InternalMessageInfo

func (m *ImagePreprocessingStep) GetKind() ImagePreprocessingStep_ImagePreprocessingKind {
	if m != nil {
		return m.Kind
	}
	return IMAGE_PREPROCESSING_KIND_UNKNOWN
}

func (m *ImagePreprocessingStep) GetConversionParams() *ImagePreprocessingStep_ImageConversionParams {
	if m != nil {
		return m.ConversionParams
	}
	return nil
}

func (m *ImagePreprocessingStep) GetResizeParams() *ImagePreprocessingStep_ImageResizeParams {
	if m != nil {
		return m.ResizeParams
	}
	return nil
}

func (m *ImagePreprocessingStep) GetStandardizeParams() *ImagePreprocessingStep_ImageStandardizeParams {
	if m != nil {
		return m.StandardizeParams
	}
	return nil
}

type ImagePreprocessingStep_ImageConversionParams struct {
	Scale bool `protobuf:"varint,1,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (m *ImagePreprocessingStep_ImageConversionParams) Reset() {
	*m = ImagePreprocessingStep_ImageConversionParams{}
}
func (*ImagePreprocessingStep_ImageConversionParams) ProtoMessage() {}
func (*ImagePreprocessingStep_ImageConversionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 0}
}
func (m *ImagePreprocessingStep_ImageConversionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePreprocessingStep_ImageConversionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImagePreprocessingStep_ImageConversionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImagePreprocessingStep_ImageConversionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePreprocessingStep_ImageConversionParams.Merge(m, src)
}
func (m *ImagePreprocessingStep_ImageConversionParams) XXX_Size() int {
	return m.Size()
}
func (m *ImagePreprocessingStep_ImageConversionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePreprocessingStep_ImageConversionParams.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePreprocessingStep_ImageConversionParams proto.InternalMessageInfo

func (m *ImagePreprocessingStep_ImageConversionParams) GetScale() bool {
	if m != nil {
		return m.Scale
	}
	return false
}

type ImagePreprocessingStep_ImageResizeParams struct {
	Kind ImagePreprocessingStep_ImageResizeParams_ImageResizeKind `protobuf:"varint,1,opt,name=kind,proto3,enum=gml.internal.api.core.v1.ImagePreprocessingStep_ImageResizeParams_ImageResizeKind" json:"kind,omitempty"`
}

func (m *ImagePreprocessingStep_ImageResizeParams) Reset() {
	*m = ImagePreprocessingStep_ImageResizeParams{}
}
func (*ImagePreprocessingStep_ImageResizeParams) ProtoMessage() {}
func (*ImagePreprocessingStep_ImageResizeParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 1}
}
func (m *ImagePreprocessingStep_ImageResizeParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePreprocessingStep_ImageResizeParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImagePreprocessingStep_ImageResizeParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImagePreprocessingStep_ImageResizeParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePreprocessingStep_ImageResizeParams.Merge(m, src)
}
func (m *ImagePreprocessingStep_ImageResizeParams) XXX_Size() int {
	return m.Size()
}
func (m *ImagePreprocessingStep_ImageResizeParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePreprocessingStep_ImageResizeParams.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePreprocessingStep_ImageResizeParams proto.InternalMessageInfo

func (m *ImagePreprocessingStep_ImageResizeParams) GetKind() ImagePreprocessingStep_ImageResizeParams_ImageResizeKind {
	if m != nil {
		return m.Kind
	}
	return IMAGE_RESIZE_KIND_UNKNOWN
}

type ImagePreprocessingStep_ImageStandardizeParams struct {
	Means   []float32 `protobuf:"fixed32,1,rep,packed,name=means,proto3" json:"means,omitempty"`
	Stddevs []float32 `protobuf:"fixed32,2,rep,packed,name=stddevs,proto3" json:"stddevs,omitempty"`
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) Reset() {
	*m = ImagePreprocessingStep_ImageStandardizeParams{}
}
func (*ImagePreprocessingStep_ImageStandardizeParams) ProtoMessage() {}
func (*ImagePreprocessingStep_ImageStandardizeParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{1, 2}
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImagePreprocessingStep_ImageStandardizeParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePreprocessingStep_ImageStandardizeParams.Merge(m, src)
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) XXX_Size() int {
	return m.Size()
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePreprocessingStep_ImageStandardizeParams.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePreprocessingStep_ImageStandardizeParams proto.InternalMessageInfo

func (m *ImagePreprocessingStep_ImageStandardizeParams) GetMeans() []float32 {
	if m != nil {
		return m.Means
	}
	return nil
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) GetStddevs() []float32 {
	if m != nil {
		return m.Stddevs
	}
	return nil
}

type DimensionSemantics struct {
	Kind                      DimensionSemantics_DimensionSemanticsKind     `protobuf:"varint,1,opt,name=kind,proto3,enum=gml.internal.api.core.v1.DimensionSemantics_DimensionSemanticsKind" json:"kind,omitempty"`
	ImageChannelParams        *DimensionSemantics_ImageChannelParams        `protobuf:"bytes,2,opt,name=image_channel_params,json=imageChannelParams,proto3" json:"image_channel_params,omitempty"`
	DetectionCandidatesParams *DimensionSemantics_DetectionCandidatesParams `protobuf:"bytes,3,opt,name=detection_candidates_params,json=detectionCandidatesParams,proto3" json:"detection_candidates_params,omitempty"`
	DetectionOutputParams     *DimensionSemantics_DetectionOutputParams     `protobuf:"bytes,4,opt,name=detection_output_params,json=detectionOutputParams,proto3" json:"detection_output_params,omitempty"`
	SegmentationMaskParams    *DimensionSemantics_SegmentationMaskParams    `protobuf:"bytes,5,opt,name=segmentation_mask_params,json=segmentationMaskParams,proto3" json:"segmentation_mask_params,omitempty"`
	RegressionParams          *DimensionSemantics_RegressionParams          `protobuf:"bytes,6,opt,name=regression_params,json=regressionParams,proto3" json:"regression_params,omitempty"`
}

func (m *DimensionSemantics) Reset()      { *m = DimensionSemantics{} }
func (*DimensionSemantics) ProtoMessage() {}
func (*DimensionSemantics) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2}
}
func (m *DimensionSemantics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics.Merge(m, src)
}
func (m *DimensionSemantics) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics proto.InternalMessageInfo

func (m *DimensionSemantics) GetKind() DimensionSemantics_DimensionSemanticsKind {
	if m != nil {
		return m.Kind
	}
	return DIMENSION_SEMANTICS_KIND_UNKNOWN
}

func (m *DimensionSemantics) GetImageChannelParams() *DimensionSemantics_ImageChannelParams {
	if m != nil {
		return m.ImageChannelParams
	}
	return nil
}

func (m *DimensionSemantics) GetDetectionCandidatesParams() *DimensionSemantics_DetectionCandidatesParams {
	if m != nil {
		return m.DetectionCandidatesParams
	}
	return nil
}

func (m *DimensionSemantics) GetDetectionOutputParams() *DimensionSemantics_DetectionOutputParams {
	if m != nil {
		return m.DetectionOutputParams
	}
	return nil
}

func (m *DimensionSemantics) GetSegmentationMaskParams() *DimensionSemantics_SegmentationMaskParams {
	if m != nil {
		return m.SegmentationMaskParams
	}
	return nil
}

func (m *DimensionSemantics) GetRegressionParams() *DimensionSemantics_RegressionParams {
	if m != nil {
		return m.RegressionParams
	}
	return nil
}

type DimensionSemantics_ImageChannelParams struct {
	Format DimensionSemantics_ImageChannelParams_ImageChannelFormat `protobuf:"varint,1,opt,name=format,proto3,enum=gml.internal.api.core.v1.DimensionSemantics_ImageChannelParams_ImageChannelFormat" json:"format,omitempty"`
}

func (m *DimensionSemantics_ImageChannelParams) Reset()      { *m = DimensionSemantics_ImageChannelParams{} }
func (*DimensionSemantics_ImageChannelParams) ProtoMessage() {}
func (*DimensionSemantics_ImageChannelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 0}
}
func (m *DimensionSemantics_ImageChannelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_ImageChannelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_ImageChannelParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_ImageChannelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_ImageChannelParams.Merge(m, src)
}
func (m *DimensionSemantics_ImageChannelParams) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_ImageChannelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_ImageChannelParams.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_ImageChannelParams proto.InternalMessageInfo

func (m *DimensionSemantics_ImageChannelParams) GetFormat() DimensionSemantics_ImageChannelParams_ImageChannelFormat {
	if m != nil {
		return m.Format
	}
	return IMAGE_CHANNEL_FORMAT_UNKNOWN
}

type DimensionSemantics_DetectionCandidatesParams struct {
	IsNmsBoxes bool `protobuf:"varint,1,opt,name=is_nms_boxes,json=isNmsBoxes,proto3" json:"is_nms_boxes,omitempty"`
}

func (m *DimensionSemantics_DetectionCandidatesParams) Reset() {
	*m = DimensionSemantics_DetectionCandidatesParams{}
}
func (*DimensionSemantics_DetectionCandidatesParams) ProtoMessage() {}
func (*DimensionSemantics_DetectionCandidatesParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 1}
}
func (m *DimensionSemantics_DetectionCandidatesParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_DetectionCandidatesParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_DetectionCandidatesParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_DetectionCandidatesParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_DetectionCandidatesParams.Merge(m, src)
}
func (m *DimensionSemantics_DetectionCandidatesParams) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_DetectionCandidatesParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_DetectionCandidatesParams.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_DetectionCandidatesParams proto.InternalMessageInfo

func (m *DimensionSemantics_DetectionCandidatesParams) GetIsNmsBoxes() bool {
	if m != nil {
		return m.IsNmsBoxes
	}
	return false
}

type DimensionSemantics_DetectionOutputParams struct {
	BoxCoordinateRange *DimensionSemantics_DetectionOutputParams_IndexRange `protobuf:"bytes,1,opt,name=box_coordinate_range,json=boxCoordinateRange,proto3" json:"box_coordinate_range,omitempty"`
	BoxFormat          *BoundingBoxInfo                                     `protobuf:"bytes,2,opt,name=box_format,json=boxFormat,proto3" json:"box_format,omitempty"`
	BoxConfidenceIndex int32                                                `protobuf:"varint,3,opt,name=box_confidence_index,json=boxConfidenceIndex,proto3" json:"box_confidence_index,omitempty"`
	ClassIndex         int32                                                `protobuf:"varint,4,opt,name=class_index,json=classIndex,proto3" json:"class_index,omitempty"`
	ScoresRange        *DimensionSemantics_DetectionOutputParams_IndexRange `protobuf:"bytes,5,opt,name=scores_range,json=scoresRange,proto3" json:"scores_range,omitempty"`
}

func (m *DimensionSemantics_DetectionOutputParams) Reset() {
	*m = DimensionSemantics_DetectionOutputParams{}
}
func (*DimensionSemantics_DetectionOutputParams) ProtoMessage() {}
func (*DimensionSemantics_DetectionOutputParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 2}
}
func (m *DimensionSemantics_DetectionOutputParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_DetectionOutputParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_DetectionOutputParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_DetectionOutputParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_DetectionOutputParams.Merge(m, src)
}
func (m *DimensionSemantics_DetectionOutputParams) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_DetectionOutputParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_DetectionOutputParams.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_DetectionOutputParams proto.InternalMessageInfo

func (m *DimensionSemantics_DetectionOutputParams) GetBoxCoordinateRange() *DimensionSemantics_DetectionOutputParams_IndexRange {
	if m != nil {
		return m.BoxCoordinateRange
	}
	return nil
}

func (m *DimensionSemantics_DetectionOutputParams) GetBoxFormat() *BoundingBoxInfo {
	if m != nil {
		return m.BoxFormat
	}
	return nil
}

func (m *DimensionSemantics_DetectionOutputParams) GetBoxConfidenceIndex() int32 {
	if m != nil {
		return m.BoxConfidenceIndex
	}
	return 0
}

func (m *DimensionSemantics_DetectionOutputParams) GetClassIndex() int32 {
	if m != nil {
		return m.ClassIndex
	}
	return 0
}

func (m *DimensionSemantics_DetectionOutputParams) GetScoresRange() *DimensionSemantics_DetectionOutputParams_IndexRange {
	if m != nil {
		return m.ScoresRange
	}
	return nil
}

type DimensionSemantics_DetectionOutputParams_IndexRange struct {
	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	Size_ int32 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) Reset() {
	*m = DimensionSemantics_DetectionOutputParams_IndexRange{}
}
func (*DimensionSemantics_DetectionOutputParams_IndexRange) ProtoMessage() {}
func (*DimensionSemantics_DetectionOutputParams_IndexRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 2, 0}
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_DetectionOutputParams_IndexRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_DetectionOutputParams_IndexRange.Merge(m, src)
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_DetectionOutputParams_IndexRange.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_DetectionOutputParams_IndexRange proto.InternalMessageInfo

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type DimensionSemantics_SegmentationMaskParams struct {
	Kind DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind `protobuf:"varint,1,opt,name=kind,proto3,enum=gml.internal.api.core.v1.DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind" json:"kind,omitempty"`
}

func (m *DimensionSemantics_SegmentationMaskParams) Reset() {
	*m = DimensionSemantics_SegmentationMaskParams{}
}
func (*DimensionSemantics_SegmentationMaskParams) ProtoMessage() {}
func (*DimensionSemantics_SegmentationMaskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 3}
}
func (m *DimensionSemantics_SegmentationMaskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_SegmentationMaskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_SegmentationMaskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_SegmentationMaskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_SegmentationMaskParams.Merge(m, src)
}
func (m *DimensionSemantics_SegmentationMaskParams) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_SegmentationMaskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_SegmentationMaskParams.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_SegmentationMaskParams proto.InternalMessageInfo

func (m *DimensionSemantics_SegmentationMaskParams) GetKind() DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind {
	if m != nil {
		return m.Kind
	}
	return SEGMENTATION_MASK_KIND_UNKNOWN
}

type DimensionSemantics_RegressionParams struct {
	Label string             `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Scale *types.DoubleValue `protobuf:"bytes,2,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (m *DimensionSemantics_RegressionParams) Reset()      { *m = DimensionSemantics_RegressionParams{} }
func (*DimensionSemantics_RegressionParams) ProtoMessage() {}
func (*DimensionSemantics_RegressionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{2, 4}
}
func (m *DimensionSemantics_RegressionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DimensionSemantics_RegressionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DimensionSemantics_RegressionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DimensionSemantics_RegressionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DimensionSemantics_RegressionParams.Merge(m, src)
}
func (m *DimensionSemantics_RegressionParams) XXX_Size() int {
	return m.Size()
}
func (m *DimensionSemantics_RegressionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DimensionSemantics_RegressionParams.DiscardUnknown(m)
}

var xxx_messageInfo_DimensionSemantics_RegressionParams proto.InternalMessageInfo

func (m *DimensionSemantics_RegressionParams) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *DimensionSemantics_RegressionParams) GetScale() *types.DoubleValue {
	if m != nil {
		return m.Scale
	}
	return nil
}

type TensorSemantics struct {
	Dimensions []*DimensionSemantics `protobuf:"bytes,1,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
}

func (m *TensorSemantics) Reset()      { *m = TensorSemantics{} }
func (*TensorSemantics) ProtoMessage() {}
func (*TensorSemantics) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{3}
}
func (m *TensorSemantics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorSemantics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorSemantics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorSemantics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorSemantics.Merge(m, src)
}
func (m *TensorSemantics) XXX_Size() int {
	return m.Size()
}
func (m *TensorSemantics) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorSemantics.DiscardUnknown(m)
}

var xxx_messageInfo_TensorSemantics proto.InternalMessageInfo

func (m *TensorSemantics) GetDimensions() []*DimensionSemantics {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

type GenerationConfig struct {
	EosTokenIds []int64 `protobuf:"varint,1,rep,packed,name=eos_token_ids,json=eosTokenIds,proto3" json:"eos_token_ids,omitempty"`
}

func (m *GenerationConfig) Reset()      { *m = GenerationConfig{} }
func (*GenerationConfig) ProtoMessage() {}
func (*GenerationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{4}
}
func (m *GenerationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerationConfig.Merge(m, src)
}
func (m *GenerationConfig) XXX_Size() int {
	return m.Size()
}
func (m *GenerationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GenerationConfig proto.InternalMessageInfo

func (m *GenerationConfig) GetEosTokenIds() []int64 {
	if m != nil {
		return m.EosTokenIds
	}
	return nil
}

type ModelInfo struct {
	Name                    string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind                    ModelInfo_ModelKind          `protobuf:"varint,2,opt,name=kind,proto3,enum=gml.internal.api.core.v1.ModelInfo_ModelKind" json:"kind,omitempty"`
	Format                  ModelInfo_ModelStorageFormat `protobuf:"varint,3,opt,name=format,proto3,enum=gml.internal.api.core.v1.ModelInfo_ModelStorageFormat" json:"format,omitempty"`
	FileAssets              map[string]*typespb.UUID     `protobuf:"bytes,4,rep,name=file_assets,json=fileAssets,proto3" json:"file_assets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InputTensorSemantics    []*TensorSemantics           `protobuf:"bytes,5,rep,name=input_tensor_semantics,json=inputTensorSemantics,proto3" json:"input_tensor_semantics,omitempty"`
	OutputTensorSemantics   []*TensorSemantics           `protobuf:"bytes,6,rep,name=output_tensor_semantics,json=outputTensorSemantics,proto3" json:"output_tensor_semantics,omitempty"`
	ClassLabels             []string                     `protobuf:"bytes,100,rep,name=class_labels,json=classLabels,proto3" json:"class_labels,omitempty"`
	BboxInfo                *BoundingBoxInfo             `protobuf:"bytes,101,opt,name=bbox_info,json=bboxInfo,proto3" json:"bbox_info,omitempty"`
	ImagePreprocessingSteps []*ImagePreprocessingStep    `protobuf:"bytes,102,rep,name=image_preprocessing_steps,json=imagePreprocessingSteps,proto3" json:"image_preprocessing_steps,omitempty"`
	GenerationConfig        *GenerationConfig            `protobuf:"bytes,103,opt,name=generation_config,json=generationConfig,proto3" json:"generation_config,omitempty"`
}

func (m *ModelInfo) Reset()      { *m = ModelInfo{} }
func (*ModelInfo) ProtoMessage() {}
func (*ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{5}
}
func (m *ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelInfo.Merge(m, src)
}
func (m *ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ModelInfo proto.InternalMessageInfo

func (m *ModelInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelInfo) GetKind() ModelInfo_ModelKind {
	if m != nil {
		return m.Kind
	}
	return MODEL_KIND_UNKNOWN
}

func (m *ModelInfo) GetFormat() ModelInfo_ModelStorageFormat {
	if m != nil {
		return m.Format
	}
	return MODEL_STORAGE_FORMAT_UNKNOWN
}

func (m *ModelInfo) GetFileAssets() map[string]*typespb.UUID {
	if m != nil {
		return m.FileAssets
	}
	return nil
}

func (m *ModelInfo) GetInputTensorSemantics() []*TensorSemantics {
	if m != nil {
		return m.InputTensorSemantics
	}
	return nil
}

func (m *ModelInfo) GetOutputTensorSemantics() []*TensorSemantics {
	if m != nil {
		return m.OutputTensorSemantics
	}
	return nil
}

func (m *ModelInfo) GetClassLabels() []string {
	if m != nil {
		return m.ClassLabels
	}
	return nil
}

func (m *ModelInfo) GetBboxInfo() *BoundingBoxInfo {
	if m != nil {
		return m.BboxInfo
	}
	return nil
}

func (m *ModelInfo) GetImagePreprocessingSteps() []*ImagePreprocessingStep {
	if m != nil {
		return m.ImagePreprocessingSteps
	}
	return nil
}

func (m *ModelInfo) GetGenerationConfig() *GenerationConfig {
	if m != nil {
		return m.GenerationConfig
	}
	return nil
}

type Node struct {
	Name       string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind       LogicalPipelineNodeKind `protobuf:"varint,2,opt,name=kind,proto3,enum=gml.internal.api.core.v1.LogicalPipelineNodeKind" json:"kind,omitempty"`
	Attributes []*NodeAttributes       `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
	Inputs     []*NodeInput            `protobuf:"bytes,4,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs    []*NodeOutput           `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs,omitempty"`
}

func (m *Node) Reset()      { *m = Node{} }
func (*Node) ProtoMessage() {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{6}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetKind() LogicalPipelineNodeKind {
	if m != nil {
		return m.Kind
	}
	return LOGICAL_PIPELINE_NODE_KIND_UNKNOWN
}

func (m *Node) GetAttributes() []*NodeAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Node) GetInputs() []*NodeInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Node) GetOutputs() []*NodeOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type ParamRef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ParamRef) Reset()      { *m = ParamRef{} }
func (*ParamRef) ProtoMessage() {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{7}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.Size()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Value struct {
	// Types that are valid to be assigned to Data:
	//	*Value_StringData
	//	*Value_Int64Data
	//	*Value_DoubleData
	//	*Value_BoolData
	//	*Value_LambdaData
	//	*Value_ModelData
	//	*Value_ParamData
	Data isValue_Data `protobuf_oneof:"data"`
}

func (m *Value) Reset()      { *m = Value{} }
func (*Value) ProtoMessage() {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{8}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Data interface {
	isValue_Data()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_StringData struct {
	StringData string `protobuf:"bytes,1,opt,name=string_data,json=stringData,proto3,oneof" json:"string_data,omitempty"`
}
type Value_Int64Data struct {
	Int64Data int64 `protobuf:"varint,2,opt,name=int64_data,json=int64Data,proto3,oneof" json:"int64_data,omitempty"`
}
type Value_DoubleData struct {
	DoubleData float64 `protobuf:"fixed64,3,opt,name=double_data,json=doubleData,proto3,oneof" json:"double_data,omitempty"`
}
type Value_BoolData struct {
	BoolData bool `protobuf:"varint,4,opt,name=bool_data,json=boolData,proto3,oneof" json:"bool_data,omitempty"`
}
type Value_LambdaData struct {
	LambdaData *Value_Lambda `protobuf:"bytes,5,opt,name=lambda_data,json=lambdaData,proto3,oneof" json:"lambda_data,omitempty"`
}
type Value_ModelData struct {
	ModelData *Value_ModelRef `protobuf:"bytes,6,opt,name=model_data,json=modelData,proto3,oneof" json:"model_data,omitempty"`
}
type Value_ParamData struct {
	ParamData *ParamRef `protobuf:"bytes,7,opt,name=param_data,json=paramData,proto3,oneof" json:"param_data,omitempty"`
}

func (*Value_StringData) isValue_Data() {}
func (*Value_Int64Data) isValue_Data()  {}
func (*Value_DoubleData) isValue_Data() {}
func (*Value_BoolData) isValue_Data()   {}
func (*Value_LambdaData) isValue_Data() {}
func (*Value_ModelData) isValue_Data()  {}
func (*Value_ParamData) isValue_Data()  {}

func (m *Value) GetData() isValue_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Value) GetStringData() string {
	if x, ok := m.GetData().(*Value_StringData); ok {
		return x.StringData
	}
	return ""
}

func (m *Value) GetInt64Data() int64 {
	if x, ok := m.GetData().(*Value_Int64Data); ok {
		return x.Int64Data
	}
	return 0
}

func (m *Value) GetDoubleData() float64 {
	if x, ok := m.GetData().(*Value_DoubleData); ok {
		return x.DoubleData
	}
	return 0
}

func (m *Value) GetBoolData() bool {
	if x, ok := m.GetData().(*Value_BoolData); ok {
		return x.BoolData
	}
	return false
}

func (m *Value) GetLambdaData() *Value_Lambda {
	if x, ok := m.GetData().(*Value_LambdaData); ok {
		return x.LambdaData
	}
	return nil
}

func (m *Value) GetModelData() *Value_ModelRef {
	if x, ok := m.GetData().(*Value_ModelData); ok {
		return x.ModelData
	}
	return nil
}

func (m *Value) GetParamData() *ParamRef {
	if x, ok := m.GetData().(*Value_ParamData); ok {
		return x.ParamData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_StringData)(nil),
		(*Value_Int64Data)(nil),
		(*Value_DoubleData)(nil),
		(*Value_BoolData)(nil),
		(*Value_LambdaData)(nil),
		(*Value_ModelData)(nil),
		(*Value_ParamData)(nil),
	}
}

type Value_ModelRef struct {
	Name string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ID   *typespb.UUID `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Value_ModelRef) Reset()      { *m = Value_ModelRef{} }
func (*Value_ModelRef) ProtoMessage() {}
func (*Value_ModelRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{8, 0}
}
func (m *Value_ModelRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value_ModelRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value_ModelRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value_ModelRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value_ModelRef.Merge(m, src)
}
func (m *Value_ModelRef) XXX_Size() int {
	return m.Size()
}
func (m *Value_ModelRef) XXX_DiscardUnknown() {
	xxx_messageInfo_Value_ModelRef.DiscardUnknown(m)
}

var xxx_messageInfo_Value_ModelRef proto.InternalMessageInfo

func (m *Value_ModelRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Value_ModelRef) GetID() *typespb.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

type Value_Lambda struct {
	Inputs  []string `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Outputs []string `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Nodes   []*Node  `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *Value_Lambda) Reset()      { *m = Value_Lambda{} }
func (*Value_Lambda) ProtoMessage() {}
func (*Value_Lambda) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{8, 1}
}
func (m *Value_Lambda) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value_Lambda) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value_Lambda.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value_Lambda) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value_Lambda.Merge(m, src)
}
func (m *Value_Lambda) XXX_Size() int {
	return m.Size()
}
func (m *Value_Lambda) XXX_DiscardUnknown() {
	xxx_messageInfo_Value_Lambda.DiscardUnknown(m)
}

var xxx_messageInfo_Value_Lambda proto.InternalMessageInfo

func (m *Value_Lambda) GetInputs() []string {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Value_Lambda) GetOutputs() []string {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Value_Lambda) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NodeAttributes struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *NodeAttributes) Reset()      { *m = NodeAttributes{} }
func (*NodeAttributes) ProtoMessage() {}
func (*NodeAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{9}
}
func (m *NodeAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAttributes.Merge(m, src)
}
func (m *NodeAttributes) XXX_Size() int {
	return m.Size()
}
func (m *NodeAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAttributes proto.InternalMessageInfo

func (m *NodeAttributes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeAttributes) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type NodeInput struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Value:
	//
	//	*NodeInput_ParamValue
	//	*NodeInput_NodeOutputValue
	//	*NodeInput_LambdaInputValue
	Value isNodeInput_Value `protobuf_oneof:"value"`
}

func (m *NodeInput) Reset()      { *m = NodeInput{} }
func (*NodeInput) ProtoMessage() {}
func (*NodeInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{10}
}
func (m *NodeInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput.Merge(m, src)
}
func (m *NodeInput) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput proto.InternalMessageInfo

type isNodeInput_Value interface {
	isNodeInput_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodeInput_ParamValue struct {
	ParamValue *ParamRef `protobuf:"bytes,2,opt,name=param_value,json=paramValue,proto3,oneof" json:"param_value,omitempty"`
}
type NodeInput_NodeOutputValue struct {
	NodeOutputValue *NodeInput_NodeOutputRef `protobuf:"bytes,3,opt,name=node_output_value,json=nodeOutputValue,proto3,oneof" json:"node_output_value,omitempty"`
}
type NodeInput_LambdaInputValue struct {
	LambdaInputValue *NodeInput_LambdaInputRef `protobuf:"bytes,4,opt,name=lambda_input_value,json=lambdaInputValue,proto3,oneof" json:"lambda_input_value,omitempty"`
}

func (*NodeInput_ParamValue) isNodeInput_Value()       {}
func (*NodeInput_NodeOutputValue) isNodeInput_Value()  {}
func (*NodeInput_LambdaInputValue) isNodeInput_Value() {}

func (m *NodeInput) GetValue() isNodeInput_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *NodeInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeInput) GetParamValue() *ParamRef {
	if x, ok := m.GetValue().(*NodeInput_ParamValue); ok {
		return x.ParamValue
	}
	return nil
}

func (m *NodeInput) GetNodeOutputValue() *NodeInput_NodeOutputRef {
	if x, ok := m.GetValue().(*NodeInput_NodeOutputValue); ok {
		return x.NodeOutputValue
	}
	return nil
}

func (m *NodeInput) GetLambdaInputValue() *NodeInput_LambdaInputRef {
	if x, ok := m.GetValue().(*NodeInput_LambdaInputValue); ok {
		return x.LambdaInputValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NodeInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NodeInput_ParamValue)(nil),
		(*NodeInput_NodeOutputValue)(nil),
		(*NodeInput_LambdaInputValue)(nil),
	}
}

type NodeInput_NodeOutputRef struct {
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeInput_NodeOutputRef) Reset()      { *m = NodeInput_NodeOutputRef{} }
func (*NodeInput_NodeOutputRef) ProtoMessage() {}
func (*NodeInput_NodeOutputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{10, 0}
}
func (m *NodeInput_NodeOutputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput_NodeOutputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput_NodeOutputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput_NodeOutputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput_NodeOutputRef.Merge(m, src)
}
func (m *NodeInput_NodeOutputRef) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput_NodeOutputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput_NodeOutputRef.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput_NodeOutputRef proto.InternalMessageInfo

func (m *NodeInput_NodeOutputRef) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *NodeInput_NodeOutputRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NodeInput_LambdaInputRef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeInput_LambdaInputRef) Reset()      { *m = NodeInput_LambdaInputRef{} }
func (*NodeInput_LambdaInputRef) ProtoMessage() {}
func (*NodeInput_LambdaInputRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{10, 1}
}
func (m *NodeInput_LambdaInputRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInput_LambdaInputRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInput_LambdaInputRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInput_LambdaInputRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInput_LambdaInputRef.Merge(m, src)
}
func (m *NodeInput_LambdaInputRef) XXX_Size() int {
	return m.Size()
}
func (m *NodeInput_LambdaInputRef) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInput_LambdaInputRef.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInput_LambdaInputRef proto.InternalMessageInfo

func (m *NodeInput_LambdaInputRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NodeOutput struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *NodeOutput) Reset()      { *m = NodeOutput{} }
func (*NodeOutput) ProtoMessage() {}
func (*NodeOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{11}
}
func (m *NodeOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeOutput.Merge(m, src)
}
func (m *NodeOutput) XXX_Size() int {
	return m.Size()
}
func (m *NodeOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeOutput.DiscardUnknown(m)
}

var xxx_messageInfo_NodeOutput proto.InternalMessageInfo

func (m *NodeOutput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Param struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DefaultValue *Value `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (m *Param) Reset()      { *m = Param{} }
func (*Param) ProtoMessage() {}
func (*Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{12}
}
func (m *Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Param.Merge(m, src)
}
func (m *Param) XXX_Size() int {
	return m.Size()
}
func (m *Param) XXX_DiscardUnknown() {
	xxx_messageInfo_Param.DiscardUnknown(m)
}

var xxx_messageInfo_Param proto.InternalMessageInfo

func (m *Param) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Param) GetDefaultValue() *Value {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

type LogicalPipeline struct {
	Params   []*Param        `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty"`
	Nodes    []*Node         `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	ModelIDs []*typespb.UUID `protobuf:"bytes,3,rep,name=model_ids,json=modelIds,proto3" json:"model_ids,omitempty"`
}

func (m *LogicalPipeline) Reset()      { *m = LogicalPipeline{} }
func (*LogicalPipeline) ProtoMessage() {}
func (*LogicalPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{13}
}
func (m *LogicalPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalPipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalPipeline.Merge(m, src)
}
func (m *LogicalPipeline) XXX_Size() int {
	return m.Size()
}
func (m *LogicalPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalPipeline proto.InternalMessageInfo

func (m *LogicalPipeline) GetParams() []*Param {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *LogicalPipeline) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *LogicalPipeline) GetModelIDs() []*typespb.UUID {
	if m != nil {
		return m.ModelIDs
	}
	return nil
}

type PipelineDeployment struct {
	ID                *typespb.UUID             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	LogicalPipelineID *typespb.UUID             `protobuf:"bytes,2,opt,name=logical_pipeline_id,json=logicalPipelineId,proto3" json:"logical_pipeline_id,omitempty"`
	FleetID           *typespb.UUID             `protobuf:"bytes,3,opt,name=fleet_id,json=fleetId,proto3" json:"fleet_id,omitempty"`
	CreatedAt         *types.Timestamp          `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt         *types.Timestamp          `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Version           int64                     `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	Spec              *PipelineDeploymentSpec   `protobuf:"bytes,7,opt,name=spec,proto3" json:"spec,omitempty"`
	Status            *PipelineDeploymentStatus `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	DeletedAt         *types.Timestamp          `protobuf:"bytes,9,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
}

func (m *PipelineDeployment) Reset()      { *m = PipelineDeployment{} }
func (*PipelineDeployment) ProtoMessage() {}
func (*PipelineDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{14}
}
func (m *PipelineDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeployment.Merge(m, src)
}
func (m *PipelineDeployment) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeployment proto.InternalMessageInfo

func (m *PipelineDeployment) GetID() *typespb.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *PipelineDeployment) GetLogicalPipelineID() *typespb.UUID {
	if m != nil {
		return m.LogicalPipelineID
	}
	return nil
}

func (m *PipelineDeployment) GetFleetID() *typespb.UUID {
	if m != nil {
		return m.FleetID
	}
	return nil
}

func (m *PipelineDeployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineDeployment) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *PipelineDeployment) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineDeployment) GetSpec() *PipelineDeploymentSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PipelineDeployment) GetStatus() *PipelineDeploymentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PipelineDeployment) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

type PipelineDeploymentSpec struct {
	State PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
}

func (m *PipelineDeploymentSpec) Reset()      { *m = PipelineDeploymentSpec{} }
func (*PipelineDeploymentSpec) ProtoMessage() {}
func (*PipelineDeploymentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{15}
}
func (m *PipelineDeploymentSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeploymentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeploymentSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeploymentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeploymentSpec.Merge(m, src)
}
func (m *PipelineDeploymentSpec) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeploymentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeploymentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeploymentSpec proto.InternalMessageInfo

func (m *PipelineDeploymentSpec) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

type PipelineDeploymentStatus struct {
	State  PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
	Reason string        `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *PipelineDeploymentStatus) Reset()      { *m = PipelineDeploymentStatus{} }
func (*PipelineDeploymentStatus) ProtoMessage() {}
func (*PipelineDeploymentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{16}
}
func (m *PipelineDeploymentStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineDeploymentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineDeploymentStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineDeploymentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineDeploymentStatus.Merge(m, src)
}
func (m *PipelineDeploymentStatus) XXX_Size() int {
	return m.Size()
}
func (m *PipelineDeploymentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineDeploymentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineDeploymentStatus proto.InternalMessageInfo

func (m *PipelineDeploymentStatus) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

func (m *PipelineDeploymentStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type PhysicalPipeline struct {
	ID                   *typespb.UUID           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PipelineDeploymentID *typespb.UUID           `protobuf:"bytes,2,opt,name=pipeline_deployment_id,json=pipelineDeploymentId,proto3" json:"pipeline_deployment_id,omitempty"`
	DeviceID             *typespb.UUID           `protobuf:"bytes,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	CreatedAt            *types.Timestamp        `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt            *types.Timestamp        `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	Spec                 *PhysicalPipelineSpec   `protobuf:"bytes,6,opt,name=spec,proto3" json:"spec,omitempty"`
	Status               *PhysicalPipelineStatus `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *PhysicalPipeline) Reset()      { *m = PhysicalPipeline{} }
func (*PhysicalPipeline) ProtoMessage() {}
func (*PhysicalPipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{17}
}
func (m *PhysicalPipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipeline.Merge(m, src)
}
func (m *PhysicalPipeline) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipeline.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipeline proto.InternalMessageInfo

func (m *PhysicalPipeline) GetID() *typespb.UUID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *PhysicalPipeline) GetPipelineDeploymentID() *typespb.UUID {
	if m != nil {
		return m.PipelineDeploymentID
	}
	return nil
}

func (m *PhysicalPipeline) GetDeviceID() *typespb.UUID {
	if m != nil {
		return m.DeviceID
	}
	return nil
}

func (m *PhysicalPipeline) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PhysicalPipeline) GetUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *PhysicalPipeline) GetSpec() *PhysicalPipelineSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PhysicalPipeline) GetStatus() *PhysicalPipelineStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type PhysicalPipelineSpec struct {
	State   PipelineState  `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
	Version int64          `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Graph   *ExecutionSpec `protobuf:"bytes,3,opt,name=graph,proto3" json:"graph,omitempty"`
	Runtime string         `protobuf:"bytes,4,opt,name=runtime,proto3" json:"runtime,omitempty"`
}

func (m *PhysicalPipelineSpec) Reset()      { *m = PhysicalPipelineSpec{} }
func (*PhysicalPipelineSpec) ProtoMessage() {}
func (*PhysicalPipelineSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{18}
}
func (m *PhysicalPipelineSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineSpec.Merge(m, src)
}
func (m *PhysicalPipelineSpec) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineSpec proto.InternalMessageInfo

func (m *PhysicalPipelineSpec) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

func (m *PhysicalPipelineSpec) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PhysicalPipelineSpec) GetGraph() *ExecutionSpec {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *PhysicalPipelineSpec) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

type PhysicalPipelineStatus struct {
	State   PipelineState `protobuf:"varint,1,opt,name=state,proto3,enum=gml.internal.api.core.v1.PipelineState" json:"state,omitempty"`
	Version int64         `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Runtime string        `protobuf:"bytes,3,opt,name=runtime,proto3" json:"runtime,omitempty"`
	Reason  string        `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *PhysicalPipelineStatus) Reset()      { *m = PhysicalPipelineStatus{} }
func (*PhysicalPipelineStatus) ProtoMessage() {}
func (*PhysicalPipelineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{19}
}
func (m *PhysicalPipelineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhysicalPipelineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhysicalPipelineStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhysicalPipelineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhysicalPipelineStatus.Merge(m, src)
}
func (m *PhysicalPipelineStatus) XXX_Size() int {
	return m.Size()
}
func (m *PhysicalPipelineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PhysicalPipelineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PhysicalPipelineStatus proto.InternalMessageInfo

func (m *PhysicalPipelineStatus) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PIPELINE_STATE_UNKNOWN
}

func (m *PhysicalPipelineStatus) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PhysicalPipelineStatus) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *PhysicalPipelineStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type FileResource struct {
	FileID     *typespb.UUID `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	SizeBytes  uint64        `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Sha256Hash string        `protobuf:"bytes,3,opt,name=sha256_hash,json=sha256Hash,proto3" json:"sha256_hash,omitempty"`
}

func (m *FileResource) Reset()      { *m = FileResource{} }
func (*FileResource) ProtoMessage() {}
func (*FileResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{20}
}
func (m *FileResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileResource.Merge(m, src)
}
func (m *FileResource) XXX_Size() int {
	return m.Size()
}
func (m *FileResource) XXX_DiscardUnknown() {
	xxx_messageInfo_FileResource.DiscardUnknown(m)
}

var xxx_messageInfo_FileResource proto.InternalMessageInfo

func (m *FileResource) GetFileID() *typespb.UUID {
	if m != nil {
		return m.FileID
	}
	return nil
}

func (m *FileResource) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileResource) GetSha256Hash() string {
	if m != nil {
		return m.Sha256Hash
	}
	return ""
}

type ExecutionSpec struct {
	Graph     *framework.CalculatorGraphConfig `protobuf:"bytes,1,opt,name=graph,proto3" json:"graph,omitempty"`
	ModelSpec []*ModelSpec                     `protobuf:"bytes,2,rep,name=model_spec,json=modelSpec,proto3" json:"model_spec,omitempty"`
}

func (m *ExecutionSpec) Reset()      { *m = ExecutionSpec{} }
func (*ExecutionSpec) ProtoMessage() {}
func (*ExecutionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{21}
}
func (m *ExecutionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionSpec.Merge(m, src)
}
func (m *ExecutionSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionSpec proto.InternalMessageInfo

func (m *ExecutionSpec) GetGraph() *framework.CalculatorGraphConfig {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ExecutionSpec) GetModelSpec() []*ModelSpec {
	if m != nil {
		return m.ModelSpec
	}
	return nil
}

type NamedAsset struct {
	Name string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	File *FileResource `protobuf:"bytes,2,opt,name=file,proto3" json:"file,omitempty"`
}

func (m *NamedAsset) Reset()      { *m = NamedAsset{} }
func (*NamedAsset) ProtoMessage() {}
func (*NamedAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{22}
}
func (m *NamedAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedAsset.Merge(m, src)
}
func (m *NamedAsset) XXX_Size() int {
	return m.Size()
}
func (m *NamedAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedAsset.DiscardUnknown(m)
}

var xxx_messageInfo_NamedAsset proto.InternalMessageInfo

func (m *NamedAsset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NamedAsset) GetFile() *FileResource {
	if m != nil {
		return m.File
	}
	return nil
}

type ModelSpec struct {
	Name         string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ONNXBlobKey  string             `protobuf:"bytes,2,opt,name=onnx_blob_key,json=onnxBlobKey,proto3" json:"onnx_blob_key,omitempty"`
	ONNXFile     *FileResource      `protobuf:"bytes,3,opt,name=onnx_file,json=onnxFile,proto3" json:"onnx_file,omitempty"`
	NamedAsset   []*NamedAsset      `protobuf:"bytes,4,rep,name=named_asset,json=namedAsset,proto3" json:"named_asset,omitempty"`
	Runtime      string             `protobuf:"bytes,50,opt,name=runtime,proto3" json:"runtime,omitempty"`
	TensorRTSpec *TensorRTModelSpec `protobuf:"bytes,100,opt,name=tensorrt_spec,json=tensorrtSpec,proto3" json:"tensorrt_spec,omitempty"`
	OpenVINOSpec *OpenVINOModelSpec `protobuf:"bytes,101,opt,name=openvino_spec,json=openvinoSpec,proto3" json:"openvino_spec,omitempty"`
}

func (m *ModelSpec) Reset()      { *m = ModelSpec{} }
func (*ModelSpec) ProtoMessage() {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{23}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelSpec) GetONNXBlobKey() string {
	if m != nil {
		return m.ONNXBlobKey
	}
	return ""
}

func (m *ModelSpec) GetONNXFile() *FileResource {
	if m != nil {
		return m.ONNXFile
	}
	return nil
}

func (m *ModelSpec) GetNamedAsset() []*NamedAsset {
	if m != nil {
		return m.NamedAsset
	}
	return nil
}

func (m *ModelSpec) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *ModelSpec) GetTensorRTSpec() *TensorRTModelSpec {
	if m != nil {
		return m.TensorRTSpec
	}
	return nil
}

func (m *ModelSpec) GetOpenVINOSpec() *OpenVINOModelSpec {
	if m != nil {
		return m.OpenVINOSpec
	}
	return nil
}

type TensorRTModelSpec struct {
	OptimizationProfile []*TensorRTOptimizationProfile `protobuf:"bytes,1,rep,name=optimization_profile,json=optimizationProfile,proto3" json:"optimization_profile,omitempty"`
	EngineBlobKey       string                         `protobuf:"bytes,2,opt,name=engine_blob_key,json=engineBlobKey,proto3" json:"engine_blob_key,omitempty"`
	MemPoolLimits       *TensorRTMemPoolLimits         `protobuf:"bytes,3,opt,name=mem_pool_limits,json=memPoolLimits,proto3" json:"mem_pool_limits,omitempty"`
}

func (m *TensorRTModelSpec) Reset()      { *m = TensorRTModelSpec{} }
func (*TensorRTModelSpec) ProtoMessage() {}
func (*TensorRTModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{24}
}
func (m *TensorRTModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTModelSpec.Merge(m, src)
}
func (m *TensorRTModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTModelSpec proto.InternalMessageInfo

func (m *TensorRTModelSpec) GetOptimizationProfile() []*TensorRTOptimizationProfile {
	if m != nil {
		return m.OptimizationProfile
	}
	return nil
}

func (m *TensorRTModelSpec) GetEngineBlobKey() string {
	if m != nil {
		return m.EngineBlobKey
	}
	return ""
}

func (m *TensorRTModelSpec) GetMemPoolLimits() *TensorRTMemPoolLimits {
	if m != nil {
		return m.MemPoolLimits
	}
	return nil
}

type TensorRTOptimizationProfile struct {
	TensorShapeRange []*TensorRTTensorShapeRange `protobuf:"bytes,1,rep,name=tensor_shape_range,json=tensorShapeRange,proto3" json:"tensor_shape_range,omitempty"`
}

func (m *TensorRTOptimizationProfile) Reset()      { *m = TensorRTOptimizationProfile{} }
func (*TensorRTOptimizationProfile) ProtoMessage() {}
func (*TensorRTOptimizationProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{25}
}
func (m *TensorRTOptimizationProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTOptimizationProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTOptimizationProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTOptimizationProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTOptimizationProfile.Merge(m, src)
}
func (m *TensorRTOptimizationProfile) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTOptimizationProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTOptimizationProfile.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTOptimizationProfile proto.InternalMessageInfo

func (m *TensorRTOptimizationProfile) GetTensorShapeRange() []*TensorRTTensorShapeRange {
	if m != nil {
		return m.TensorShapeRange
	}
	return nil
}

type TensorRTTensorShapeRange struct {
	TensorName string  `protobuf:"bytes,1,opt,name=tensor_name,json=tensorName,proto3" json:"tensor_name,omitempty"`
	Dim        []int32 `protobuf:"varint,2,rep,packed,name=dim,proto3" json:"dim,omitempty"`
}

func (m *TensorRTTensorShapeRange) Reset()      { *m = TensorRTTensorShapeRange{} }
func (*TensorRTTensorShapeRange) ProtoMessage() {}
func (*TensorRTTensorShapeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{26}
}
func (m *TensorRTTensorShapeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTTensorShapeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTTensorShapeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTTensorShapeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTTensorShapeRange.Merge(m, src)
}
func (m *TensorRTTensorShapeRange) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTTensorShapeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTTensorShapeRange.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTTensorShapeRange proto.InternalMessageInfo

func (m *TensorRTTensorShapeRange) GetTensorName() string {
	if m != nil {
		return m.TensorName
	}
	return ""
}

func (m *TensorRTTensorShapeRange) GetDim() []int32 {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorRTMemPoolLimits struct {
	Workspace int64 `protobuf:"varint,1,opt,name=workspace,proto3" json:"workspace,omitempty"`
}

func (m *TensorRTMemPoolLimits) Reset()      { *m = TensorRTMemPoolLimits{} }
func (*TensorRTMemPoolLimits) ProtoMessage() {}
func (*TensorRTMemPoolLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{27}
}
func (m *TensorRTMemPoolLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorRTMemPoolLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorRTMemPoolLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorRTMemPoolLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorRTMemPoolLimits.Merge(m, src)
}
func (m *TensorRTMemPoolLimits) XXX_Size() int {
	return m.Size()
}
func (m *TensorRTMemPoolLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorRTMemPoolLimits.DiscardUnknown(m)
}

var xxx_messageInfo_TensorRTMemPoolLimits proto.InternalMessageInfo

func (m *TensorRTMemPoolLimits) GetWorkspace() int64 {
	if m != nil {
		return m.Workspace
	}
	return 0
}

type OpenVINOModelSpec struct {
	InputShape []*OpenVINOModelSpec_TensorShape `protobuf:"bytes,1,rep,name=input_shape,json=inputShape,proto3" json:"input_shape,omitempty"`
}

func (m *OpenVINOModelSpec) Reset()      { *m = OpenVINOModelSpec{} }
func (*OpenVINOModelSpec) ProtoMessage() {}
func (*OpenVINOModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{28}
}
func (m *OpenVINOModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenVINOModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenVINOModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenVINOModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenVINOModelSpec.Merge(m, src)
}
func (m *OpenVINOModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *OpenVINOModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenVINOModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OpenVINOModelSpec proto.InternalMessageInfo

func (m *OpenVINOModelSpec) GetInputShape() []*OpenVINOModelSpec_TensorShape {
	if m != nil {
		return m.InputShape
	}
	return nil
}

type OpenVINOModelSpec_TensorShape struct {
	Dim []int32 `protobuf:"varint,1,rep,packed,name=dim,proto3" json:"dim,omitempty"`
}

func (m *OpenVINOModelSpec_TensorShape) Reset()      { *m = OpenVINOModelSpec_TensorShape{} }
func (*OpenVINOModelSpec_TensorShape) ProtoMessage() {}
func (*OpenVINOModelSpec_TensorShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_2eacf87cbdc6b8b6, []int{28, 0}
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenVINOModelSpec_TensorShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenVINOModelSpec_TensorShape.Merge(m, src)
}
func (m *OpenVINOModelSpec_TensorShape) XXX_Size() int {
	return m.Size()
}
func (m *OpenVINOModelSpec_TensorShape) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenVINOModelSpec_TensorShape.DiscardUnknown(m)
}

var xxx_messageInfo_OpenVINOModelSpec_TensorShape proto.InternalMessageInfo

func (m *OpenVINOModelSpec_TensorShape) GetDim() []int32 {
	if m != nil {
		return m.Dim
	}
	return nil
}

func init() {
	proto.RegisterEnum("gml.internal.api.core.v1.LogicalPipelineNodeKind", LogicalPipelineNodeKind_name, LogicalPipelineNodeKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.PipelineState", PipelineState_name, PipelineState_value)
	proto.RegisterEnum("gml.internal.api.core.v1.BoundingBoxInfo_BoundingBoxFormat", BoundingBoxInfo_BoundingBoxFormat_name, BoundingBoxInfo_BoundingBoxFormat_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ImagePreprocessingStep_ImagePreprocessingKind", ImagePreprocessingStep_ImagePreprocessingKind_name, ImagePreprocessingStep_ImagePreprocessingKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ImagePreprocessingStep_ImageResizeParams_ImageResizeKind", ImagePreprocessingStep_ImageResizeParams_ImageResizeKind_name, ImagePreprocessingStep_ImageResizeParams_ImageResizeKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.DimensionSemantics_DimensionSemanticsKind", DimensionSemantics_DimensionSemanticsKind_name, DimensionSemantics_DimensionSemanticsKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.DimensionSemantics_ImageChannelParams_ImageChannelFormat", DimensionSemantics_ImageChannelParams_ImageChannelFormat_name, DimensionSemantics_ImageChannelParams_ImageChannelFormat_value)
	proto.RegisterEnum("gml.internal.api.core.v1.DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind", DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind_name, DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ModelInfo_ModelKind", ModelInfo_ModelKind_name, ModelInfo_ModelKind_value)
	proto.RegisterEnum("gml.internal.api.core.v1.ModelInfo_ModelStorageFormat", ModelInfo_ModelStorageFormat_name, ModelInfo_ModelStorageFormat_value)
	proto.RegisterType((*BoundingBoxInfo)(nil), "gml.internal.api.core.v1.BoundingBoxInfo")
	proto.RegisterType((*ImagePreprocessingStep)(nil), "gml.internal.api.core.v1.ImagePreprocessingStep")
	proto.RegisterType((*ImagePreprocessingStep_ImageConversionParams)(nil), "gml.internal.api.core.v1.ImagePreprocessingStep.ImageConversionParams")
	proto.RegisterType((*ImagePreprocessingStep_ImageResizeParams)(nil), "gml.internal.api.core.v1.ImagePreprocessingStep.ImageResizeParams")
	proto.RegisterType((*ImagePreprocessingStep_ImageStandardizeParams)(nil), "gml.internal.api.core.v1.ImagePreprocessingStep.ImageStandardizeParams")
	proto.RegisterType((*DimensionSemantics)(nil), "gml.internal.api.core.v1.DimensionSemantics")
	proto.RegisterType((*DimensionSemantics_ImageChannelParams)(nil), "gml.internal.api.core.v1.DimensionSemantics.ImageChannelParams")
	proto.RegisterType((*DimensionSemantics_DetectionCandidatesParams)(nil), "gml.internal.api.core.v1.DimensionSemantics.DetectionCandidatesParams")
	proto.RegisterType((*DimensionSemantics_DetectionOutputParams)(nil), "gml.internal.api.core.v1.DimensionSemantics.DetectionOutputParams")
	proto.RegisterType((*DimensionSemantics_DetectionOutputParams_IndexRange)(nil), "gml.internal.api.core.v1.DimensionSemantics.DetectionOutputParams.IndexRange")
	proto.RegisterType((*DimensionSemantics_SegmentationMaskParams)(nil), "gml.internal.api.core.v1.DimensionSemantics.SegmentationMaskParams")
	proto.RegisterType((*DimensionSemantics_RegressionParams)(nil), "gml.internal.api.core.v1.DimensionSemantics.RegressionParams")
	proto.RegisterType((*TensorSemantics)(nil), "gml.internal.api.core.v1.TensorSemantics")
	proto.RegisterType((*GenerationConfig)(nil), "gml.internal.api.core.v1.GenerationConfig")
	proto.RegisterType((*ModelInfo)(nil), "gml.internal.api.core.v1.ModelInfo")
	proto.RegisterMapType((map[string]*typespb.UUID)(nil), "gml.internal.api.core.v1.ModelInfo.FileAssetsEntry")
	proto.RegisterType((*Node)(nil), "gml.internal.api.core.v1.Node")
	proto.RegisterType((*ParamRef)(nil), "gml.internal.api.core.v1.ParamRef")
	proto.RegisterType((*Value)(nil), "gml.internal.api.core.v1.Value")
	proto.RegisterType((*Value_ModelRef)(nil), "gml.internal.api.core.v1.Value.ModelRef")
	proto.RegisterType((*Value_Lambda)(nil), "gml.internal.api.core.v1.Value.Lambda")
	proto.RegisterType((*NodeAttributes)(nil), "gml.internal.api.core.v1.NodeAttributes")
	proto.RegisterType((*NodeInput)(nil), "gml.internal.api.core.v1.NodeInput")
	proto.RegisterType((*NodeInput_NodeOutputRef)(nil), "gml.internal.api.core.v1.NodeInput.NodeOutputRef")
	proto.RegisterType((*NodeInput_LambdaInputRef)(nil), "gml.internal.api.core.v1.NodeInput.LambdaInputRef")
	proto.RegisterType((*NodeOutput)(nil), "gml.internal.api.core.v1.NodeOutput")
	proto.RegisterType((*Param)(nil), "gml.internal.api.core.v1.Param")
	proto.RegisterType((*LogicalPipeline)(nil), "gml.internal.api.core.v1.LogicalPipeline")
	proto.RegisterType((*PipelineDeployment)(nil), "gml.internal.api.core.v1.PipelineDeployment")
	proto.RegisterType((*PipelineDeploymentSpec)(nil), "gml.internal.api.core.v1.PipelineDeploymentSpec")
	proto.RegisterType((*PipelineDeploymentStatus)(nil), "gml.internal.api.core.v1.PipelineDeploymentStatus")
	proto.RegisterType((*PhysicalPipeline)(nil), "gml.internal.api.core.v1.PhysicalPipeline")
	proto.RegisterType((*PhysicalPipelineSpec)(nil), "gml.internal.api.core.v1.PhysicalPipelineSpec")
	proto.RegisterType((*PhysicalPipelineStatus)(nil), "gml.internal.api.core.v1.PhysicalPipelineStatus")
	proto.RegisterType((*FileResource)(nil), "gml.internal.api.core.v1.FileResource")
	proto.RegisterType((*ExecutionSpec)(nil), "gml.internal.api.core.v1.ExecutionSpec")
	proto.RegisterType((*NamedAsset)(nil), "gml.internal.api.core.v1.NamedAsset")
	proto.RegisterType((*ModelSpec)(nil), "gml.internal.api.core.v1.ModelSpec")
	proto.RegisterType((*TensorRTModelSpec)(nil), "gml.internal.api.core.v1.TensorRTModelSpec")
	proto.RegisterType((*TensorRTOptimizationProfile)(nil), "gml.internal.api.core.v1.TensorRTOptimizationProfile")
	proto.RegisterType((*TensorRTTensorShapeRange)(nil), "gml.internal.api.core.v1.TensorRTTensorShapeRange")
	proto.RegisterType((*TensorRTMemPoolLimits)(nil), "gml.internal.api.core.v1.TensorRTMemPoolLimits")
	proto.RegisterType((*OpenVINOModelSpec)(nil), "gml.internal.api.core.v1.OpenVINOModelSpec")
	proto.RegisterType((*OpenVINOModelSpec_TensorShape)(nil), "gml.internal.api.core.v1.OpenVINOModelSpec.TensorShape")
}

func init() {
	proto.RegisterFile("src/api/corepb/v1/model_exec.proto", fileDescriptor_2eacf87cbdc6b8b6)
}

var fileDescriptor_2eacf87cbdc6b8b6 = []byte{
	// 3852 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0xdd, 0x6f, 0xdb, 0x58,
	0x76, 0xb7, 0x24, 0xdb, 0xb2, 0x8f, 0xec, 0x31, 0x7d, 0xc7, 0xf1, 0x28, 0x4a, 0x22, 0x39, 0x9c,
	0x7c, 0x6d, 0x66, 0x22, 0x4f, 0x3c, 0x93, 0x4c, 0x3b, 0x83, 0x69, 0x4b, 0x49, 0xb4, 0xcc, 0x46,
	0x22, 0xbd, 0x57, 0x74, 0xe2, 0xcc, 0x2e, 0xc0, 0x52, 0xe2, 0xb5, 0xc2, 0x8d, 0x44, 0x6a, 0x49,
	0x3a, 0x93, 0x0c, 0x50, 0x6c, 0x1f, 0x8a, 0xbe, 0x14, 0x28, 0xf6, 0x0f, 0xe8, 0x5b, 0x51, 0x74,
	0x81, 0x05, 0xfa, 0xd2, 0xd7, 0x16, 0xe8, 0x53, 0xbb, 0x0f, 0x7d, 0x48, 0x3f, 0x80, 0xee, 0x43,
	0x91, 0xdd, 0xf1, 0xbc, 0x6c, 0xdb, 0xdd, 0x76, 0x5a, 0xec, 0x73, 0x51, 0xdc, 0x7b, 0x49, 0x59,
	0x5f, 0x94, 0xec, 0x49, 0x17, 0x7d, 0x23, 0xcf, 0xfd, 0x9d, 0x73, 0xee, 0x39, 0xf7, 0x9c, 0x73,
	0xcf, 0xbd, 0x24, 0x88, 0xbe, 0xd7, 0xda, 0x36, 0x7b, 0xf6, 0x76, 0xcb, 0xf5, 0x48, 0xaf, 0xb9,
	0xfd, 0xec, 0xee, 0x76, 0xd7, 0xb5, 0x48, 0xc7, 0x20, 0xcf, 0x49, 0xab, 0xd8, 0xf3, 0xdc, 0xc0,
	0x45, 0xd9, 0x76, 0xb7, 0x53, 0xb4, 0x9d, 0x80, 0x78, 0x8e, 0xd9, 0x29, 0x9a, 0x3d, 0xbb, 0x48,
	0xc1, 0xc5, 0x67, 0x77, 0x73, 0x1b, 0x6d, 0xb7, 0xed, 0x32, 0xd0, 0x36, 0x7d, 0xe2, 0xf8, 0xdc,
	0xb5, 0x2e, 0xb1, 0x6c, 0xb3, 0x67, 0xf7, 0xc8, 0xf6, 0x91, 0x67, 0x76, 0xc9, 0x67, 0xae, 0xf7,
	0x74, 0xbb, 0x65, 0x76, 0x5a, 0xc7, 0x1d, 0x33, 0x70, 0xbd, 0x10, 0x75, 0x85, 0x6a, 0x6e, 0xb9,
	0xdd, 0xae, 0xeb, 0x6c, 0x07, 0x2f, 0x7a, 0xc4, 0xef, 0x35, 0xb7, 0x8f, 0x8f, 0x6d, 0x2b, 0x1c,
	0x2e, 0xb4, 0x5d, 0xb7, 0xdd, 0x21, 0xdb, 0xec, 0xad, 0x79, 0x7c, 0xb4, 0x1d, 0xd8, 0x5d, 0xe2,
	0x07, 0x66, 0xb7, 0x17, 0x02, 0xf2, 0xa3, 0x80, 0xcf, 0x3c, 0xb3, 0xd7, 0x23, 0x9e, 0xcf, 0xc7,
	0xc5, 0x3f, 0x4b, 0xc2, 0x5a, 0xc9, 0x3d, 0x76, 0x2c, 0xdb, 0x69, 0x97, 0xdc, 0xe7, 0x8a, 0x73,
	0xe4, 0xa2, 0x4f, 0x01, 0x9a, 0xee, 0x73, 0xe3, 0xc8, 0xf5, 0xba, 0x66, 0x90, 0x4d, 0x6c, 0x25,
	0x6e, 0xbd, 0xb1, 0xf3, 0x71, 0x31, 0xce, 0xbc, 0xe2, 0x08, 0xfb, 0xe0, 0xfb, 0x2e, 0x13, 0x81,
	0x97, 0x9b, 0xd1, 0x23, 0xba, 0x0e, 0x6f, 0x50, 0xd9, 0x0e, 0x7d, 0xeb, 0xd8, 0x9f, 0x13, 0x2b,
	0x9b, 0xdc, 0x4a, 0xdc, 0x5a, 0xc2, 0xab, 0x4d, 0xf7, 0xb9, 0xda, 0x27, 0x8a, 0xdf, 0x4f, 0xc0,
	0xfa, 0x98, 0x1c, 0x54, 0x80, 0x4b, 0x25, 0xed, 0x40, 0xad, 0x28, 0x6a, 0xd5, 0x28, 0x69, 0x87,
	0xc6, 0xae, 0x86, 0xeb, 0x92, 0x6e, 0x1c, 0xa8, 0x0f, 0x54, 0xed, 0x91, 0x2a, 0xcc, 0xa1, 0x3c,
	0xe4, 0x26, 0x01, 0xca, 0x87, 0xe5, 0xc7, 0x8f, 0xf6, 0x84, 0x04, 0xba, 0x0c, 0xd9, 0x49, 0xe3,
	0x8f, 0x0f, 0x1f, 0x1f, 0x0a, 0xc9, 0xb8, 0xd1, 0xc3, 0xc7, 0x87, 0x8f, 0x85, 0x94, 0xf8, 0xcb,
	0x34, 0x6c, 0x2a, 0x5d, 0xb3, 0x4d, 0xf6, 0x3d, 0xd2, 0xf3, 0xdc, 0x16, 0xf1, 0x7d, 0xdb, 0x69,
	0x37, 0x02, 0xd2, 0x43, 0xdf, 0x82, 0xf9, 0xa7, 0xb6, 0x63, 0x85, 0xae, 0xaa, 0xc6, 0xbb, 0x6a,
	0x32, 0xff, 0x04, 0xf2, 0x03, 0xdb, 0xb1, 0x30, 0x13, 0x8a, 0x7c, 0x58, 0x6f, 0xb9, 0xce, 0x33,
	0xe2, 0xf9, 0xb6, 0xeb, 0x18, 0x3d, 0xd3, 0x33, 0xbb, 0x3e, 0x73, 0x5a, 0x66, 0x67, 0xf7, 0xeb,
	0x69, 0x2a, 0xf7, 0xc5, 0xed, 0x33, 0x69, 0x58, 0x68, 0x8d, 0x50, 0x50, 0x1b, 0x56, 0x3d, 0xe2,
	0xdb, 0x9f, 0x93, 0x48, 0x61, 0x8a, 0x29, 0x2c, 0x7d, 0x3d, 0x85, 0x98, 0x89, 0x0a, 0x95, 0xad,
	0x78, 0x03, 0x6f, 0xe8, 0x19, 0x20, 0x3f, 0x30, 0x1d, 0xcb, 0xf4, 0xac, 0x01, 0x6d, 0xf3, 0x4c,
	0xdb, 0xd7, 0x74, 0x64, 0xe3, 0x54, 0x5e, 0xa8, 0x72, 0xdd, 0x1f, 0x25, 0xe5, 0xee, 0xc0, 0x85,
	0x89, 0xbe, 0x40, 0x1b, 0xb0, 0xe0, 0xb7, 0xcc, 0x0e, 0x61, 0x8b, 0xb9, 0x84, 0xf9, 0x4b, 0xee,
	0x17, 0x09, 0x58, 0x1f, 0x33, 0x05, 0x1d, 0x0d, 0xad, 0x3b, 0x7e, 0x7d, 0xe7, 0x0c, 0x52, 0x4e,
	0x43, 0x40, 0xec, 0xc1, 0xda, 0xc8, 0x00, 0xba, 0x02, 0x17, 0x95, 0xba, 0x54, 0x95, 0x0d, 0x2c,
	0x37, 0x94, 0x4f, 0x65, 0xe3, 0x81, 0xa2, 0x56, 0x06, 0x12, 0x61, 0xe2, 0x70, 0x43, 0xc7, 0xb2,
	0x5e, 0xa6, 0x79, 0x50, 0x80, 0x4b, 0xe3, 0xc3, 0x35, 0x59, 0xd7, 0x65, 0x5c, 0xd2, 0x0e, 0x85,
	0x64, 0x6e, 0x2f, 0x8c, 0xf5, 0x31, 0x5f, 0x52, 0xff, 0x74, 0x89, 0xe9, 0xf8, 0xd9, 0xc4, 0x56,
	0xea, 0x56, 0x12, 0xf3, 0x17, 0x94, 0x85, 0xb4, 0x1f, 0x58, 0x16, 0x79, 0x46, 0x43, 0x93, 0xd2,
	0xa3, 0x57, 0xf1, 0xaf, 0x12, 0x93, 0xd2, 0x86, 0xd9, 0x70, 0x0d, 0xb6, 0xf8, 0x2c, 0xf6, 0xb1,
	0xbc, 0x8f, 0xb5, 0xb2, 0xdc, 0x68, 0xd0, 0xd4, 0x1b, 0x31, 0xa5, 0x08, 0xb7, 0x63, 0x51, 0x65,
	0x4d, 0x7d, 0x28, 0x63, 0xdd, 0xd0, 0x35, 0x43, 0x97, 0xd5, 0x86, 0x86, 0x85, 0x04, 0x7a, 0x1b,
	0x0a, 0xb1, 0x78, 0x6e, 0xae, 0x90, 0x44, 0xb7, 0xe0, 0x5a, 0x2c, 0xa8, 0xa1, 0x4b, 0x6a, 0x45,
	0xc2, 0x15, 0x8a, 0x4c, 0x89, 0x7f, 0xb3, 0x01, 0xa8, 0x62, 0x77, 0x89, 0x43, 0x63, 0xa4, 0x41,
	0xba, 0xa6, 0x13, 0xd8, 0x2d, 0x1f, 0x3d, 0x1a, 0x5a, 0xfa, 0x72, 0xfc, 0xd2, 0x8f, 0xf3, 0x4e,
	0x20, 0x0d, 0xa4, 0xfb, 0x77, 0x61, 0xc3, 0xa6, 0xee, 0x32, 0x5a, 0x4f, 0x4c, 0xc7, 0x21, 0x9d,
	0xe1, 0x8c, 0xff, 0xcd, 0x73, 0x29, 0xe2, 0x11, 0xce, 0xe5, 0x84, 0xa9, 0x80, 0xec, 0x31, 0x1a,
	0xfa, 0x83, 0x04, 0x5c, 0xb2, 0x48, 0x40, 0x5a, 0x01, 0xad, 0x30, 0x2d, 0xd3, 0xb1, 0x6c, 0xcb,
	0x0c, 0x88, 0x3f, 0x9c, 0xfb, 0xbb, 0xe7, 0xb3, 0x31, 0x92, 0x57, 0xee, 0x8b, 0x0b, 0x67, 0x70,
	0xd1, 0x8a, 0x1b, 0x42, 0x9f, 0xc3, 0x5b, 0xa7, 0xf3, 0x70, 0x8f, 0x83, 0xde, 0x71, 0x30, 0x5c,
	0x11, 0x4a, 0x5f, 0x6f, 0x0e, 0x1a, 0x13, 0x15, 0xea, 0xbf, 0x60, 0x4d, 0x22, 0xa3, 0xdf, 0x85,
	0xac, 0x4f, 0xda, 0x5d, 0xe2, 0x04, 0x26, 0x53, 0xdf, 0x35, 0xfd, 0xa7, 0x91, 0xf2, 0x05, 0xa6,
	0xfc, 0x7c, 0x8b, 0xdc, 0x18, 0x10, 0x56, 0x37, 0xfd, 0xa7, 0xa1, 0xf6, 0x4d, 0x7f, 0x22, 0x1d,
	0x7d, 0x07, 0xd6, 0x3d, 0xd2, 0xf6, 0x68, 0x76, 0x9c, 0x56, 0xf9, 0x45, 0xa6, 0xf7, 0x93, 0x73,
	0xe9, 0xc5, 0x7d, 0x29, 0x51, 0x71, 0xf7, 0x46, 0x28, 0xb9, 0x5f, 0x26, 0x00, 0x8d, 0x87, 0x06,
	0xfa, 0x0e, 0x2c, 0x0e, 0x6d, 0xf9, 0xf8, 0x35, 0x63, 0x6d, 0x88, 0x14, 0x76, 0x02, 0xa1, 0x06,
	0xd1, 0x1b, 0x9e, 0x41, 0xb8, 0xbf, 0x6f, 0xc1, 0x65, 0x9e, 0x95, 0xe5, 0x3d, 0x49, 0x55, 0xe5,
	0xda, 0xf8, 0x06, 0x7f, 0x19, 0xb2, 0x13, 0x11, 0xb8, 0x5a, 0xe2, 0xdb, 0xfb, 0xc4, 0xd1, 0x52,
	0x15, 0x0b, 0xc9, 0xdc, 0x27, 0x70, 0x31, 0x36, 0x2a, 0xd1, 0x16, 0xac, 0xd8, 0xbe, 0xe1, 0x74,
	0x7d, 0xa3, 0xe9, 0x3e, 0x27, 0x7e, 0x58, 0xfd, 0xc1, 0xf6, 0xd5, 0xae, 0x5f, 0xa2, 0x94, 0xdc,
	0x4f, 0x52, 0x70, 0x61, 0x62, 0x44, 0xa1, 0xef, 0xc1, 0x06, 0xed, 0x69, 0x5a, 0xae, 0xeb, 0x59,
	0xb6, 0x63, 0x06, 0xc4, 0xf0, 0x4c, 0xa7, 0xcd, 0x77, 0x90, 0xcc, 0x4e, 0xfd, 0xf5, 0x63, 0xb6,
	0xa8, 0x38, 0x16, 0x79, 0x8e, 0xa9, 0x50, 0x8c, 0x9a, 0xee, 0xf3, 0x72, 0x5f, 0x13, 0xa3, 0xa1,
	0xbd, 0xa1, 0x86, 0x8d, 0x57, 0x8a, 0x6f, 0x9c, 0xb9, 0x61, 0x1b, 0x6c, 0xcf, 0xde, 0x8b, 0x4c,
	0x71, 0x8e, 0x6c, 0x8b, 0x38, 0x2d, 0x62, 0xd8, 0x54, 0x35, 0x2b, 0x01, 0x0b, 0xa1, 0xee, 0x68,
	0x88, 0x4d, 0x0a, 0x15, 0x20, 0xd3, 0xea, 0x98, 0xbe, 0x1f, 0x02, 0xe7, 0x19, 0x10, 0x18, 0x89,
	0x03, 0x7a, 0xb0, 0xe2, 0x53, 0xcd, 0x7e, 0xe8, 0x95, 0x85, 0x5f, 0x85, 0x57, 0x32, 0x5c, 0x05,
	0x7b, 0xc9, 0xdd, 0x07, 0x38, 0x1d, 0x62, 0x1b, 0x7a, 0x60, 0x7a, 0x3c, 0xaa, 0x17, 0x30, 0x7f,
	0x41, 0x08, 0xe6, 0xe9, 0x5e, 0xca, 0x9c, 0xb5, 0x80, 0xd9, 0x73, 0xee, 0xcf, 0x93, 0xb0, 0x39,
	0x39, 0x6d, 0x51, 0x67, 0xa8, 0xdc, 0x1f, 0xfe, 0x1f, 0x54, 0x82, 0x31, 0xf2, 0xc0, 0x7e, 0xff,
	0xa7, 0x09, 0xd8, 0x98, 0x34, 0x8c, 0x44, 0xc8, 0x37, 0xe4, 0x6a, 0x5d, 0x56, 0x75, 0x49, 0x57,
	0x34, 0xd5, 0xa8, 0x4b, 0x8d, 0x07, 0xa3, 0xfb, 0xe5, 0x0d, 0x10, 0x63, 0x30, 0xe5, 0x9a, 0xd4,
	0x68, 0x18, 0x35, 0xa9, 0x24, 0xd7, 0x78, 0x0f, 0x10, 0x83, 0x2b, 0x69, 0x5a, 0x4d, 0x48, 0xd2,
	0x6c, 0x8c, 0x01, 0x34, 0xca, 0x1a, 0x96, 0x85, 0x54, 0xee, 0xdb, 0x20, 0x8c, 0x96, 0x1b, 0xea,
	0xee, 0x8e, 0xd9, 0x24, 0x1d, 0xe6, 0xaa, 0x65, 0xcc, 0x5f, 0xd0, 0x4e, 0xd4, 0x55, 0xf1, 0xe0,
	0xbc, 0x5c, 0xe4, 0xc7, 0x92, 0x62, 0x74, 0x2c, 0x29, 0x56, 0xdc, 0xe3, 0x66, 0x87, 0x3c, 0x34,
	0x3b, 0xc7, 0x24, 0xec, 0xb9, 0xc4, 0xbf, 0x5b, 0x80, 0xcd, 0xc9, 0x5b, 0x25, 0xed, 0x1c, 0x2a,
	0x4a, 0x5d, 0x56, 0x1b, 0x74, 0x5e, 0x0d, 0xb9, 0x2e, 0xa9, 0xba, 0x52, 0x6e, 0x8c, 0x7a, 0x42,
	0x84, 0x7c, 0x2c, 0xaa, 0x24, 0xf1, 0x4e, 0xe8, 0x6d, 0x28, 0xc4, 0x62, 0x94, 0xaa, 0x4a, 0xed,
	0x4c, 0xa2, 0xdb, 0x70, 0x23, 0x1e, 0x34, 0x58, 0x70, 0x84, 0x14, 0xfa, 0x06, 0x5c, 0x9f, 0x81,
	0xdd, 0x93, 0x95, 0xea, 0x9e, 0x2e, 0xcc, 0xd3, 0x26, 0x64, 0x06, 0xf4, 0x91, 0x52, 0xd1, 0xf7,
	0x84, 0x05, 0x74, 0x17, 0xee, 0xc4, 0x22, 0x2b, 0xb2, 0x2e, 0x97, 0xd9, 0x02, 0x95, 0x25, 0xb5,
	0xa2, 0x54, 0x24, 0x5d, 0x6e, 0x08, 0x8b, 0xe8, 0x0e, 0x7c, 0xe3, 0x0c, 0x2c, 0xda, 0x81, 0xbe,
	0x7f, 0xa0, 0x0b, 0xe9, 0xa9, 0xd3, 0xe6, 0x71, 0xc3, 0x16, 0xbd, 0x21, 0x2c, 0xa1, 0xfb, 0xb0,
	0x13, 0x0b, 0x1d, 0x0f, 0x98, 0xc8, 0x33, 0xcb, 0x67, 0x50, 0xc1, 0x42, 0xb3, 0x21, 0xc0, 0xd4,
	0xc9, 0x63, 0xb9, 0x8a, 0x69, 0xbb, 0xa6, 0xa9, 0xc6, 0x43, 0xa9, 0x76, 0x20, 0x0b, 0x99, 0xa9,
	0x8b, 0xa8, 0x6b, 0x0f, 0x64, 0xb5, 0x21, 0xac, 0xa0, 0x77, 0xe0, 0x66, 0x2c, 0x48, 0xd2, 0x75,
	0x59, 0xed, 0xcf, 0x59, 0x58, 0x9d, 0x3a, 0xd7, 0x87, 0x5a, 0x59, 0x2a, 0x19, 0x35, 0xad, 0xaa,
	0xe8, 0x0d, 0xe1, 0x0d, 0x9a, 0x6f, 0xb1, 0x50, 0xb9, 0x5e, 0x92, 0x2b, 0xf4, 0x3c, 0x29, 0xac,
	0x89, 0x06, 0xac, 0xe9, 0xc4, 0xf1, 0x5d, 0xef, 0xb4, 0x89, 0xac, 0x01, 0x58, 0x51, 0x80, 0xf3,
	0x86, 0x3a, 0xb3, 0xf3, 0xee, 0x79, 0x6a, 0x0b, 0x1e, 0xe0, 0x17, 0xef, 0x83, 0x50, 0x25, 0x0e,
	0xf1, 0x58, 0xc9, 0x60, 0x65, 0xba, 0x8d, 0x44, 0x58, 0x25, 0xae, 0x6f, 0x04, 0xee, 0x53, 0xe2,
	0x18, 0xb6, 0xc5, 0x95, 0xa4, 0x70, 0x86, 0xb8, 0xbe, 0x4e, 0x69, 0x8a, 0xe5, 0x8b, 0x7f, 0x0b,
	0xb0, 0x5c, 0x77, 0x2d, 0xd2, 0x61, 0x87, 0x7f, 0x04, 0xf3, 0x8e, 0xd9, 0x25, 0x61, 0xfa, 0xb2,
	0x67, 0x24, 0x85, 0xd5, 0x2f, 0xc9, 0xaa, 0xdf, 0x9d, 0xf8, 0x19, 0xf6, 0xc5, 0xf0, 0xa7, 0x81,
	0xb6, 0x56, 0xed, 0x37, 0x17, 0x29, 0x26, 0xe4, 0xfe, 0x99, 0x85, 0x34, 0x02, 0xd7, 0x33, 0xdb,
	0x64, 0xb8, 0x81, 0x40, 0x3a, 0x64, 0x8e, 0xec, 0x0e, 0x31, 0x4c, 0xdf, 0x27, 0x01, 0x6d, 0x0f,
	0xa9, 0xef, 0xde, 0x3f, 0x8b, 0xd0, 0x5d, 0xbb, 0x43, 0x24, 0xc6, 0x25, 0x3b, 0x81, 0xf7, 0x02,
	0xc3, 0x51, 0x9f, 0x80, 0x0c, 0xd8, 0xb4, 0x1d, 0xda, 0x75, 0x06, 0x6c, 0xa5, 0x0c, 0x3f, 0x72,
	0x74, 0x76, 0x81, 0x29, 0x98, 0xb2, 0xa9, 0x8e, 0xac, 0x2d, 0xde, 0x60, 0x82, 0x46, 0x57, 0xdc,
	0x84, 0xb7, 0xc2, 0xbe, 0x76, 0x4c, 0xc3, 0xe2, 0x79, 0x35, 0x5c, 0xe0, 0x92, 0x46, 0x55, 0x5c,
	0x85, 0x15, 0xbe, 0x21, 0xb3, 0xca, 0xeb, 0x67, 0xad, 0xad, 0xd4, 0xad, 0x65, 0xcc, 0x37, 0xe9,
	0x1a, 0x23, 0xa1, 0x5d, 0x58, 0x6e, 0xd2, 0x6d, 0xde, 0x76, 0x8e, 0xdc, 0x2c, 0x39, 0x6f, 0xbb,
	0xb0, 0x44, 0x79, 0x59, 0xac, 0x74, 0xe0, 0x22, 0x3f, 0xab, 0xf4, 0x06, 0xcf, 0x76, 0x86, 0x1f,
	0x90, 0x9e, 0x9f, 0x3d, 0x62, 0xf6, 0xbc, 0x77, 0xde, 0x43, 0x31, 0x7e, 0xcb, 0x9e, 0x48, 0xa7,
	0x47, 0xae, 0xf5, 0x76, 0x3f, 0xbe, 0x79, 0x8b, 0xd2, 0xce, 0xb6, 0xd9, 0xec, 0x6f, 0xc7, 0x6b,
	0x19, 0x4d, 0x09, 0x2c, 0xb4, 0x47, 0x28, 0x39, 0x15, 0xd6, 0x46, 0x82, 0x02, 0x09, 0x90, 0x7a,
	0x4a, 0x5e, 0x84, 0x49, 0x40, 0x1f, 0xd1, 0x75, 0x58, 0x78, 0x46, 0x77, 0xa7, 0x70, 0x07, 0x5b,
	0x63, 0x1a, 0xd9, 0x8d, 0x5c, 0xf1, 0xe0, 0x40, 0xa9, 0x60, 0x3e, 0xfa, 0x51, 0xf2, 0xd7, 0x12,
	0xe2, 0x5f, 0x27, 0xc2, 0x84, 0x62, 0x7b, 0xd5, 0x26, 0xa0, 0xba, 0x56, 0x91, 0x6b, 0xa3, 0xbb,
	0xd3, 0x06, 0x08, 0x03, 0x74, 0x5d, 0xc3, 0x6c, 0x3f, 0xca, 0xc1, 0xe6, 0x28, 0xb5, 0x51, 0xc6,
	0xca, 0xbe, 0x2e, 0x24, 0xd1, 0x9b, 0xb0, 0x36, 0x30, 0xa6, 0xa9, 0xea, 0xa1, 0x90, 0x42, 0x17,
	0x60, 0x7d, 0x90, 0x61, 0xb7, 0xa6, 0xe8, 0xb2, 0x30, 0x8f, 0xde, 0x82, 0x37, 0x07, 0xb1, 0xfb,
	0xb2, 0xfa, 0x50, 0x51, 0x35, 0x61, 0x81, 0x6e, 0x9d, 0x03, 0x03, 0x7b, 0x07, 0xd5, 0xaa, 0xa2,
	0x56, 0x77, 0xa5, 0xb2, 0xcc, 0x2b, 0xa5, 0xf2, 0xa9, 0x8c, 0x85, 0x45, 0xf1, 0x2f, 0x92, 0x80,
	0xc6, 0xb3, 0x8f, 0xb6, 0x04, 0x9c, 0xb9, 0xa1, 0x6b, 0x98, 0x6e, 0x50, 0x63, 0x0d, 0xfa, 0x0d,
	0x10, 0x27, 0x22, 0xea, 0x35, 0x05, 0x1b, 0xa5, 0xc7, 0xba, 0x5c, 0xd6, 0x2a, 0xb2, 0x90, 0xa0,
	0x7b, 0x73, 0x3c, 0x4e, 0x97, 0x0f, 0xa9, 0xbd, 0x57, 0xe1, 0xca, 0x44, 0xcc, 0x3e, 0xd6, 0x74,
	0xad, 0x74, 0xb0, 0x2b, 0xa4, 0x68, 0xe5, 0x8f, 0x87, 0x70, 0x39, 0xf3, 0xb1, 0xa0, 0xdd, 0x9a,
	0xa4, 0x97, 0x0e, 0x76, 0x77, 0x65, 0x2c, 0x2c, 0xc4, 0x2a, 0xeb, 0xbb, 0x6e, 0x91, 0x76, 0x4c,
	0x31, 0x10, 0xe9, 0x9b, 0x07, 0xb2, 0x90, 0x16, 0x7f, 0x90, 0x84, 0x79, 0xd5, 0xb5, 0xc8, 0xc4,
	0x22, 0x2a, 0x0f, 0x15, 0xd1, 0xbb, 0xf1, 0x11, 0x5b, 0x73, 0xdb, 0x76, 0xcb, 0xec, 0xec, 0xdb,
	0x3d, 0xd2, 0xb1, 0x1d, 0x42, 0x05, 0x0e, 0x14, 0xd2, 0x3d, 0x00, 0x33, 0x08, 0x3c, 0xbb, 0x79,
	0x1c, 0x10, 0x7a, 0x34, 0xa7, 0x49, 0x76, 0x2b, 0x5e, 0x18, 0xe5, 0x96, 0xfa, 0x78, 0x3c, 0xc0,
	0x8b, 0x3e, 0x86, 0x45, 0x56, 0xa3, 0xa2, 0xea, 0xf9, 0xf6, 0x74, 0x29, 0x0a, 0xc5, 0xe2, 0x90,
	0x05, 0xfd, 0x06, 0xa4, 0x79, 0xf9, 0x89, 0x4a, 0xe3, 0xb5, 0xe9, 0xdc, 0xbc, 0x71, 0xc7, 0x11,
	0x93, 0x98, 0x87, 0x25, 0xd6, 0x30, 0x62, 0x72, 0x34, 0xc9, 0x5b, 0xe2, 0x0f, 0xe7, 0x61, 0x81,
	0x75, 0x83, 0xe8, 0x2a, 0x64, 0xfc, 0xc0, 0xa3, 0x75, 0xc5, 0x32, 0x03, 0x93, 0x83, 0xf6, 0xe6,
	0x30, 0x70, 0x62, 0xc5, 0x0c, 0x4c, 0x54, 0x00, 0xb0, 0x9d, 0xe0, 0xfe, 0x07, 0x1c, 0x41, 0x1d,
	0x9c, 0xda, 0x9b, 0xc3, 0xcb, 0x8c, 0xc6, 0x00, 0x57, 0x21, 0x63, 0xb1, 0x06, 0x93, 0x23, 0xe8,
	0x16, 0x94, 0xa0, 0x32, 0x38, 0x91, 0x41, 0xae, 0xc0, 0x72, 0xd3, 0x75, 0x3b, 0x1c, 0x40, 0x4f,
	0x31, 0x4b, 0x7b, 0x73, 0x78, 0x89, 0x92, 0xd8, 0xb0, 0x02, 0x99, 0x8e, 0xd9, 0x6d, 0x5a, 0x26,
	0x07, 0xf0, 0x43, 0xcc, 0x8d, 0x78, 0x9b, 0xd9, 0xdc, 0x8b, 0x35, 0xc6, 0x42, 0x35, 0x71, 0xe6,
	0x50, 0x14, 0xf0, 0x8f, 0x07, 0x4c, 0x12, 0x3f, 0xe3, 0xdf, 0x9a, 0x25, 0x89, 0x25, 0x23, 0x26,
	0x47, 0xd4, 0x2e, 0xc6, 0xcd, 0x44, 0x95, 0x01, 0xd8, 0x55, 0x01, 0x17, 0x95, 0x66, 0xa2, 0xc4,
	0x78, 0x51, 0x91, 0xc7, 0xa9, 0x10, 0xc6, 0x47, 0x85, 0xe4, 0xaa, 0xb0, 0x14, 0x49, 0x9f, 0x18,
	0xb8, 0x37, 0x21, 0x69, 0x5b, 0x31, 0x65, 0xaf, 0xb4, 0x78, 0xf2, 0xaa, 0x90, 0x54, 0x2a, 0x38,
	0x69, 0x5b, 0xb9, 0x1e, 0x2c, 0x72, 0x83, 0xd1, 0x66, 0x3f, 0xb4, 0x12, 0x6c, 0xf7, 0x89, 0xa2,
	0x26, 0x7b, 0x1a, 0x35, 0x49, 0x36, 0x10, 0xbd, 0xa2, 0x0f, 0x60, 0xc1, 0x71, 0xad, 0x7e, 0x44,
	0xe7, 0xa7, 0x47, 0x13, 0xe6, 0xe0, 0xd2, 0x22, 0xcc, 0x53, 0xcb, 0xc5, 0x6f, 0xc1, 0x1b, 0xc3,
	0x81, 0x3e, 0xd1, 0x90, 0x7b, 0xc3, 0x25, 0xbc, 0x30, 0xc3, 0xe7, 0x61, 0x49, 0x17, 0xff, 0x38,
	0x05, 0xcb, 0xfd, 0x04, 0x88, 0x49, 0xed, 0x0c, 0x5f, 0x86, 0x41, 0xf1, 0x67, 0x5b, 0x07, 0xbe,
	0x7e, 0x3c, 0xd2, 0x0d, 0x58, 0xa7, 0x66, 0x45, 0x37, 0x5f, 0x5c, 0x18, 0xbf, 0x7c, 0xbb, 0x7b,
	0x86, 0xdc, 0x1c, 0xcc, 0x33, 0x26, 0x7b, 0xcd, 0xe9, 0x13, 0xb8, 0x82, 0x26, 0xa0, 0x30, 0x88,
	0x79, 0x97, 0xc3, 0x35, 0xf0, 0xab, 0xb5, 0x9d, 0xb3, 0x68, 0xe0, 0xcb, 0xcb, 0x2b, 0x01, 0x53,
	0x21, 0x74, 0x4e, 0x29, 0x4c, 0x47, 0xee, 0xb7, 0x60, 0x75, 0x68, 0x1e, 0xe8, 0x12, 0x2c, 0x33,
	0xab, 0x06, 0xbc, 0xb6, 0x44, 0x09, 0x2a, 0xf5, 0x5c, 0xe4, 0xcd, 0xe4, 0xa9, 0x37, 0x73, 0xd7,
	0xe0, 0x8d, 0x61, 0x3d, 0x93, 0x7c, 0x5e, 0x4a, 0x87, 0x8b, 0x29, 0x6e, 0x01, 0x9c, 0x2a, 0x9c,
	0x58, 0x4b, 0x4c, 0x58, 0x60, 0x1e, 0x9f, 0xb8, 0x76, 0x15, 0x58, 0xb5, 0xc8, 0x91, 0x79, 0xdc,
	0x09, 0x8c, 0x73, 0x05, 0xc7, 0x4a, 0xc8, 0xc5, 0xde, 0xc4, 0xbf, 0x4c, 0xc0, 0xda, 0x48, 0xdd,
	0x46, 0x1f, 0xc2, 0x62, 0x78, 0x8f, 0xc7, 0x3b, 0xfb, 0xc2, 0xac, 0x80, 0x08, 0xe1, 0xa7, 0xb9,
	0x90, 0x3c, 0x47, 0x2e, 0xa0, 0x8f, 0x80, 0x17, 0x06, 0xd6, 0xe6, 0xf3, 0x2c, 0x1a, 0xcb, 0xd6,
	0x95, 0x93, 0x57, 0x05, 0x9e, 0xec, 0x4a, 0xc5, 0xc7, 0x4b, 0x0c, 0x4f, 0x8f, 0x00, 0x3f, 0x9c,
	0x07, 0x14, 0xcd, 0xbb, 0x42, 0x7a, 0x1d, 0xf7, 0x45, 0x97, 0x38, 0x41, 0x98, 0xf9, 0x89, 0x99,
	0x99, 0x8f, 0x1e, 0xc2, 0x9b, 0x1d, 0x6e, 0xbd, 0xd1, 0x0b, 0xc5, 0x18, 0xf1, 0x35, 0xe3, 0xc2,
	0xc9, 0xab, 0xc2, 0xfa, 0x88, 0xb7, 0x94, 0x0a, 0x5e, 0xef, 0x8c, 0x90, 0x2c, 0xf4, 0x21, 0x2c,
	0x1d, 0x75, 0x08, 0x09, 0xa8, 0xb0, 0xd4, 0x64, 0x61, 0x99, 0x93, 0x57, 0x85, 0xf4, 0x2e, 0x05,
	0x29, 0x15, 0x9c, 0x66, 0x68, 0xc5, 0x42, 0xbf, 0x0e, 0xd0, 0xf2, 0x88, 0x19, 0x10, 0xcb, 0x30,
	0x83, 0x30, 0xc2, 0x73, 0x63, 0x97, 0x0e, 0x7a, 0xf4, 0xb1, 0x14, 0x2f, 0x87, 0x68, 0x29, 0xa0,
	0xac, 0xc7, 0x3d, 0x2b, 0x62, 0x5d, 0x98, 0xcd, 0x1a, 0xa2, 0xa5, 0x80, 0x96, 0xb7, 0xf0, 0x63,
	0x12, 0x2b, 0xeb, 0x29, 0x1c, 0xbd, 0xa2, 0x0a, 0xcc, 0xfb, 0x3d, 0xd2, 0x0a, 0x4b, 0xf4, 0x94,
	0xa6, 0x78, 0x7c, 0x15, 0x1a, 0x3d, 0xd2, 0xc2, 0x8c, 0x1b, 0xfd, 0x36, 0x2c, 0xfa, 0x81, 0x19,
	0x1c, 0xfb, 0xd9, 0xa5, 0x59, 0x39, 0x3b, 0x41, 0x0e, 0xe3, 0xc4, 0xa1, 0x04, 0x6a, 0xa6, 0x45,
	0x3a, 0x24, 0x34, 0x73, 0x79, 0xb6, 0x99, 0x21, 0x5a, 0x0a, 0xc4, 0x47, 0xb0, 0x39, 0x79, 0x9a,
	0xe8, 0x13, 0x76, 0xd7, 0x16, 0x90, 0xf0, 0x9e, 0xec, 0xe6, 0xec, 0xf9, 0xd1, 0x59, 0x11, 0xcc,
	0xb9, 0xc4, 0xef, 0x42, 0x36, 0x6e, 0xde, 0xaf, 0x29, 0x9a, 0xee, 0x48, 0x1e, 0x31, 0x7d, 0xd7,
	0x09, 0x4b, 0x4d, 0xf8, 0x26, 0xfe, 0x4b, 0x0a, 0x84, 0xfd, 0x27, 0x2f, 0xfc, 0xa1, 0xcc, 0x3d,
	0x73, 0xdc, 0x1b, 0xb0, 0xd9, 0x8f, 0x77, 0xab, 0x3f, 0xe3, 0x29, 0xa1, 0x9f, 0x3d, 0x79, 0x55,
	0xd8, 0x18, 0xb7, 0x51, 0xa9, 0xe0, 0x8d, 0xde, 0x38, 0xd5, 0xa2, 0x49, 0x6d, 0x91, 0x67, 0x76,
	0x8b, 0x4c, 0xc9, 0x00, 0x96, 0xd4, 0x15, 0x86, 0x52, 0x2a, 0x78, 0x89, 0xe3, 0xff, 0xdf, 0x72,
	0xa0, 0x14, 0x46, 0x3a, 0xef, 0x6b, 0x8a, 0x53, 0x96, 0x69, 0xc4, 0xeb, 0x03, 0x71, 0xbe, 0xd7,
	0x8f, 0xf3, 0xd9, 0xf9, 0x32, 0x2a, 0x65, 0x28, 0xca, 0xc5, 0x1f, 0x25, 0x60, 0x63, 0x92, 0xa2,
	0xd7, 0x0d, 0xa7, 0x81, 0x4c, 0x4f, 0x0e, 0x67, 0xfa, 0x27, 0xb0, 0xd0, 0xf6, 0xcc, 0xde, 0x93,
	0x70, 0xb5, 0xa6, 0x08, 0x96, 0x9f, 0x93, 0xd6, 0x31, 0x3d, 0x86, 0x32, 0xcb, 0x39, 0x17, 0x15,
	0xec, 0x1d, 0x3b, 0x81, 0xdd, 0xe5, 0xfb, 0xf2, 0x32, 0x8e, 0x5e, 0xc5, 0x3f, 0x49, 0xc0, 0xe6,
	0x64, 0x6b, 0x7f, 0x75, 0xc6, 0x0c, 0xcc, 0x26, 0x35, 0x34, 0x9b, 0x81, 0x7c, 0x9a, 0x1f, 0xca,
	0xa7, 0xdf, 0x4f, 0xc0, 0x0a, 0x3d, 0x4c, 0x63, 0xe2, 0xbb, 0xc7, 0x5e, 0x8b, 0xa0, 0x0f, 0x20,
	0xcd, 0x2e, 0x6a, 0xe2, 0x13, 0x0a, 0x4e, 0x5e, 0x15, 0x16, 0x29, 0x8f, 0x52, 0xc1, 0x8b, 0x14,
	0xab, 0x58, 0xe8, 0x0a, 0x00, 0xfb, 0xfb, 0xa0, 0xf9, 0x22, 0x20, 0xfc, 0xdb, 0xe7, 0x3c, 0x5e,
	0xa6, 0x94, 0x12, 0x25, 0xa0, 0x02, 0x64, 0xfc, 0x27, 0xe6, 0xce, 0xbd, 0xfb, 0xc6, 0x13, 0xd3,
	0x7f, 0x12, 0xce, 0x0d, 0x38, 0x69, 0xcf, 0xf4, 0x9f, 0x88, 0x7f, 0x98, 0x80, 0xd5, 0x21, 0xff,
	0xa2, 0xfb, 0xd1, 0xba, 0xf0, 0x59, 0x6c, 0x15, 0xfb, 0xbf, 0xdf, 0x14, 0xcb, 0xfd, 0x9f, 0x6e,
	0xaa, 0x14, 0x11, 0xde, 0x13, 0x84, 0x0b, 0x52, 0x8a, 0xba, 0x75, 0x16, 0xd5, 0xc9, 0x59, 0x27,
	0x25, 0x7e, 0x68, 0xa6, 0x0b, 0xca, 0x77, 0x63, 0xfa, 0x28, 0x7e, 0x1b, 0x80, 0x76, 0x3b, 0x16,
	0xbb, 0x61, 0x98, 0xd8, 0x85, 0x7c, 0x04, 0xf3, 0xd4, 0xf2, 0xb0, 0x6c, 0x4c, 0x39, 0x57, 0x0c,
	0xfa, 0x16, 0x33, 0x1e, 0xf1, 0x65, 0x2a, 0xbc, 0x6e, 0x60, 0x76, 0x4e, 0x92, 0xfe, 0x3e, 0xac,
	0xba, 0x8e, 0xf3, 0xdc, 0x68, 0x76, 0xdc, 0xa6, 0xf1, 0x94, 0xbc, 0xe0, 0x35, 0xb0, 0xb4, 0x76,
	0xf2, 0xaa, 0x90, 0xd1, 0x54, 0xf5, 0xb0, 0xd4, 0x71, 0x9b, 0x0f, 0xc8, 0x0b, 0x9c, 0xa1, 0xa8,
	0xf0, 0x05, 0x7d, 0x13, 0x96, 0x19, 0x13, 0x9b, 0x57, 0xea, 0x3c, 0xf3, 0xe2, 0x15, 0x89, 0x0a,
	0x66, 0xd4, 0x25, 0x2a, 0x86, 0x3e, 0xd1, 0x3e, 0x99, 0xce, 0xc7, 0xe2, 0xb7, 0x76, 0xe1, 0xb1,
	0x73, 0xda, 0xc1, 0xb1, 0xef, 0x34, 0x0c, 0xce, 0xa9, 0x03, 0x07, 0xa2, 0x72, 0x67, 0x38, 0x2a,
	0x9b, 0xb0, 0xca, 0xef, 0xd5, 0xbc, 0x80, 0xaf, 0x97, 0xc5, 0xe6, 0xfd, 0xce, 0xac, 0x4b, 0x35,
	0xac, 0xf7, 0x1d, 0x58, 0x12, 0x4e, 0x5e, 0x15, 0x56, 0x22, 0x32, 0x5b, 0xc9, 0x95, 0x48, 0x26,
	0x73, 0x70, 0x13, 0x56, 0xdd, 0x1e, 0x71, 0x9e, 0xd9, 0x8e, 0xcb, 0x75, 0x90, 0x59, 0x3a, 0xb4,
	0x1e, 0x71, 0x1e, 0x2a, 0xaa, 0x36, 0xa2, 0x23, 0x22, 0x73, 0x1d, 0x91, 0x4c, 0x16, 0x30, 0xff,
	0x93, 0x80, 0xf5, 0xb1, 0x99, 0xa1, 0x27, 0xb0, 0xe1, 0xf6, 0x02, 0xbb, 0x6b, 0x7f, 0xce, 0xaf,
	0xc0, 0x7a, 0x9e, 0xcb, 0x16, 0x87, 0xb7, 0x97, 0xf7, 0x66, 0x1b, 0xa9, 0x0d, 0x70, 0xef, 0x73,
	0x66, 0xfc, 0xa6, 0x3b, 0x4e, 0x44, 0x37, 0x60, 0x8d, 0x38, 0x6d, 0xba, 0xab, 0x0d, 0x87, 0x0c,
	0x5e, 0xe5, 0xe4, 0x28, 0x46, 0x1e, 0xc1, 0x5a, 0x97, 0x74, 0x8d, 0x1e, 0x3d, 0x38, 0x77, 0xec,
	0xae, 0x1d, 0x44, 0x3f, 0x0b, 0x6c, 0x9f, 0xc1, 0xe3, 0xa4, 0xbb, 0xef, 0xba, 0x9d, 0x1a, 0x63,
	0xc3, 0xab, 0xdd, 0xc1, 0x57, 0xf1, 0x7b, 0x70, 0x69, 0xca, 0xa4, 0xd1, 0xef, 0x00, 0x8a, 0xee,
	0x4f, 0x9f, 0x98, 0xbd, 0xd3, 0xef, 0xad, 0xa9, 0xe9, 0x4d, 0x51, 0x24, 0x32, 0xbc, 0x32, 0xa5,
	0xac, 0xfc, 0xf3, 0xa1, 0x10, 0x8c, 0x50, 0xc4, 0x3a, 0x64, 0xe3, 0xd0, 0xb4, 0xfa, 0x84, 0xda,
	0x07, 0x32, 0x0d, 0x38, 0x89, 0x9d, 0x6a, 0x04, 0x48, 0x59, 0x76, 0x97, 0x15, 0x8b, 0x05, 0x4c,
	0x1f, 0xc5, 0x7b, 0x70, 0x61, 0xa2, 0xdd, 0xe8, 0x32, 0x2c, 0x7f, 0xe6, 0x7a, 0x4f, 0xfd, 0x9e,
	0xd9, 0xe2, 0x92, 0x52, 0xf8, 0x94, 0x20, 0xfe, 0x51, 0x02, 0xd6, 0xc7, 0xa2, 0x07, 0x1d, 0x42,
	0x86, 0x9f, 0xdf, 0x98, 0xf1, 0xa1, 0xd9, 0x1f, 0x9e, 0x23, 0xfe, 0x8a, 0x83, 0x26, 0x01, 0x93,
	0xc5, 0x9e, 0x73, 0x05, 0xc8, 0x0c, 0x0c, 0x45, 0x76, 0x24, 0xfa, 0x76, 0xdc, 0xfe, 0x79, 0x1a,
	0xde, 0x8a, 0xb9, 0x9f, 0x42, 0x37, 0x40, 0xac, 0x69, 0x55, 0xa5, 0x2c, 0xd5, 0x8c, 0x7d, 0x65,
	0x5f, 0xae, 0x29, 0xaa, 0x6c, 0xa8, 0x5a, 0x65, 0xec, 0xdf, 0xa4, 0x77, 0xe1, 0xd6, 0x14, 0x5c,
	0x59, 0xaa, 0xcb, 0x58, 0x32, 0x1a, 0xda, 0x01, 0x2e, 0xcb, 0x02, 0xa0, 0xbb, 0x70, 0x67, 0x0a,
	0x5a, 0x97, 0x0f, 0x75, 0xf6, 0x5f, 0x93, 0x54, 0x8f, 0x58, 0x32, 0xe8, 0x06, 0x5c, 0x9d, 0xc2,
	0xc2, 0x3f, 0x7e, 0x09, 0x3f, 0x4b, 0xa3, 0x5b, 0xf0, 0xf6, 0xb4, 0x89, 0xd4, 0xa4, 0x46, 0x43,
	0xd9, 0x7d, 0x2c, 0xfc, 0x6b, 0x1a, 0xdd, 0x9c, 0x6a, 0x5a, 0xf8, 0xd1, 0x4b, 0xf8, 0xb7, 0x34,
	0x7a, 0x1f, 0x8a, 0x53, 0x80, 0xf5, 0x83, 0x9a, 0xae, 0x18, 0xfb, 0x07, 0x78, 0x5f, 0x6b, 0xc8,
	0x06, 0xbb, 0x4b, 0x14, 0xfe, 0x7d, 0x96, 0xf4, 0xf0, 0x7b, 0x97, 0xf0, 0xf3, 0x34, 0xba, 0x0e,
	0x5b, 0xd3, 0x7c, 0x81, 0xa5, 0xf2, 0x03, 0xe1, 0x17, 0x69, 0xb4, 0x0d, 0xb7, 0xa7, 0xc0, 0xaa,
	0xb2, 0x2a, 0x63, 0x49, 0x97, 0xa3, 0x2f, 0x63, 0xff, 0x31, 0xcb, 0x11, 0xd1, 0xbd, 0xb0, 0xf0,
	0x9f, 0x69, 0x74, 0x1b, 0xae, 0x4f, 0x77, 0x6d, 0x84, 0xfd, 0x6a, 0xd6, 0x6c, 0xd9, 0xa7, 0x31,
	0xe1, 0xbf, 0xd2, 0xe8, 0x1e, 0xbc, 0x37, 0x75, 0x81, 0xeb, 0xfb, 0x35, 0x3a, 0xdb, 0xf2, 0x9e,
	0xa4, 0x1b, 0x75, 0xb9, 0xd1, 0x90, 0xaa, 0xb2, 0xf0, 0xdf, 0x69, 0xf4, 0x2e, 0xdc, 0x9c, 0xc2,
	0xb6, 0xab, 0x61, 0x43, 0x96, 0xca, 0x7b, 0x06, 0xd6, 0x14, 0xe1, 0x27, 0x19, 0x74, 0x67, 0x6a,
	0xcc, 0x3d, 0x94, 0xcb, 0xba, 0x86, 0x8d, 0x86, 0x2c, 0xe1, 0xf2, 0x9e, 0xf0, 0xd3, 0x0c, 0xba,
	0x0b, 0xef, 0x4e, 0x83, 0x2b, 0x15, 0x59, 0xeb, 0x47, 0x9d, 0xa2, 0x3e, 0x10, 0x5e, 0xae, 0xa1,
	0x0f, 0x61, 0x67, 0x66, 0xd0, 0x29, 0x9a, 0xda, 0x30, 0xea, 0xb2, 0x8e, 0x95, 0x72, 0x83, 0x33,
	0xfe, 0xfd, 0x1a, 0xfa, 0x00, 0xb6, 0xa7, 0x30, 0x52, 0xdb, 0xd5, 0xf2, 0xe3, 0x61, 0xae, 0x7f,
	0x58, 0x43, 0x3b, 0x53, 0xd3, 0x62, 0x17, 0x4b, 0x75, 0x79, 0x98, 0xe7, 0x1f, 0xd7, 0xd0, 0x7b,
	0xf0, 0xce, 0x59, 0x53, 0x89, 0x72, 0xfc, 0xd3, 0xda, 0xed, 0x7f, 0x4e, 0xc0, 0xea, 0x50, 0xcb,
	0x88, 0x72, 0xb0, 0xd9, 0xe7, 0x6d, 0xe8, 0x74, 0x61, 0x4e, 0x13, 0x7b, 0x7c, 0x6c, 0x5f, 0x66,
	0x7f, 0xd3, 0x0a, 0x09, 0x94, 0x85, 0x8d, 0x91, 0x31, 0x2c, 0x4b, 0x95, 0xc7, 0x42, 0x72, 0x02,
	0x17, 0x3e, 0x50, 0x55, 0xca, 0x95, 0x42, 0x79, 0xc8, 0x8d, 0x8c, 0xe9, 0x32, 0xae, 0x2b, 0xaa,
	0xa4, 0xd3, 0xf1, 0x79, 0x74, 0x05, 0x2e, 0xc6, 0x8c, 0xcb, 0x15, 0x61, 0x01, 0x5d, 0x84, 0x0b,
	0x23, 0xc3, 0xbb, 0x92, 0x52, 0x93, 0x2b, 0xc2, 0x62, 0xa9, 0xf5, 0xf2, 0x8b, 0xfc, 0xdc, 0x8f,
	0xbf, 0xc8, 0xcf, 0x7d, 0xf5, 0x45, 0x3e, 0xf1, 0x7b, 0x27, 0xf9, 0xc4, 0x0f, 0x4e, 0xf2, 0x89,
	0x1f, 0x9d, 0xe4, 0x13, 0x2f, 0x4f, 0xf2, 0x89, 0x9f, 0x9e, 0xe4, 0x13, 0x3f, 0x3b, 0xc9, 0xcf,
	0x7d, 0x75, 0x92, 0x4f, 0x7c, 0xff, 0xcb, 0xfc, 0xdc, 0xcb, 0x2f, 0xf3, 0x73, 0x3f, 0xfe, 0x32,
	0x3f, 0xf7, 0xe9, 0x9d, 0xb6, 0xdd, 0xed, 0x90, 0xa0, 0x63, 0x36, 0xfd, 0xa2, 0x69, 0x6f, 0xf3,
	0xb7, 0xed, 0xb1, 0x9f, 0xc3, 0x3f, 0xe6, 0x4f, 0xcd, 0x45, 0x76, 0x54, 0x7a, 0xff, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x18, 0x0e, 0xbf, 0x3e, 0x3f, 0x2e, 0x00, 0x00,
}

func (x LogicalPipelineNodeKind) String() string {
	s, ok := LogicalPipelineNodeKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PipelineState) String() string {
	s, ok := PipelineState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BoundingBoxInfo_BoundingBoxFormat) String() string {
	s, ok := BoundingBoxInfo_BoundingBoxFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ImagePreprocessingStep_ImagePreprocessingKind) String() string {
	s, ok := ImagePreprocessingStep_ImagePreprocessingKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ImagePreprocessingStep_ImageResizeParams_ImageResizeKind) String() string {
	s, ok := ImagePreprocessingStep_ImageResizeParams_ImageResizeKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DimensionSemantics_DimensionSemanticsKind) String() string {
	s, ok := DimensionSemantics_DimensionSemanticsKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DimensionSemantics_ImageChannelParams_ImageChannelFormat) String() string {
	s, ok := DimensionSemantics_ImageChannelParams_ImageChannelFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind) String() string {
	s, ok := DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ModelInfo_ModelKind) String() string {
	s, ok := ModelInfo_ModelKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ModelInfo_ModelStorageFormat) String() string {
	s, ok := ModelInfo_ModelStorageFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BoundingBoxInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoundingBoxInfo)
	if !ok {
		that2, ok := that.(BoundingBoxInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoxFormat != that1.BoxFormat {
		return false
	}
	if this.BoxNormalized != that1.BoxNormalized {
		return false
	}
	return true
}
func (this *ImagePreprocessingStep) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImagePreprocessingStep)
	if !ok {
		that2, ok := that.(ImagePreprocessingStep)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !this.ConversionParams.Equal(that1.ConversionParams) {
		return false
	}
	if !this.ResizeParams.Equal(that1.ResizeParams) {
		return false
	}
	if !this.StandardizeParams.Equal(that1.StandardizeParams) {
		return false
	}
	return true
}
func (this *ImagePreprocessingStep_ImageConversionParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImagePreprocessingStep_ImageConversionParams)
	if !ok {
		that2, ok := that.(ImagePreprocessingStep_ImageConversionParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Scale != that1.Scale {
		return false
	}
	return true
}
func (this *ImagePreprocessingStep_ImageResizeParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImagePreprocessingStep_ImageResizeParams)
	if !ok {
		that2, ok := that.(ImagePreprocessingStep_ImageResizeParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *ImagePreprocessingStep_ImageStandardizeParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImagePreprocessingStep_ImageStandardizeParams)
	if !ok {
		that2, ok := that.(ImagePreprocessingStep_ImageStandardizeParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Means) != len(that1.Means) {
		return false
	}
	for i := range this.Means {
		if this.Means[i] != that1.Means[i] {
			return false
		}
	}
	if len(this.Stddevs) != len(that1.Stddevs) {
		return false
	}
	for i := range this.Stddevs {
		if this.Stddevs[i] != that1.Stddevs[i] {
			return false
		}
	}
	return true
}
func (this *DimensionSemantics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics)
	if !ok {
		that2, ok := that.(DimensionSemantics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !this.ImageChannelParams.Equal(that1.ImageChannelParams) {
		return false
	}
	if !this.DetectionCandidatesParams.Equal(that1.DetectionCandidatesParams) {
		return false
	}
	if !this.DetectionOutputParams.Equal(that1.DetectionOutputParams) {
		return false
	}
	if !this.SegmentationMaskParams.Equal(that1.SegmentationMaskParams) {
		return false
	}
	if !this.RegressionParams.Equal(that1.RegressionParams) {
		return false
	}
	return true
}
func (this *DimensionSemantics_ImageChannelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_ImageChannelParams)
	if !ok {
		that2, ok := that.(DimensionSemantics_ImageChannelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	return true
}
func (this *DimensionSemantics_DetectionCandidatesParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_DetectionCandidatesParams)
	if !ok {
		that2, ok := that.(DimensionSemantics_DetectionCandidatesParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsNmsBoxes != that1.IsNmsBoxes {
		return false
	}
	return true
}
func (this *DimensionSemantics_DetectionOutputParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_DetectionOutputParams)
	if !ok {
		that2, ok := that.(DimensionSemantics_DetectionOutputParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BoxCoordinateRange.Equal(that1.BoxCoordinateRange) {
		return false
	}
	if !this.BoxFormat.Equal(that1.BoxFormat) {
		return false
	}
	if this.BoxConfidenceIndex != that1.BoxConfidenceIndex {
		return false
	}
	if this.ClassIndex != that1.ClassIndex {
		return false
	}
	if !this.ScoresRange.Equal(that1.ScoresRange) {
		return false
	}
	return true
}
func (this *DimensionSemantics_DetectionOutputParams_IndexRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_DetectionOutputParams_IndexRange)
	if !ok {
		that2, ok := that.(DimensionSemantics_DetectionOutputParams_IndexRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	return true
}
func (this *DimensionSemantics_SegmentationMaskParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_SegmentationMaskParams)
	if !ok {
		that2, ok := that.(DimensionSemantics_SegmentationMaskParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *DimensionSemantics_RegressionParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DimensionSemantics_RegressionParams)
	if !ok {
		that2, ok := that.(DimensionSemantics_RegressionParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if !this.Scale.Equal(that1.Scale) {
		return false
	}
	return true
}
func (this *TensorSemantics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorSemantics)
	if !ok {
		that2, ok := that.(TensorSemantics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dimensions) != len(that1.Dimensions) {
		return false
	}
	for i := range this.Dimensions {
		if !this.Dimensions[i].Equal(that1.Dimensions[i]) {
			return false
		}
	}
	return true
}
func (this *GenerationConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GenerationConfig)
	if !ok {
		that2, ok := that.(GenerationConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EosTokenIds) != len(that1.EosTokenIds) {
		return false
	}
	for i := range this.EosTokenIds {
		if this.EosTokenIds[i] != that1.EosTokenIds[i] {
			return false
		}
	}
	return true
}
func (this *ModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelInfo)
	if !ok {
		that2, ok := that.(ModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if len(this.FileAssets) != len(that1.FileAssets) {
		return false
	}
	for i := range this.FileAssets {
		if !this.FileAssets[i].Equal(that1.FileAssets[i]) {
			return false
		}
	}
	if len(this.InputTensorSemantics) != len(that1.InputTensorSemantics) {
		return false
	}
	for i := range this.InputTensorSemantics {
		if !this.InputTensorSemantics[i].Equal(that1.InputTensorSemantics[i]) {
			return false
		}
	}
	if len(this.OutputTensorSemantics) != len(that1.OutputTensorSemantics) {
		return false
	}
	for i := range this.OutputTensorSemantics {
		if !this.OutputTensorSemantics[i].Equal(that1.OutputTensorSemantics[i]) {
			return false
		}
	}
	if len(this.ClassLabels) != len(that1.ClassLabels) {
		return false
	}
	for i := range this.ClassLabels {
		if this.ClassLabels[i] != that1.ClassLabels[i] {
			return false
		}
	}
	if !this.BboxInfo.Equal(that1.BboxInfo) {
		return false
	}
	if len(this.ImagePreprocessingSteps) != len(that1.ImagePreprocessingSteps) {
		return false
	}
	for i := range this.ImagePreprocessingSteps {
		if !this.ImagePreprocessingSteps[i].Equal(that1.ImagePreprocessingSteps[i]) {
			return false
		}
	}
	if !this.GenerationConfig.Equal(that1.GenerationConfig) {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(that1.Attributes[i]) {
			return false
		}
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if !this.Inputs[i].Equal(that1.Inputs[i]) {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if !this.Outputs[i].Equal(that1.Outputs[i]) {
			return false
		}
	}
	return true
}
func (this *ParamRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParamRef)
	if !ok {
		that2, ok := that.(ParamRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Data == nil {
		if this.Data != nil {
			return false
		}
	} else if this.Data == nil {
		return false
	} else if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *Value_StringData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_StringData)
	if !ok {
		that2, ok := that.(Value_StringData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StringData != that1.StringData {
		return false
	}
	return true
}
func (this *Value_Int64Data) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Int64Data)
	if !ok {
		that2, ok := that.(Value_Int64Data)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int64Data != that1.Int64Data {
		return false
	}
	return true
}
func (this *Value_DoubleData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_DoubleData)
	if !ok {
		that2, ok := that.(Value_DoubleData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoubleData != that1.DoubleData {
		return false
	}
	return true
}
func (this *Value_BoolData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_BoolData)
	if !ok {
		that2, ok := that.(Value_BoolData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoolData != that1.BoolData {
		return false
	}
	return true
}
func (this *Value_LambdaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_LambdaData)
	if !ok {
		that2, ok := that.(Value_LambdaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LambdaData.Equal(that1.LambdaData) {
		return false
	}
	return true
}
func (this *Value_ModelData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ModelData)
	if !ok {
		that2, ok := that.(Value_ModelData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ModelData.Equal(that1.ModelData) {
		return false
	}
	return true
}
func (this *Value_ParamData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ParamData)
	if !ok {
		that2, ok := that.(Value_ParamData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamData.Equal(that1.ParamData) {
		return false
	}
	return true
}
func (this *Value_ModelRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_ModelRef)
	if !ok {
		that2, ok := that.(Value_ModelRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	return true
}
func (this *Value_Lambda) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value_Lambda)
	if !ok {
		that2, ok := that.(Value_Lambda)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if this.Inputs[i] != that1.Inputs[i] {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if this.Outputs[i] != that1.Outputs[i] {
			return false
		}
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *NodeAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeAttributes)
	if !ok {
		that2, ok := that.(NodeAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *NodeInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput)
	if !ok {
		that2, ok := that.(NodeInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *NodeInput_ParamValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_ParamValue)
	if !ok {
		that2, ok := that.(NodeInput_ParamValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamValue.Equal(that1.ParamValue) {
		return false
	}
	return true
}
func (this *NodeInput_NodeOutputValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_NodeOutputValue)
	if !ok {
		that2, ok := that.(NodeInput_NodeOutputValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeOutputValue.Equal(that1.NodeOutputValue) {
		return false
	}
	return true
}
func (this *NodeInput_LambdaInputValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_LambdaInputValue)
	if !ok {
		that2, ok := that.(NodeInput_LambdaInputValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LambdaInputValue.Equal(that1.LambdaInputValue) {
		return false
	}
	return true
}
func (this *NodeInput_NodeOutputRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_NodeOutputRef)
	if !ok {
		that2, ok := that.(NodeInput_NodeOutputRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeName != that1.NodeName {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *NodeInput_LambdaInputRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInput_LambdaInputRef)
	if !ok {
		that2, ok := that.(NodeInput_LambdaInputRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *NodeOutput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeOutput)
	if !ok {
		that2, ok := that.(NodeOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Param) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Param)
	if !ok {
		that2, ok := that.(Param)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.DefaultValue.Equal(that1.DefaultValue) {
		return false
	}
	return true
}
func (this *LogicalPipeline) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogicalPipeline)
	if !ok {
		that2, ok := that.(LogicalPipeline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(that1.Params[i]) {
			return false
		}
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if len(this.ModelIDs) != len(that1.ModelIDs) {
		return false
	}
	for i := range this.ModelIDs {
		if !this.ModelIDs[i].Equal(that1.ModelIDs[i]) {
			return false
		}
	}
	return true
}
func (this *PipelineDeployment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeployment)
	if !ok {
		that2, ok := that.(PipelineDeployment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.LogicalPipelineID.Equal(that1.LogicalPipelineID) {
		return false
	}
	if !this.FleetID.Equal(that1.FleetID) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	if !this.DeletedAt.Equal(that1.DeletedAt) {
		return false
	}
	return true
}
func (this *PipelineDeploymentSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeploymentSpec)
	if !ok {
		that2, ok := that.(PipelineDeploymentSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *PipelineDeploymentStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PipelineDeploymentStatus)
	if !ok {
		that2, ok := that.(PipelineDeploymentStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *PhysicalPipeline) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipeline)
	if !ok {
		that2, ok := that.(PhysicalPipeline)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.PipelineDeploymentID.Equal(that1.PipelineDeploymentID) {
		return false
	}
	if !this.DeviceID.Equal(that1.DeviceID) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *PhysicalPipelineSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineSpec)
	if !ok {
		that2, ok := that.(PhysicalPipelineSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if this.Runtime != that1.Runtime {
		return false
	}
	return true
}
func (this *PhysicalPipelineStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PhysicalPipelineStatus)
	if !ok {
		that2, ok := that.(PhysicalPipelineStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Runtime != that1.Runtime {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *FileResource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileResource)
	if !ok {
		that2, ok := that.(FileResource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileID.Equal(that1.FileID) {
		return false
	}
	if this.SizeBytes != that1.SizeBytes {
		return false
	}
	if this.Sha256Hash != that1.Sha256Hash {
		return false
	}
	return true
}
func (this *ExecutionSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutionSpec)
	if !ok {
		that2, ok := that.(ExecutionSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if len(this.ModelSpec) != len(that1.ModelSpec) {
		return false
	}
	for i := range this.ModelSpec {
		if !this.ModelSpec[i].Equal(that1.ModelSpec[i]) {
			return false
		}
	}
	return true
}
func (this *NamedAsset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedAsset)
	if !ok {
		that2, ok := that.(NamedAsset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.File.Equal(that1.File) {
		return false
	}
	return true
}
func (this *ModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelSpec)
	if !ok {
		that2, ok := that.(ModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ONNXBlobKey != that1.ONNXBlobKey {
		return false
	}
	if !this.ONNXFile.Equal(that1.ONNXFile) {
		return false
	}
	if len(this.NamedAsset) != len(that1.NamedAsset) {
		return false
	}
	for i := range this.NamedAsset {
		if !this.NamedAsset[i].Equal(that1.NamedAsset[i]) {
			return false
		}
	}
	if this.Runtime != that1.Runtime {
		return false
	}
	if !this.TensorRTSpec.Equal(that1.TensorRTSpec) {
		return false
	}
	if !this.OpenVINOSpec.Equal(that1.OpenVINOSpec) {
		return false
	}
	return true
}
func (this *TensorRTModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTModelSpec)
	if !ok {
		that2, ok := that.(TensorRTModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OptimizationProfile) != len(that1.OptimizationProfile) {
		return false
	}
	for i := range this.OptimizationProfile {
		if !this.OptimizationProfile[i].Equal(that1.OptimizationProfile[i]) {
			return false
		}
	}
	if this.EngineBlobKey != that1.EngineBlobKey {
		return false
	}
	if !this.MemPoolLimits.Equal(that1.MemPoolLimits) {
		return false
	}
	return true
}
func (this *TensorRTOptimizationProfile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTOptimizationProfile)
	if !ok {
		that2, ok := that.(TensorRTOptimizationProfile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TensorShapeRange) != len(that1.TensorShapeRange) {
		return false
	}
	for i := range this.TensorShapeRange {
		if !this.TensorShapeRange[i].Equal(that1.TensorShapeRange[i]) {
			return false
		}
	}
	return true
}
func (this *TensorRTTensorShapeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTTensorShapeRange)
	if !ok {
		that2, ok := that.(TensorRTTensorShapeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TensorName != that1.TensorName {
		return false
	}
	if len(this.Dim) != len(that1.Dim) {
		return false
	}
	for i := range this.Dim {
		if this.Dim[i] != that1.Dim[i] {
			return false
		}
	}
	return true
}
func (this *TensorRTMemPoolLimits) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorRTMemPoolLimits)
	if !ok {
		that2, ok := that.(TensorRTMemPoolLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Workspace != that1.Workspace {
		return false
	}
	return true
}
func (this *OpenVINOModelSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenVINOModelSpec)
	if !ok {
		that2, ok := that.(OpenVINOModelSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InputShape) != len(that1.InputShape) {
		return false
	}
	for i := range this.InputShape {
		if !this.InputShape[i].Equal(that1.InputShape[i]) {
			return false
		}
	}
	return true
}
func (this *OpenVINOModelSpec_TensorShape) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpenVINOModelSpec_TensorShape)
	if !ok {
		that2, ok := that.(OpenVINOModelSpec_TensorShape)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dim) != len(that1.Dim) {
		return false
	}
	for i := range this.Dim {
		if this.Dim[i] != that1.Dim[i] {
			return false
		}
	}
	return true
}
func (this *BoundingBoxInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.BoundingBoxInfo{")
	s = append(s, "BoxFormat: "+fmt.Sprintf("%#v", this.BoxFormat)+",\n")
	s = append(s, "BoxNormalized: "+fmt.Sprintf("%#v", this.BoxNormalized)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagePreprocessingStep) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&corepb.ImagePreprocessingStep{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	if this.ConversionParams != nil {
		s = append(s, "ConversionParams: "+fmt.Sprintf("%#v", this.ConversionParams)+",\n")
	}
	if this.ResizeParams != nil {
		s = append(s, "ResizeParams: "+fmt.Sprintf("%#v", this.ResizeParams)+",\n")
	}
	if this.StandardizeParams != nil {
		s = append(s, "StandardizeParams: "+fmt.Sprintf("%#v", this.StandardizeParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagePreprocessingStep_ImageConversionParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.ImagePreprocessingStep_ImageConversionParams{")
	s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagePreprocessingStep_ImageResizeParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.ImagePreprocessingStep_ImageResizeParams{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImagePreprocessingStep_ImageStandardizeParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ImagePreprocessingStep_ImageStandardizeParams{")
	s = append(s, "Means: "+fmt.Sprintf("%#v", this.Means)+",\n")
	s = append(s, "Stddevs: "+fmt.Sprintf("%#v", this.Stddevs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&corepb.DimensionSemantics{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	if this.ImageChannelParams != nil {
		s = append(s, "ImageChannelParams: "+fmt.Sprintf("%#v", this.ImageChannelParams)+",\n")
	}
	if this.DetectionCandidatesParams != nil {
		s = append(s, "DetectionCandidatesParams: "+fmt.Sprintf("%#v", this.DetectionCandidatesParams)+",\n")
	}
	if this.DetectionOutputParams != nil {
		s = append(s, "DetectionOutputParams: "+fmt.Sprintf("%#v", this.DetectionOutputParams)+",\n")
	}
	if this.SegmentationMaskParams != nil {
		s = append(s, "SegmentationMaskParams: "+fmt.Sprintf("%#v", this.SegmentationMaskParams)+",\n")
	}
	if this.RegressionParams != nil {
		s = append(s, "RegressionParams: "+fmt.Sprintf("%#v", this.RegressionParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_ImageChannelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DimensionSemantics_ImageChannelParams{")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_DetectionCandidatesParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DimensionSemantics_DetectionCandidatesParams{")
	s = append(s, "IsNmsBoxes: "+fmt.Sprintf("%#v", this.IsNmsBoxes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_DetectionOutputParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&corepb.DimensionSemantics_DetectionOutputParams{")
	if this.BoxCoordinateRange != nil {
		s = append(s, "BoxCoordinateRange: "+fmt.Sprintf("%#v", this.BoxCoordinateRange)+",\n")
	}
	if this.BoxFormat != nil {
		s = append(s, "BoxFormat: "+fmt.Sprintf("%#v", this.BoxFormat)+",\n")
	}
	s = append(s, "BoxConfidenceIndex: "+fmt.Sprintf("%#v", this.BoxConfidenceIndex)+",\n")
	s = append(s, "ClassIndex: "+fmt.Sprintf("%#v", this.ClassIndex)+",\n")
	if this.ScoresRange != nil {
		s = append(s, "ScoresRange: "+fmt.Sprintf("%#v", this.ScoresRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_DetectionOutputParams_IndexRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.DimensionSemantics_DetectionOutputParams_IndexRange{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_SegmentationMaskParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.DimensionSemantics_SegmentationMaskParams{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DimensionSemantics_RegressionParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.DimensionSemantics_RegressionParams{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	if this.Scale != nil {
		s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorSemantics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.TensorSemantics{")
	if this.Dimensions != nil {
		s = append(s, "Dimensions: "+fmt.Sprintf("%#v", this.Dimensions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GenerationConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.GenerationConfig{")
	s = append(s, "EosTokenIds: "+fmt.Sprintf("%#v", this.EosTokenIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&corepb.ModelInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	keysForFileAssets := make([]string, 0, len(this.FileAssets))
	for k, _ := range this.FileAssets {
		keysForFileAssets = append(keysForFileAssets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFileAssets)
	mapStringForFileAssets := "map[string]*typespb.UUID{"
	for _, k := range keysForFileAssets {
		mapStringForFileAssets += fmt.Sprintf("%#v: %#v,", k, this.FileAssets[k])
	}
	mapStringForFileAssets += "}"
	if this.FileAssets != nil {
		s = append(s, "FileAssets: "+mapStringForFileAssets+",\n")
	}
	if this.InputTensorSemantics != nil {
		s = append(s, "InputTensorSemantics: "+fmt.Sprintf("%#v", this.InputTensorSemantics)+",\n")
	}
	if this.OutputTensorSemantics != nil {
		s = append(s, "OutputTensorSemantics: "+fmt.Sprintf("%#v", this.OutputTensorSemantics)+",\n")
	}
	s = append(s, "ClassLabels: "+fmt.Sprintf("%#v", this.ClassLabels)+",\n")
	if this.BboxInfo != nil {
		s = append(s, "BboxInfo: "+fmt.Sprintf("%#v", this.BboxInfo)+",\n")
	}
	if this.ImagePreprocessingSteps != nil {
		s = append(s, "ImagePreprocessingSteps: "+fmt.Sprintf("%#v", this.ImagePreprocessingSteps)+",\n")
	}
	if this.GenerationConfig != nil {
		s = append(s, "GenerationConfig: "+fmt.Sprintf("%#v", this.GenerationConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&corepb.Node{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.Inputs != nil {
		s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	}
	if this.Outputs != nil {
		s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ParamRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.ParamRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&corepb.Value{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_StringData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_StringData{` +
		`StringData:` + fmt.Sprintf("%#v", this.StringData) + `}`}, ", ")
	return s
}
func (this *Value_Int64Data) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_Int64Data{` +
		`Int64Data:` + fmt.Sprintf("%#v", this.Int64Data) + `}`}, ", ")
	return s
}
func (this *Value_DoubleData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_DoubleData{` +
		`DoubleData:` + fmt.Sprintf("%#v", this.DoubleData) + `}`}, ", ")
	return s
}
func (this *Value_BoolData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_BoolData{` +
		`BoolData:` + fmt.Sprintf("%#v", this.BoolData) + `}`}, ", ")
	return s
}
func (this *Value_LambdaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_LambdaData{` +
		`LambdaData:` + fmt.Sprintf("%#v", this.LambdaData) + `}`}, ", ")
	return s
}
func (this *Value_ModelData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_ModelData{` +
		`ModelData:` + fmt.Sprintf("%#v", this.ModelData) + `}`}, ", ")
	return s
}
func (this *Value_ParamData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.Value_ParamData{` +
		`ParamData:` + fmt.Sprintf("%#v", this.ParamData) + `}`}, ", ")
	return s
}
func (this *Value_ModelRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.Value_ModelRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Lambda) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.Value_Lambda{")
	s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.NodeAttributes{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&corepb.NodeInput{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput_ParamValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_ParamValue{` +
		`ParamValue:` + fmt.Sprintf("%#v", this.ParamValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_NodeOutputValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_NodeOutputValue{` +
		`NodeOutputValue:` + fmt.Sprintf("%#v", this.NodeOutputValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_LambdaInputValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&corepb.NodeInput_LambdaInputValue{` +
		`LambdaInputValue:` + fmt.Sprintf("%#v", this.LambdaInputValue) + `}`}, ", ")
	return s
}
func (this *NodeInput_NodeOutputRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.NodeInput_NodeOutputRef{")
	s = append(s, "NodeName: "+fmt.Sprintf("%#v", this.NodeName)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInput_LambdaInputRef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.NodeInput_LambdaInputRef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeOutput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.NodeOutput{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Param) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.Param{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.DefaultValue != nil {
		s = append(s, "DefaultValue: "+fmt.Sprintf("%#v", this.DefaultValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogicalPipeline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.LogicalPipeline{")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	if this.ModelIDs != nil {
		s = append(s, "ModelIDs: "+fmt.Sprintf("%#v", this.ModelIDs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeployment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&corepb.PipelineDeployment{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.LogicalPipelineID != nil {
		s = append(s, "LogicalPipelineID: "+fmt.Sprintf("%#v", this.LogicalPipelineID)+",\n")
	}
	if this.FleetID != nil {
		s = append(s, "FleetID: "+fmt.Sprintf("%#v", this.FleetID)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	if this.DeletedAt != nil {
		s = append(s, "DeletedAt: "+fmt.Sprintf("%#v", this.DeletedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeploymentSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.PipelineDeploymentSpec{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PipelineDeploymentStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.PipelineDeploymentStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipeline) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&corepb.PhysicalPipeline{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.PipelineDeploymentID != nil {
		s = append(s, "PipelineDeploymentID: "+fmt.Sprintf("%#v", this.PipelineDeploymentID)+",\n")
	}
	if this.DeviceID != nil {
		s = append(s, "DeviceID: "+fmt.Sprintf("%#v", this.DeviceID)+",\n")
	}
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.UpdatedAt != nil {
		s = append(s, "UpdatedAt: "+fmt.Sprintf("%#v", this.UpdatedAt)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&corepb.PhysicalPipelineSpec{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Graph != nil {
		s = append(s, "Graph: "+fmt.Sprintf("%#v", this.Graph)+",\n")
	}
	s = append(s, "Runtime: "+fmt.Sprintf("%#v", this.Runtime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PhysicalPipelineStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&corepb.PhysicalPipelineStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Runtime: "+fmt.Sprintf("%#v", this.Runtime)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileResource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.FileResource{")
	if this.FileID != nil {
		s = append(s, "FileID: "+fmt.Sprintf("%#v", this.FileID)+",\n")
	}
	s = append(s, "SizeBytes: "+fmt.Sprintf("%#v", this.SizeBytes)+",\n")
	s = append(s, "Sha256Hash: "+fmt.Sprintf("%#v", this.Sha256Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutionSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.ExecutionSpec{")
	if this.Graph != nil {
		s = append(s, "Graph: "+fmt.Sprintf("%#v", this.Graph)+",\n")
	}
	if this.ModelSpec != nil {
		s = append(s, "ModelSpec: "+fmt.Sprintf("%#v", this.ModelSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamedAsset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.NamedAsset{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&corepb.ModelSpec{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ONNXBlobKey: "+fmt.Sprintf("%#v", this.ONNXBlobKey)+",\n")
	if this.ONNXFile != nil {
		s = append(s, "ONNXFile: "+fmt.Sprintf("%#v", this.ONNXFile)+",\n")
	}
	if this.NamedAsset != nil {
		s = append(s, "NamedAsset: "+fmt.Sprintf("%#v", this.NamedAsset)+",\n")
	}
	s = append(s, "Runtime: "+fmt.Sprintf("%#v", this.Runtime)+",\n")
	if this.TensorRTSpec != nil {
		s = append(s, "TensorRTSpec: "+fmt.Sprintf("%#v", this.TensorRTSpec)+",\n")
	}
	if this.OpenVINOSpec != nil {
		s = append(s, "OpenVINOSpec: "+fmt.Sprintf("%#v", this.OpenVINOSpec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&corepb.TensorRTModelSpec{")
	if this.OptimizationProfile != nil {
		s = append(s, "OptimizationProfile: "+fmt.Sprintf("%#v", this.OptimizationProfile)+",\n")
	}
	s = append(s, "EngineBlobKey: "+fmt.Sprintf("%#v", this.EngineBlobKey)+",\n")
	if this.MemPoolLimits != nil {
		s = append(s, "MemPoolLimits: "+fmt.Sprintf("%#v", this.MemPoolLimits)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTOptimizationProfile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.TensorRTOptimizationProfile{")
	if this.TensorShapeRange != nil {
		s = append(s, "TensorShapeRange: "+fmt.Sprintf("%#v", this.TensorShapeRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTTensorShapeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&corepb.TensorRTTensorShapeRange{")
	s = append(s, "TensorName: "+fmt.Sprintf("%#v", this.TensorName)+",\n")
	s = append(s, "Dim: "+fmt.Sprintf("%#v", this.Dim)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorRTMemPoolLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.TensorRTMemPoolLimits{")
	s = append(s, "Workspace: "+fmt.Sprintf("%#v", this.Workspace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenVINOModelSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.OpenVINOModelSpec{")
	if this.InputShape != nil {
		s = append(s, "InputShape: "+fmt.Sprintf("%#v", this.InputShape)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpenVINOModelSpec_TensorShape) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&corepb.OpenVINOModelSpec_TensorShape{")
	s = append(s, "Dim: "+fmt.Sprintf("%#v", this.Dim)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringModelExec(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BoundingBoxInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundingBoxInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoundingBoxInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BoxNormalized {
		i--
		if m.BoxNormalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.BoxFormat != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.BoxFormat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImagePreprocessingStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePreprocessingStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePreprocessingStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StandardizeParams != nil {
		{
			size, err := m.StandardizeParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ResizeParams != nil {
		{
			size, err := m.ResizeParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ConversionParams != nil {
		{
			size, err := m.ConversionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImagePreprocessingStep_ImageConversionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePreprocessingStep_ImageConversionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePreprocessingStep_ImageConversionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scale {
		i--
		if m.Scale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImagePreprocessingStep_ImageResizeParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePreprocessingStep_ImageResizeParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePreprocessingStep_ImageResizeParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stddevs) > 0 {
		for iNdEx := len(m.Stddevs) - 1; iNdEx >= 0; iNdEx-- {
			f4 := math.Float32bits(float32(m.Stddevs[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f4))
		}
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Stddevs)*4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Means) > 0 {
		for iNdEx := len(m.Means) - 1; iNdEx >= 0; iNdEx-- {
			f5 := math.Float32bits(float32(m.Means[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f5))
		}
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Means)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegressionParams != nil {
		{
			size, err := m.RegressionParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SegmentationMaskParams != nil {
		{
			size, err := m.SegmentationMaskParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DetectionOutputParams != nil {
		{
			size, err := m.DetectionOutputParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DetectionCandidatesParams != nil {
		{
			size, err := m.DetectionCandidatesParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImageChannelParams != nil {
		{
			size, err := m.ImageChannelParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_ImageChannelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_ImageChannelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_ImageChannelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Format != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Format))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_DetectionCandidatesParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_DetectionCandidatesParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_DetectionCandidatesParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsNmsBoxes {
		i--
		if m.IsNmsBoxes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_DetectionOutputParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_DetectionOutputParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_DetectionOutputParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScoresRange != nil {
		{
			size, err := m.ScoresRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ClassIndex != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.ClassIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.BoxConfidenceIndex != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.BoxConfidenceIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.BoxFormat != nil {
		{
			size, err := m.BoxFormat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BoxCoordinateRange != nil {
		{
			size, err := m.BoxCoordinateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_SegmentationMaskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_SegmentationMaskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_SegmentationMaskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DimensionSemantics_RegressionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DimensionSemantics_RegressionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DimensionSemantics_RegressionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scale != nil {
		{
			size, err := m.Scale.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorSemantics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorSemantics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorSemantics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		for iNdEx := len(m.Dimensions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dimensions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GenerationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EosTokenIds) > 0 {
		dAtA16 := make([]byte, len(m.EosTokenIds)*10)
		var j15 int
		for _, num1 := range m.EosTokenIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintModelExec(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GenerationConfig != nil {
		{
			size, err := m.GenerationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if len(m.ImagePreprocessingSteps) > 0 {
		for iNdEx := len(m.ImagePreprocessingSteps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ImagePreprocessingSteps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.BboxInfo != nil {
		{
			size, err := m.BboxInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ClassLabels) > 0 {
		for iNdEx := len(m.ClassLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClassLabels[iNdEx])
			copy(dAtA[i:], m.ClassLabels[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.ClassLabels[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.OutputTensorSemantics) > 0 {
		for iNdEx := len(m.OutputTensorSemantics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutputTensorSemantics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.InputTensorSemantics) > 0 {
		for iNdEx := len(m.InputTensorSemantics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputTensorSemantics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FileAssets) > 0 {
		for k := range m.FileAssets {
			v := m.FileAssets[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintModelExec(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModelExec(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModelExec(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Format != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Format))
		i--
		dAtA[i] = 0x18
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Kind != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_StringData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_StringData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringData)
	copy(dAtA[i:], m.StringData)
	i = encodeVarintModelExec(dAtA, i, uint64(len(m.StringData)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Value_Int64Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int64Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintModelExec(dAtA, i, uint64(m.Int64Data))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Value_DoubleData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DoubleData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleData))))
	i--
	dAtA[i] = 0x19
	return len(dAtA) - i, nil
}
func (m *Value_BoolData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BoolData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolData {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_LambdaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_LambdaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LambdaData != nil {
		{
			size, err := m.LambdaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Value_ModelData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ModelData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ModelData != nil {
		{
			size, err := m.ModelData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Value_ParamData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ParamData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamData != nil {
		{
			size, err := m.ParamData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Value_ModelRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_ModelRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ModelRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value_Lambda) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Lambda) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Lambda) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Outputs[iNdEx])
			copy(dAtA[i:], m.Outputs[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.Outputs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Inputs[iNdEx])
			copy(dAtA[i:], m.Inputs[iNdEx])
			i = encodeVarintModelExec(dAtA, i, uint64(len(m.Inputs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput_ParamValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_ParamValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamValue != nil {
		{
			size, err := m.ParamValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_NodeOutputValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_NodeOutputValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeOutputValue != nil {
		{
			size, err := m.NodeOutputValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_LambdaInputValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_LambdaInputValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LambdaInputValue != nil {
		{
			size, err := m.LambdaInputValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NodeInput_NodeOutputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput_NodeOutputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_NodeOutputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInput_LambdaInputRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInput_LambdaInputRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInput_LambdaInputRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultValue != nil {
		{
			size, err := m.DefaultValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogicalPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelIDs) > 0 {
		for iNdEx := len(m.ModelIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModelIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Version != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x30
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FleetID != nil {
		{
			size, err := m.FleetID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LogicalPipelineID != nil {
		{
			size, err := m.LogicalPipelineID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeploymentSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeploymentSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeploymentSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PipelineDeploymentStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineDeploymentStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineDeploymentStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdatedAt != nil {
		{
			size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeviceID != nil {
		{
			size, err := m.DeviceID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineDeploymentID != nil {
		{
			size, err := m.PipelineDeploymentID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ID != nil {
		{
			size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0x22
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhysicalPipelineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalPipelineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhysicalPipelineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sha256Hash) > 0 {
		i -= len(m.Sha256Hash)
		copy(dAtA[i:], m.Sha256Hash)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Sha256Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.FileID != nil {
		{
			size, err := m.FileID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelSpec) > 0 {
		for iNdEx := len(m.ModelSpec) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModelSpec[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Graph != nil {
		{
			size, err := m.Graph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamedAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenVINOSpec != nil {
		{
			size, err := m.OpenVINOSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.TensorRTSpec != nil {
		{
			size, err := m.TensorRTSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.NamedAsset) > 0 {
		for iNdEx := len(m.NamedAsset) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamedAsset[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ONNXFile != nil {
		{
			size, err := m.ONNXFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ONNXBlobKey) > 0 {
		i -= len(m.ONNXBlobKey)
		copy(dAtA[i:], m.ONNXBlobKey)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.ONNXBlobKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemPoolLimits != nil {
		{
			size, err := m.MemPoolLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModelExec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EngineBlobKey) > 0 {
		i -= len(m.EngineBlobKey)
		copy(dAtA[i:], m.EngineBlobKey)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.EngineBlobKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OptimizationProfile) > 0 {
		for iNdEx := len(m.OptimizationProfile) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OptimizationProfile[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTOptimizationProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTOptimizationProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTOptimizationProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TensorShapeRange) > 0 {
		for iNdEx := len(m.TensorShapeRange) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TensorShapeRange[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTTensorShapeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTTensorShapeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTTensorShapeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		dAtA53 := make([]byte, len(m.Dim)*10)
		var j52 int
		for _, num1 := range m.Dim {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintModelExec(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TensorName) > 0 {
		i -= len(m.TensorName)
		copy(dAtA[i:], m.TensorName)
		i = encodeVarintModelExec(dAtA, i, uint64(len(m.TensorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TensorRTMemPoolLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorRTMemPoolLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorRTMemPoolLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Workspace != 0 {
		i = encodeVarintModelExec(dAtA, i, uint64(m.Workspace))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenVINOModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenVINOModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenVINOModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputShape) > 0 {
		for iNdEx := len(m.InputShape) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputShape[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModelExec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpenVINOModelSpec_TensorShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenVINOModelSpec_TensorShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenVINOModelSpec_TensorShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		dAtA55 := make([]byte, len(m.Dim)*10)
		var j54 int
		for _, num1 := range m.Dim {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		i -= j54
		copy(dAtA[i:], dAtA55[:j54])
		i = encodeVarintModelExec(dAtA, i, uint64(j54))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModelExec(dAtA []byte, offset int, v uint64) int {
	offset -= sovModelExec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BoundingBoxInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoxFormat != 0 {
		n += 1 + sovModelExec(uint64(m.BoxFormat))
	}
	if m.BoxNormalized {
		n += 2
	}
	return n
}

func (m *ImagePreprocessingStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if m.ConversionParams != nil {
		l = m.ConversionParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.ResizeParams != nil {
		l = m.ResizeParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.StandardizeParams != nil {
		l = m.StandardizeParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *ImagePreprocessingStep_ImageConversionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scale {
		n += 2
	}
	return n
}

func (m *ImagePreprocessingStep_ImageResizeParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	return n
}

func (m *ImagePreprocessingStep_ImageStandardizeParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Means) > 0 {
		n += 1 + sovModelExec(uint64(len(m.Means)*4)) + len(m.Means)*4
	}
	if len(m.Stddevs) > 0 {
		n += 1 + sovModelExec(uint64(len(m.Stddevs)*4)) + len(m.Stddevs)*4
	}
	return n
}

func (m *DimensionSemantics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if m.ImageChannelParams != nil {
		l = m.ImageChannelParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DetectionCandidatesParams != nil {
		l = m.DetectionCandidatesParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DetectionOutputParams != nil {
		l = m.DetectionOutputParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.SegmentationMaskParams != nil {
		l = m.SegmentationMaskParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.RegressionParams != nil {
		l = m.RegressionParams.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *DimensionSemantics_ImageChannelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Format != 0 {
		n += 1 + sovModelExec(uint64(m.Format))
	}
	return n
}

func (m *DimensionSemantics_DetectionCandidatesParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsNmsBoxes {
		n += 2
	}
	return n
}

func (m *DimensionSemantics_DetectionOutputParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoxCoordinateRange != nil {
		l = m.BoxCoordinateRange.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.BoxFormat != nil {
		l = m.BoxFormat.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.BoxConfidenceIndex != 0 {
		n += 1 + sovModelExec(uint64(m.BoxConfidenceIndex))
	}
	if m.ClassIndex != 0 {
		n += 1 + sovModelExec(uint64(m.ClassIndex))
	}
	if m.ScoresRange != nil {
		l = m.ScoresRange.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *DimensionSemantics_DetectionOutputParams_IndexRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovModelExec(uint64(m.Start))
	}
	if m.Size_ != 0 {
		n += 1 + sovModelExec(uint64(m.Size_))
	}
	return n
}

func (m *DimensionSemantics_SegmentationMaskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	return n
}

func (m *DimensionSemantics_RegressionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Scale != nil {
		l = m.Scale.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *TensorSemantics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dimensions) > 0 {
		for _, e := range m.Dimensions {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *GenerationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EosTokenIds) > 0 {
		l = 0
		for _, e := range m.EosTokenIds {
			l += sovModelExec(uint64(e))
		}
		n += 1 + sovModelExec(uint64(l)) + l
	}
	return n
}

func (m *ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if m.Format != 0 {
		n += 1 + sovModelExec(uint64(m.Format))
	}
	if len(m.FileAssets) > 0 {
		for k, v := range m.FileAssets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModelExec(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModelExec(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModelExec(uint64(mapEntrySize))
		}
	}
	if len(m.InputTensorSemantics) > 0 {
		for _, e := range m.InputTensorSemantics {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.OutputTensorSemantics) > 0 {
		for _, e := range m.OutputTensorSemantics {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.ClassLabels) > 0 {
		for _, s := range m.ClassLabels {
			l = len(s)
			n += 2 + l + sovModelExec(uint64(l))
		}
	}
	if m.BboxInfo != nil {
		l = m.BboxInfo.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	if len(m.ImagePreprocessingSteps) > 0 {
		for _, e := range m.ImagePreprocessingSteps {
			l = e.Size()
			n += 2 + l + sovModelExec(uint64(l))
		}
	}
	if m.GenerationConfig != nil {
		l = m.GenerationConfig.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovModelExec(uint64(m.Kind))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *ParamRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *Value_StringData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringData)
	n += 1 + l + sovModelExec(uint64(l))
	return n
}
func (m *Value_Int64Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovModelExec(uint64(m.Int64Data))
	return n
}
func (m *Value_DoubleData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_BoolData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_LambdaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LambdaData != nil {
		l = m.LambdaData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ModelData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelData != nil {
		l = m.ModelData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ParamData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamData != nil {
		l = m.ParamData.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *Value_ModelRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Value_Lambda) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Inputs) > 0 {
		for _, s := range m.Inputs {
			l = len(s)
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, s := range m.Outputs {
			l = len(s)
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *NodeAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *NodeInput_ParamValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamValue != nil {
		l = m.ParamValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_NodeOutputValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeOutputValue != nil {
		l = m.NodeOutputValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_LambdaInputValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LambdaInputValue != nil {
		l = m.LambdaInputValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}
func (m *NodeInput_NodeOutputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeInput_LambdaInputRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *NodeOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *LogicalPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	if len(m.ModelIDs) > 0 {
		for _, e := range m.ModelIDs {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *PipelineDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.LogicalPipelineID != nil {
		l = m.LogicalPipelineID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.FleetID != nil {
		l = m.FleetID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovModelExec(uint64(m.Version))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PipelineDeploymentSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	return n
}

func (m *PipelineDeploymentStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PhysicalPipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.PipelineDeploymentID != nil {
		l = m.PipelineDeploymentID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.DeviceID != nil {
		l = m.DeviceID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PhysicalPipelineSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovModelExec(uint64(m.Version))
	}
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *PhysicalPipelineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovModelExec(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovModelExec(uint64(m.Version))
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *FileResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileID != nil {
		l = m.FileID.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovModelExec(uint64(m.SizeBytes))
	}
	l = len(m.Sha256Hash)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *ExecutionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.ModelSpec) > 0 {
		for _, e := range m.ModelSpec {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *NamedAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	l = len(m.ONNXBlobKey)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.ONNXFile != nil {
		l = m.ONNXFile.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.NamedAsset) > 0 {
		for _, e := range m.NamedAsset {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 2 + l + sovModelExec(uint64(l))
	}
	if m.TensorRTSpec != nil {
		l = m.TensorRTSpec.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	if m.OpenVINOSpec != nil {
		l = m.OpenVINOSpec.Size()
		n += 2 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *TensorRTModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OptimizationProfile) > 0 {
		for _, e := range m.OptimizationProfile {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	l = len(m.EngineBlobKey)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if m.MemPoolLimits != nil {
		l = m.MemPoolLimits.Size()
		n += 1 + l + sovModelExec(uint64(l))
	}
	return n
}

func (m *TensorRTOptimizationProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TensorShapeRange) > 0 {
		for _, e := range m.TensorShapeRange {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *TensorRTTensorShapeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TensorName)
	if l > 0 {
		n += 1 + l + sovModelExec(uint64(l))
	}
	if len(m.Dim) > 0 {
		l = 0
		for _, e := range m.Dim {
			l += sovModelExec(uint64(e))
		}
		n += 1 + sovModelExec(uint64(l)) + l
	}
	return n
}

func (m *TensorRTMemPoolLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workspace != 0 {
		n += 1 + sovModelExec(uint64(m.Workspace))
	}
	return n
}

func (m *OpenVINOModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InputShape) > 0 {
		for _, e := range m.InputShape {
			l = e.Size()
			n += 1 + l + sovModelExec(uint64(l))
		}
	}
	return n
}

func (m *OpenVINOModelSpec_TensorShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dim) > 0 {
		l = 0
		for _, e := range m.Dim {
			l += sovModelExec(uint64(e))
		}
		n += 1 + sovModelExec(uint64(l)) + l
	}
	return n
}

func sovModelExec(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModelExec(x uint64) (n int) {
	return sovModelExec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BoundingBoxInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoundingBoxInfo{`,
		`BoxFormat:` + fmt.Sprintf("%v", this.BoxFormat) + `,`,
		`BoxNormalized:` + fmt.Sprintf("%v", this.BoxNormalized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePreprocessingStep) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePreprocessingStep{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`ConversionParams:` + strings.Replace(fmt.Sprintf("%v", this.ConversionParams), "ImagePreprocessingStep_ImageConversionParams", "ImagePreprocessingStep_ImageConversionParams", 1) + `,`,
		`ResizeParams:` + strings.Replace(fmt.Sprintf("%v", this.ResizeParams), "ImagePreprocessingStep_ImageResizeParams", "ImagePreprocessingStep_ImageResizeParams", 1) + `,`,
		`StandardizeParams:` + strings.Replace(fmt.Sprintf("%v", this.StandardizeParams), "ImagePreprocessingStep_ImageStandardizeParams", "ImagePreprocessingStep_ImageStandardizeParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePreprocessingStep_ImageConversionParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePreprocessingStep_ImageConversionParams{`,
		`Scale:` + fmt.Sprintf("%v", this.Scale) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePreprocessingStep_ImageResizeParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePreprocessingStep_ImageResizeParams{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImagePreprocessingStep_ImageStandardizeParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImagePreprocessingStep_ImageStandardizeParams{`,
		`Means:` + fmt.Sprintf("%v", this.Means) + `,`,
		`Stddevs:` + fmt.Sprintf("%v", this.Stddevs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`ImageChannelParams:` + strings.Replace(fmt.Sprintf("%v", this.ImageChannelParams), "DimensionSemantics_ImageChannelParams", "DimensionSemantics_ImageChannelParams", 1) + `,`,
		`DetectionCandidatesParams:` + strings.Replace(fmt.Sprintf("%v", this.DetectionCandidatesParams), "DimensionSemantics_DetectionCandidatesParams", "DimensionSemantics_DetectionCandidatesParams", 1) + `,`,
		`DetectionOutputParams:` + strings.Replace(fmt.Sprintf("%v", this.DetectionOutputParams), "DimensionSemantics_DetectionOutputParams", "DimensionSemantics_DetectionOutputParams", 1) + `,`,
		`SegmentationMaskParams:` + strings.Replace(fmt.Sprintf("%v", this.SegmentationMaskParams), "DimensionSemantics_SegmentationMaskParams", "DimensionSemantics_SegmentationMaskParams", 1) + `,`,
		`RegressionParams:` + strings.Replace(fmt.Sprintf("%v", this.RegressionParams), "DimensionSemantics_RegressionParams", "DimensionSemantics_RegressionParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_ImageChannelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_ImageChannelParams{`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_DetectionCandidatesParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_DetectionCandidatesParams{`,
		`IsNmsBoxes:` + fmt.Sprintf("%v", this.IsNmsBoxes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_DetectionOutputParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_DetectionOutputParams{`,
		`BoxCoordinateRange:` + strings.Replace(fmt.Sprintf("%v", this.BoxCoordinateRange), "DimensionSemantics_DetectionOutputParams_IndexRange", "DimensionSemantics_DetectionOutputParams_IndexRange", 1) + `,`,
		`BoxFormat:` + strings.Replace(this.BoxFormat.String(), "BoundingBoxInfo", "BoundingBoxInfo", 1) + `,`,
		`BoxConfidenceIndex:` + fmt.Sprintf("%v", this.BoxConfidenceIndex) + `,`,
		`ClassIndex:` + fmt.Sprintf("%v", this.ClassIndex) + `,`,
		`ScoresRange:` + strings.Replace(fmt.Sprintf("%v", this.ScoresRange), "DimensionSemantics_DetectionOutputParams_IndexRange", "DimensionSemantics_DetectionOutputParams_IndexRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_DetectionOutputParams_IndexRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_DetectionOutputParams_IndexRange{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_SegmentationMaskParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_SegmentationMaskParams{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DimensionSemantics_RegressionParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DimensionSemantics_RegressionParams{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Scale:` + strings.Replace(fmt.Sprintf("%v", this.Scale), "DoubleValue", "types.DoubleValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorSemantics) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDimensions := "[]*DimensionSemantics{"
	for _, f := range this.Dimensions {
		repeatedStringForDimensions += strings.Replace(f.String(), "DimensionSemantics", "DimensionSemantics", 1) + ","
	}
	repeatedStringForDimensions += "}"
	s := strings.Join([]string{`&TensorSemantics{`,
		`Dimensions:` + repeatedStringForDimensions + `,`,
		`}`,
	}, "")
	return s
}
func (this *GenerationConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GenerationConfig{`,
		`EosTokenIds:` + fmt.Sprintf("%v", this.EosTokenIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInputTensorSemantics := "[]*TensorSemantics{"
	for _, f := range this.InputTensorSemantics {
		repeatedStringForInputTensorSemantics += strings.Replace(f.String(), "TensorSemantics", "TensorSemantics", 1) + ","
	}
	repeatedStringForInputTensorSemantics += "}"
	repeatedStringForOutputTensorSemantics := "[]*TensorSemantics{"
	for _, f := range this.OutputTensorSemantics {
		repeatedStringForOutputTensorSemantics += strings.Replace(f.String(), "TensorSemantics", "TensorSemantics", 1) + ","
	}
	repeatedStringForOutputTensorSemantics += "}"
	repeatedStringForImagePreprocessingSteps := "[]*ImagePreprocessingStep{"
	for _, f := range this.ImagePreprocessingSteps {
		repeatedStringForImagePreprocessingSteps += strings.Replace(f.String(), "ImagePreprocessingStep", "ImagePreprocessingStep", 1) + ","
	}
	repeatedStringForImagePreprocessingSteps += "}"
	keysForFileAssets := make([]string, 0, len(this.FileAssets))
	for k, _ := range this.FileAssets {
		keysForFileAssets = append(keysForFileAssets, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFileAssets)
	mapStringForFileAssets := "map[string]*typespb.UUID{"
	for _, k := range keysForFileAssets {
		mapStringForFileAssets += fmt.Sprintf("%v: %v,", k, this.FileAssets[k])
	}
	mapStringForFileAssets += "}"
	s := strings.Join([]string{`&ModelInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`FileAssets:` + mapStringForFileAssets + `,`,
		`InputTensorSemantics:` + repeatedStringForInputTensorSemantics + `,`,
		`OutputTensorSemantics:` + repeatedStringForOutputTensorSemantics + `,`,
		`ClassLabels:` + fmt.Sprintf("%v", this.ClassLabels) + `,`,
		`BboxInfo:` + strings.Replace(this.BboxInfo.String(), "BoundingBoxInfo", "BoundingBoxInfo", 1) + `,`,
		`ImagePreprocessingSteps:` + repeatedStringForImagePreprocessingSteps + `,`,
		`GenerationConfig:` + strings.Replace(this.GenerationConfig.String(), "GenerationConfig", "GenerationConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttributes := "[]*NodeAttributes{"
	for _, f := range this.Attributes {
		repeatedStringForAttributes += strings.Replace(f.String(), "NodeAttributes", "NodeAttributes", 1) + ","
	}
	repeatedStringForAttributes += "}"
	repeatedStringForInputs := "[]*NodeInput{"
	for _, f := range this.Inputs {
		repeatedStringForInputs += strings.Replace(f.String(), "NodeInput", "NodeInput", 1) + ","
	}
	repeatedStringForInputs += "}"
	repeatedStringForOutputs := "[]*NodeOutput{"
	for _, f := range this.Outputs {
		repeatedStringForOutputs += strings.Replace(f.String(), "NodeOutput", "NodeOutput", 1) + ","
	}
	repeatedStringForOutputs += "}"
	s := strings.Join([]string{`&Node{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Attributes:` + repeatedStringForAttributes + `,`,
		`Inputs:` + repeatedStringForInputs + `,`,
		`Outputs:` + repeatedStringForOutputs + `,`,
		`}`,
	}, "")
	return s
}
func (this *ParamRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ParamRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_StringData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_StringData{`,
		`StringData:` + fmt.Sprintf("%v", this.StringData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Int64Data) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Int64Data{`,
		`Int64Data:` + fmt.Sprintf("%v", this.Int64Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_DoubleData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_DoubleData{`,
		`DoubleData:` + fmt.Sprintf("%v", this.DoubleData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_BoolData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_BoolData{`,
		`BoolData:` + fmt.Sprintf("%v", this.BoolData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_LambdaData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_LambdaData{`,
		`LambdaData:` + strings.Replace(fmt.Sprintf("%v", this.LambdaData), "Value_Lambda", "Value_Lambda", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ModelData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ModelData{`,
		`ModelData:` + strings.Replace(fmt.Sprintf("%v", this.ModelData), "Value_ModelRef", "Value_ModelRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ParamData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ParamData{`,
		`ParamData:` + strings.Replace(fmt.Sprintf("%v", this.ParamData), "ParamRef", "ParamRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_ModelRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_ModelRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "typespb.UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Lambda) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	s := strings.Join([]string{`&Value_Lambda{`,
		`Inputs:` + fmt.Sprintf("%v", this.Inputs) + `,`,
		`Outputs:` + fmt.Sprintf("%v", this.Outputs) + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeAttributes{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + strings.Replace(this.Value.String(), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_ParamValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_ParamValue{`,
		`ParamValue:` + strings.Replace(fmt.Sprintf("%v", this.ParamValue), "ParamRef", "ParamRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_NodeOutputValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_NodeOutputValue{`,
		`NodeOutputValue:` + strings.Replace(fmt.Sprintf("%v", this.NodeOutputValue), "NodeInput_NodeOutputRef", "NodeInput_NodeOutputRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_LambdaInputValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_LambdaInputValue{`,
		`LambdaInputValue:` + strings.Replace(fmt.Sprintf("%v", this.LambdaInputValue), "NodeInput_LambdaInputRef", "NodeInput_LambdaInputRef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_NodeOutputRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_NodeOutputRef{`,
		`NodeName:` + fmt.Sprintf("%v", this.NodeName) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInput_LambdaInputRef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInput_LambdaInputRef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeOutput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeOutput{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Param) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Param{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DefaultValue:` + strings.Replace(this.DefaultValue.String(), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogicalPipeline) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParams := "[]*Param{"
	for _, f := range this.Params {
		repeatedStringForParams += strings.Replace(f.String(), "Param", "Param", 1) + ","
	}
	repeatedStringForParams += "}"
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForModelIDs := "[]*UUID{"
	for _, f := range this.ModelIDs {
		repeatedStringForModelIDs += strings.Replace(fmt.Sprintf("%v", f), "UUID", "typespb.UUID", 1) + ","
	}
	repeatedStringForModelIDs += "}"
	s := strings.Join([]string{`&LogicalPipeline{`,
		`Params:` + repeatedStringForParams + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`ModelIDs:` + repeatedStringForModelIDs + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeployment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeployment{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "typespb.UUID", 1) + `,`,
		`LogicalPipelineID:` + strings.Replace(fmt.Sprintf("%v", this.LogicalPipelineID), "UUID", "typespb.UUID", 1) + `,`,
		`FleetID:` + strings.Replace(fmt.Sprintf("%v", this.FleetID), "UUID", "typespb.UUID", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "PipelineDeploymentSpec", "PipelineDeploymentSpec", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "PipelineDeploymentStatus", "PipelineDeploymentStatus", 1) + `,`,
		`DeletedAt:` + strings.Replace(fmt.Sprintf("%v", this.DeletedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeploymentSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeploymentSpec{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PipelineDeploymentStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PipelineDeploymentStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipeline) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipeline{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "UUID", "typespb.UUID", 1) + `,`,
		`PipelineDeploymentID:` + strings.Replace(fmt.Sprintf("%v", this.PipelineDeploymentID), "UUID", "typespb.UUID", 1) + `,`,
		`DeviceID:` + strings.Replace(fmt.Sprintf("%v", this.DeviceID), "UUID", "typespb.UUID", 1) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`UpdatedAt:` + strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Spec:` + strings.Replace(this.Spec.String(), "PhysicalPipelineSpec", "PhysicalPipelineSpec", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "PhysicalPipelineStatus", "PhysicalPipelineStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineSpec{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Graph:` + strings.Replace(this.Graph.String(), "ExecutionSpec", "ExecutionSpec", 1) + `,`,
		`Runtime:` + fmt.Sprintf("%v", this.Runtime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PhysicalPipelineStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PhysicalPipelineStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Runtime:` + fmt.Sprintf("%v", this.Runtime) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileResource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileResource{`,
		`FileID:` + strings.Replace(fmt.Sprintf("%v", this.FileID), "UUID", "typespb.UUID", 1) + `,`,
		`SizeBytes:` + fmt.Sprintf("%v", this.SizeBytes) + `,`,
		`Sha256Hash:` + fmt.Sprintf("%v", this.Sha256Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutionSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModelSpec := "[]*ModelSpec{"
	for _, f := range this.ModelSpec {
		repeatedStringForModelSpec += strings.Replace(f.String(), "ModelSpec", "ModelSpec", 1) + ","
	}
	repeatedStringForModelSpec += "}"
	s := strings.Join([]string{`&ExecutionSpec{`,
		`Graph:` + strings.Replace(fmt.Sprintf("%v", this.Graph), "CalculatorGraphConfig", "framework.CalculatorGraphConfig", 1) + `,`,
		`ModelSpec:` + repeatedStringForModelSpec + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamedAsset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamedAsset{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`File:` + strings.Replace(this.File.String(), "FileResource", "FileResource", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamedAsset := "[]*NamedAsset{"
	for _, f := range this.NamedAsset {
		repeatedStringForNamedAsset += strings.Replace(f.String(), "NamedAsset", "NamedAsset", 1) + ","
	}
	repeatedStringForNamedAsset += "}"
	s := strings.Join([]string{`&ModelSpec{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ONNXBlobKey:` + fmt.Sprintf("%v", this.ONNXBlobKey) + `,`,
		`ONNXFile:` + strings.Replace(this.ONNXFile.String(), "FileResource", "FileResource", 1) + `,`,
		`NamedAsset:` + repeatedStringForNamedAsset + `,`,
		`Runtime:` + fmt.Sprintf("%v", this.Runtime) + `,`,
		`TensorRTSpec:` + strings.Replace(this.TensorRTSpec.String(), "TensorRTModelSpec", "TensorRTModelSpec", 1) + `,`,
		`OpenVINOSpec:` + strings.Replace(this.OpenVINOSpec.String(), "OpenVINOModelSpec", "OpenVINOModelSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOptimizationProfile := "[]*TensorRTOptimizationProfile{"
	for _, f := range this.OptimizationProfile {
		repeatedStringForOptimizationProfile += strings.Replace(f.String(), "TensorRTOptimizationProfile", "TensorRTOptimizationProfile", 1) + ","
	}
	repeatedStringForOptimizationProfile += "}"
	s := strings.Join([]string{`&TensorRTModelSpec{`,
		`OptimizationProfile:` + repeatedStringForOptimizationProfile + `,`,
		`EngineBlobKey:` + fmt.Sprintf("%v", this.EngineBlobKey) + `,`,
		`MemPoolLimits:` + strings.Replace(this.MemPoolLimits.String(), "TensorRTMemPoolLimits", "TensorRTMemPoolLimits", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTOptimizationProfile) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTensorShapeRange := "[]*TensorRTTensorShapeRange{"
	for _, f := range this.TensorShapeRange {
		repeatedStringForTensorShapeRange += strings.Replace(f.String(), "TensorRTTensorShapeRange", "TensorRTTensorShapeRange", 1) + ","
	}
	repeatedStringForTensorShapeRange += "}"
	s := strings.Join([]string{`&TensorRTOptimizationProfile{`,
		`TensorShapeRange:` + repeatedStringForTensorShapeRange + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTTensorShapeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorRTTensorShapeRange{`,
		`TensorName:` + fmt.Sprintf("%v", this.TensorName) + `,`,
		`Dim:` + fmt.Sprintf("%v", this.Dim) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorRTMemPoolLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorRTMemPoolLimits{`,
		`Workspace:` + fmt.Sprintf("%v", this.Workspace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenVINOModelSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInputShape := "[]*OpenVINOModelSpec_TensorShape{"
	for _, f := range this.InputShape {
		repeatedStringForInputShape += strings.Replace(fmt.Sprintf("%v", f), "OpenVINOModelSpec_TensorShape", "OpenVINOModelSpec_TensorShape", 1) + ","
	}
	repeatedStringForInputShape += "}"
	s := strings.Join([]string{`&OpenVINOModelSpec{`,
		`InputShape:` + repeatedStringForInputShape + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenVINOModelSpec_TensorShape) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenVINOModelSpec_TensorShape{`,
		`Dim:` + fmt.Sprintf("%v", this.Dim) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringModelExec(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BoundingBoxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundingBoxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundingBoxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxFormat", wireType)
			}
			m.BoxFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoxFormat |= BoundingBoxInfo_BoundingBoxFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxNormalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoxNormalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePreprocessingStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePreprocessingStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePreprocessingStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ImagePreprocessingStep_ImagePreprocessingKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConversionParams == nil {
				m.ConversionParams = &ImagePreprocessingStep_ImageConversionParams{}
			}
			if err := m.ConversionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResizeParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResizeParams == nil {
				m.ResizeParams = &ImagePreprocessingStep_ImageResizeParams{}
			}
			if err := m.ResizeParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardizeParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StandardizeParams == nil {
				m.StandardizeParams = &ImagePreprocessingStep_ImageStandardizeParams{}
			}
			if err := m.StandardizeParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePreprocessingStep_ImageConversionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageConversionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageConversionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scale = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePreprocessingStep_ImageResizeParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageResizeParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageResizeParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ImagePreprocessingStep_ImageResizeParams_ImageResizeKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePreprocessingStep_ImageStandardizeParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageStandardizeParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageStandardizeParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Means = append(m.Means, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Means) == 0 {
					m.Means = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Means = append(m.Means, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Means", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Stddevs = append(m.Stddevs, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Stddevs) == 0 {
					m.Stddevs = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Stddevs = append(m.Stddevs, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stddevs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DimensionSemantics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DimensionSemantics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= DimensionSemantics_DimensionSemanticsKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageChannelParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageChannelParams == nil {
				m.ImageChannelParams = &DimensionSemantics_ImageChannelParams{}
			}
			if err := m.ImageChannelParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionCandidatesParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionCandidatesParams == nil {
				m.DetectionCandidatesParams = &DimensionSemantics_DetectionCandidatesParams{}
			}
			if err := m.DetectionCandidatesParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionOutputParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectionOutputParams == nil {
				m.DetectionOutputParams = &DimensionSemantics_DetectionOutputParams{}
			}
			if err := m.DetectionOutputParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationMaskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentationMaskParams == nil {
				m.SegmentationMaskParams = &DimensionSemantics_SegmentationMaskParams{}
			}
			if err := m.SegmentationMaskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegressionParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegressionParams == nil {
				m.RegressionParams = &DimensionSemantics_RegressionParams{}
			}
			if err := m.RegressionParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_ImageChannelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageChannelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageChannelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= DimensionSemantics_ImageChannelParams_ImageChannelFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_DetectionCandidatesParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectionCandidatesParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectionCandidatesParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNmsBoxes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNmsBoxes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_DetectionOutputParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectionOutputParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectionOutputParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxCoordinateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoxCoordinateRange == nil {
				m.BoxCoordinateRange = &DimensionSemantics_DetectionOutputParams_IndexRange{}
			}
			if err := m.BoxCoordinateRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxFormat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoxFormat == nil {
				m.BoxFormat = &BoundingBoxInfo{}
			}
			if err := m.BoxFormat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxConfidenceIndex", wireType)
			}
			m.BoxConfidenceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoxConfidenceIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassIndex", wireType)
			}
			m.ClassIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoresRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScoresRange == nil {
				m.ScoresRange = &DimensionSemantics_DetectionOutputParams_IndexRange{}
			}
			if err := m.ScoresRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_DetectionOutputParams_IndexRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_SegmentationMaskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentationMaskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentationMaskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= DimensionSemantics_SegmentationMaskParams_SegmentationMaskKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DimensionSemantics_RegressionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegressionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegressionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scale == nil {
				m.Scale = &types.DoubleValue{}
			}
			if err := m.Scale.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorSemantics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorSemantics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorSemantics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dimensions = append(m.Dimensions, &DimensionSemantics{})
			if err := m.Dimensions[len(m.Dimensions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EosTokenIds = append(m.EosTokenIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EosTokenIds) == 0 {
					m.EosTokenIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EosTokenIds = append(m.EosTokenIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EosTokenIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ModelInfo_ModelKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= ModelInfo_ModelStorageFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileAssets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileAssets == nil {
				m.FileAssets = make(map[string]*typespb.UUID)
			}
			var mapkey string
			var mapvalue *typespb.UUID
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModelExec
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModelExec
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthModelExec
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &typespb.UUID{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModelExec(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthModelExec
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FileAssets[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputTensorSemantics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputTensorSemantics = append(m.InputTensorSemantics, &TensorSemantics{})
			if err := m.InputTensorSemantics[len(m.InputTensorSemantics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputTensorSemantics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputTensorSemantics = append(m.OutputTensorSemantics, &TensorSemantics{})
			if err := m.OutputTensorSemantics[len(m.OutputTensorSemantics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassLabels = append(m.ClassLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BboxInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BboxInfo == nil {
				m.BboxInfo = &BoundingBoxInfo{}
			}
			if err := m.BboxInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePreprocessingSteps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePreprocessingSteps = append(m.ImagePreprocessingSteps, &ImagePreprocessingStep{})
			if err := m.ImagePreprocessingSteps[len(m.ImagePreprocessingSteps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenerationConfig == nil {
				m.GenerationConfig = &GenerationConfig{}
			}
			if err := m.GenerationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= LogicalPipelineNodeKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &NodeAttributes{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &NodeInput{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &NodeOutput{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Value_StringData{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Data", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = &Value_Int64Data{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Data = &Value_DoubleData{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Data = &Value_BoolData{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Value_Lambda{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_LambdaData{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Value_ModelRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_ModelData{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Value_ParamData{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_ModelRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &typespb.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Lambda) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lambda: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lambda: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_ParamValue{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOutputValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeInput_NodeOutputRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_NodeOutputValue{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LambdaInputValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeInput_LambdaInputRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &NodeInput_LambdaInputValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput_NodeOutputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeOutputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeOutputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInput_LambdaInputRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LambdaInputRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LambdaInputRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &Value{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Param{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelIDs = append(m.ModelIDs, &typespb.UUID{})
			if err := m.ModelIDs[len(m.ModelIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &typespb.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalPipelineID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogicalPipelineID == nil {
				m.LogicalPipelineID = &typespb.UUID{}
			}
			if err := m.LogicalPipelineID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FleetID == nil {
				m.FleetID = &typespb.UUID{}
			}
			if err := m.FleetID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PipelineDeploymentSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PipelineDeploymentStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeploymentSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeploymentSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeploymentSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineDeploymentStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineDeploymentStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineDeploymentStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &typespb.UUID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineDeploymentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PipelineDeploymentID == nil {
				m.PipelineDeploymentID = &typespb.UUID{}
			}
			if err := m.PipelineDeploymentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceID == nil {
				m.DeviceID = &typespb.UUID{}
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PhysicalPipelineSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PhysicalPipelineStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &ExecutionSpec{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalPipelineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalPipelineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalPipelineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileID == nil {
				m.FileID = &typespb.UUID{}
			}
			if err := m.FileID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &framework.CalculatorGraphConfig{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelSpec = append(m.ModelSpec, &ModelSpec{})
			if err := m.ModelSpec[len(m.ModelSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &FileResource{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ONNXBlobKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ONNXBlobKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ONNXFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ONNXFile == nil {
				m.ONNXFile = &FileResource{}
			}
			if err := m.ONNXFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamedAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamedAsset = append(m.NamedAsset, &NamedAsset{})
			if err := m.NamedAsset[len(m.NamedAsset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorRTSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorRTSpec == nil {
				m.TensorRTSpec = &TensorRTModelSpec{}
			}
			if err := m.TensorRTSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenVINOSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenVINOSpec == nil {
				m.OpenVINOSpec = &OpenVINOModelSpec{}
			}
			if err := m.OpenVINOSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizationProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptimizationProfile = append(m.OptimizationProfile, &TensorRTOptimizationProfile{})
			if err := m.OptimizationProfile[len(m.OptimizationProfile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineBlobKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EngineBlobKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPoolLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemPoolLimits == nil {
				m.MemPoolLimits = &TensorRTMemPoolLimits{}
			}
			if err := m.MemPoolLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTOptimizationProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTOptimizationProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTOptimizationProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorShapeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorShapeRange = append(m.TensorShapeRange, &TensorRTTensorShapeRange{})
			if err := m.TensorShapeRange[len(m.TensorShapeRange)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTTensorShapeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTTensorShapeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTTensorShapeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dim = append(m.Dim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dim) == 0 {
					m.Dim = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dim = append(m.Dim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorRTMemPoolLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorRTMemPoolLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorRTMemPoolLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workspace", wireType)
			}
			m.Workspace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Workspace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenVINOModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenVINOModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenVINOModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputShape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModelExec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModelExec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputShape = append(m.InputShape, &OpenVINOModelSpec_TensorShape{})
			if err := m.InputShape[len(m.InputShape)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenVINOModelSpec_TensorShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dim = append(m.Dim, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModelExec
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModelExec
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModelExec
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dim) == 0 {
					m.Dim = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModelExec
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dim = append(m.Dim, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModelExec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModelExec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModelExec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModelExec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModelExec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModelExec
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModelExec
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModelExec
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModelExec        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModelExec          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModelExec = fmt.Errorf("proto: unexpected end of group")
)
