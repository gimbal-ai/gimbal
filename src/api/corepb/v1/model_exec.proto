/*
 * Copyright Â© 2023- Gimlet Labs, Inc.
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Gimlet Labs, Inc. and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Gimlet Labs, Inc. and its suppliers and
 * may be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law. Dissemination
 * of this information or reproduction of this material is strictly
 * forbidden unless prior written permission is obtained from
 * Gimlet Labs, Inc.
 *
 * SPDX-License-Identifier: Proprietary
 */

syntax = "proto3";

package gml.internal.api.core.v1;

option go_package = "gimletlabs.ai/gimlet/src/api/corepb/v1;corepb";

import "gogoproto/gogo.proto";
import "mediapipe/framework/calculator.proto";
import "src/common/typespb/uuid.proto";
import "google/protobuf/timestamp.proto";

/****************************************************************************
 * Logical Pipeline definitions.
 *****************************************************************************/

// All supported logical pipeline nodes.
enum LogicalPipelineNodeKind {
  LOGICAL_PIPELINE_NODE_KIND_UNKNOWN = 0;
  // Declares vars that are inputs to the graph (if any).
  LOGICAL_PIPELINE_NODE_KIND_INPUT = 1;
  // Declares vars that are output from the graph (if any).
  LOGICAL_PIPELINE_NODE_KIND_OUTPUT = 2;
  // Source nodes
  LOGICAL_PIPELINE_NODE_KIND_CAMERA_SOURCE = 10;
  // Model nodes
  LOGICAL_PIPELINE_NODE_KIND_DETECT = 1000;
  LOGICAL_PIPELINE_NODE_KIND_CLASSIFY = 1001;
  // Processing nodes
  LOGICAL_PIPELINE_NODE_KIND_FOR_EACH_ROI = 1503;
  // Sink nodes
  LOGICAL_PIPELINE_NODE_KIND_VIDEO_STREAM_SINK = 2000;
  LOGICAL_PIPELINE_NODE_KIND_DETECTIONS_METRICS_SINK = 2001;
  LOGICAL_PIPELINE_NODE_KIND_LATENCY_METRICS_SINK = 2002;
  LOGICAL_PIPELINE_NODE_KIND_FRAME_METRICS_SINK = 2003;
}

// A node in a logical pipeline graph.
message Node {
  // Unique name for the node in the logical pipeline.
  string name = 1;
  LogicalPipelineNodeKind kind = 2;
  repeated NodeInput inputs = 3;
  repeated NodeOutput outputs = 4;
  repeated NodeInitArgs init_args = 5;
}

// Node Init args are constants that are used in node init.
message NodeInitArgs {
  // Name of the init arg.
  string name = 1;
  // Value for the arg. This also defines the type we expect the param to be.
  oneof default_value {
    string string_value = 2;
    int64 int64_value = 3;
    double double_value = 4;
    bool bool_value = 5;
    Lambda lambda_value = 6;
  }
}

message Lambda {
  repeated Node nodes = 1;
}

// Input values for a node.
message NodeInput {
  // A reference to an output field of another node in the logical pipeline.
  message NodeOutputRef {
    // Name of the node that produced this output.
    int64 node_name = 1;
    // Name of the node's output field.
    string name = 2;
  }

  message ModelInput {
    // Name of the model which the user has uploaded to their org.
    string model_name = 1;
  }

  message ParamInput {
    // Name of the global param.
    string param_name = 1;
  }

  // Name of the input.
  string name = 1;
  oneof value {
    // The name of a global param.
    ParamInput param_value = 2;
    // Name of the model which the user has uploaded to their org.
    ModelInput model_value = 3;
    // Input value is another node's output.
    NodeOutputRef node_output_value = 4;
  }
}

// Output values for a node.
message NodeOutput {
  // Name of the output field. This must be unique within the logical pipeline, as other nodes may
  // reference it.
  string name = 1;
}

// Global params that are used to configure the pipeline.
message GlobalParam {
  // Name of the global param.
  string name = 1;
  // Default value for the param. This also defines the type we expect the param to be.
  oneof default_value {
    string string_value = 2;
    int64 int64_value = 3;
    double double_value = 4;
    bool bool_value = 5;
  }
}

// A logical pipeline represents the high level steps of an execution graph. Users specify their
// pipeline YAML which is converted into this proto format.
message LogicalPipeline {
  // Global params that are used to configure the pipeline.
  repeated GlobalParam global_params = 1;
  // The nodes in the logical pipeline.
  repeated Node nodes = 2;
}

/****************************************************************************
 * Pipeline deployment definitions.
 *****************************************************************************/

enum PipelineState {
  PIPELINE_STATE_UNKNOWN = 0;
  PIPELINE_STATE_PENDING = 1;
  PIPELINE_STATE_READY = 2;
  PIPELINE_STATE_RUNNING = 3;
  PIPELINE_STATE_TERMINATING = 4;
  PIPELINE_STATE_TERMINATED = 5;
  PIPELINE_STATE_FAILED = 6;
}

// A pipeline deployment represents the instance of a logical pipeline deployed to a fleet.
message PipelineDeployment {
  // The ID of the deployment.
  gml.types.UUID id = 1 [ (gogoproto.customname) = "ID" ];
  // The ID of the logical pipeline this deployment is for.
  gml.types.UUID logical_pipeline_id = 2 [ (gogoproto.customname) = "LogicalPipelineID" ];
  // The ID of the fleet this pipeline should be deployed to.
  gml.types.UUID fleet_id = 3 [ (gogoproto.customname) = "FleetID" ];
  // The time this deployment was created.
  google.protobuf.Timestamp created_at = 4;
  // The time this deployment was last updated.
  google.protobuf.Timestamp updated_at = 5;
  // The version of the deployment.
  int64 version = 6;
  PipelineDeploymentSpec spec = 7;
  PipelineDeploymentState state = 8;
}

// The spec represents the desired state of the deployment.
message PipelineDeploymentSpec {
  // The state that we would like the deployment to be in.
  PipelineState state = 1;
}

// The state represents the actual state of the deployment.
message PipelineDeploymentState {
  // The state that the deployment is currently in.
  PipelineState state = 2;
}

// A physical pipeline represents the deployment of a pipeline to a specific device.
message PhysicalPipeline {
  // The ID of the physical pipeline.
  gml.types.UUID id = 1 [ (gogoproto.customname) = "ID" ];
  ;
  // The ID of the pipeline deployment this physical pipeline is for.
  gml.types.UUID pipeline_deployment_id = 2 [ (gogoproto.customname) = "PipelineDeploymentID" ];
  // The ID of the device this physical pipeline is for.
  gml.types.UUID device_id = 3 [ (gogoproto.customname) = "DeviceID" ];
  // The time this physical pipeline was created.
  google.protobuf.Timestamp created_at = 4;
  // The time this physical pipeline was last updated.
  google.protobuf.Timestamp updated_at = 5;
  // The version of the physical pipeline.
  int64 version = 6;
  // The spec of the deployment.
  PhysicalPipelineSpec spec = 7;
  // The state of the deployment.
  PhysicalPipelineStatus status = 8;
}

// The spec represents the desired state of the deployment.
message PhysicalPipelineSpec {
  // The state that we would like the pipeline to be in.
  PipelineState state = 1;
}

// The state represents the actual state of the deployment.
message PhysicalPipelineStatus {
  // The state that the pipeline is currently in.
  PipelineState state = 1;
}

/****************************************************************************
 * Older pipeline definitions. We should clean these up as we refactor our
 * logical pipelines/graph representation.
 *****************************************************************************/

// Pipeline is a high-level representation of an execution graph.
message Pipeline {
  // List of nodes in the pipeline.
  // Each node defines its input and output ports.
  // To connect nodes, the same net name should set for the relevant ports.
  repeated PipelineNode nodes = 2;
}

// PipelineNode is a node in an execution pipeline.
message PipelineNode {
  // A unique ID used to reference this node.
  uint64 id = 1;
  string type = 2;
  repeated Port inputs = 3;
  repeated Port outputs = 4;
  // TODO(james): temporary API change, will likely remove when we redo the pipelinecompiler.
  map<string, string> attr = 5;
}

// A port has a name, and a net.
// The port is a logical name for the input or output.
// The net defines how the port is connected to other ports of other nodes (common net names on
// ports throughout the graph are connected).
message Port {
  string name = 1;
  string net = 2;
}

message FileResource {
  // The ID of the file to fetch.
  gml.types.UUID file_id = 1 [ (gogoproto.customname) = "FileID" ];
  // The size of the file, in bytes.
  uint64 size_bytes = 2;
  // The sha256hash of the file.
  string sha256_hash = 3;
}

// ExecutionSpec represents a deployment that the GEM should execute.
message ExecutionSpec {
  mediapipe.CalculatorGraphConfig graph = 1;

  // Any models referenced by any nodes in the graph above need to have a model spec.
  repeated ModelSpec model_spec = 2;
}

// ModelSpec defines how to prepare the model.
// The current spec definitions are temporary and subject to change significantly.
message ModelSpec {
  string name = 1;

  // TODO(oazizi): Remove onnx_blob_key once file download work is complete; using name instead.
  string onnx_blob_key = 2 [ (gogoproto.customname) = "ONNXBlobKey" ];
  FileResource onnx_file = 3 [ (gogoproto.customname) = "ONNXFile" ];

  // The preferred runtime for the execution.
  string runtime = 50;

  // Plugin specs.
  // TensorRT specific specifications.
  TensorRTModelSpec tensorrt_spec = 100 [ (gogoproto.customname) = "TensorRTSpec" ];
  // OpenVINO specific specifications.
  OpenVINOModelSpec openvino_spec = 101 [ (gogoproto.customname) = "OpenVINOSpec" ];
}

// TensorRTModelSpec defines TensorRT specific parameters for building a TensorRT engine.
message TensorRTModelSpec {
  repeated TensorRTOptimizationProfile optimization_profile = 1;

  // BlobStore key for a cached version of the engine. If not empty, the model builder will attempt
  // to load the engine from the cached blob, if that fails it will build the engine and then insert
  // the built engine into the BlobStore with this key.
  string engine_blob_key = 2;

  TensorRTMemPoolLimits mem_pool_limits = 3;
}

// TensorRTOptimizationProfile defines TensorRT specific parameters to aid TensorRT profiling based
// optimization.
message TensorRTOptimizationProfile {
  repeated TensorRTTensorShapeRange tensor_shape_range = 1;
}

// TensorRTTensorShapeRange represents the range of shapes that a tensor is allowed to take.
// TensorRT uses this to aid in optimization.
message TensorRTTensorShapeRange {
  // For now we explicitly set the tensor shape instead of specifying a min/opt/max range.
  string tensor_name = 1;
  repeated int32 dim = 2;
}

message TensorRTMemPoolLimits {
  int64 workspace = 1;
}

message OpenVINOModelSpec {
  message TensorShape {
    repeated int32 dim = 1;
  }
  repeated TensorShape input_shape = 1;
}
