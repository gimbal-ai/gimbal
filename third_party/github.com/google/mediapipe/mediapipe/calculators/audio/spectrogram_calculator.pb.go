// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/calculators/audio/spectrogram_calculator.proto

package audio

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	framework "github.com/google/mediapipe/mediapipe/framework"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SpectrogramCalculatorOptions_OutputType int32

const (
	SQUARED_MAGNITUDE SpectrogramCalculatorOptions_OutputType = 0
	LINEAR_MAGNITUDE  SpectrogramCalculatorOptions_OutputType = 1
	DECIBELS          SpectrogramCalculatorOptions_OutputType = 2
	COMPLEX           SpectrogramCalculatorOptions_OutputType = 3
)

var SpectrogramCalculatorOptions_OutputType_name = map[int32]string{
	0: "SQUARED_MAGNITUDE",
	1: "LINEAR_MAGNITUDE",
	2: "DECIBELS",
	3: "COMPLEX",
}

var SpectrogramCalculatorOptions_OutputType_value = map[string]int32{
	"SQUARED_MAGNITUDE": 0,
	"LINEAR_MAGNITUDE":  1,
	"DECIBELS":          2,
	"COMPLEX":           3,
}

func (x SpectrogramCalculatorOptions_OutputType) Enum() *SpectrogramCalculatorOptions_OutputType {
	p := new(SpectrogramCalculatorOptions_OutputType)
	*p = x
	return p
}

func (x SpectrogramCalculatorOptions_OutputType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(SpectrogramCalculatorOptions_OutputType_name, int32(x))
}

func (x *SpectrogramCalculatorOptions_OutputType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SpectrogramCalculatorOptions_OutputType_value, data, "SpectrogramCalculatorOptions_OutputType")
	if err != nil {
		return err
	}
	*x = SpectrogramCalculatorOptions_OutputType(value)
	return nil
}

func (SpectrogramCalculatorOptions_OutputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_255b15defe81e2e8, []int{0, 0}
}

type SpectrogramCalculatorOptions_WindowType int32

const (
	WINDOW_TYPE_HANN      SpectrogramCalculatorOptions_WindowType = 0
	WINDOW_TYPE_HAMMING   SpectrogramCalculatorOptions_WindowType = 1
	WINDOW_TYPE_COSINE    SpectrogramCalculatorOptions_WindowType = 2
	WINDOW_TYPE_SQRT_HANN SpectrogramCalculatorOptions_WindowType = 4
)

var SpectrogramCalculatorOptions_WindowType_name = map[int32]string{
	0: "WINDOW_TYPE_HANN",
	1: "WINDOW_TYPE_HAMMING",
	2: "WINDOW_TYPE_COSINE",
	4: "WINDOW_TYPE_SQRT_HANN",
}

var SpectrogramCalculatorOptions_WindowType_value = map[string]int32{
	"WINDOW_TYPE_HANN":      0,
	"WINDOW_TYPE_HAMMING":   1,
	"WINDOW_TYPE_COSINE":    2,
	"WINDOW_TYPE_SQRT_HANN": 4,
}

func (x SpectrogramCalculatorOptions_WindowType) Enum() *SpectrogramCalculatorOptions_WindowType {
	p := new(SpectrogramCalculatorOptions_WindowType)
	*p = x
	return p
}

func (x SpectrogramCalculatorOptions_WindowType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(SpectrogramCalculatorOptions_WindowType_name, int32(x))
}

func (x *SpectrogramCalculatorOptions_WindowType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SpectrogramCalculatorOptions_WindowType_value, data, "SpectrogramCalculatorOptions_WindowType")
	if err != nil {
		return err
	}
	*x = SpectrogramCalculatorOptions_WindowType(value)
	return nil
}

func (SpectrogramCalculatorOptions_WindowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_255b15defe81e2e8, []int{0, 1}
}

type SpectrogramCalculatorOptions struct {
	FrameDurationSeconds   float64                                  `protobuf:"fixed64,1,opt,name=frame_duration_seconds,json=frameDurationSeconds" json:"frame_duration_seconds"`
	FrameOverlapSeconds    *float64                                 `protobuf:"fixed64,2,opt,name=frame_overlap_seconds,json=frameOverlapSeconds,def=0" json:"frame_overlap_seconds,omitempty"`
	PadFinalPacket         *bool                                    `protobuf:"varint,3,opt,name=pad_final_packet,json=padFinalPacket,def=1" json:"pad_final_packet,omitempty"`
	OutputType             *SpectrogramCalculatorOptions_OutputType `protobuf:"varint,4,opt,name=output_type,json=outputType,enum=mediapipe.SpectrogramCalculatorOptions_OutputType,def=0" json:"output_type,omitempty"`
	AllowMultichannelInput *bool                                    `protobuf:"varint,5,opt,name=allow_multichannel_input,json=allowMultichannelInput,def=0" json:"allow_multichannel_input,omitempty"`
	WindowType             *SpectrogramCalculatorOptions_WindowType `protobuf:"varint,6,opt,name=window_type,json=windowType,enum=mediapipe.SpectrogramCalculatorOptions_WindowType,def=0" json:"window_type,omitempty"`
	OutputScale            *float64                                 `protobuf:"fixed64,7,opt,name=output_scale,json=outputScale,def=1" json:"output_scale,omitempty"`
	UseLocalTimestamp      *bool                                    `protobuf:"varint,8,opt,name=use_local_timestamp,json=useLocalTimestamp,def=0" json:"use_local_timestamp,omitempty"`
}

func (m *SpectrogramCalculatorOptions) Reset()      { *m = SpectrogramCalculatorOptions{} }
func (*SpectrogramCalculatorOptions) ProtoMessage() {}
func (*SpectrogramCalculatorOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_255b15defe81e2e8, []int{0}
}
func (m *SpectrogramCalculatorOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpectrogramCalculatorOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpectrogramCalculatorOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpectrogramCalculatorOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpectrogramCalculatorOptions.Merge(m, src)
}
func (m *SpectrogramCalculatorOptions) XXX_Size() int {
	return m.Size()
}
func (m *SpectrogramCalculatorOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SpectrogramCalculatorOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SpectrogramCalculatorOptions proto.InternalMessageInfo

const Default_SpectrogramCalculatorOptions_FrameOverlapSeconds float64 = 0
const Default_SpectrogramCalculatorOptions_PadFinalPacket bool = true
const Default_SpectrogramCalculatorOptions_OutputType SpectrogramCalculatorOptions_OutputType = SQUARED_MAGNITUDE
const Default_SpectrogramCalculatorOptions_AllowMultichannelInput bool = false
const Default_SpectrogramCalculatorOptions_WindowType SpectrogramCalculatorOptions_WindowType = WINDOW_TYPE_HANN
const Default_SpectrogramCalculatorOptions_OutputScale float64 = 1
const Default_SpectrogramCalculatorOptions_UseLocalTimestamp bool = false

func (m *SpectrogramCalculatorOptions) GetFrameDurationSeconds() float64 {
	if m != nil {
		return m.FrameDurationSeconds
	}
	return 0
}

func (m *SpectrogramCalculatorOptions) GetFrameOverlapSeconds() float64 {
	if m != nil && m.FrameOverlapSeconds != nil {
		return *m.FrameOverlapSeconds
	}
	return Default_SpectrogramCalculatorOptions_FrameOverlapSeconds
}

func (m *SpectrogramCalculatorOptions) GetPadFinalPacket() bool {
	if m != nil && m.PadFinalPacket != nil {
		return *m.PadFinalPacket
	}
	return Default_SpectrogramCalculatorOptions_PadFinalPacket
}

func (m *SpectrogramCalculatorOptions) GetOutputType() SpectrogramCalculatorOptions_OutputType {
	if m != nil && m.OutputType != nil {
		return *m.OutputType
	}
	return Default_SpectrogramCalculatorOptions_OutputType
}

func (m *SpectrogramCalculatorOptions) GetAllowMultichannelInput() bool {
	if m != nil && m.AllowMultichannelInput != nil {
		return *m.AllowMultichannelInput
	}
	return Default_SpectrogramCalculatorOptions_AllowMultichannelInput
}

func (m *SpectrogramCalculatorOptions) GetWindowType() SpectrogramCalculatorOptions_WindowType {
	if m != nil && m.WindowType != nil {
		return *m.WindowType
	}
	return Default_SpectrogramCalculatorOptions_WindowType
}

func (m *SpectrogramCalculatorOptions) GetOutputScale() float64 {
	if m != nil && m.OutputScale != nil {
		return *m.OutputScale
	}
	return Default_SpectrogramCalculatorOptions_OutputScale
}

func (m *SpectrogramCalculatorOptions) GetUseLocalTimestamp() bool {
	if m != nil && m.UseLocalTimestamp != nil {
		return *m.UseLocalTimestamp
	}
	return Default_SpectrogramCalculatorOptions_UseLocalTimestamp
}

var E_SpectrogramCalculatorOptions_Ext = &proto.ExtensionDesc{
	ExtendedType:  (*framework.CalculatorOptions)(nil),
	ExtensionType: (*SpectrogramCalculatorOptions)(nil),
	Field:         76186688,
	Name:          "mediapipe.SpectrogramCalculatorOptions.ext",
	Tag:           "bytes,76186688,opt,name=ext",
	Filename:      "mediapipe/calculators/audio/spectrogram_calculator.proto",
}

func init() {
	proto.RegisterEnum("mediapipe.SpectrogramCalculatorOptions_OutputType", SpectrogramCalculatorOptions_OutputType_name, SpectrogramCalculatorOptions_OutputType_value)
	proto.RegisterEnum("mediapipe.SpectrogramCalculatorOptions_WindowType", SpectrogramCalculatorOptions_WindowType_name, SpectrogramCalculatorOptions_WindowType_value)
	proto.RegisterExtension(E_SpectrogramCalculatorOptions_Ext)
	proto.RegisterType((*SpectrogramCalculatorOptions)(nil), "mediapipe.SpectrogramCalculatorOptions")
}

func init() {
	proto.RegisterFile("mediapipe/calculators/audio/spectrogram_calculator.proto", fileDescriptor_255b15defe81e2e8)
}

var fileDescriptor_255b15defe81e2e8 = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xcd, 0x4e, 0xdb, 0x4e,
	0x14, 0xc5, 0x3d, 0x10, 0x3e, 0xfe, 0x13, 0x84, 0xcc, 0xf0, 0xf1, 0x77, 0x2b, 0xe4, 0x46, 0x08,
	0xa9, 0x59, 0x25, 0x6d, 0x24, 0xd4, 0x2a, 0x9b, 0x2a, 0x24, 0x2e, 0x8d, 0x94, 0x38, 0x60, 0x07,
	0xd1, 0xb2, 0x19, 0x4d, 0xed, 0x49, 0xb0, 0x18, 0x7b, 0x46, 0xf6, 0xb8, 0x29, 0xbb, 0x2e, 0xbb,
	0xec, 0x63, 0x54, 0x7d, 0x8a, 0x2e, 0x59, 0x66, 0xc9, 0xaa, 0x2a, 0x66, 0xd3, 0x25, 0x8f, 0x50,
	0xd9, 0x81, 0x24, 0x05, 0x09, 0xb5, 0xdb, 0x7b, 0xce, 0xef, 0xea, 0x9e, 0x63, 0x79, 0xe0, 0x4b,
	0x9f, 0xba, 0x1e, 0x11, 0x9e, 0xa0, 0x65, 0x87, 0x30, 0x27, 0x66, 0x44, 0xf2, 0x30, 0x2a, 0x93,
	0xd8, 0xf5, 0x78, 0x39, 0x12, 0xd4, 0x91, 0x21, 0xef, 0x87, 0xc4, 0xc7, 0x13, 0xb5, 0x24, 0x42,
	0x2e, 0x39, 0xfa, 0x6f, 0x4c, 0x3e, 0xde, 0x9e, 0x2c, 0xe9, 0x85, 0xc4, 0xa7, 0x03, 0x1e, 0x9e,
	0x96, 0xef, 0x02, 0x5b, 0xc3, 0x79, 0xb8, 0x69, 0x4f, 0x36, 0xd6, 0xc7, 0x7a, 0x47, 0x48, 0x8f,
	0x07, 0x11, 0xaa, 0xc2, 0x8d, 0x0c, 0xc7, 0x6e, 0x1c, 0x92, 0x74, 0x84, 0x23, 0xea, 0xf0, 0xc0,
	0x8d, 0x34, 0x50, 0x00, 0x45, 0xb0, 0x9b, 0x3b, 0xff, 0xf1, 0x44, 0xb1, 0xd6, 0x32, 0x4f, 0xe3,
	0xc6, 0x62, 0x8f, 0x1c, 0x68, 0x07, 0xae, 0x8f, 0x58, 0xfe, 0x81, 0x86, 0x8c, 0x88, 0x31, 0x3a,
	0x93, 0xa2, 0x55, 0xf0, 0xcc, 0x5a, 0xcd, 0xf4, 0xce, 0x48, 0xbe, 0xc5, 0x4a, 0x50, 0x15, 0xc4,
	0xc5, 0x3d, 0x2f, 0x20, 0x0c, 0x0b, 0xe2, 0x9c, 0x52, 0xa9, 0xcd, 0x16, 0x40, 0x71, 0xb1, 0x9a,
	0x93, 0x61, 0x4c, 0xad, 0x65, 0x41, 0xdc, 0xd7, 0xa9, 0xb8, 0x9f, 0x69, 0xa8, 0x07, 0xf3, 0x3c,
	0x96, 0x22, 0x96, 0x58, 0x9e, 0x09, 0xaa, 0xe5, 0x0a, 0xa0, 0xb8, 0x5c, 0xa9, 0x94, 0xc6, 0xf9,
	0x4b, 0x0f, 0x05, 0x2c, 0x75, 0x32, 0xb4, 0x7b, 0x26, 0x68, 0x75, 0xc5, 0x3e, 0x38, 0xac, 0x59,
	0x46, 0x03, 0xb7, 0x6b, 0x7b, 0x66, 0xb3, 0x7b, 0xd8, 0x30, 0x2c, 0xc8, 0xc7, 0x32, 0x7a, 0x05,
	0x35, 0xc2, 0x18, 0x1f, 0x60, 0x3f, 0x66, 0xd2, 0x73, 0x4e, 0x48, 0x10, 0x50, 0x86, 0xbd, 0x40,
	0xc4, 0x52, 0x9b, 0xcb, 0xee, 0x9b, 0xeb, 0x11, 0x16, 0x51, 0x6b, 0x23, 0xb3, 0xb5, 0xa7, 0x5c,
	0xcd, 0xd4, 0x84, 0x28, 0xcc, 0x0f, 0xbc, 0xc0, 0xe5, 0x83, 0xd1, 0xa1, 0xf3, 0xff, 0x76, 0xe8,
	0x51, 0x86, 0x66, 0x87, 0xaa, 0x47, 0x4d, 0xb3, 0xd1, 0x39, 0xc2, 0xdd, 0x77, 0xfb, 0x06, 0x7e,
	0x53, 0x33, 0x4d, 0x0b, 0x0e, 0xc6, 0x2a, 0xda, 0x86, 0x4b, 0x37, 0x7d, 0x44, 0x0e, 0x61, 0x54,
	0x5b, 0x18, 0xb5, 0xfd, 0xdc, 0xba, 0xa9, 0xc9, 0x4e, 0xa7, 0x68, 0x07, 0xae, 0xc6, 0x11, 0xc5,
	0x8c, 0x3b, 0x84, 0x61, 0xe9, 0xf9, 0x34, 0x92, 0xc4, 0x17, 0xda, 0xe2, 0x74, 0x90, 0x95, 0x38,
	0xa2, 0xad, 0xd4, 0xd0, 0xbd, 0xd5, 0xb7, 0xba, 0x10, 0x4e, 0x1a, 0x43, 0xeb, 0xf0, 0x7e, 0x67,
	0xaa, 0x82, 0xd6, 0xa0, 0xda, 0x6a, 0x9a, 0x46, 0xcd, 0x9a, 0x9a, 0x02, 0xb4, 0x04, 0x17, 0x1b,
	0x46, 0xbd, 0xb9, 0x6b, 0xb4, 0x6c, 0x75, 0x06, 0xe5, 0xe1, 0x42, 0xbd, 0xd3, 0xde, 0x6f, 0x19,
	0x6f, 0xd5, 0xd9, 0xad, 0x00, 0xc2, 0x49, 0xbc, 0x14, 0xbf, 0x1b, 0x50, 0x55, 0xd0, 0xff, 0x70,
	0xf5, 0xcf, 0x69, 0xbb, 0xdd, 0x34, 0xf7, 0x54, 0x80, 0x36, 0x20, 0x9a, 0x16, 0xea, 0x1d, 0xbb,
	0x69, 0x1a, 0xea, 0x0c, 0x7a, 0x04, 0xd7, 0xa7, 0xe7, 0xf6, 0x81, 0xd5, 0x1d, 0xed, 0xca, 0x55,
	0x8e, 0xe1, 0x2c, 0xfd, 0x28, 0xd1, 0xe6, 0x54, 0xf7, 0xf7, 0x0a, 0xd7, 0xbe, 0x7f, 0xfe, 0xb6,
	0x5d, 0x00, 0xc5, 0x7c, 0xe5, 0xe9, 0x5f, 0x7e, 0x22, 0x2b, 0x5d, 0xba, 0xeb, 0x0f, 0x2f, 0x75,
	0xe5, 0xe2, 0x52, 0x57, 0xae, 0x2f, 0x75, 0xf0, 0x29, 0xd1, 0xc1, 0xd7, 0x44, 0x07, 0xe7, 0x89,
	0x0e, 0x86, 0x89, 0x0e, 0x7e, 0x26, 0x3a, 0xf8, 0x95, 0xe8, 0xca, 0x75, 0xa2, 0x83, 0x2f, 0x57,
	0xba, 0x32, 0xbc, 0xd2, 0x95, 0x8b, 0x2b, 0x5d, 0x39, 0x7e, 0xd1, 0xf7, 0xe4, 0x49, 0xfc, 0xbe,
	0xe4, 0x70, 0xbf, 0xdc, 0xe7, 0xbc, 0xcf, 0x68, 0x79, 0xf2, 0x03, 0x3f, 0xf0, 0x1e, 0xfc, 0x0e,
	0x00, 0x00, 0xff, 0xff, 0x9d, 0x9d, 0xed, 0x48, 0x2d, 0x04, 0x00, 0x00,
}

func (x SpectrogramCalculatorOptions_OutputType) String() string {
	s, ok := SpectrogramCalculatorOptions_OutputType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SpectrogramCalculatorOptions_WindowType) String() string {
	s, ok := SpectrogramCalculatorOptions_WindowType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SpectrogramCalculatorOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpectrogramCalculatorOptions)
	if !ok {
		that2, ok := that.(SpectrogramCalculatorOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FrameDurationSeconds != that1.FrameDurationSeconds {
		return false
	}
	if this.FrameOverlapSeconds != nil && that1.FrameOverlapSeconds != nil {
		if *this.FrameOverlapSeconds != *that1.FrameOverlapSeconds {
			return false
		}
	} else if this.FrameOverlapSeconds != nil {
		return false
	} else if that1.FrameOverlapSeconds != nil {
		return false
	}
	if this.PadFinalPacket != nil && that1.PadFinalPacket != nil {
		if *this.PadFinalPacket != *that1.PadFinalPacket {
			return false
		}
	} else if this.PadFinalPacket != nil {
		return false
	} else if that1.PadFinalPacket != nil {
		return false
	}
	if this.OutputType != nil && that1.OutputType != nil {
		if *this.OutputType != *that1.OutputType {
			return false
		}
	} else if this.OutputType != nil {
		return false
	} else if that1.OutputType != nil {
		return false
	}
	if this.AllowMultichannelInput != nil && that1.AllowMultichannelInput != nil {
		if *this.AllowMultichannelInput != *that1.AllowMultichannelInput {
			return false
		}
	} else if this.AllowMultichannelInput != nil {
		return false
	} else if that1.AllowMultichannelInput != nil {
		return false
	}
	if this.WindowType != nil && that1.WindowType != nil {
		if *this.WindowType != *that1.WindowType {
			return false
		}
	} else if this.WindowType != nil {
		return false
	} else if that1.WindowType != nil {
		return false
	}
	if this.OutputScale != nil && that1.OutputScale != nil {
		if *this.OutputScale != *that1.OutputScale {
			return false
		}
	} else if this.OutputScale != nil {
		return false
	} else if that1.OutputScale != nil {
		return false
	}
	if this.UseLocalTimestamp != nil && that1.UseLocalTimestamp != nil {
		if *this.UseLocalTimestamp != *that1.UseLocalTimestamp {
			return false
		}
	} else if this.UseLocalTimestamp != nil {
		return false
	} else if that1.UseLocalTimestamp != nil {
		return false
	}
	return true
}
func (this *SpectrogramCalculatorOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&audio.SpectrogramCalculatorOptions{")
	s = append(s, "FrameDurationSeconds: "+fmt.Sprintf("%#v", this.FrameDurationSeconds)+",\n")
	if this.FrameOverlapSeconds != nil {
		s = append(s, "FrameOverlapSeconds: "+valueToGoStringSpectrogramCalculator(this.FrameOverlapSeconds, "float64")+",\n")
	}
	if this.PadFinalPacket != nil {
		s = append(s, "PadFinalPacket: "+valueToGoStringSpectrogramCalculator(this.PadFinalPacket, "bool")+",\n")
	}
	if this.OutputType != nil {
		s = append(s, "OutputType: "+valueToGoStringSpectrogramCalculator(this.OutputType, "SpectrogramCalculatorOptions_OutputType")+",\n")
	}
	if this.AllowMultichannelInput != nil {
		s = append(s, "AllowMultichannelInput: "+valueToGoStringSpectrogramCalculator(this.AllowMultichannelInput, "bool")+",\n")
	}
	if this.WindowType != nil {
		s = append(s, "WindowType: "+valueToGoStringSpectrogramCalculator(this.WindowType, "SpectrogramCalculatorOptions_WindowType")+",\n")
	}
	if this.OutputScale != nil {
		s = append(s, "OutputScale: "+valueToGoStringSpectrogramCalculator(this.OutputScale, "float64")+",\n")
	}
	if this.UseLocalTimestamp != nil {
		s = append(s, "UseLocalTimestamp: "+valueToGoStringSpectrogramCalculator(this.UseLocalTimestamp, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSpectrogramCalculator(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SpectrogramCalculatorOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpectrogramCalculatorOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpectrogramCalculatorOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseLocalTimestamp != nil {
		i--
		if *m.UseLocalTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.OutputScale != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.OutputScale))))
		i--
		dAtA[i] = 0x39
	}
	if m.WindowType != nil {
		i = encodeVarintSpectrogramCalculator(dAtA, i, uint64(*m.WindowType))
		i--
		dAtA[i] = 0x30
	}
	if m.AllowMultichannelInput != nil {
		i--
		if *m.AllowMultichannelInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.OutputType != nil {
		i = encodeVarintSpectrogramCalculator(dAtA, i, uint64(*m.OutputType))
		i--
		dAtA[i] = 0x20
	}
	if m.PadFinalPacket != nil {
		i--
		if *m.PadFinalPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FrameOverlapSeconds != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.FrameOverlapSeconds))))
		i--
		dAtA[i] = 0x11
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrameDurationSeconds))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}

func encodeVarintSpectrogramCalculator(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpectrogramCalculator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpectrogramCalculatorOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	if m.FrameOverlapSeconds != nil {
		n += 9
	}
	if m.PadFinalPacket != nil {
		n += 2
	}
	if m.OutputType != nil {
		n += 1 + sovSpectrogramCalculator(uint64(*m.OutputType))
	}
	if m.AllowMultichannelInput != nil {
		n += 2
	}
	if m.WindowType != nil {
		n += 1 + sovSpectrogramCalculator(uint64(*m.WindowType))
	}
	if m.OutputScale != nil {
		n += 9
	}
	if m.UseLocalTimestamp != nil {
		n += 2
	}
	return n
}

func sovSpectrogramCalculator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpectrogramCalculator(x uint64) (n int) {
	return sovSpectrogramCalculator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SpectrogramCalculatorOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpectrogramCalculatorOptions{`,
		`FrameDurationSeconds:` + fmt.Sprintf("%v", this.FrameDurationSeconds) + `,`,
		`FrameOverlapSeconds:` + valueToStringSpectrogramCalculator(this.FrameOverlapSeconds) + `,`,
		`PadFinalPacket:` + valueToStringSpectrogramCalculator(this.PadFinalPacket) + `,`,
		`OutputType:` + valueToStringSpectrogramCalculator(this.OutputType) + `,`,
		`AllowMultichannelInput:` + valueToStringSpectrogramCalculator(this.AllowMultichannelInput) + `,`,
		`WindowType:` + valueToStringSpectrogramCalculator(this.WindowType) + `,`,
		`OutputScale:` + valueToStringSpectrogramCalculator(this.OutputScale) + `,`,
		`UseLocalTimestamp:` + valueToStringSpectrogramCalculator(this.UseLocalTimestamp) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSpectrogramCalculator(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SpectrogramCalculatorOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpectrogramCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpectrogramCalculatorOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpectrogramCalculatorOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrameDurationSeconds = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameOverlapSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.FrameOverlapSeconds = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PadFinalPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PadFinalPacket = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			var v SpectrogramCalculatorOptions_OutputType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SpectrogramCalculatorOptions_OutputType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMultichannelInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowMultichannelInput = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowType", wireType)
			}
			var v SpectrogramCalculatorOptions_WindowType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SpectrogramCalculatorOptions_WindowType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowType = &v
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputScale", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.OutputScale = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLocalTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseLocalTimestamp = &b
		default:
			iNdEx = preIndex
			skippy, err := skipSpectrogramCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpectrogramCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpectrogramCalculator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpectrogramCalculator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpectrogramCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpectrogramCalculator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpectrogramCalculator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpectrogramCalculator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpectrogramCalculator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpectrogramCalculator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpectrogramCalculator = fmt.Errorf("proto: unexpected end of group")
)
