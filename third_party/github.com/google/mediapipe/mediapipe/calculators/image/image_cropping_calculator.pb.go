// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/calculators/image/image_cropping_calculator.proto

package image

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	framework "github.com/google/mediapipe/mediapipe/framework"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ImageCroppingCalculatorOptions_BorderMode int32

const (
	CROP_BORDER_UNSPECIFIED ImageCroppingCalculatorOptions_BorderMode = 0
	CROP_BORDER_ZERO        ImageCroppingCalculatorOptions_BorderMode = 1
	CROP_BORDER_REPLICATE   ImageCroppingCalculatorOptions_BorderMode = 2
)

var ImageCroppingCalculatorOptions_BorderMode_name = map[int32]string{
	0: "CROP_BORDER_UNSPECIFIED",
	1: "CROP_BORDER_ZERO",
	2: "CROP_BORDER_REPLICATE",
}

var ImageCroppingCalculatorOptions_BorderMode_value = map[string]int32{
	"CROP_BORDER_UNSPECIFIED": 0,
	"CROP_BORDER_ZERO":        1,
	"CROP_BORDER_REPLICATE":   2,
}

func (x ImageCroppingCalculatorOptions_BorderMode) Enum() *ImageCroppingCalculatorOptions_BorderMode {
	p := new(ImageCroppingCalculatorOptions_BorderMode)
	*p = x
	return p
}

func (x ImageCroppingCalculatorOptions_BorderMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ImageCroppingCalculatorOptions_BorderMode_name, int32(x))
}

func (x *ImageCroppingCalculatorOptions_BorderMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageCroppingCalculatorOptions_BorderMode_value, data, "ImageCroppingCalculatorOptions_BorderMode")
	if err != nil {
		return err
	}
	*x = ImageCroppingCalculatorOptions_BorderMode(value)
	return nil
}

func (ImageCroppingCalculatorOptions_BorderMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_44449d8e5670c463, []int{0, 0}
}

type ImageCroppingCalculatorOptions struct {
	Width           int32                                      `protobuf:"varint,1,opt,name=width" json:"width"`
	Height          int32                                      `protobuf:"varint,2,opt,name=height" json:"height"`
	Rotation        *float32                                   `protobuf:"fixed32,3,opt,name=rotation,def=0" json:"rotation,omitempty"`
	NormWidth       float32                                    `protobuf:"fixed32,4,opt,name=norm_width,json=normWidth" json:"norm_width"`
	NormHeight      float32                                    `protobuf:"fixed32,5,opt,name=norm_height,json=normHeight" json:"norm_height"`
	NormCenterX     *float32                                   `protobuf:"fixed32,6,opt,name=norm_center_x,json=normCenterX,def=0" json:"norm_center_x,omitempty"`
	NormCenterY     *float32                                   `protobuf:"fixed32,7,opt,name=norm_center_y,json=normCenterY,def=0" json:"norm_center_y,omitempty"`
	BorderMode      *ImageCroppingCalculatorOptions_BorderMode `protobuf:"varint,8,opt,name=border_mode,json=borderMode,enum=mediapipe.ImageCroppingCalculatorOptions_BorderMode,def=1" json:"border_mode,omitempty"`
	OutputMaxWidth  int32                                      `protobuf:"varint,9,opt,name=output_max_width,json=outputMaxWidth" json:"output_max_width"`
	OutputMaxHeight int32                                      `protobuf:"varint,10,opt,name=output_max_height,json=outputMaxHeight" json:"output_max_height"`
}

func (m *ImageCroppingCalculatorOptions) Reset()      { *m = ImageCroppingCalculatorOptions{} }
func (*ImageCroppingCalculatorOptions) ProtoMessage() {}
func (*ImageCroppingCalculatorOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_44449d8e5670c463, []int{0}
}
func (m *ImageCroppingCalculatorOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageCroppingCalculatorOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageCroppingCalculatorOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageCroppingCalculatorOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCroppingCalculatorOptions.Merge(m, src)
}
func (m *ImageCroppingCalculatorOptions) XXX_Size() int {
	return m.Size()
}
func (m *ImageCroppingCalculatorOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCroppingCalculatorOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCroppingCalculatorOptions proto.InternalMessageInfo

const Default_ImageCroppingCalculatorOptions_Rotation float32 = 0
const Default_ImageCroppingCalculatorOptions_NormCenterX float32 = 0
const Default_ImageCroppingCalculatorOptions_NormCenterY float32 = 0
const Default_ImageCroppingCalculatorOptions_BorderMode ImageCroppingCalculatorOptions_BorderMode = CROP_BORDER_ZERO

func (m *ImageCroppingCalculatorOptions) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ImageCroppingCalculatorOptions) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ImageCroppingCalculatorOptions) GetRotation() float32 {
	if m != nil && m.Rotation != nil {
		return *m.Rotation
	}
	return Default_ImageCroppingCalculatorOptions_Rotation
}

func (m *ImageCroppingCalculatorOptions) GetNormWidth() float32 {
	if m != nil {
		return m.NormWidth
	}
	return 0
}

func (m *ImageCroppingCalculatorOptions) GetNormHeight() float32 {
	if m != nil {
		return m.NormHeight
	}
	return 0
}

func (m *ImageCroppingCalculatorOptions) GetNormCenterX() float32 {
	if m != nil && m.NormCenterX != nil {
		return *m.NormCenterX
	}
	return Default_ImageCroppingCalculatorOptions_NormCenterX
}

func (m *ImageCroppingCalculatorOptions) GetNormCenterY() float32 {
	if m != nil && m.NormCenterY != nil {
		return *m.NormCenterY
	}
	return Default_ImageCroppingCalculatorOptions_NormCenterY
}

func (m *ImageCroppingCalculatorOptions) GetBorderMode() ImageCroppingCalculatorOptions_BorderMode {
	if m != nil && m.BorderMode != nil {
		return *m.BorderMode
	}
	return Default_ImageCroppingCalculatorOptions_BorderMode
}

func (m *ImageCroppingCalculatorOptions) GetOutputMaxWidth() int32 {
	if m != nil {
		return m.OutputMaxWidth
	}
	return 0
}

func (m *ImageCroppingCalculatorOptions) GetOutputMaxHeight() int32 {
	if m != nil {
		return m.OutputMaxHeight
	}
	return 0
}

var E_ImageCroppingCalculatorOptions_Ext = &proto.ExtensionDesc{
	ExtendedType:  (*framework.CalculatorOptions)(nil),
	ExtensionType: (*ImageCroppingCalculatorOptions)(nil),
	Field:         262466399,
	Name:          "mediapipe.ImageCroppingCalculatorOptions.ext",
	Tag:           "bytes,262466399,opt,name=ext",
	Filename:      "mediapipe/calculators/image/image_cropping_calculator.proto",
}

func init() {
	proto.RegisterEnum("mediapipe.ImageCroppingCalculatorOptions_BorderMode", ImageCroppingCalculatorOptions_BorderMode_name, ImageCroppingCalculatorOptions_BorderMode_value)
	proto.RegisterExtension(E_ImageCroppingCalculatorOptions_Ext)
	proto.RegisterType((*ImageCroppingCalculatorOptions)(nil), "mediapipe.ImageCroppingCalculatorOptions")
}

func init() {
	proto.RegisterFile("mediapipe/calculators/image/image_cropping_calculator.proto", fileDescriptor_44449d8e5670c463)
}

var fileDescriptor_44449d8e5670c463 = []byte{
	// 504 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xcf, 0x6e, 0xd3, 0x4c,
	0x14, 0xc5, 0x3d, 0x69, 0xd3, 0xaf, 0xb9, 0xd1, 0x57, 0xcc, 0x08, 0x84, 0x29, 0x65, 0x88, 0x0a,
	0x95, 0xc2, 0xc6, 0xae, 0x22, 0x24, 0xa4, 0xb2, 0x22, 0xae, 0x11, 0x91, 0x28, 0x89, 0x06, 0x10,
	0x10, 0x21, 0x59, 0x8e, 0x3d, 0x38, 0x16, 0x71, 0xc6, 0x9a, 0x4e, 0xd4, 0xb0, 0x40, 0xe2, 0x11,
	0x90, 0xd8, 0xf0, 0x08, 0x3c, 0x4a, 0x97, 0x59, 0xa1, 0xae, 0x80, 0x38, 0x1b, 0x96, 0x7d, 0x04,
	0xe4, 0x3f, 0x38, 0x56, 0x8b, 0x2a, 0x36, 0xb3, 0x38, 0xf7, 0x9c, 0x73, 0xaf, 0x7e, 0xd2, 0xc0,
	0x83, 0x90, 0x79, 0x81, 0x13, 0x05, 0x11, 0x33, 0x5c, 0x67, 0xe4, 0x4e, 0x46, 0x8e, 0xe4, 0xe2,
	0xd0, 0x08, 0x42, 0xc7, 0x67, 0xd9, 0x6b, 0xbb, 0x82, 0x47, 0x51, 0x30, 0xf6, 0xed, 0xa5, 0x41,
	0x8f, 0x04, 0x97, 0x1c, 0xd7, 0x8a, 0xf0, 0xe6, 0x9d, 0x65, 0xcf, 0x5b, 0xe1, 0x84, 0xec, 0x88,
	0x8b, 0x77, 0xc6, 0xd9, 0xc0, 0xf6, 0x97, 0x2a, 0x90, 0x4e, 0x52, 0x6a, 0xe6, 0x9d, 0x66, 0xe1,
	0xe8, 0x46, 0x32, 0xe0, 0xe3, 0x43, 0xbc, 0x09, 0xd5, 0xa3, 0xc0, 0x93, 0x43, 0x0d, 0x35, 0x50,
	0xb3, 0xda, 0x5e, 0x3d, 0xfe, 0x7e, 0x4b, 0xa1, 0x99, 0x84, 0xb7, 0x60, 0x6d, 0xc8, 0x02, 0x7f,
	0x28, 0xb5, 0x4a, 0x69, 0x98, 0x6b, 0xf8, 0x26, 0xac, 0x0b, 0x2e, 0x9d, 0xa4, 0x46, 0x5b, 0x69,
	0xa0, 0x66, 0x65, 0x0f, 0xed, 0xd2, 0x42, 0xc2, 0xb7, 0x01, 0xc6, 0x5c, 0x84, 0x76, 0xd6, 0xbe,
	0x9a, 0x18, 0xf2, 0x82, 0x5a, 0xa2, 0xbf, 0x4c, 0x37, 0xec, 0x40, 0x3d, 0x35, 0xe5, 0x6b, 0xaa,
	0x25, 0x57, 0x9a, 0x7e, 0x9c, 0xad, 0xda, 0x81, 0xff, 0x53, 0x9b, 0xcb, 0xc6, 0x92, 0x09, 0x7b,
	0xaa, 0xad, 0xfd, 0xd9, 0x97, 0xc6, 0xcd, 0x54, 0x7e, 0x75, 0xd6, 0xf6, 0x5e, 0xfb, 0xef, 0x2f,
	0xb6, 0xd7, 0xd8, 0x87, 0xfa, 0x80, 0x0b, 0x8f, 0x09, 0x3b, 0xe4, 0x1e, 0xd3, 0xd6, 0x1b, 0xa8,
	0xb9, 0xd1, 0xba, 0xa7, 0x17, 0x44, 0xf5, 0x8b, 0x91, 0xe9, 0xed, 0x34, 0x7c, 0xc0, 0x3d, 0xb6,
	0xa7, 0x9a, 0xb4, 0xdb, 0xb3, 0xdb, 0x5d, 0xba, 0x6f, 0x51, 0xbb, 0x6f, 0xd1, 0x2e, 0x85, 0x41,
	0x31, 0xc5, 0x3a, 0xa8, 0x7c, 0x22, 0xa3, 0x89, 0xb4, 0x43, 0x67, 0x9a, 0x83, 0xa8, 0x95, 0x48,
	0x6e, 0x64, 0xd3, 0x03, 0x67, 0x9a, 0xd1, 0xd8, 0x85, 0xcb, 0x25, 0x7f, 0xce, 0x04, 0x4a, 0x81,
	0x4b, 0x45, 0x20, 0x03, 0xb3, 0xdd, 0x07, 0x58, 0x5e, 0x83, 0x6f, 0xc0, 0xb5, 0xf2, 0x3d, 0x2f,
	0x9e, 0x3e, 0xeb, 0x59, 0x66, 0xe7, 0x51, 0xc7, 0xda, 0x57, 0x15, 0x7c, 0x05, 0xce, 0x1d, 0xab,
	0x22, 0x7c, 0x1d, 0xae, 0x96, 0x55, 0x6a, 0xf5, 0x9e, 0x74, 0xcc, 0x87, 0xcf, 0x2d, 0xb5, 0xd2,
	0x7a, 0x03, 0x2b, 0x6c, 0x2a, 0xf1, 0x56, 0x09, 0xcc, 0x39, 0x16, 0xda, 0x8f, 0x6f, 0x9f, 0x3f,
	0x34, 0x50, 0xb3, 0xde, 0xba, 0xfb, 0xcf, 0xfc, 0x68, 0x52, 0xdb, 0x0e, 0x67, 0x73, 0xa2, 0x9c,
	0xcc, 0x89, 0x72, 0x3a, 0x27, 0xe8, 0x63, 0x4c, 0xd0, 0xd7, 0x98, 0xa0, 0xe3, 0x98, 0xa0, 0x59,
	0x4c, 0xd0, 0xcf, 0x98, 0xa0, 0x5f, 0x31, 0x51, 0x4e, 0x63, 0x82, 0x3e, 0x2d, 0x88, 0x32, 0x5b,
	0x10, 0xe5, 0x64, 0x41, 0x94, 0xfe, 0x7d, 0x3f, 0x90, 0xc3, 0xc9, 0x40, 0x77, 0x79, 0x68, 0xf8,
	0x9c, 0xfb, 0x23, 0x66, 0x2c, 0x3f, 0xc2, 0x05, 0x5f, 0xeb, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb8, 0x63, 0x53, 0xdc, 0x78, 0x03, 0x00, 0x00,
}

func (x ImageCroppingCalculatorOptions_BorderMode) String() string {
	s, ok := ImageCroppingCalculatorOptions_BorderMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ImageCroppingCalculatorOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageCroppingCalculatorOptions)
	if !ok {
		that2, ok := that.(ImageCroppingCalculatorOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Rotation != nil && that1.Rotation != nil {
		if *this.Rotation != *that1.Rotation {
			return false
		}
	} else if this.Rotation != nil {
		return false
	} else if that1.Rotation != nil {
		return false
	}
	if this.NormWidth != that1.NormWidth {
		return false
	}
	if this.NormHeight != that1.NormHeight {
		return false
	}
	if this.NormCenterX != nil && that1.NormCenterX != nil {
		if *this.NormCenterX != *that1.NormCenterX {
			return false
		}
	} else if this.NormCenterX != nil {
		return false
	} else if that1.NormCenterX != nil {
		return false
	}
	if this.NormCenterY != nil && that1.NormCenterY != nil {
		if *this.NormCenterY != *that1.NormCenterY {
			return false
		}
	} else if this.NormCenterY != nil {
		return false
	} else if that1.NormCenterY != nil {
		return false
	}
	if this.BorderMode != nil && that1.BorderMode != nil {
		if *this.BorderMode != *that1.BorderMode {
			return false
		}
	} else if this.BorderMode != nil {
		return false
	} else if that1.BorderMode != nil {
		return false
	}
	if this.OutputMaxWidth != that1.OutputMaxWidth {
		return false
	}
	if this.OutputMaxHeight != that1.OutputMaxHeight {
		return false
	}
	return true
}
func (this *ImageCroppingCalculatorOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&image.ImageCroppingCalculatorOptions{")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	if this.Rotation != nil {
		s = append(s, "Rotation: "+valueToGoStringImageCroppingCalculator(this.Rotation, "float32")+",\n")
	}
	s = append(s, "NormWidth: "+fmt.Sprintf("%#v", this.NormWidth)+",\n")
	s = append(s, "NormHeight: "+fmt.Sprintf("%#v", this.NormHeight)+",\n")
	if this.NormCenterX != nil {
		s = append(s, "NormCenterX: "+valueToGoStringImageCroppingCalculator(this.NormCenterX, "float32")+",\n")
	}
	if this.NormCenterY != nil {
		s = append(s, "NormCenterY: "+valueToGoStringImageCroppingCalculator(this.NormCenterY, "float32")+",\n")
	}
	if this.BorderMode != nil {
		s = append(s, "BorderMode: "+valueToGoStringImageCroppingCalculator(this.BorderMode, "ImageCroppingCalculatorOptions_BorderMode")+",\n")
	}
	s = append(s, "OutputMaxWidth: "+fmt.Sprintf("%#v", this.OutputMaxWidth)+",\n")
	s = append(s, "OutputMaxHeight: "+fmt.Sprintf("%#v", this.OutputMaxHeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringImageCroppingCalculator(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ImageCroppingCalculatorOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageCroppingCalculatorOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageCroppingCalculatorOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintImageCroppingCalculator(dAtA, i, uint64(m.OutputMaxHeight))
	i--
	dAtA[i] = 0x50
	i = encodeVarintImageCroppingCalculator(dAtA, i, uint64(m.OutputMaxWidth))
	i--
	dAtA[i] = 0x48
	if m.BorderMode != nil {
		i = encodeVarintImageCroppingCalculator(dAtA, i, uint64(*m.BorderMode))
		i--
		dAtA[i] = 0x40
	}
	if m.NormCenterY != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.NormCenterY))))
		i--
		dAtA[i] = 0x3d
	}
	if m.NormCenterX != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.NormCenterX))))
		i--
		dAtA[i] = 0x35
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NormHeight))))
	i--
	dAtA[i] = 0x2d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NormWidth))))
	i--
	dAtA[i] = 0x25
	if m.Rotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Rotation))))
		i--
		dAtA[i] = 0x1d
	}
	i = encodeVarintImageCroppingCalculator(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x10
	i = encodeVarintImageCroppingCalculator(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintImageCroppingCalculator(dAtA []byte, offset int, v uint64) int {
	offset -= sovImageCroppingCalculator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ImageCroppingCalculatorOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovImageCroppingCalculator(uint64(m.Width))
	n += 1 + sovImageCroppingCalculator(uint64(m.Height))
	if m.Rotation != nil {
		n += 5
	}
	n += 5
	n += 5
	if m.NormCenterX != nil {
		n += 5
	}
	if m.NormCenterY != nil {
		n += 5
	}
	if m.BorderMode != nil {
		n += 1 + sovImageCroppingCalculator(uint64(*m.BorderMode))
	}
	n += 1 + sovImageCroppingCalculator(uint64(m.OutputMaxWidth))
	n += 1 + sovImageCroppingCalculator(uint64(m.OutputMaxHeight))
	return n
}

func sovImageCroppingCalculator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozImageCroppingCalculator(x uint64) (n int) {
	return sovImageCroppingCalculator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ImageCroppingCalculatorOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageCroppingCalculatorOptions{`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`Rotation:` + valueToStringImageCroppingCalculator(this.Rotation) + `,`,
		`NormWidth:` + fmt.Sprintf("%v", this.NormWidth) + `,`,
		`NormHeight:` + fmt.Sprintf("%v", this.NormHeight) + `,`,
		`NormCenterX:` + valueToStringImageCroppingCalculator(this.NormCenterX) + `,`,
		`NormCenterY:` + valueToStringImageCroppingCalculator(this.NormCenterY) + `,`,
		`BorderMode:` + valueToStringImageCroppingCalculator(this.BorderMode) + `,`,
		`OutputMaxWidth:` + fmt.Sprintf("%v", this.OutputMaxWidth) + `,`,
		`OutputMaxHeight:` + fmt.Sprintf("%v", this.OutputMaxHeight) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringImageCroppingCalculator(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ImageCroppingCalculatorOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageCroppingCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageCroppingCalculatorOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageCroppingCalculatorOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Rotation = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormWidth", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NormWidth = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormHeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NormHeight = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormCenterX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.NormCenterX = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormCenterY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.NormCenterY = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorderMode", wireType)
			}
			var v ImageCroppingCalculatorOptions_BorderMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ImageCroppingCalculatorOptions_BorderMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BorderMode = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxWidth", wireType)
			}
			m.OutputMaxWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMaxHeight", wireType)
			}
			m.OutputMaxHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputMaxHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageCroppingCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageCroppingCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImageCroppingCalculator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImageCroppingCalculator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageCroppingCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthImageCroppingCalculator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupImageCroppingCalculator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthImageCroppingCalculator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthImageCroppingCalculator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImageCroppingCalculator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupImageCroppingCalculator = fmt.Errorf("proto: unexpected end of group")
)
