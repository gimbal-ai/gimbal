// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/calculators/image/image_transformation_calculator.proto

package image

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	framework "github.com/google/mediapipe/mediapipe/framework"
	gpu "github.com/google/mediapipe/mediapipe/gpu"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ImageTransformationCalculatorOptions_InterpolationMode int32

const (
	INTERPOLATION_MODE_DEFAULT ImageTransformationCalculatorOptions_InterpolationMode = 0
	INTERPOLATION_MODE_LINEAR  ImageTransformationCalculatorOptions_InterpolationMode = 1
	INTERPOLATION_MODE_NEAREST ImageTransformationCalculatorOptions_InterpolationMode = 2
)

var ImageTransformationCalculatorOptions_InterpolationMode_name = map[int32]string{
	0: "INTERPOLATION_MODE_DEFAULT",
	1: "INTERPOLATION_MODE_LINEAR",
	2: "INTERPOLATION_MODE_NEAREST",
}

var ImageTransformationCalculatorOptions_InterpolationMode_value = map[string]int32{
	"INTERPOLATION_MODE_DEFAULT": 0,
	"INTERPOLATION_MODE_LINEAR":  1,
	"INTERPOLATION_MODE_NEAREST": 2,
}

func (x ImageTransformationCalculatorOptions_InterpolationMode) Enum() *ImageTransformationCalculatorOptions_InterpolationMode {
	p := new(ImageTransformationCalculatorOptions_InterpolationMode)
	*p = x
	return p
}

func (x ImageTransformationCalculatorOptions_InterpolationMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ImageTransformationCalculatorOptions_InterpolationMode_name, int32(x))
}

func (x *ImageTransformationCalculatorOptions_InterpolationMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageTransformationCalculatorOptions_InterpolationMode_value, data, "ImageTransformationCalculatorOptions_InterpolationMode")
	if err != nil {
		return err
	}
	*x = ImageTransformationCalculatorOptions_InterpolationMode(value)
	return nil
}

func (ImageTransformationCalculatorOptions_InterpolationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0b5829b530bd699, []int{0, 0}
}

type ImageTransformationCalculatorOptions struct {
	OutputWidth       *int32                                                 `protobuf:"varint,1,opt,name=output_width,json=outputWidth,def=0" json:"output_width,omitempty"`
	OutputHeight      *int32                                                 `protobuf:"varint,2,opt,name=output_height,json=outputHeight,def=0" json:"output_height,omitempty"`
	RotationMode      RotationMode_Mode                                      `protobuf:"varint,3,opt,name=rotation_mode,json=rotationMode,enum=mediapipe.RotationMode_Mode" json:"rotation_mode"`
	FlipVertically    *bool                                                  `protobuf:"varint,4,opt,name=flip_vertically,json=flipVertically,def=0" json:"flip_vertically,omitempty"`
	FlipHorizontally  *bool                                                  `protobuf:"varint,5,opt,name=flip_horizontally,json=flipHorizontally,def=0" json:"flip_horizontally,omitempty"`
	ScaleMode         gpu.ScaleMode_Mode                                     `protobuf:"varint,6,opt,name=scale_mode,json=scaleMode,enum=mediapipe.ScaleMode_Mode" json:"scale_mode"`
	ConstantPadding   *bool                                                  `protobuf:"varint,7,opt,name=constant_padding,json=constantPadding,def=1" json:"constant_padding,omitempty"`
	PaddingColor      *ImageTransformationCalculatorOptions_Color            `protobuf:"bytes,8,opt,name=padding_color,json=paddingColor" json:"padding_color,omitempty"`
	InterpolationMode ImageTransformationCalculatorOptions_InterpolationMode `protobuf:"varint,9,opt,name=interpolation_mode,json=interpolationMode,enum=mediapipe.ImageTransformationCalculatorOptions_InterpolationMode" json:"interpolation_mode"`
}

func (m *ImageTransformationCalculatorOptions) Reset()      { *m = ImageTransformationCalculatorOptions{} }
func (*ImageTransformationCalculatorOptions) ProtoMessage() {}
func (*ImageTransformationCalculatorOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0b5829b530bd699, []int{0}
}
func (m *ImageTransformationCalculatorOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageTransformationCalculatorOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageTransformationCalculatorOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageTransformationCalculatorOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageTransformationCalculatorOptions.Merge(m, src)
}
func (m *ImageTransformationCalculatorOptions) XXX_Size() int {
	return m.Size()
}
func (m *ImageTransformationCalculatorOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageTransformationCalculatorOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ImageTransformationCalculatorOptions proto.InternalMessageInfo

const Default_ImageTransformationCalculatorOptions_OutputWidth int32 = 0
const Default_ImageTransformationCalculatorOptions_OutputHeight int32 = 0
const Default_ImageTransformationCalculatorOptions_FlipVertically bool = false
const Default_ImageTransformationCalculatorOptions_FlipHorizontally bool = false
const Default_ImageTransformationCalculatorOptions_ConstantPadding bool = true

func (m *ImageTransformationCalculatorOptions) GetOutputWidth() int32 {
	if m != nil && m.OutputWidth != nil {
		return *m.OutputWidth
	}
	return Default_ImageTransformationCalculatorOptions_OutputWidth
}

func (m *ImageTransformationCalculatorOptions) GetOutputHeight() int32 {
	if m != nil && m.OutputHeight != nil {
		return *m.OutputHeight
	}
	return Default_ImageTransformationCalculatorOptions_OutputHeight
}

func (m *ImageTransformationCalculatorOptions) GetRotationMode() RotationMode_Mode {
	if m != nil {
		return m.RotationMode
	}
	return ROTATION_MODE_UNKNOWN
}

func (m *ImageTransformationCalculatorOptions) GetFlipVertically() bool {
	if m != nil && m.FlipVertically != nil {
		return *m.FlipVertically
	}
	return Default_ImageTransformationCalculatorOptions_FlipVertically
}

func (m *ImageTransformationCalculatorOptions) GetFlipHorizontally() bool {
	if m != nil && m.FlipHorizontally != nil {
		return *m.FlipHorizontally
	}
	return Default_ImageTransformationCalculatorOptions_FlipHorizontally
}

func (m *ImageTransformationCalculatorOptions) GetScaleMode() gpu.ScaleMode_Mode {
	if m != nil {
		return m.ScaleMode
	}
	return gpu.SCALE_MODE_DEFAULT
}

func (m *ImageTransformationCalculatorOptions) GetConstantPadding() bool {
	if m != nil && m.ConstantPadding != nil {
		return *m.ConstantPadding
	}
	return Default_ImageTransformationCalculatorOptions_ConstantPadding
}

func (m *ImageTransformationCalculatorOptions) GetPaddingColor() *ImageTransformationCalculatorOptions_Color {
	if m != nil {
		return m.PaddingColor
	}
	return nil
}

func (m *ImageTransformationCalculatorOptions) GetInterpolationMode() ImageTransformationCalculatorOptions_InterpolationMode {
	if m != nil {
		return m.InterpolationMode
	}
	return INTERPOLATION_MODE_DEFAULT
}

var E_ImageTransformationCalculatorOptions_Ext = &proto.ExtensionDesc{
	ExtendedType:  (*framework.CalculatorOptions)(nil),
	ExtensionType: (*ImageTransformationCalculatorOptions)(nil),
	Field:         251952830,
	Name:          "mediapipe.ImageTransformationCalculatorOptions.ext",
	Tag:           "bytes,251952830,opt,name=ext",
	Filename:      "mediapipe/calculators/image/image_transformation_calculator.proto",
}

type ImageTransformationCalculatorOptions_Color struct {
	Red   *int32 `protobuf:"varint,1,opt,name=red,def=0" json:"red,omitempty"`
	Green *int32 `protobuf:"varint,2,opt,name=green,def=0" json:"green,omitempty"`
	Blue  *int32 `protobuf:"varint,3,opt,name=blue,def=0" json:"blue,omitempty"`
}

func (m *ImageTransformationCalculatorOptions_Color) Reset() {
	*m = ImageTransformationCalculatorOptions_Color{}
}
func (*ImageTransformationCalculatorOptions_Color) ProtoMessage() {}
func (*ImageTransformationCalculatorOptions_Color) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0b5829b530bd699, []int{0, 0}
}
func (m *ImageTransformationCalculatorOptions_Color) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageTransformationCalculatorOptions_Color) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageTransformationCalculatorOptions_Color.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageTransformationCalculatorOptions_Color) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageTransformationCalculatorOptions_Color.Merge(m, src)
}
func (m *ImageTransformationCalculatorOptions_Color) XXX_Size() int {
	return m.Size()
}
func (m *ImageTransformationCalculatorOptions_Color) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageTransformationCalculatorOptions_Color.DiscardUnknown(m)
}

var xxx_messageInfo_ImageTransformationCalculatorOptions_Color proto.InternalMessageInfo

const Default_ImageTransformationCalculatorOptions_Color_Red int32 = 0
const Default_ImageTransformationCalculatorOptions_Color_Green int32 = 0
const Default_ImageTransformationCalculatorOptions_Color_Blue int32 = 0

func (m *ImageTransformationCalculatorOptions_Color) GetRed() int32 {
	if m != nil && m.Red != nil {
		return *m.Red
	}
	return Default_ImageTransformationCalculatorOptions_Color_Red
}

func (m *ImageTransformationCalculatorOptions_Color) GetGreen() int32 {
	if m != nil && m.Green != nil {
		return *m.Green
	}
	return Default_ImageTransformationCalculatorOptions_Color_Green
}

func (m *ImageTransformationCalculatorOptions_Color) GetBlue() int32 {
	if m != nil && m.Blue != nil {
		return *m.Blue
	}
	return Default_ImageTransformationCalculatorOptions_Color_Blue
}

func init() {
	proto.RegisterEnum("mediapipe.ImageTransformationCalculatorOptions_InterpolationMode", ImageTransformationCalculatorOptions_InterpolationMode_name, ImageTransformationCalculatorOptions_InterpolationMode_value)
	proto.RegisterExtension(E_ImageTransformationCalculatorOptions_Ext)
	proto.RegisterType((*ImageTransformationCalculatorOptions)(nil), "mediapipe.ImageTransformationCalculatorOptions")
	proto.RegisterType((*ImageTransformationCalculatorOptions_Color)(nil), "mediapipe.ImageTransformationCalculatorOptions.Color")
}

func init() {
	proto.RegisterFile("mediapipe/calculators/image/image_transformation_calculator.proto", fileDescriptor_e0b5829b530bd699)
}

var fileDescriptor_e0b5829b530bd699 = []byte{
	// 633 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4f, 0x4f, 0xd4, 0x40,
	0x14, 0xef, 0xc0, 0xae, 0xc0, 0xf0, 0x6f, 0x19, 0x63, 0x2c, 0x1b, 0x1d, 0x37, 0x04, 0xcd, 0x7a,
	0x69, 0xcd, 0x26, 0xc6, 0x84, 0x83, 0xc9, 0x02, 0xab, 0x6c, 0xb2, 0xb0, 0xa4, 0xac, 0x9a, 0x70,
	0x69, 0x4a, 0x77, 0xb6, 0x3b, 0xb1, 0xed, 0x34, 0xd3, 0x29, 0xa0, 0x27, 0x3f, 0x80, 0x07, 0xfd,
	0x16, 0x7e, 0x0a, 0xbd, 0x72, 0xe4, 0xc8, 0xc9, 0x48, 0xb9, 0x78, 0xe4, 0x0b, 0x98, 0x98, 0x69,
	0x97, 0x6d, 0x59, 0x94, 0xc0, 0x65, 0x92, 0xf7, 0x7e, 0xef, 0xfd, 0x7e, 0xbf, 0x79, 0xf3, 0x32,
	0xb0, 0xee, 0x91, 0x2e, 0xb5, 0x02, 0x1a, 0x10, 0xdd, 0xb6, 0x5c, 0x3b, 0x72, 0x2d, 0xc1, 0x78,
	0xa8, 0x53, 0xcf, 0x72, 0x48, 0x7a, 0x9a, 0x82, 0x5b, 0x7e, 0xd8, 0x63, 0xdc, 0xb3, 0x04, 0x65,
	0xbe, 0x99, 0x95, 0x69, 0x01, 0x67, 0x82, 0xa1, 0xa9, 0x21, 0x45, 0x59, 0xbf, 0x8e, 0x8d, 0x33,
	0x91, 0x32, 0x78, 0xac, 0x4b, 0xd2, 0xde, 0xf2, 0x72, 0xd6, 0xd0, 0xe3, 0x96, 0x47, 0x0e, 0x18,
	0x7f, 0xaf, 0x8f, 0x2a, 0x94, 0x71, 0x56, 0xe5, 0x04, 0x91, 0x1e, 0xda, 0x96, 0x4b, 0x72, 0x2c,
	0x4b, 0x9f, 0x27, 0xe0, 0x72, 0x53, 0x6a, 0x74, 0x2e, 0x59, 0x5d, 0x1b, 0xf2, 0xb4, 0x03, 0x19,
	0x87, 0x68, 0x19, 0xce, 0xb0, 0x48, 0x04, 0x91, 0x30, 0x0f, 0x68, 0x57, 0xf4, 0x55, 0x50, 0x01,
	0xd5, 0xe2, 0x0a, 0x78, 0x66, 0x4c, 0xa7, 0xe9, 0x77, 0x32, 0x8b, 0x9e, 0xc0, 0xd9, 0x41, 0x55,
	0x9f, 0x50, 0xa7, 0x2f, 0xd4, 0xb1, 0x8b, 0xb2, 0x41, 0xf7, 0x46, 0x92, 0x46, 0xaf, 0xe1, 0xec,
	0xa5, 0x3b, 0xa9, 0xe3, 0x15, 0x50, 0x9d, 0xab, 0x3d, 0xd0, 0x86, 0x76, 0x35, 0x63, 0x80, 0x6f,
	0x4a, 0xb3, 0xf2, 0x58, 0x2d, 0x1c, 0xfd, 0x7c, 0xa4, 0x18, 0x33, 0x3c, 0x07, 0x20, 0x0d, 0xce,
	0xf7, 0x5c, 0x1a, 0x98, 0xfb, 0x84, 0x0b, 0x6a, 0x5b, 0xae, 0xfb, 0x41, 0x2d, 0x54, 0x40, 0x75,
	0x72, 0xa5, 0xd8, 0xb3, 0xdc, 0x90, 0x18, 0x73, 0x12, 0x7d, 0x3b, 0x04, 0x51, 0x0d, 0x2e, 0x24,
	0xf5, 0x7d, 0xc6, 0xe9, 0x47, 0xe6, 0x8b, 0xa4, 0xa3, 0x98, 0xef, 0x28, 0x49, 0x7c, 0x23, 0x07,
	0xa3, 0x97, 0x10, 0x66, 0x73, 0x53, 0xef, 0x24, 0x4e, 0x17, 0x73, 0x4e, 0x77, 0x24, 0x38, 0x6a,
	0x73, 0x2a, 0xbc, 0xc8, 0x22, 0x1d, 0x96, 0x6c, 0xe6, 0x87, 0xc2, 0xf2, 0x85, 0x19, 0x58, 0xdd,
	0x2e, 0xf5, 0x1d, 0x75, 0x22, 0x91, 0x2c, 0x08, 0x1e, 0x11, 0x63, 0xfe, 0x02, 0xdd, 0x4e, 0x41,
	0xb4, 0x0b, 0x67, 0x07, 0x75, 0xa6, 0xcd, 0x5c, 0xc6, 0xd5, 0xc9, 0x0a, 0xa8, 0x4e, 0xd7, 0x9e,
	0xe7, 0x34, 0x6f, 0xf2, 0x66, 0xda, 0x9a, 0x6c, 0x36, 0x66, 0x06, 0x5c, 0x49, 0x84, 0xf6, 0x21,
	0xa2, 0xbe, 0x20, 0x3c, 0x60, 0x6e, 0x6e, 0xfc, 0x53, 0xc9, 0xa5, 0xea, 0xb7, 0x15, 0x68, 0xe6,
	0x99, 0x72, 0x97, 0x5f, 0xa0, 0xa3, 0x40, 0xb9, 0x05, 0x8b, 0xa9, 0x81, 0xbb, 0x70, 0x9c, 0x93,
	0x6e, 0xb6, 0x3f, 0x32, 0x42, 0xf7, 0x61, 0xd1, 0xe1, 0x84, 0xf8, 0xd9, 0xbe, 0xa4, 0x31, 0xba,
	0x07, 0x0b, 0x7b, 0x6e, 0x94, 0xee, 0x47, 0x92, 0x4f, 0xc2, 0x25, 0x0e, 0x17, 0xae, 0x68, 0x23,
	0x0c, 0xcb, 0xcd, 0xad, 0x4e, 0xc3, 0xd8, 0x6e, 0xb7, 0xea, 0x9d, 0x66, 0x7b, 0xcb, 0xdc, 0x6c,
	0xaf, 0x37, 0xcc, 0xf5, 0xc6, 0xab, 0xfa, 0x9b, 0x56, 0xa7, 0xa4, 0xa0, 0x87, 0x70, 0xf1, 0x1f,
	0x78, 0xab, 0xb9, 0xd5, 0xa8, 0x1b, 0x25, 0xf0, 0x9f, 0x76, 0x09, 0x36, 0x76, 0x3a, 0xa5, 0xb1,
	0xda, 0x1e, 0x1c, 0x27, 0x87, 0x02, 0xe5, 0x77, 0xf4, 0xca, 0x44, 0xd4, 0xef, 0x7f, 0xbe, 0x1e,
	0x26, 0x8f, 0xa5, 0xdf, 0x72, 0x96, 0x86, 0x24, 0x5f, 0xfd, 0x01, 0x8e, 0x4f, 0xb1, 0x72, 0x72,
	0x8a, 0x95, 0xf3, 0x53, 0x0c, 0x3e, 0xc5, 0x18, 0x7c, 0x8b, 0x31, 0x38, 0x8a, 0x31, 0x38, 0x8e,
	0x31, 0xf8, 0x15, 0x63, 0xf0, 0x3b, 0xc6, 0xca, 0x79, 0x8c, 0xc1, 0x97, 0x33, 0xac, 0x1c, 0x9f,
	0x61, 0xe5, 0xe4, 0x0c, 0x2b, 0xf0, 0xb1, 0xcd, 0x3c, 0xcd, 0x61, 0xcc, 0x71, 0x49, 0x4e, 0x76,
	0xf4, 0x33, 0x58, 0x7d, 0x7a, 0x13, 0x23, 0xdb, 0xb2, 0x74, 0xf7, 0x85, 0x43, 0x45, 0x3f, 0xda,
	0xd3, 0x6c, 0xe6, 0xe9, 0x29, 0x71, 0xee, 0x83, 0xba, 0xe6, 0xab, 0xfa, 0x1b, 0x00, 0x00, 0xff,
	0xff, 0x06, 0x36, 0x9a, 0x20, 0x16, 0x05, 0x00, 0x00,
}

func (x ImageTransformationCalculatorOptions_InterpolationMode) String() string {
	s, ok := ImageTransformationCalculatorOptions_InterpolationMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ImageTransformationCalculatorOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageTransformationCalculatorOptions)
	if !ok {
		that2, ok := that.(ImageTransformationCalculatorOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OutputWidth != nil && that1.OutputWidth != nil {
		if *this.OutputWidth != *that1.OutputWidth {
			return false
		}
	} else if this.OutputWidth != nil {
		return false
	} else if that1.OutputWidth != nil {
		return false
	}
	if this.OutputHeight != nil && that1.OutputHeight != nil {
		if *this.OutputHeight != *that1.OutputHeight {
			return false
		}
	} else if this.OutputHeight != nil {
		return false
	} else if that1.OutputHeight != nil {
		return false
	}
	if this.RotationMode != that1.RotationMode {
		return false
	}
	if this.FlipVertically != nil && that1.FlipVertically != nil {
		if *this.FlipVertically != *that1.FlipVertically {
			return false
		}
	} else if this.FlipVertically != nil {
		return false
	} else if that1.FlipVertically != nil {
		return false
	}
	if this.FlipHorizontally != nil && that1.FlipHorizontally != nil {
		if *this.FlipHorizontally != *that1.FlipHorizontally {
			return false
		}
	} else if this.FlipHorizontally != nil {
		return false
	} else if that1.FlipHorizontally != nil {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.ConstantPadding != nil && that1.ConstantPadding != nil {
		if *this.ConstantPadding != *that1.ConstantPadding {
			return false
		}
	} else if this.ConstantPadding != nil {
		return false
	} else if that1.ConstantPadding != nil {
		return false
	}
	if !this.PaddingColor.Equal(that1.PaddingColor) {
		return false
	}
	if this.InterpolationMode != that1.InterpolationMode {
		return false
	}
	return true
}
func (this *ImageTransformationCalculatorOptions_Color) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageTransformationCalculatorOptions_Color)
	if !ok {
		that2, ok := that.(ImageTransformationCalculatorOptions_Color)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Red != nil && that1.Red != nil {
		if *this.Red != *that1.Red {
			return false
		}
	} else if this.Red != nil {
		return false
	} else if that1.Red != nil {
		return false
	}
	if this.Green != nil && that1.Green != nil {
		if *this.Green != *that1.Green {
			return false
		}
	} else if this.Green != nil {
		return false
	} else if that1.Green != nil {
		return false
	}
	if this.Blue != nil && that1.Blue != nil {
		if *this.Blue != *that1.Blue {
			return false
		}
	} else if this.Blue != nil {
		return false
	} else if that1.Blue != nil {
		return false
	}
	return true
}
func (this *ImageTransformationCalculatorOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&image.ImageTransformationCalculatorOptions{")
	if this.OutputWidth != nil {
		s = append(s, "OutputWidth: "+valueToGoStringImageTransformationCalculator(this.OutputWidth, "int32")+",\n")
	}
	if this.OutputHeight != nil {
		s = append(s, "OutputHeight: "+valueToGoStringImageTransformationCalculator(this.OutputHeight, "int32")+",\n")
	}
	s = append(s, "RotationMode: "+fmt.Sprintf("%#v", this.RotationMode)+",\n")
	if this.FlipVertically != nil {
		s = append(s, "FlipVertically: "+valueToGoStringImageTransformationCalculator(this.FlipVertically, "bool")+",\n")
	}
	if this.FlipHorizontally != nil {
		s = append(s, "FlipHorizontally: "+valueToGoStringImageTransformationCalculator(this.FlipHorizontally, "bool")+",\n")
	}
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	if this.ConstantPadding != nil {
		s = append(s, "ConstantPadding: "+valueToGoStringImageTransformationCalculator(this.ConstantPadding, "bool")+",\n")
	}
	if this.PaddingColor != nil {
		s = append(s, "PaddingColor: "+fmt.Sprintf("%#v", this.PaddingColor)+",\n")
	}
	s = append(s, "InterpolationMode: "+fmt.Sprintf("%#v", this.InterpolationMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageTransformationCalculatorOptions_Color) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&image.ImageTransformationCalculatorOptions_Color{")
	if this.Red != nil {
		s = append(s, "Red: "+valueToGoStringImageTransformationCalculator(this.Red, "int32")+",\n")
	}
	if this.Green != nil {
		s = append(s, "Green: "+valueToGoStringImageTransformationCalculator(this.Green, "int32")+",\n")
	}
	if this.Blue != nil {
		s = append(s, "Blue: "+valueToGoStringImageTransformationCalculator(this.Blue, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringImageTransformationCalculator(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ImageTransformationCalculatorOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageTransformationCalculatorOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageTransformationCalculatorOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(m.InterpolationMode))
	i--
	dAtA[i] = 0x48
	if m.PaddingColor != nil {
		{
			size, err := m.PaddingColor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ConstantPadding != nil {
		i--
		if *m.ConstantPadding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(m.ScaleMode))
	i--
	dAtA[i] = 0x30
	if m.FlipHorizontally != nil {
		i--
		if *m.FlipHorizontally {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.FlipVertically != nil {
		i--
		if *m.FlipVertically {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(m.RotationMode))
	i--
	dAtA[i] = 0x18
	if m.OutputHeight != nil {
		i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(*m.OutputHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.OutputWidth != nil {
		i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(*m.OutputWidth))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImageTransformationCalculatorOptions_Color) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageTransformationCalculatorOptions_Color) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageTransformationCalculatorOptions_Color) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Blue != nil {
		i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(*m.Blue))
		i--
		dAtA[i] = 0x18
	}
	if m.Green != nil {
		i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(*m.Green))
		i--
		dAtA[i] = 0x10
	}
	if m.Red != nil {
		i = encodeVarintImageTransformationCalculator(dAtA, i, uint64(*m.Red))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintImageTransformationCalculator(dAtA []byte, offset int, v uint64) int {
	offset -= sovImageTransformationCalculator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ImageTransformationCalculatorOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputWidth != nil {
		n += 1 + sovImageTransformationCalculator(uint64(*m.OutputWidth))
	}
	if m.OutputHeight != nil {
		n += 1 + sovImageTransformationCalculator(uint64(*m.OutputHeight))
	}
	n += 1 + sovImageTransformationCalculator(uint64(m.RotationMode))
	if m.FlipVertically != nil {
		n += 2
	}
	if m.FlipHorizontally != nil {
		n += 2
	}
	n += 1 + sovImageTransformationCalculator(uint64(m.ScaleMode))
	if m.ConstantPadding != nil {
		n += 2
	}
	if m.PaddingColor != nil {
		l = m.PaddingColor.Size()
		n += 1 + l + sovImageTransformationCalculator(uint64(l))
	}
	n += 1 + sovImageTransformationCalculator(uint64(m.InterpolationMode))
	return n
}

func (m *ImageTransformationCalculatorOptions_Color) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Red != nil {
		n += 1 + sovImageTransformationCalculator(uint64(*m.Red))
	}
	if m.Green != nil {
		n += 1 + sovImageTransformationCalculator(uint64(*m.Green))
	}
	if m.Blue != nil {
		n += 1 + sovImageTransformationCalculator(uint64(*m.Blue))
	}
	return n
}

func sovImageTransformationCalculator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozImageTransformationCalculator(x uint64) (n int) {
	return sovImageTransformationCalculator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ImageTransformationCalculatorOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageTransformationCalculatorOptions{`,
		`OutputWidth:` + valueToStringImageTransformationCalculator(this.OutputWidth) + `,`,
		`OutputHeight:` + valueToStringImageTransformationCalculator(this.OutputHeight) + `,`,
		`RotationMode:` + fmt.Sprintf("%v", this.RotationMode) + `,`,
		`FlipVertically:` + valueToStringImageTransformationCalculator(this.FlipVertically) + `,`,
		`FlipHorizontally:` + valueToStringImageTransformationCalculator(this.FlipHorizontally) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`ConstantPadding:` + valueToStringImageTransformationCalculator(this.ConstantPadding) + `,`,
		`PaddingColor:` + strings.Replace(fmt.Sprintf("%v", this.PaddingColor), "ImageTransformationCalculatorOptions_Color", "ImageTransformationCalculatorOptions_Color", 1) + `,`,
		`InterpolationMode:` + fmt.Sprintf("%v", this.InterpolationMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageTransformationCalculatorOptions_Color) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageTransformationCalculatorOptions_Color{`,
		`Red:` + valueToStringImageTransformationCalculator(this.Red) + `,`,
		`Green:` + valueToStringImageTransformationCalculator(this.Green) + `,`,
		`Blue:` + valueToStringImageTransformationCalculator(this.Blue) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringImageTransformationCalculator(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ImageTransformationCalculatorOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageTransformationCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageTransformationCalculatorOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageTransformationCalculatorOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputWidth = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputHeight = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RotationMode", wireType)
			}
			m.RotationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RotationMode |= RotationMode_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipVertically", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FlipVertically = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipHorizontally", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FlipHorizontally = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= gpu.ScaleMode_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstantPadding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ConstantPadding = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaddingColor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageTransformationCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageTransformationCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaddingColor == nil {
				m.PaddingColor = &ImageTransformationCalculatorOptions_Color{}
			}
			if err := m.PaddingColor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterpolationMode", wireType)
			}
			m.InterpolationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterpolationMode |= ImageTransformationCalculatorOptions_InterpolationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageTransformationCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageTransformationCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageTransformationCalculatorOptions_Color) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageTransformationCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Color: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Color: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Red", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Red = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Green", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Green = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blue = &v
		default:
			iNdEx = preIndex
			skippy, err := skipImageTransformationCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageTransformationCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImageTransformationCalculator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImageTransformationCalculator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageTransformationCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthImageTransformationCalculator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupImageTransformationCalculator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthImageTransformationCalculator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthImageTransformationCalculator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImageTransformationCalculator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupImageTransformationCalculator = fmt.Errorf("proto: unexpected end of group")
)
