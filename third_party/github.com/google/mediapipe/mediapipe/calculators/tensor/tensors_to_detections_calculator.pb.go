// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/calculators/tensor/tensors_to_detections_calculator.proto

package tensor

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	framework "github.com/google/mediapipe/mediapipe/framework"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TensorsToDetectionsCalculatorOptions_BoxFormat int32

const (
	BOX_FORMAT_UNSPECIFIED TensorsToDetectionsCalculatorOptions_BoxFormat = 0
	BOX_FORMAT_YXHW        TensorsToDetectionsCalculatorOptions_BoxFormat = 1
	BOX_FORMAT_XYWH        TensorsToDetectionsCalculatorOptions_BoxFormat = 2
	BOX_FORMAT_XYXY        TensorsToDetectionsCalculatorOptions_BoxFormat = 3
)

var TensorsToDetectionsCalculatorOptions_BoxFormat_name = map[int32]string{
	0: "BOX_FORMAT_UNSPECIFIED",
	1: "BOX_FORMAT_YXHW",
	2: "BOX_FORMAT_XYWH",
	3: "BOX_FORMAT_XYXY",
}

var TensorsToDetectionsCalculatorOptions_BoxFormat_value = map[string]int32{
	"BOX_FORMAT_UNSPECIFIED": 0,
	"BOX_FORMAT_YXHW":        1,
	"BOX_FORMAT_XYWH":        2,
	"BOX_FORMAT_XYXY":        3,
}

func (x TensorsToDetectionsCalculatorOptions_BoxFormat) Enum() *TensorsToDetectionsCalculatorOptions_BoxFormat {
	p := new(TensorsToDetectionsCalculatorOptions_BoxFormat)
	*p = x
	return p
}

func (x TensorsToDetectionsCalculatorOptions_BoxFormat) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TensorsToDetectionsCalculatorOptions_BoxFormat_name, int32(x))
}

func (x *TensorsToDetectionsCalculatorOptions_BoxFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorsToDetectionsCalculatorOptions_BoxFormat_value, data, "TensorsToDetectionsCalculatorOptions_BoxFormat")
	if err != nil {
		return err
	}
	*x = TensorsToDetectionsCalculatorOptions_BoxFormat(value)
	return nil
}

func (TensorsToDetectionsCalculatorOptions_BoxFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1017fbda3f902459, []int{0, 0}
}

type TensorsToDetectionsCalculatorOptions struct {
	NumClasses                int32                                               `protobuf:"varint,1,opt,name=num_classes,json=numClasses" json:"num_classes"`
	NumBoxes                  int32                                               `protobuf:"varint,2,opt,name=num_boxes,json=numBoxes" json:"num_boxes"`
	NumCoords                 int32                                               `protobuf:"varint,3,opt,name=num_coords,json=numCoords" json:"num_coords"`
	KeypointCoordOffset       int32                                               `protobuf:"varint,9,opt,name=keypoint_coord_offset,json=keypointCoordOffset" json:"keypoint_coord_offset"`
	NumKeypoints              *int32                                              `protobuf:"varint,10,opt,name=num_keypoints,json=numKeypoints,def=0" json:"num_keypoints,omitempty"`
	NumValuesPerKeypoint      *int32                                              `protobuf:"varint,11,opt,name=num_values_per_keypoint,json=numValuesPerKeypoint,def=2" json:"num_values_per_keypoint,omitempty"`
	BoxCoordOffset            *int32                                              `protobuf:"varint,12,opt,name=box_coord_offset,json=boxCoordOffset,def=0" json:"box_coord_offset,omitempty"`
	XScale                    *float32                                            `protobuf:"fixed32,4,opt,name=x_scale,json=xScale,def=0" json:"x_scale,omitempty"`
	YScale                    *float32                                            `protobuf:"fixed32,5,opt,name=y_scale,json=yScale,def=0" json:"y_scale,omitempty"`
	WScale                    *float32                                            `protobuf:"fixed32,6,opt,name=w_scale,json=wScale,def=0" json:"w_scale,omitempty"`
	HScale                    *float32                                            `protobuf:"fixed32,7,opt,name=h_scale,json=hScale,def=0" json:"h_scale,omitempty"`
	ApplyExponentialOnBoxSize *bool                                               `protobuf:"varint,13,opt,name=apply_exponential_on_box_size,json=applyExponentialOnBoxSize,def=0" json:"apply_exponential_on_box_size,omitempty"`
	ReverseOutputOrder        *bool                                               `protobuf:"varint,14,opt,name=reverse_output_order,json=reverseOutputOrder,def=0" json:"reverse_output_order,omitempty"`
	IgnoreClasses             []int32                                             `protobuf:"varint,8,rep,name=ignore_classes,json=ignoreClasses" json:"ignore_classes,omitempty"`
	AllowClasses              []int32                                             `protobuf:"varint,21,rep,packed,name=allow_classes,json=allowClasses" json:"allow_classes,omitempty"`
	SigmoidScore              *bool                                               `protobuf:"varint,15,opt,name=sigmoid_score,json=sigmoidScore,def=0" json:"sigmoid_score,omitempty"`
	ScoreClippingThresh       float32                                             `protobuf:"fixed32,16,opt,name=score_clipping_thresh,json=scoreClippingThresh" json:"score_clipping_thresh"`
	FlipVertically            *bool                                               `protobuf:"varint,18,opt,name=flip_vertically,json=flipVertically,def=0" json:"flip_vertically,omitempty"`
	MinScoreThresh            float32                                             `protobuf:"fixed32,19,opt,name=min_score_thresh,json=minScoreThresh" json:"min_score_thresh"`
	MaxResults                *int32                                              `protobuf:"varint,20,opt,name=max_results,json=maxResults,def=-1" json:"max_results,omitempty"`
	TensorMapping             *TensorsToDetectionsCalculatorOptions_TensorMapping `protobuf:"bytes,22,opt,name=tensor_mapping,json=tensorMapping" json:"tensor_mapping,omitempty"`
	// Types that are valid to be assigned to BoxIndices:
	//	*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_
	BoxIndices isTensorsToDetectionsCalculatorOptions_BoxIndices `protobuf_oneof:"box_indices"`
	BoxFormat  *TensorsToDetectionsCalculatorOptions_BoxFormat   `protobuf:"varint,24,opt,name=box_format,json=boxFormat,enum=mediapipe.TensorsToDetectionsCalculatorOptions_BoxFormat,def=0" json:"box_format,omitempty"`
}

func (m *TensorsToDetectionsCalculatorOptions) Reset()      { *m = TensorsToDetectionsCalculatorOptions{} }
func (*TensorsToDetectionsCalculatorOptions) ProtoMessage() {}
func (*TensorsToDetectionsCalculatorOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1017fbda3f902459, []int{0}
}
func (m *TensorsToDetectionsCalculatorOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorsToDetectionsCalculatorOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorsToDetectionsCalculatorOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorsToDetectionsCalculatorOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions.Merge(m, src)
}
func (m *TensorsToDetectionsCalculatorOptions) XXX_Size() int {
	return m.Size()
}
func (m *TensorsToDetectionsCalculatorOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TensorsToDetectionsCalculatorOptions proto.InternalMessageInfo

const Default_TensorsToDetectionsCalculatorOptions_NumKeypoints int32 = 0
const Default_TensorsToDetectionsCalculatorOptions_NumValuesPerKeypoint int32 = 2
const Default_TensorsToDetectionsCalculatorOptions_BoxCoordOffset int32 = 0
const Default_TensorsToDetectionsCalculatorOptions_XScale float32 = 0
const Default_TensorsToDetectionsCalculatorOptions_YScale float32 = 0
const Default_TensorsToDetectionsCalculatorOptions_WScale float32 = 0
const Default_TensorsToDetectionsCalculatorOptions_HScale float32 = 0
const Default_TensorsToDetectionsCalculatorOptions_ApplyExponentialOnBoxSize bool = false
const Default_TensorsToDetectionsCalculatorOptions_ReverseOutputOrder bool = false
const Default_TensorsToDetectionsCalculatorOptions_SigmoidScore bool = false
const Default_TensorsToDetectionsCalculatorOptions_FlipVertically bool = false
const Default_TensorsToDetectionsCalculatorOptions_MaxResults int32 = -1
const Default_TensorsToDetectionsCalculatorOptions_BoxFormat TensorsToDetectionsCalculatorOptions_BoxFormat = BOX_FORMAT_UNSPECIFIED

type isTensorsToDetectionsCalculatorOptions_BoxIndices interface {
	isTensorsToDetectionsCalculatorOptions_BoxIndices()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_ struct {
	BoxBoundariesIndices *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices `protobuf:"bytes,23,opt,name=box_boundaries_indices,json=boxBoundariesIndices,oneof" json:"box_boundaries_indices,omitempty"`
}

func (*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) isTensorsToDetectionsCalculatorOptions_BoxIndices() {
}

func (m *TensorsToDetectionsCalculatorOptions) GetBoxIndices() isTensorsToDetectionsCalculatorOptions_BoxIndices {
	if m != nil {
		return m.BoxIndices
	}
	return nil
}

func (m *TensorsToDetectionsCalculatorOptions) GetNumClasses() int32 {
	if m != nil {
		return m.NumClasses
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetNumBoxes() int32 {
	if m != nil {
		return m.NumBoxes
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetNumCoords() int32 {
	if m != nil {
		return m.NumCoords
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetKeypointCoordOffset() int32 {
	if m != nil {
		return m.KeypointCoordOffset
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetNumKeypoints() int32 {
	if m != nil && m.NumKeypoints != nil {
		return *m.NumKeypoints
	}
	return Default_TensorsToDetectionsCalculatorOptions_NumKeypoints
}

func (m *TensorsToDetectionsCalculatorOptions) GetNumValuesPerKeypoint() int32 {
	if m != nil && m.NumValuesPerKeypoint != nil {
		return *m.NumValuesPerKeypoint
	}
	return Default_TensorsToDetectionsCalculatorOptions_NumValuesPerKeypoint
}

func (m *TensorsToDetectionsCalculatorOptions) GetBoxCoordOffset() int32 {
	if m != nil && m.BoxCoordOffset != nil {
		return *m.BoxCoordOffset
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxCoordOffset
}

func (m *TensorsToDetectionsCalculatorOptions) GetXScale() float32 {
	if m != nil && m.XScale != nil {
		return *m.XScale
	}
	return Default_TensorsToDetectionsCalculatorOptions_XScale
}

func (m *TensorsToDetectionsCalculatorOptions) GetYScale() float32 {
	if m != nil && m.YScale != nil {
		return *m.YScale
	}
	return Default_TensorsToDetectionsCalculatorOptions_YScale
}

func (m *TensorsToDetectionsCalculatorOptions) GetWScale() float32 {
	if m != nil && m.WScale != nil {
		return *m.WScale
	}
	return Default_TensorsToDetectionsCalculatorOptions_WScale
}

func (m *TensorsToDetectionsCalculatorOptions) GetHScale() float32 {
	if m != nil && m.HScale != nil {
		return *m.HScale
	}
	return Default_TensorsToDetectionsCalculatorOptions_HScale
}

func (m *TensorsToDetectionsCalculatorOptions) GetApplyExponentialOnBoxSize() bool {
	if m != nil && m.ApplyExponentialOnBoxSize != nil {
		return *m.ApplyExponentialOnBoxSize
	}
	return Default_TensorsToDetectionsCalculatorOptions_ApplyExponentialOnBoxSize
}

func (m *TensorsToDetectionsCalculatorOptions) GetReverseOutputOrder() bool {
	if m != nil && m.ReverseOutputOrder != nil {
		return *m.ReverseOutputOrder
	}
	return Default_TensorsToDetectionsCalculatorOptions_ReverseOutputOrder
}

func (m *TensorsToDetectionsCalculatorOptions) GetIgnoreClasses() []int32 {
	if m != nil {
		return m.IgnoreClasses
	}
	return nil
}

func (m *TensorsToDetectionsCalculatorOptions) GetAllowClasses() []int32 {
	if m != nil {
		return m.AllowClasses
	}
	return nil
}

func (m *TensorsToDetectionsCalculatorOptions) GetSigmoidScore() bool {
	if m != nil && m.SigmoidScore != nil {
		return *m.SigmoidScore
	}
	return Default_TensorsToDetectionsCalculatorOptions_SigmoidScore
}

func (m *TensorsToDetectionsCalculatorOptions) GetScoreClippingThresh() float32 {
	if m != nil {
		return m.ScoreClippingThresh
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetFlipVertically() bool {
	if m != nil && m.FlipVertically != nil {
		return *m.FlipVertically
	}
	return Default_TensorsToDetectionsCalculatorOptions_FlipVertically
}

func (m *TensorsToDetectionsCalculatorOptions) GetMinScoreThresh() float32 {
	if m != nil {
		return m.MinScoreThresh
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions) GetMaxResults() int32 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return Default_TensorsToDetectionsCalculatorOptions_MaxResults
}

func (m *TensorsToDetectionsCalculatorOptions) GetTensorMapping() *TensorsToDetectionsCalculatorOptions_TensorMapping {
	if m != nil {
		return m.TensorMapping
	}
	return nil
}

func (m *TensorsToDetectionsCalculatorOptions) GetBoxBoundariesIndices() *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices {
	if x, ok := m.GetBoxIndices().(*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_); ok {
		return x.BoxBoundariesIndices
	}
	return nil
}

func (m *TensorsToDetectionsCalculatorOptions) GetBoxFormat() TensorsToDetectionsCalculatorOptions_BoxFormat {
	if m != nil && m.BoxFormat != nil {
		return *m.BoxFormat
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxFormat
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TensorsToDetectionsCalculatorOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_)(nil),
	}
}

var E_TensorsToDetectionsCalculatorOptions_Ext = &proto.ExtensionDesc{
	ExtendedType:  (*framework.CalculatorOptions)(nil),
	ExtensionType: (*TensorsToDetectionsCalculatorOptions)(nil),
	Field:         335742639,
	Name:          "mediapipe.TensorsToDetectionsCalculatorOptions.ext",
	Tag:           "bytes,335742639,opt,name=ext",
	Filename:      "mediapipe/calculators/tensor/tensors_to_detections_calculator.proto",
}

type TensorsToDetectionsCalculatorOptions_TensorMapping struct {
	DetectionsTensorIndex    int32 `protobuf:"varint,1,opt,name=detections_tensor_index,json=detectionsTensorIndex" json:"detections_tensor_index"`
	ClassesTensorIndex       int32 `protobuf:"varint,2,opt,name=classes_tensor_index,json=classesTensorIndex" json:"classes_tensor_index"`
	ScoresTensorIndex        int32 `protobuf:"varint,3,opt,name=scores_tensor_index,json=scoresTensorIndex" json:"scores_tensor_index"`
	NumDetectionsTensorIndex int32 `protobuf:"varint,4,opt,name=num_detections_tensor_index,json=numDetectionsTensorIndex" json:"num_detections_tensor_index"`
	AnchorsTensorIndex       int32 `protobuf:"varint,5,opt,name=anchors_tensor_index,json=anchorsTensorIndex" json:"anchors_tensor_index"`
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) Reset() {
	*m = TensorsToDetectionsCalculatorOptions_TensorMapping{}
}
func (*TensorsToDetectionsCalculatorOptions_TensorMapping) ProtoMessage() {}
func (*TensorsToDetectionsCalculatorOptions_TensorMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_1017fbda3f902459, []int{0, 0}
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorsToDetectionsCalculatorOptions_TensorMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions_TensorMapping.Merge(m, src)
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) XXX_Size() int {
	return m.Size()
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions_TensorMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TensorsToDetectionsCalculatorOptions_TensorMapping proto.InternalMessageInfo

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) GetDetectionsTensorIndex() int32 {
	if m != nil {
		return m.DetectionsTensorIndex
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) GetClassesTensorIndex() int32 {
	if m != nil {
		return m.ClassesTensorIndex
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) GetScoresTensorIndex() int32 {
	if m != nil {
		return m.ScoresTensorIndex
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) GetNumDetectionsTensorIndex() int32 {
	if m != nil {
		return m.NumDetectionsTensorIndex
	}
	return 0
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) GetAnchorsTensorIndex() int32 {
	if m != nil {
		return m.AnchorsTensorIndex
	}
	return 0
}

type TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices struct {
	Ymin *int32 `protobuf:"varint,1,opt,name=ymin,def=0" json:"ymin,omitempty"`
	Xmin *int32 `protobuf:"varint,2,opt,name=xmin,def=1" json:"xmin,omitempty"`
	Ymax *int32 `protobuf:"varint,3,opt,name=ymax,def=2" json:"ymax,omitempty"`
	Xmax *int32 `protobuf:"varint,4,opt,name=xmax,def=3" json:"xmax,omitempty"`
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Reset() {
	*m = TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices{}
}
func (*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) ProtoMessage() {}
func (*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Descriptor() ([]byte, []int) {
	return fileDescriptor_1017fbda3f902459, []int{0, 1}
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices.Merge(m, src)
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) XXX_Size() int {
	return m.Size()
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices.DiscardUnknown(m)
}

var xxx_messageInfo_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices proto.InternalMessageInfo

const Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Ymin int32 = 0
const Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Xmin int32 = 1
const Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Ymax int32 = 2
const Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Xmax int32 = 3

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) GetYmin() int32 {
	if m != nil && m.Ymin != nil {
		return *m.Ymin
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Ymin
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) GetXmin() int32 {
	if m != nil && m.Xmin != nil {
		return *m.Xmin
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Xmin
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) GetYmax() int32 {
	if m != nil && m.Ymax != nil {
		return *m.Ymax
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Ymax
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) GetXmax() int32 {
	if m != nil && m.Xmax != nil {
		return *m.Xmax
	}
	return Default_TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_Xmax
}

func init() {
	proto.RegisterEnum("mediapipe.TensorsToDetectionsCalculatorOptions_BoxFormat", TensorsToDetectionsCalculatorOptions_BoxFormat_name, TensorsToDetectionsCalculatorOptions_BoxFormat_value)
	proto.RegisterExtension(E_TensorsToDetectionsCalculatorOptions_Ext)
	proto.RegisterType((*TensorsToDetectionsCalculatorOptions)(nil), "mediapipe.TensorsToDetectionsCalculatorOptions")
	proto.RegisterType((*TensorsToDetectionsCalculatorOptions_TensorMapping)(nil), "mediapipe.TensorsToDetectionsCalculatorOptions.TensorMapping")
	proto.RegisterType((*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices)(nil), "mediapipe.TensorsToDetectionsCalculatorOptions.BoxBoundariesIndices")
}

func init() {
	proto.RegisterFile("mediapipe/calculators/tensor/tensors_to_detections_calculator.proto", fileDescriptor_1017fbda3f902459)
}

var fileDescriptor_1017fbda3f902459 = []byte{
	// 1006 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0x4f, 0x53, 0x23, 0xc5,
	0x1b, 0xc7, 0x33, 0x01, 0x76, 0xa1, 0x21, 0x21, 0xbf, 0x26, 0xc0, 0xfc, 0x50, 0xc7, 0xb8, 0x7f,
	0x34, 0xa5, 0x65, 0xe2, 0xa2, 0xa5, 0x48, 0xe9, 0xc1, 0x04, 0x10, 0xca, 0x5a, 0xb3, 0x35, 0xe0,
	0x2e, 0x78, 0xe9, 0xea, 0x4c, 0x3a, 0x49, 0xd7, 0xce, 0x74, 0x4f, 0x75, 0xcf, 0xc0, 0x64, 0xcb,
	0x83, 0x2f, 0x40, 0xab, 0x7c, 0x09, 0x1e, 0xbd, 0x79, 0xf5, 0x25, 0xec, 0x91, 0xe3, 0x9e, 0x2c,
	0x09, 0x17, 0x0f, 0x1e, 0xf6, 0x25, 0x58, 0xdd, 0x33, 0x19, 0x1a, 0x76, 0xb1, 0x5c, 0x4f, 0x54,
	0x3f, 0xdf, 0xcf, 0xf7, 0x79, 0x9e, 0x74, 0x3f, 0xdd, 0x03, 0x68, 0x07, 0xa4, 0x47, 0x71, 0x48,
	0x43, 0xd2, 0xf4, 0xb0, 0xef, 0xc5, 0x3e, 0x8e, 0xb8, 0x90, 0xcd, 0x88, 0x30, 0xc9, 0x45, 0xf6,
	0x47, 0xa2, 0x88, 0xa3, 0x1e, 0x89, 0x88, 0x17, 0x51, 0xce, 0x24, 0xba, 0x00, 0x1b, 0xa1, 0xe0,
	0x11, 0x87, 0x73, 0x79, 0x92, 0xb5, 0x3b, 0x17, 0xf9, 0xfa, 0x02, 0x07, 0xe4, 0x84, 0x8b, 0xc7,
	0xcd, 0xab, 0x86, 0x5b, 0x7f, 0x95, 0xc1, 0x9d, 0x83, 0x34, 0xf7, 0x01, 0xdf, 0xca, 0x33, 0xb7,
	0x73, 0xae, 0x13, 0xea, 0x00, 0xbc, 0x0b, 0xe6, 0x59, 0x1c, 0x20, 0xcf, 0xc7, 0x52, 0x12, 0x69,
	0x5b, 0x35, 0xab, 0x3e, 0xd3, 0x9a, 0x7e, 0xfa, 0xfb, 0x9b, 0x05, 0x17, 0xb0, 0x38, 0x68, 0xa7,
	0x71, 0xf8, 0x16, 0x98, 0x53, 0x58, 0x97, 0x27, 0x44, 0xda, 0x45, 0x03, 0x9a, 0x65, 0x71, 0xd0,
	0x52, 0x51, 0x78, 0x1b, 0x00, 0x9d, 0x89, 0x73, 0xd1, 0x93, 0xf6, 0x94, 0xc1, 0x28, 0x6b, 0x5b,
	0x87, 0xe1, 0x06, 0x58, 0x7e, 0x4c, 0x46, 0x21, 0xa7, 0x2c, 0x4a, 0x49, 0xc4, 0xfb, 0x7d, 0x49,
	0x22, 0x7b, 0xce, 0xe0, 0x97, 0x26, 0x88, 0x36, 0x75, 0x34, 0x00, 0xdf, 0x06, 0x25, 0x95, 0x7e,
	0x22, 0x49, 0x1b, 0x28, 0xc7, 0xa6, 0xf5, 0x81, 0xbb, 0xc0, 0xe2, 0xe0, 0xab, 0x49, 0x18, 0x6e,
	0x80, 0x55, 0xc5, 0x1d, 0x63, 0x3f, 0x26, 0x12, 0x85, 0x44, 0xe4, 0x16, 0x7b, 0x3e, 0x75, 0xac,
	0xbb, 0x55, 0x16, 0x07, 0x0f, 0x35, 0xf0, 0x80, 0x88, 0x89, 0x15, 0xbe, 0x07, 0x2a, 0x5d, 0x9e,
	0x5c, 0x6e, 0x6b, 0x61, 0x52, 0xa4, 0xdc, 0xe5, 0x89, 0xd9, 0xce, 0x1a, 0xb8, 0x99, 0x20, 0xe9,
	0x61, 0x9f, 0xd8, 0xd3, 0x35, 0xab, 0x5e, 0x54, 0xcc, 0x8d, 0x64, 0x5f, 0x05, 0x94, 0x36, 0xca,
	0xb4, 0x99, 0x5c, 0x1b, 0xe5, 0xda, 0x49, 0xa6, 0xdd, 0xc8, 0xb5, 0x93, 0x5c, 0x1b, 0x66, 0xda,
	0xcd, 0x5c, 0x1b, 0xa6, 0xda, 0x97, 0xe0, 0x0d, 0x1c, 0x86, 0xfe, 0x08, 0x91, 0x24, 0xe4, 0x8c,
	0xb0, 0x88, 0x62, 0x1f, 0x71, 0xa6, 0x4e, 0x04, 0x49, 0xfa, 0x84, 0xd8, 0xa5, 0x9a, 0x55, 0x9f,
	0xdd, 0x9c, 0xe9, 0x63, 0x5f, 0x12, 0xf7, 0xff, 0x9a, 0xdd, 0xbe, 0x40, 0x3b, 0xac, 0xc5, 0x93,
	0x7d, 0xfa, 0x84, 0xc0, 0x4f, 0x40, 0x55, 0x90, 0x63, 0x22, 0x24, 0x41, 0x3c, 0x8e, 0xc2, 0x38,
	0x42, 0x5c, 0xf4, 0x88, 0xb0, 0xcb, 0xa6, 0x1f, 0x66, 0x48, 0x47, 0x13, 0x1d, 0x05, 0xc0, 0xbb,
	0xa0, 0x4c, 0x07, 0x8c, 0x0b, 0x92, 0x0f, 0xcb, 0x6c, 0x6d, 0xaa, 0x3e, 0xe3, 0x96, 0xd2, 0xe8,
	0x64, 0x52, 0xde, 0x01, 0x25, 0xec, 0xfb, 0xfc, 0x24, 0xa7, 0x96, 0x15, 0xd5, 0x2a, 0x56, 0x2c,
	0x77, 0x41, 0x0b, 0x13, 0xf0, 0x5d, 0x50, 0x92, 0x74, 0x10, 0x70, 0xda, 0x43, 0xd2, 0xe3, 0x82,
	0xd8, 0x8b, 0x66, 0x07, 0x0b, 0x99, 0xb6, 0xaf, 0x24, 0x35, 0x36, 0x9a, 0x41, 0x9e, 0x4f, 0xc3,
	0x90, 0xb2, 0x01, 0x8a, 0x86, 0x82, 0xc8, 0xa1, 0x5d, 0x51, 0xfb, 0x34, 0x19, 0x1b, 0x8d, 0xb4,
	0x33, 0xe2, 0x40, 0x03, 0xb0, 0x01, 0x16, 0xfb, 0x3e, 0x0d, 0xd1, 0x31, 0x11, 0x11, 0xf5, 0xb0,
	0xef, 0x8f, 0x6c, 0x68, 0xd6, 0x29, 0x2b, 0xf5, 0x61, 0x2e, 0xc2, 0x06, 0xa8, 0x04, 0x94, 0xa5,
	0x1d, 0x4d, 0x8a, 0x2c, 0x19, 0x45, 0xca, 0x01, 0x65, 0xba, 0xa7, 0x2c, 0xff, 0x6d, 0x30, 0x1f,
	0xe0, 0x04, 0x09, 0x22, 0x63, 0x3f, 0x92, 0x76, 0x55, 0xcf, 0x4b, 0xf1, 0xfd, 0x7b, 0x2e, 0x08,
	0x70, 0xe2, 0xa6, 0x51, 0xd8, 0x03, 0xe5, 0xf4, 0xa2, 0xa3, 0x00, 0xeb, 0xe6, 0xec, 0x95, 0x9a,
	0x55, 0x9f, 0x5f, 0xff, 0xbc, 0x91, 0x5f, 0xe6, 0xc6, 0xbf, 0xb9, 0xad, 0x19, 0x74, 0x3f, 0x4d,
	0xe2, 0x96, 0x22, 0x73, 0x09, 0xbf, 0x03, 0x2b, 0x6a, 0x1a, 0xba, 0x3c, 0x66, 0x3d, 0x2c, 0x28,
	0x91, 0x88, 0xb2, 0x1e, 0xf5, 0x88, 0xb4, 0x57, 0x75, 0xb5, 0xad, 0x57, 0xad, 0xd6, 0xe2, 0x49,
	0x2b, 0x4f, 0xb6, 0x97, 0xe6, 0xda, 0x2d, 0xb8, 0xd5, 0xee, 0x4b, 0xe2, 0x30, 0x04, 0x40, 0x55,
	0xef, 0x73, 0x11, 0xe0, 0xc8, 0xb6, 0x6b, 0x56, 0xbd, 0xbc, 0xfe, 0xe9, 0x7f, 0xa8, 0xb8, 0xa3,
	0x13, 0x6c, 0xae, 0xb4, 0x3a, 0x87, 0x68, 0xa7, 0xe3, 0xde, 0xff, 0xe2, 0x00, 0x7d, 0xf3, 0xf5,
	0xfe, 0x83, 0xed, 0xf6, 0xde, 0xce, 0xde, 0xf6, 0x96, 0x3b, 0xd7, 0x9d, 0x20, 0x6b, 0xbf, 0x15,
	0x41, 0xe9, 0xd2, 0x86, 0xc0, 0xcf, 0xc0, 0xaa, 0xf1, 0x8a, 0x66, 0x5b, 0x4e, 0x59, 0x8f, 0x24,
	0x97, 0x1e, 0xb6, 0xe5, 0x0b, 0x28, 0xf5, 0xef, 0x29, 0x04, 0x7e, 0x0c, 0xaa, 0xd9, 0xcc, 0x5e,
	0xb6, 0x9a, 0xcf, 0x1d, 0xcc, 0x08, 0xd3, 0xf7, 0x11, 0x48, 0x27, 0xef, 0x8a, 0xcd, 0x7c, 0x01,
	0xff, 0x97, 0x02, 0xa6, 0xab, 0x0d, 0x5e, 0x53, 0xef, 0xd4, 0x75, 0xfd, 0x4e, 0x1b, 0x6e, 0x9b,
	0xc5, 0xc1, 0xd6, 0x75, 0x2d, 0x63, 0xe6, 0x0d, 0xf5, 0x17, 0xc4, 0x74, 0xcf, 0x98, 0x2d, 0x67,
	0x84, 0xe1, 0x5b, 0x13, 0xa0, 0xfa, 0xb2, 0xc3, 0x85, 0xcb, 0x60, 0x7a, 0x14, 0x50, 0x96, 0xee,
	0x96, 0x7a, 0x7e, 0xf4, 0x52, 0x85, 0x13, 0x15, 0x2e, 0xa6, 0xe1, 0x7b, 0xae, 0x5e, 0xa6, 0x34,
	0xce, 0x7e, 0xa9, 0x7a, 0x57, 0xf5, 0x32, 0xa5, 0x71, 0xf6, 0x13, 0x36, 0xad, 0x0f, 0x5d, 0xbd,
	0xbc, 0xd5, 0x07, 0x73, 0xf9, 0xf1, 0xc2, 0x35, 0x70, 0xcd, 0x01, 0x57, 0x0a, 0x70, 0x09, 0x2c,
	0x1a, 0xda, 0xd1, 0xe1, 0xee, 0xa3, 0x8a, 0x75, 0x25, 0x78, 0x78, 0xf4, 0x68, 0xb7, 0x52, 0x7c,
	0x21, 0x78, 0x78, 0x54, 0x99, 0x5a, 0xf7, 0xc0, 0x14, 0x49, 0x22, 0xf8, 0xba, 0x31, 0x7b, 0x2f,
	0x0c, 0x9a, 0xfd, 0xeb, 0x8f, 0x3f, 0xfc, 0x6c, 0xe9, 0x5b, 0xd1, 0x7c, 0xc5, 0x19, 0x75, 0x55,
	0xf6, 0x56, 0x09, 0xcc, 0xab, 0x69, 0xcf, 0x2e, 0x58, 0x8b, 0x9d, 0x9e, 0x39, 0x85, 0x67, 0x67,
	0x4e, 0xe1, 0xf9, 0x99, 0x63, 0x7d, 0x3f, 0x76, 0xac, 0x5f, 0xc6, 0x8e, 0xf5, 0x74, 0xec, 0x58,
	0xa7, 0x63, 0xc7, 0xfa, 0x63, 0xec, 0x58, 0x7f, 0x8e, 0x9d, 0xc2, 0xf3, 0xb1, 0x63, 0xfd, 0x74,
	0xee, 0x14, 0x4e, 0xcf, 0x9d, 0xc2, 0xb3, 0x73, 0xa7, 0xf0, 0xed, 0xc6, 0x80, 0x46, 0xc3, 0xb8,
	0xdb, 0xf0, 0x78, 0xd0, 0x1c, 0x70, 0x3e, 0xf0, 0x49, 0xf3, 0xe2, 0xe3, 0xfe, 0x4f, 0xff, 0x36,
	0xfc, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x18, 0x25, 0xb7, 0x49, 0x55, 0x08, 0x00, 0x00,
}

func (x TensorsToDetectionsCalculatorOptions_BoxFormat) String() string {
	s, ok := TensorsToDetectionsCalculatorOptions_BoxFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TensorsToDetectionsCalculatorOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorsToDetectionsCalculatorOptions)
	if !ok {
		that2, ok := that.(TensorsToDetectionsCalculatorOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumClasses != that1.NumClasses {
		return false
	}
	if this.NumBoxes != that1.NumBoxes {
		return false
	}
	if this.NumCoords != that1.NumCoords {
		return false
	}
	if this.KeypointCoordOffset != that1.KeypointCoordOffset {
		return false
	}
	if this.NumKeypoints != nil && that1.NumKeypoints != nil {
		if *this.NumKeypoints != *that1.NumKeypoints {
			return false
		}
	} else if this.NumKeypoints != nil {
		return false
	} else if that1.NumKeypoints != nil {
		return false
	}
	if this.NumValuesPerKeypoint != nil && that1.NumValuesPerKeypoint != nil {
		if *this.NumValuesPerKeypoint != *that1.NumValuesPerKeypoint {
			return false
		}
	} else if this.NumValuesPerKeypoint != nil {
		return false
	} else if that1.NumValuesPerKeypoint != nil {
		return false
	}
	if this.BoxCoordOffset != nil && that1.BoxCoordOffset != nil {
		if *this.BoxCoordOffset != *that1.BoxCoordOffset {
			return false
		}
	} else if this.BoxCoordOffset != nil {
		return false
	} else if that1.BoxCoordOffset != nil {
		return false
	}
	if this.XScale != nil && that1.XScale != nil {
		if *this.XScale != *that1.XScale {
			return false
		}
	} else if this.XScale != nil {
		return false
	} else if that1.XScale != nil {
		return false
	}
	if this.YScale != nil && that1.YScale != nil {
		if *this.YScale != *that1.YScale {
			return false
		}
	} else if this.YScale != nil {
		return false
	} else if that1.YScale != nil {
		return false
	}
	if this.WScale != nil && that1.WScale != nil {
		if *this.WScale != *that1.WScale {
			return false
		}
	} else if this.WScale != nil {
		return false
	} else if that1.WScale != nil {
		return false
	}
	if this.HScale != nil && that1.HScale != nil {
		if *this.HScale != *that1.HScale {
			return false
		}
	} else if this.HScale != nil {
		return false
	} else if that1.HScale != nil {
		return false
	}
	if this.ApplyExponentialOnBoxSize != nil && that1.ApplyExponentialOnBoxSize != nil {
		if *this.ApplyExponentialOnBoxSize != *that1.ApplyExponentialOnBoxSize {
			return false
		}
	} else if this.ApplyExponentialOnBoxSize != nil {
		return false
	} else if that1.ApplyExponentialOnBoxSize != nil {
		return false
	}
	if this.ReverseOutputOrder != nil && that1.ReverseOutputOrder != nil {
		if *this.ReverseOutputOrder != *that1.ReverseOutputOrder {
			return false
		}
	} else if this.ReverseOutputOrder != nil {
		return false
	} else if that1.ReverseOutputOrder != nil {
		return false
	}
	if len(this.IgnoreClasses) != len(that1.IgnoreClasses) {
		return false
	}
	for i := range this.IgnoreClasses {
		if this.IgnoreClasses[i] != that1.IgnoreClasses[i] {
			return false
		}
	}
	if len(this.AllowClasses) != len(that1.AllowClasses) {
		return false
	}
	for i := range this.AllowClasses {
		if this.AllowClasses[i] != that1.AllowClasses[i] {
			return false
		}
	}
	if this.SigmoidScore != nil && that1.SigmoidScore != nil {
		if *this.SigmoidScore != *that1.SigmoidScore {
			return false
		}
	} else if this.SigmoidScore != nil {
		return false
	} else if that1.SigmoidScore != nil {
		return false
	}
	if this.ScoreClippingThresh != that1.ScoreClippingThresh {
		return false
	}
	if this.FlipVertically != nil && that1.FlipVertically != nil {
		if *this.FlipVertically != *that1.FlipVertically {
			return false
		}
	} else if this.FlipVertically != nil {
		return false
	} else if that1.FlipVertically != nil {
		return false
	}
	if this.MinScoreThresh != that1.MinScoreThresh {
		return false
	}
	if this.MaxResults != nil && that1.MaxResults != nil {
		if *this.MaxResults != *that1.MaxResults {
			return false
		}
	} else if this.MaxResults != nil {
		return false
	} else if that1.MaxResults != nil {
		return false
	}
	if !this.TensorMapping.Equal(that1.TensorMapping) {
		return false
	}
	if that1.BoxIndices == nil {
		if this.BoxIndices != nil {
			return false
		}
	} else if this.BoxIndices == nil {
		return false
	} else if !this.BoxIndices.Equal(that1.BoxIndices) {
		return false
	}
	if this.BoxFormat != nil && that1.BoxFormat != nil {
		if *this.BoxFormat != *that1.BoxFormat {
			return false
		}
	} else if this.BoxFormat != nil {
		return false
	} else if that1.BoxFormat != nil {
		return false
	}
	return true
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_)
	if !ok {
		that2, ok := that.(TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BoxBoundariesIndices.Equal(that1.BoxBoundariesIndices) {
		return false
	}
	return true
}
func (this *TensorsToDetectionsCalculatorOptions_TensorMapping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorsToDetectionsCalculatorOptions_TensorMapping)
	if !ok {
		that2, ok := that.(TensorsToDetectionsCalculatorOptions_TensorMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DetectionsTensorIndex != that1.DetectionsTensorIndex {
		return false
	}
	if this.ClassesTensorIndex != that1.ClassesTensorIndex {
		return false
	}
	if this.ScoresTensorIndex != that1.ScoresTensorIndex {
		return false
	}
	if this.NumDetectionsTensorIndex != that1.NumDetectionsTensorIndex {
		return false
	}
	if this.AnchorsTensorIndex != that1.AnchorsTensorIndex {
		return false
	}
	return true
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices)
	if !ok {
		that2, ok := that.(TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ymin != nil && that1.Ymin != nil {
		if *this.Ymin != *that1.Ymin {
			return false
		}
	} else if this.Ymin != nil {
		return false
	} else if that1.Ymin != nil {
		return false
	}
	if this.Xmin != nil && that1.Xmin != nil {
		if *this.Xmin != *that1.Xmin {
			return false
		}
	} else if this.Xmin != nil {
		return false
	} else if that1.Xmin != nil {
		return false
	}
	if this.Ymax != nil && that1.Ymax != nil {
		if *this.Ymax != *that1.Ymax {
			return false
		}
	} else if this.Ymax != nil {
		return false
	} else if that1.Ymax != nil {
		return false
	}
	if this.Xmax != nil && that1.Xmax != nil {
		if *this.Xmax != *that1.Xmax {
			return false
		}
	} else if this.Xmax != nil {
		return false
	} else if that1.Xmax != nil {
		return false
	}
	return true
}
func (this *TensorsToDetectionsCalculatorOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&tensor.TensorsToDetectionsCalculatorOptions{")
	s = append(s, "NumClasses: "+fmt.Sprintf("%#v", this.NumClasses)+",\n")
	s = append(s, "NumBoxes: "+fmt.Sprintf("%#v", this.NumBoxes)+",\n")
	s = append(s, "NumCoords: "+fmt.Sprintf("%#v", this.NumCoords)+",\n")
	s = append(s, "KeypointCoordOffset: "+fmt.Sprintf("%#v", this.KeypointCoordOffset)+",\n")
	if this.NumKeypoints != nil {
		s = append(s, "NumKeypoints: "+valueToGoStringTensorsToDetectionsCalculator(this.NumKeypoints, "int32")+",\n")
	}
	if this.NumValuesPerKeypoint != nil {
		s = append(s, "NumValuesPerKeypoint: "+valueToGoStringTensorsToDetectionsCalculator(this.NumValuesPerKeypoint, "int32")+",\n")
	}
	if this.BoxCoordOffset != nil {
		s = append(s, "BoxCoordOffset: "+valueToGoStringTensorsToDetectionsCalculator(this.BoxCoordOffset, "int32")+",\n")
	}
	if this.XScale != nil {
		s = append(s, "XScale: "+valueToGoStringTensorsToDetectionsCalculator(this.XScale, "float32")+",\n")
	}
	if this.YScale != nil {
		s = append(s, "YScale: "+valueToGoStringTensorsToDetectionsCalculator(this.YScale, "float32")+",\n")
	}
	if this.WScale != nil {
		s = append(s, "WScale: "+valueToGoStringTensorsToDetectionsCalculator(this.WScale, "float32")+",\n")
	}
	if this.HScale != nil {
		s = append(s, "HScale: "+valueToGoStringTensorsToDetectionsCalculator(this.HScale, "float32")+",\n")
	}
	if this.ApplyExponentialOnBoxSize != nil {
		s = append(s, "ApplyExponentialOnBoxSize: "+valueToGoStringTensorsToDetectionsCalculator(this.ApplyExponentialOnBoxSize, "bool")+",\n")
	}
	if this.ReverseOutputOrder != nil {
		s = append(s, "ReverseOutputOrder: "+valueToGoStringTensorsToDetectionsCalculator(this.ReverseOutputOrder, "bool")+",\n")
	}
	if this.IgnoreClasses != nil {
		s = append(s, "IgnoreClasses: "+fmt.Sprintf("%#v", this.IgnoreClasses)+",\n")
	}
	if this.AllowClasses != nil {
		s = append(s, "AllowClasses: "+fmt.Sprintf("%#v", this.AllowClasses)+",\n")
	}
	if this.SigmoidScore != nil {
		s = append(s, "SigmoidScore: "+valueToGoStringTensorsToDetectionsCalculator(this.SigmoidScore, "bool")+",\n")
	}
	s = append(s, "ScoreClippingThresh: "+fmt.Sprintf("%#v", this.ScoreClippingThresh)+",\n")
	if this.FlipVertically != nil {
		s = append(s, "FlipVertically: "+valueToGoStringTensorsToDetectionsCalculator(this.FlipVertically, "bool")+",\n")
	}
	s = append(s, "MinScoreThresh: "+fmt.Sprintf("%#v", this.MinScoreThresh)+",\n")
	if this.MaxResults != nil {
		s = append(s, "MaxResults: "+valueToGoStringTensorsToDetectionsCalculator(this.MaxResults, "int32")+",\n")
	}
	if this.TensorMapping != nil {
		s = append(s, "TensorMapping: "+fmt.Sprintf("%#v", this.TensorMapping)+",\n")
	}
	if this.BoxIndices != nil {
		s = append(s, "BoxIndices: "+fmt.Sprintf("%#v", this.BoxIndices)+",\n")
	}
	if this.BoxFormat != nil {
		s = append(s, "BoxFormat: "+valueToGoStringTensorsToDetectionsCalculator(this.BoxFormat, "TensorsToDetectionsCalculatorOptions_BoxFormat")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensor.TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_{` +
		`BoxBoundariesIndices:` + fmt.Sprintf("%#v", this.BoxBoundariesIndices) + `}`}, ", ")
	return s
}
func (this *TensorsToDetectionsCalculatorOptions_TensorMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensor.TensorsToDetectionsCalculatorOptions_TensorMapping{")
	s = append(s, "DetectionsTensorIndex: "+fmt.Sprintf("%#v", this.DetectionsTensorIndex)+",\n")
	s = append(s, "ClassesTensorIndex: "+fmt.Sprintf("%#v", this.ClassesTensorIndex)+",\n")
	s = append(s, "ScoresTensorIndex: "+fmt.Sprintf("%#v", this.ScoresTensorIndex)+",\n")
	s = append(s, "NumDetectionsTensorIndex: "+fmt.Sprintf("%#v", this.NumDetectionsTensorIndex)+",\n")
	s = append(s, "AnchorsTensorIndex: "+fmt.Sprintf("%#v", this.AnchorsTensorIndex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensor.TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices{")
	if this.Ymin != nil {
		s = append(s, "Ymin: "+valueToGoStringTensorsToDetectionsCalculator(this.Ymin, "int32")+",\n")
	}
	if this.Xmin != nil {
		s = append(s, "Xmin: "+valueToGoStringTensorsToDetectionsCalculator(this.Xmin, "int32")+",\n")
	}
	if this.Ymax != nil {
		s = append(s, "Ymax: "+valueToGoStringTensorsToDetectionsCalculator(this.Ymax, "int32")+",\n")
	}
	if this.Xmax != nil {
		s = append(s, "Xmax: "+valueToGoStringTensorsToDetectionsCalculator(this.Xmax, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTensorsToDetectionsCalculator(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TensorsToDetectionsCalculatorOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorsToDetectionsCalculatorOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorsToDetectionsCalculatorOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BoxFormat != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.BoxFormat))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.BoxIndices != nil {
		{
			size := m.BoxIndices.Size()
			i -= size
			if _, err := m.BoxIndices.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TensorMapping != nil {
		{
			size, err := m.TensorMapping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.AllowClasses) > 0 {
		dAtA3 := make([]byte, len(m.AllowClasses)*10)
		var j2 int
		for _, num1 := range m.AllowClasses {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MaxResults != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.MaxResults))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MinScoreThresh))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9d
	if m.FlipVertically != nil {
		i--
		if *m.FlipVertically {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreClippingThresh))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x85
	if m.SigmoidScore != nil {
		i--
		if *m.SigmoidScore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.ReverseOutputOrder != nil {
		i--
		if *m.ReverseOutputOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.ApplyExponentialOnBoxSize != nil {
		i--
		if *m.ApplyExponentialOnBoxSize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.BoxCoordOffset != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.BoxCoordOffset))
		i--
		dAtA[i] = 0x60
	}
	if m.NumValuesPerKeypoint != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.NumValuesPerKeypoint))
		i--
		dAtA[i] = 0x58
	}
	if m.NumKeypoints != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.NumKeypoints))
		i--
		dAtA[i] = 0x50
	}
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.KeypointCoordOffset))
	i--
	dAtA[i] = 0x48
	if len(m.IgnoreClasses) > 0 {
		for iNdEx := len(m.IgnoreClasses) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.IgnoreClasses[iNdEx]))
			i--
			dAtA[i] = 0x40
		}
	}
	if m.HScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.HScale))))
		i--
		dAtA[i] = 0x3d
	}
	if m.WScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.WScale))))
		i--
		dAtA[i] = 0x35
	}
	if m.YScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.YScale))))
		i--
		dAtA[i] = 0x2d
	}
	if m.XScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.XScale))))
		i--
		dAtA[i] = 0x25
	}
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.NumCoords))
	i--
	dAtA[i] = 0x18
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.NumBoxes))
	i--
	dAtA[i] = 0x10
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.NumClasses))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BoxBoundariesIndices != nil {
		{
			size, err := m.BoxBoundariesIndices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.AnchorsTensorIndex))
	i--
	dAtA[i] = 0x28
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.NumDetectionsTensorIndex))
	i--
	dAtA[i] = 0x20
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.ScoresTensorIndex))
	i--
	dAtA[i] = 0x18
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.ClassesTensorIndex))
	i--
	dAtA[i] = 0x10
	i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(m.DetectionsTensorIndex))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Xmax != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.Xmax))
		i--
		dAtA[i] = 0x20
	}
	if m.Ymax != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.Ymax))
		i--
		dAtA[i] = 0x18
	}
	if m.Xmin != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.Xmin))
		i--
		dAtA[i] = 0x10
	}
	if m.Ymin != nil {
		i = encodeVarintTensorsToDetectionsCalculator(dAtA, i, uint64(*m.Ymin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTensorsToDetectionsCalculator(dAtA []byte, offset int, v uint64) int {
	offset -= sovTensorsToDetectionsCalculator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TensorsToDetectionsCalculatorOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.NumClasses))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.NumBoxes))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.NumCoords))
	if m.XScale != nil {
		n += 5
	}
	if m.YScale != nil {
		n += 5
	}
	if m.WScale != nil {
		n += 5
	}
	if m.HScale != nil {
		n += 5
	}
	if len(m.IgnoreClasses) > 0 {
		for _, e := range m.IgnoreClasses {
			n += 1 + sovTensorsToDetectionsCalculator(uint64(e))
		}
	}
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.KeypointCoordOffset))
	if m.NumKeypoints != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.NumKeypoints))
	}
	if m.NumValuesPerKeypoint != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.NumValuesPerKeypoint))
	}
	if m.BoxCoordOffset != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.BoxCoordOffset))
	}
	if m.ApplyExponentialOnBoxSize != nil {
		n += 2
	}
	if m.ReverseOutputOrder != nil {
		n += 2
	}
	if m.SigmoidScore != nil {
		n += 2
	}
	n += 6
	if m.FlipVertically != nil {
		n += 3
	}
	n += 6
	if m.MaxResults != nil {
		n += 2 + sovTensorsToDetectionsCalculator(uint64(*m.MaxResults))
	}
	if len(m.AllowClasses) > 0 {
		l = 0
		for _, e := range m.AllowClasses {
			l += sovTensorsToDetectionsCalculator(uint64(e))
		}
		n += 2 + sovTensorsToDetectionsCalculator(uint64(l)) + l
	}
	if m.TensorMapping != nil {
		l = m.TensorMapping.Size()
		n += 2 + l + sovTensorsToDetectionsCalculator(uint64(l))
	}
	if m.BoxIndices != nil {
		n += m.BoxIndices.Size()
	}
	if m.BoxFormat != nil {
		n += 2 + sovTensorsToDetectionsCalculator(uint64(*m.BoxFormat))
	}
	return n
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoxBoundariesIndices != nil {
		l = m.BoxBoundariesIndices.Size()
		n += 2 + l + sovTensorsToDetectionsCalculator(uint64(l))
	}
	return n
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.DetectionsTensorIndex))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.ClassesTensorIndex))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.ScoresTensorIndex))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.NumDetectionsTensorIndex))
	n += 1 + sovTensorsToDetectionsCalculator(uint64(m.AnchorsTensorIndex))
	return n
}

func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ymin != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.Ymin))
	}
	if m.Xmin != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.Xmin))
	}
	if m.Ymax != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.Ymax))
	}
	if m.Xmax != nil {
		n += 1 + sovTensorsToDetectionsCalculator(uint64(*m.Xmax))
	}
	return n
}

func sovTensorsToDetectionsCalculator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTensorsToDetectionsCalculator(x uint64) (n int) {
	return sovTensorsToDetectionsCalculator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TensorsToDetectionsCalculatorOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorsToDetectionsCalculatorOptions{`,
		`NumClasses:` + fmt.Sprintf("%v", this.NumClasses) + `,`,
		`NumBoxes:` + fmt.Sprintf("%v", this.NumBoxes) + `,`,
		`NumCoords:` + fmt.Sprintf("%v", this.NumCoords) + `,`,
		`XScale:` + valueToStringTensorsToDetectionsCalculator(this.XScale) + `,`,
		`YScale:` + valueToStringTensorsToDetectionsCalculator(this.YScale) + `,`,
		`WScale:` + valueToStringTensorsToDetectionsCalculator(this.WScale) + `,`,
		`HScale:` + valueToStringTensorsToDetectionsCalculator(this.HScale) + `,`,
		`IgnoreClasses:` + fmt.Sprintf("%v", this.IgnoreClasses) + `,`,
		`KeypointCoordOffset:` + fmt.Sprintf("%v", this.KeypointCoordOffset) + `,`,
		`NumKeypoints:` + valueToStringTensorsToDetectionsCalculator(this.NumKeypoints) + `,`,
		`NumValuesPerKeypoint:` + valueToStringTensorsToDetectionsCalculator(this.NumValuesPerKeypoint) + `,`,
		`BoxCoordOffset:` + valueToStringTensorsToDetectionsCalculator(this.BoxCoordOffset) + `,`,
		`ApplyExponentialOnBoxSize:` + valueToStringTensorsToDetectionsCalculator(this.ApplyExponentialOnBoxSize) + `,`,
		`ReverseOutputOrder:` + valueToStringTensorsToDetectionsCalculator(this.ReverseOutputOrder) + `,`,
		`SigmoidScore:` + valueToStringTensorsToDetectionsCalculator(this.SigmoidScore) + `,`,
		`ScoreClippingThresh:` + fmt.Sprintf("%v", this.ScoreClippingThresh) + `,`,
		`FlipVertically:` + valueToStringTensorsToDetectionsCalculator(this.FlipVertically) + `,`,
		`MinScoreThresh:` + fmt.Sprintf("%v", this.MinScoreThresh) + `,`,
		`MaxResults:` + valueToStringTensorsToDetectionsCalculator(this.MaxResults) + `,`,
		`AllowClasses:` + fmt.Sprintf("%v", this.AllowClasses) + `,`,
		`TensorMapping:` + strings.Replace(fmt.Sprintf("%v", this.TensorMapping), "TensorsToDetectionsCalculatorOptions_TensorMapping", "TensorsToDetectionsCalculatorOptions_TensorMapping", 1) + `,`,
		`BoxIndices:` + fmt.Sprintf("%v", this.BoxIndices) + `,`,
		`BoxFormat:` + valueToStringTensorsToDetectionsCalculator(this.BoxFormat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_{`,
		`BoxBoundariesIndices:` + strings.Replace(fmt.Sprintf("%v", this.BoxBoundariesIndices), "TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices", "TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorsToDetectionsCalculatorOptions_TensorMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorsToDetectionsCalculatorOptions_TensorMapping{`,
		`DetectionsTensorIndex:` + fmt.Sprintf("%v", this.DetectionsTensorIndex) + `,`,
		`ClassesTensorIndex:` + fmt.Sprintf("%v", this.ClassesTensorIndex) + `,`,
		`ScoresTensorIndex:` + fmt.Sprintf("%v", this.ScoresTensorIndex) + `,`,
		`NumDetectionsTensorIndex:` + fmt.Sprintf("%v", this.NumDetectionsTensorIndex) + `,`,
		`AnchorsTensorIndex:` + fmt.Sprintf("%v", this.AnchorsTensorIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices{`,
		`Ymin:` + valueToStringTensorsToDetectionsCalculator(this.Ymin) + `,`,
		`Xmin:` + valueToStringTensorsToDetectionsCalculator(this.Xmin) + `,`,
		`Ymax:` + valueToStringTensorsToDetectionsCalculator(this.Ymax) + `,`,
		`Xmax:` + valueToStringTensorsToDetectionsCalculator(this.Xmax) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTensorsToDetectionsCalculator(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TensorsToDetectionsCalculatorOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorsToDetectionsCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorsToDetectionsCalculatorOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorsToDetectionsCalculatorOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClasses", wireType)
			}
			m.NumClasses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClasses |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBoxes", wireType)
			}
			m.NumBoxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBoxes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCoords", wireType)
			}
			m.NumCoords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCoords |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field XScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.XScale = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field YScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.YScale = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.WScale = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.HScale = &v2
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTensorsToDetectionsCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IgnoreClasses = append(m.IgnoreClasses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTensorsToDetectionsCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTensorsToDetectionsCalculator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTensorsToDetectionsCalculator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IgnoreClasses) == 0 {
					m.IgnoreClasses = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTensorsToDetectionsCalculator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IgnoreClasses = append(m.IgnoreClasses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreClasses", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeypointCoordOffset", wireType)
			}
			m.KeypointCoordOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeypointCoordOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeypoints", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumKeypoints = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValuesPerKeypoint", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumValuesPerKeypoint = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxCoordOffset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoxCoordOffset = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyExponentialOnBoxSize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ApplyExponentialOnBoxSize = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseOutputOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReverseOutputOrder = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigmoidScore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SigmoidScore = &b
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreClippingThresh", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreClippingThresh = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlipVertically", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FlipVertically = &b
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScoreThresh", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MinScoreThresh = float32(math.Float32frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxResults = &v
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTensorsToDetectionsCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowClasses = append(m.AllowClasses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTensorsToDetectionsCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTensorsToDetectionsCalculator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTensorsToDetectionsCalculator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllowClasses) == 0 {
					m.AllowClasses = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTensorsToDetectionsCalculator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowClasses = append(m.AllowClasses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowClasses", wireType)
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorMapping == nil {
				m.TensorMapping = &TensorsToDetectionsCalculatorOptions_TensorMapping{}
			}
			if err := m.TensorMapping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxBoundariesIndices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BoxIndices = &TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxFormat", wireType)
			}
			var v TensorsToDetectionsCalculatorOptions_BoxFormat
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TensorsToDetectionsCalculatorOptions_BoxFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoxFormat = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTensorsToDetectionsCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorsToDetectionsCalculatorOptions_TensorMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorsToDetectionsCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionsTensorIndex", wireType)
			}
			m.DetectionsTensorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectionsTensorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassesTensorIndex", wireType)
			}
			m.ClassesTensorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassesTensorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoresTensorIndex", wireType)
			}
			m.ScoresTensorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoresTensorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumDetectionsTensorIndex", wireType)
			}
			m.NumDetectionsTensorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumDetectionsTensorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorsTensorIndex", wireType)
			}
			m.AnchorsTensorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorsTensorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTensorsToDetectionsCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorsToDetectionsCalculatorOptions_BoxBoundariesIndices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorsToDetectionsCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoxBoundariesIndices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoxBoundariesIndices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ymin = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Xmin = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ymax = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmax", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Xmax = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTensorsToDetectionsCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTensorsToDetectionsCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTensorsToDetectionsCalculator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTensorsToDetectionsCalculator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTensorsToDetectionsCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTensorsToDetectionsCalculator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTensorsToDetectionsCalculator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTensorsToDetectionsCalculator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTensorsToDetectionsCalculator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTensorsToDetectionsCalculator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTensorsToDetectionsCalculator = fmt.Errorf("proto: unexpected end of group")
)
