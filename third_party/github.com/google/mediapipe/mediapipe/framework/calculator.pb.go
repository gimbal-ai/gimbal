// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/framework/calculator.proto

package framework

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InputCollection_InputType int32

const (
	INPUT_TYPE_UNKNOWN             InputCollection_InputType = 0
	INPUT_TYPE_RECORDIO            InputCollection_InputType = 1
	INPUT_TYPE_FOREIGN_RECORDIO    InputCollection_InputType = 2
	INPUT_TYPE_FOREIGN_CSV_TEXT    InputCollection_InputType = 3
	INPUT_TYPE_INVALID_UPPER_BOUND InputCollection_InputType = 4
)

var InputCollection_InputType_name = map[int32]string{
	0: "INPUT_TYPE_UNKNOWN",
	1: "INPUT_TYPE_RECORDIO",
	2: "INPUT_TYPE_FOREIGN_RECORDIO",
	3: "INPUT_TYPE_FOREIGN_CSV_TEXT",
	4: "INPUT_TYPE_INVALID_UPPER_BOUND",
}

var InputCollection_InputType_value = map[string]int32{
	"INPUT_TYPE_UNKNOWN":             0,
	"INPUT_TYPE_RECORDIO":            1,
	"INPUT_TYPE_FOREIGN_RECORDIO":    2,
	"INPUT_TYPE_FOREIGN_CSV_TEXT":    3,
	"INPUT_TYPE_INVALID_UPPER_BOUND": 4,
}

func (InputCollection_InputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{1, 0}
}

type ExecutorConfig struct {
	Name    string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type    string            `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Options *MediaPipeOptions `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
}

func (m *ExecutorConfig) Reset()      { *m = ExecutorConfig{} }
func (*ExecutorConfig) ProtoMessage() {}
func (*ExecutorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{0}
}
func (m *ExecutorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorConfig.Merge(m, src)
}
func (m *ExecutorConfig) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorConfig proto.InternalMessageInfo

func (m *ExecutorConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExecutorConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ExecutorConfig) GetOptions() *MediaPipeOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type InputCollection struct {
	Name              string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SidePacketName    []string                  `protobuf:"bytes,2,rep,name=side_packet_name,json=sidePacketName,proto3" json:"side_packet_name,omitempty"`
	ExternalInputName []string                  `protobuf:"bytes,1002,rep,name=external_input_name,json=externalInputName,proto3" json:"external_input_name,omitempty"`
	InputType         InputCollection_InputType `protobuf:"varint,3,opt,name=input_type,json=inputType,proto3,enum=mediapipe.InputCollection_InputType" json:"input_type,omitempty"`
	FileName          string                    `protobuf:"bytes,4,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *InputCollection) Reset()      { *m = InputCollection{} }
func (*InputCollection) ProtoMessage() {}
func (*InputCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{1}
}
func (m *InputCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputCollection.Merge(m, src)
}
func (m *InputCollection) XXX_Size() int {
	return m.Size()
}
func (m *InputCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_InputCollection.DiscardUnknown(m)
}

var xxx_messageInfo_InputCollection proto.InternalMessageInfo

func (m *InputCollection) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InputCollection) GetSidePacketName() []string {
	if m != nil {
		return m.SidePacketName
	}
	return nil
}

func (m *InputCollection) GetExternalInputName() []string {
	if m != nil {
		return m.ExternalInputName
	}
	return nil
}

func (m *InputCollection) GetInputType() InputCollection_InputType {
	if m != nil {
		return m.InputType
	}
	return INPUT_TYPE_UNKNOWN
}

func (m *InputCollection) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

type InputCollectionSet struct {
	InputCollection []*InputCollection `protobuf:"bytes,1,rep,name=input_collection,json=inputCollection,proto3" json:"input_collection,omitempty"`
}

func (m *InputCollectionSet) Reset()      { *m = InputCollectionSet{} }
func (*InputCollectionSet) ProtoMessage() {}
func (*InputCollectionSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{2}
}
func (m *InputCollectionSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputCollectionSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputCollectionSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputCollectionSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputCollectionSet.Merge(m, src)
}
func (m *InputCollectionSet) XXX_Size() int {
	return m.Size()
}
func (m *InputCollectionSet) XXX_DiscardUnknown() {
	xxx_messageInfo_InputCollectionSet.DiscardUnknown(m)
}

var xxx_messageInfo_InputCollectionSet proto.InternalMessageInfo

func (m *InputCollectionSet) GetInputCollection() []*InputCollection {
	if m != nil {
		return m.InputCollection
	}
	return nil
}

type InputStreamInfo struct {
	TagIndex string `protobuf:"bytes,1,opt,name=tag_index,json=tagIndex,proto3" json:"tag_index,omitempty"`
	BackEdge bool   `protobuf:"varint,2,opt,name=back_edge,json=backEdge,proto3" json:"back_edge,omitempty"`
}

func (m *InputStreamInfo) Reset()      { *m = InputStreamInfo{} }
func (*InputStreamInfo) ProtoMessage() {}
func (*InputStreamInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{3}
}
func (m *InputStreamInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputStreamInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputStreamInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputStreamInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputStreamInfo.Merge(m, src)
}
func (m *InputStreamInfo) XXX_Size() int {
	return m.Size()
}
func (m *InputStreamInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InputStreamInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InputStreamInfo proto.InternalMessageInfo

func (m *InputStreamInfo) GetTagIndex() string {
	if m != nil {
		return m.TagIndex
	}
	return ""
}

func (m *InputStreamInfo) GetBackEdge() bool {
	if m != nil {
		return m.BackEdge
	}
	return false
}

type ProfilerConfig struct {
	HistogramIntervalSizeUsec        int64   `protobuf:"varint,1,opt,name=histogram_interval_size_usec,json=histogramIntervalSizeUsec,proto3" json:"histogram_interval_size_usec,omitempty"`
	NumHistogramIntervals            int64   `protobuf:"varint,2,opt,name=num_histogram_intervals,json=numHistogramIntervals,proto3" json:"num_histogram_intervals,omitempty"`
	EnableInputOutputLatency         bool    `protobuf:"varint,3,opt,name=enable_input_output_latency,json=enableInputOutputLatency,proto3" json:"enable_input_output_latency,omitempty"` // Deprecated: Do not use.
	EnableProfiler                   bool    `protobuf:"varint,4,opt,name=enable_profiler,json=enableProfiler,proto3" json:"enable_profiler,omitempty"`
	EnableStreamLatency              bool    `protobuf:"varint,5,opt,name=enable_stream_latency,json=enableStreamLatency,proto3" json:"enable_stream_latency,omitempty"`
	UsePacketTimestampForAddedPacket bool    `protobuf:"varint,6,opt,name=use_packet_timestamp_for_added_packet,json=usePacketTimestampForAddedPacket,proto3" json:"use_packet_timestamp_for_added_packet,omitempty"`
	TraceLogCapacity                 int64   `protobuf:"varint,7,opt,name=trace_log_capacity,json=traceLogCapacity,proto3" json:"trace_log_capacity,omitempty"`
	TraceEventTypesDisabled          []int32 `protobuf:"varint,8,rep,packed,name=trace_event_types_disabled,json=traceEventTypesDisabled,proto3" json:"trace_event_types_disabled,omitempty"`
	TraceLogPath                     string  `protobuf:"bytes,9,opt,name=trace_log_path,json=traceLogPath,proto3" json:"trace_log_path,omitempty"`
	TraceLogCount                    int32   `protobuf:"varint,10,opt,name=trace_log_count,json=traceLogCount,proto3" json:"trace_log_count,omitempty"`
	TraceLogIntervalUsec             int64   `protobuf:"varint,11,opt,name=trace_log_interval_usec,json=traceLogIntervalUsec,proto3" json:"trace_log_interval_usec,omitempty"`
	TraceLogMarginUsec               int64   `protobuf:"varint,12,opt,name=trace_log_margin_usec,json=traceLogMarginUsec,proto3" json:"trace_log_margin_usec,omitempty"`
	TraceLogDurationEvents           bool    `protobuf:"varint,13,opt,name=trace_log_duration_events,json=traceLogDurationEvents,proto3" json:"trace_log_duration_events,omitempty"` // Deprecated: Do not use.
	TraceLogIntervalCount            int32   `protobuf:"varint,14,opt,name=trace_log_interval_count,json=traceLogIntervalCount,proto3" json:"trace_log_interval_count,omitempty"`
	TraceLogDisabled                 bool    `protobuf:"varint,15,opt,name=trace_log_disabled,json=traceLogDisabled,proto3" json:"trace_log_disabled,omitempty"`
	TraceEnabled                     bool    `protobuf:"varint,16,opt,name=trace_enabled,json=traceEnabled,proto3" json:"trace_enabled,omitempty"`
	TraceLogInstantEvents            bool    `protobuf:"varint,17,opt,name=trace_log_instant_events,json=traceLogInstantEvents,proto3" json:"trace_log_instant_events,omitempty"`
	CalculatorFilter                 string  `protobuf:"bytes,18,opt,name=calculator_filter,json=calculatorFilter,proto3" json:"calculator_filter,omitempty"`
}

func (m *ProfilerConfig) Reset()      { *m = ProfilerConfig{} }
func (*ProfilerConfig) ProtoMessage() {}
func (*ProfilerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{4}
}
func (m *ProfilerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilerConfig.Merge(m, src)
}
func (m *ProfilerConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProfilerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilerConfig proto.InternalMessageInfo

func (m *ProfilerConfig) GetHistogramIntervalSizeUsec() int64 {
	if m != nil {
		return m.HistogramIntervalSizeUsec
	}
	return 0
}

func (m *ProfilerConfig) GetNumHistogramIntervals() int64 {
	if m != nil {
		return m.NumHistogramIntervals
	}
	return 0
}

// Deprecated: Do not use.
func (m *ProfilerConfig) GetEnableInputOutputLatency() bool {
	if m != nil {
		return m.EnableInputOutputLatency
	}
	return false
}

func (m *ProfilerConfig) GetEnableProfiler() bool {
	if m != nil {
		return m.EnableProfiler
	}
	return false
}

func (m *ProfilerConfig) GetEnableStreamLatency() bool {
	if m != nil {
		return m.EnableStreamLatency
	}
	return false
}

func (m *ProfilerConfig) GetUsePacketTimestampForAddedPacket() bool {
	if m != nil {
		return m.UsePacketTimestampForAddedPacket
	}
	return false
}

func (m *ProfilerConfig) GetTraceLogCapacity() int64 {
	if m != nil {
		return m.TraceLogCapacity
	}
	return 0
}

func (m *ProfilerConfig) GetTraceEventTypesDisabled() []int32 {
	if m != nil {
		return m.TraceEventTypesDisabled
	}
	return nil
}

func (m *ProfilerConfig) GetTraceLogPath() string {
	if m != nil {
		return m.TraceLogPath
	}
	return ""
}

func (m *ProfilerConfig) GetTraceLogCount() int32 {
	if m != nil {
		return m.TraceLogCount
	}
	return 0
}

func (m *ProfilerConfig) GetTraceLogIntervalUsec() int64 {
	if m != nil {
		return m.TraceLogIntervalUsec
	}
	return 0
}

func (m *ProfilerConfig) GetTraceLogMarginUsec() int64 {
	if m != nil {
		return m.TraceLogMarginUsec
	}
	return 0
}

// Deprecated: Do not use.
func (m *ProfilerConfig) GetTraceLogDurationEvents() bool {
	if m != nil {
		return m.TraceLogDurationEvents
	}
	return false
}

func (m *ProfilerConfig) GetTraceLogIntervalCount() int32 {
	if m != nil {
		return m.TraceLogIntervalCount
	}
	return 0
}

func (m *ProfilerConfig) GetTraceLogDisabled() bool {
	if m != nil {
		return m.TraceLogDisabled
	}
	return false
}

func (m *ProfilerConfig) GetTraceEnabled() bool {
	if m != nil {
		return m.TraceEnabled
	}
	return false
}

func (m *ProfilerConfig) GetTraceLogInstantEvents() bool {
	if m != nil {
		return m.TraceLogInstantEvents
	}
	return false
}

func (m *ProfilerConfig) GetCalculatorFilter() string {
	if m != nil {
		return m.CalculatorFilter
	}
	return ""
}

type CalculatorGraphConfig struct {
	Node                []*CalculatorGraphConfig_Node `protobuf:"bytes,1,rep,name=node,proto3" json:"node,omitempty"`
	PacketFactory       []*PacketFactoryConfig        `protobuf:"bytes,6,rep,name=packet_factory,json=packetFactory,proto3" json:"packet_factory,omitempty"`
	PacketGenerator     []*PacketGeneratorConfig      `protobuf:"bytes,7,rep,name=packet_generator,json=packetGenerator,proto3" json:"packet_generator,omitempty"` // Deprecated: Do not use.
	NumThreads          int32                         `protobuf:"varint,8,opt,name=num_threads,json=numThreads,proto3" json:"num_threads,omitempty"`
	StatusHandler       []*StatusHandlerConfig        `protobuf:"bytes,9,rep,name=status_handler,json=statusHandler,proto3" json:"status_handler,omitempty"`
	InputStream         []string                      `protobuf:"bytes,10,rep,name=input_stream,json=inputStream,proto3" json:"input_stream,omitempty"`
	OutputStream        []string                      `protobuf:"bytes,15,rep,name=output_stream,json=outputStream,proto3" json:"output_stream,omitempty"`
	InputSidePacket     []string                      `protobuf:"bytes,16,rep,name=input_side_packet,json=inputSidePacket,proto3" json:"input_side_packet,omitempty"`
	OutputSidePacket    []string                      `protobuf:"bytes,17,rep,name=output_side_packet,json=outputSidePacket,proto3" json:"output_side_packet,omitempty"`
	MaxQueueSize        int32                         `protobuf:"varint,11,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	ReportDeadlock      bool                          `protobuf:"varint,21,opt,name=report_deadlock,json=reportDeadlock,proto3" json:"report_deadlock,omitempty"`
	InputStreamHandler  *InputStreamHandlerConfig     `protobuf:"bytes,12,opt,name=input_stream_handler,json=inputStreamHandler,proto3" json:"input_stream_handler,omitempty"`
	OutputStreamHandler *OutputStreamHandlerConfig    `protobuf:"bytes,13,opt,name=output_stream_handler,json=outputStreamHandler,proto3" json:"output_stream_handler,omitempty"`
	Executor            []*ExecutorConfig             `protobuf:"bytes,14,rep,name=executor,proto3" json:"executor,omitempty"`
	ProfilerConfig      *ProfilerConfig               `protobuf:"bytes,18,opt,name=profiler_config,json=profilerConfig,proto3" json:"profiler_config,omitempty"`
	Package             string                        `protobuf:"bytes,19,opt,name=package,proto3" json:"package,omitempty"`
	Type                string                        `protobuf:"bytes,20,opt,name=type,proto3" json:"type,omitempty"`
	Options             *MediaPipeOptions             `protobuf:"bytes,1001,opt,name=options,proto3" json:"options,omitempty"`
	GraphOptions        []*types.Any                  `protobuf:"bytes,1002,rep,name=graph_options,json=graphOptions,proto3" json:"graph_options,omitempty"`
}

func (m *CalculatorGraphConfig) Reset()      { *m = CalculatorGraphConfig{} }
func (*CalculatorGraphConfig) ProtoMessage() {}
func (*CalculatorGraphConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{5}
}
func (m *CalculatorGraphConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalculatorGraphConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculatorGraphConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalculatorGraphConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculatorGraphConfig.Merge(m, src)
}
func (m *CalculatorGraphConfig) XXX_Size() int {
	return m.Size()
}
func (m *CalculatorGraphConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculatorGraphConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CalculatorGraphConfig proto.InternalMessageInfo

func (m *CalculatorGraphConfig) GetNode() []*CalculatorGraphConfig_Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *CalculatorGraphConfig) GetPacketFactory() []*PacketFactoryConfig {
	if m != nil {
		return m.PacketFactory
	}
	return nil
}

// Deprecated: Do not use.
func (m *CalculatorGraphConfig) GetPacketGenerator() []*PacketGeneratorConfig {
	if m != nil {
		return m.PacketGenerator
	}
	return nil
}

func (m *CalculatorGraphConfig) GetNumThreads() int32 {
	if m != nil {
		return m.NumThreads
	}
	return 0
}

func (m *CalculatorGraphConfig) GetStatusHandler() []*StatusHandlerConfig {
	if m != nil {
		return m.StatusHandler
	}
	return nil
}

func (m *CalculatorGraphConfig) GetInputStream() []string {
	if m != nil {
		return m.InputStream
	}
	return nil
}

func (m *CalculatorGraphConfig) GetOutputStream() []string {
	if m != nil {
		return m.OutputStream
	}
	return nil
}

func (m *CalculatorGraphConfig) GetInputSidePacket() []string {
	if m != nil {
		return m.InputSidePacket
	}
	return nil
}

func (m *CalculatorGraphConfig) GetOutputSidePacket() []string {
	if m != nil {
		return m.OutputSidePacket
	}
	return nil
}

func (m *CalculatorGraphConfig) GetMaxQueueSize() int32 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *CalculatorGraphConfig) GetReportDeadlock() bool {
	if m != nil {
		return m.ReportDeadlock
	}
	return false
}

func (m *CalculatorGraphConfig) GetInputStreamHandler() *InputStreamHandlerConfig {
	if m != nil {
		return m.InputStreamHandler
	}
	return nil
}

func (m *CalculatorGraphConfig) GetOutputStreamHandler() *OutputStreamHandlerConfig {
	if m != nil {
		return m.OutputStreamHandler
	}
	return nil
}

func (m *CalculatorGraphConfig) GetExecutor() []*ExecutorConfig {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *CalculatorGraphConfig) GetProfilerConfig() *ProfilerConfig {
	if m != nil {
		return m.ProfilerConfig
	}
	return nil
}

func (m *CalculatorGraphConfig) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *CalculatorGraphConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CalculatorGraphConfig) GetOptions() *MediaPipeOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *CalculatorGraphConfig) GetGraphOptions() []*types.Any {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

type CalculatorGraphConfig_Node struct {
	Name                string                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Calculator          string                     `protobuf:"bytes,2,opt,name=calculator,proto3" json:"calculator,omitempty"`
	InputStream         []string                   `protobuf:"bytes,3,rep,name=input_stream,json=inputStream,proto3" json:"input_stream,omitempty"`
	OutputStream        []string                   `protobuf:"bytes,4,rep,name=output_stream,json=outputStream,proto3" json:"output_stream,omitempty"`
	InputSidePacket     []string                   `protobuf:"bytes,5,rep,name=input_side_packet,json=inputSidePacket,proto3" json:"input_side_packet,omitempty"`
	OutputSidePacket    []string                   `protobuf:"bytes,6,rep,name=output_side_packet,json=outputSidePacket,proto3" json:"output_side_packet,omitempty"`
	Options             *CalculatorOptions         `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
	NodeOptions         []*types.Any               `protobuf:"bytes,8,rep,name=node_options,json=nodeOptions,proto3" json:"node_options,omitempty"`
	SourceLayer         int32                      `protobuf:"varint,9,opt,name=source_layer,json=sourceLayer,proto3" json:"source_layer,omitempty"`
	BufferSizeHint      int32                      `protobuf:"varint,10,opt,name=buffer_size_hint,json=bufferSizeHint,proto3" json:"buffer_size_hint,omitempty"`
	InputStreamHandler  *InputStreamHandlerConfig  `protobuf:"bytes,11,opt,name=input_stream_handler,json=inputStreamHandler,proto3" json:"input_stream_handler,omitempty"`
	OutputStreamHandler *OutputStreamHandlerConfig `protobuf:"bytes,12,opt,name=output_stream_handler,json=outputStreamHandler,proto3" json:"output_stream_handler,omitempty"`
	InputStreamInfo     []*InputStreamInfo         `protobuf:"bytes,13,rep,name=input_stream_info,json=inputStreamInfo,proto3" json:"input_stream_info,omitempty"`
	Executor            string                     `protobuf:"bytes,14,opt,name=executor,proto3" json:"executor,omitempty"`
	ProfilerConfig      *ProfilerConfig            `protobuf:"bytes,15,opt,name=profiler_config,json=profilerConfig,proto3" json:"profiler_config,omitempty"` // Deprecated: Do not use.
	MaxInFlight         int32                      `protobuf:"varint,16,opt,name=max_in_flight,json=maxInFlight,proto3" json:"max_in_flight,omitempty"`
	OptionValue         []string                   `protobuf:"bytes,17,rep,name=option_value,json=optionValue,proto3" json:"option_value,omitempty"`
	ExternalInput       []string                   `protobuf:"bytes,1005,rep,name=external_input,json=externalInput,proto3" json:"external_input,omitempty"`
}

func (m *CalculatorGraphConfig_Node) Reset()      { *m = CalculatorGraphConfig_Node{} }
func (*CalculatorGraphConfig_Node) ProtoMessage() {}
func (*CalculatorGraphConfig_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_356afd20af55cca2, []int{5, 0}
}
func (m *CalculatorGraphConfig_Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalculatorGraphConfig_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculatorGraphConfig_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalculatorGraphConfig_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculatorGraphConfig_Node.Merge(m, src)
}
func (m *CalculatorGraphConfig_Node) XXX_Size() int {
	return m.Size()
}
func (m *CalculatorGraphConfig_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculatorGraphConfig_Node.DiscardUnknown(m)
}

var xxx_messageInfo_CalculatorGraphConfig_Node proto.InternalMessageInfo

func (m *CalculatorGraphConfig_Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CalculatorGraphConfig_Node) GetCalculator() string {
	if m != nil {
		return m.Calculator
	}
	return ""
}

func (m *CalculatorGraphConfig_Node) GetInputStream() []string {
	if m != nil {
		return m.InputStream
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetOutputStream() []string {
	if m != nil {
		return m.OutputStream
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetInputSidePacket() []string {
	if m != nil {
		return m.InputSidePacket
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetOutputSidePacket() []string {
	if m != nil {
		return m.OutputSidePacket
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetOptions() *CalculatorOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetNodeOptions() []*types.Any {
	if m != nil {
		return m.NodeOptions
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetSourceLayer() int32 {
	if m != nil {
		return m.SourceLayer
	}
	return 0
}

func (m *CalculatorGraphConfig_Node) GetBufferSizeHint() int32 {
	if m != nil {
		return m.BufferSizeHint
	}
	return 0
}

func (m *CalculatorGraphConfig_Node) GetInputStreamHandler() *InputStreamHandlerConfig {
	if m != nil {
		return m.InputStreamHandler
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetOutputStreamHandler() *OutputStreamHandlerConfig {
	if m != nil {
		return m.OutputStreamHandler
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetInputStreamInfo() []*InputStreamInfo {
	if m != nil {
		return m.InputStreamInfo
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetExecutor() string {
	if m != nil {
		return m.Executor
	}
	return ""
}

// Deprecated: Do not use.
func (m *CalculatorGraphConfig_Node) GetProfilerConfig() *ProfilerConfig {
	if m != nil {
		return m.ProfilerConfig
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetMaxInFlight() int32 {
	if m != nil {
		return m.MaxInFlight
	}
	return 0
}

func (m *CalculatorGraphConfig_Node) GetOptionValue() []string {
	if m != nil {
		return m.OptionValue
	}
	return nil
}

func (m *CalculatorGraphConfig_Node) GetExternalInput() []string {
	if m != nil {
		return m.ExternalInput
	}
	return nil
}

func init() {
	proto.RegisterEnum("mediapipe.InputCollection_InputType", InputCollection_InputType_name, InputCollection_InputType_value)
	proto.RegisterType((*ExecutorConfig)(nil), "mediapipe.ExecutorConfig")
	proto.RegisterType((*InputCollection)(nil), "mediapipe.InputCollection")
	proto.RegisterType((*InputCollectionSet)(nil), "mediapipe.InputCollectionSet")
	proto.RegisterType((*InputStreamInfo)(nil), "mediapipe.InputStreamInfo")
	proto.RegisterType((*ProfilerConfig)(nil), "mediapipe.ProfilerConfig")
	proto.RegisterType((*CalculatorGraphConfig)(nil), "mediapipe.CalculatorGraphConfig")
	proto.RegisterType((*CalculatorGraphConfig_Node)(nil), "mediapipe.CalculatorGraphConfig.Node")
}

func init() {
	proto.RegisterFile("mediapipe/framework/calculator.proto", fileDescriptor_356afd20af55cca2)
}

var fileDescriptor_356afd20af55cca2 = []byte{
	// 1625 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4b, 0x6f, 0xdb, 0xca,
	0x15, 0x16, 0x2d, 0x3f, 0xa4, 0xd1, 0xd3, 0x63, 0xfb, 0x9a, 0xb6, 0x2f, 0x78, 0x55, 0x5d, 0xdf,
	0x5b, 0x21, 0x09, 0x64, 0xd4, 0x45, 0x12, 0xb4, 0x45, 0x51, 0xf8, 0x21, 0x27, 0x42, 0x1c, 0x49,
	0xa5, 0xed, 0x34, 0x6d, 0x17, 0xc4, 0x98, 0x1c, 0x51, 0x84, 0xf9, 0x2a, 0x39, 0x4c, 0xed, 0xac,
	0xba, 0xeb, 0xb6, 0xe8, 0x4f, 0xe8, 0xaa, 0x3f, 0xa5, 0xab, 0x22, 0xcb, 0x2c, 0x1b, 0x07, 0x28,
	0xda, 0x02, 0x05, 0xb2, 0xee, 0xaa, 0x98, 0x07, 0x5f, 0x92, 0x9c, 0xa4, 0x28, 0xee, 0x4a, 0xe2,
	0x77, 0xbe, 0x39, 0x73, 0xe6, 0xbc, 0xe6, 0x0c, 0xd8, 0x75, 0xb0, 0x61, 0x21, 0xdf, 0xf2, 0xf1,
	0xde, 0x38, 0x40, 0x0e, 0xfe, 0xad, 0x17, 0x5c, 0xed, 0xe9, 0xc8, 0xd6, 0x23, 0x1b, 0x11, 0x2f,
	0xe8, 0xfa, 0x81, 0x47, 0x3c, 0x58, 0x4e, 0x58, 0xdb, 0x0f, 0x3e, 0xbe, 0x40, 0xf3, 0x7c, 0x62,
	0x79, 0x6e, 0xc8, 0x17, 0x6e, 0x6f, 0x99, 0x9e, 0x67, 0xda, 0x78, 0x8f, 0x7d, 0x5d, 0x46, 0xe3,
	0x3d, 0xe4, 0xde, 0x08, 0xd1, 0xfd, 0x79, 0x8a, 0x12, 0x6c, 0x4a, 0x4f, 0x67, 0x1e, 0xd9, 0x47,
	0xfa, 0x15, 0x26, 0xda, 0x18, 0xe9, 0xc4, 0x0b, 0x62, 0xb5, 0xf7, 0x3e, 0xc2, 0x34, 0xb1, 0x8b,
	0x83, 0xf4, 0x58, 0xf3, 0xb5, 0x86, 0x04, 0x91, 0x28, 0xd4, 0x26, 0xc8, 0x35, 0x6c, 0xfc, 0x09,
	0x66, 0x80, 0x91, 0x93, 0x67, 0xb6, 0x3d, 0x50, 0xef, 0x5d, 0x63, 0x3d, 0x22, 0x5e, 0x70, 0xe4,
	0xb9, 0x63, 0xcb, 0x84, 0x10, 0x2c, 0xba, 0xc8, 0xc1, 0xb2, 0xd4, 0x92, 0x3a, 0x65, 0x95, 0xfd,
	0xa7, 0x18, 0xb9, 0xf1, 0xb1, 0xbc, 0xc0, 0x31, 0xfa, 0x1f, 0x3e, 0x04, 0x2b, 0xe2, 0xd0, 0x72,
	0xb1, 0x25, 0x75, 0x2a, 0xfb, 0x3b, 0xdd, 0x64, 0xd7, 0xee, 0x73, 0xfa, 0x6f, 0x64, 0xf9, 0x78,
	0xc8, 0x29, 0x6a, 0xcc, 0x6d, 0xff, 0xbe, 0x08, 0x1a, 0x7d, 0xd7, 0x8f, 0xc8, 0x91, 0x67, 0xdb,
	0x58, 0xa7, 0xe0, 0xdc, 0x2d, 0x3b, 0xa0, 0x19, 0x5a, 0x06, 0xd6, 0x84, 0x2f, 0x98, 0x7c, 0xa1,
	0x55, 0xec, 0x94, 0xd5, 0x3a, 0xc5, 0x47, 0x0c, 0x1e, 0x50, 0xe6, 0x1e, 0x58, 0xc3, 0xd7, 0x04,
	0x07, 0x2e, 0xb2, 0x35, 0x8b, 0x6a, 0xe6, 0xe4, 0x7f, 0xad, 0x30, 0xf6, 0x6a, 0x2c, 0x63, 0x9b,
	0xb2, 0x05, 0x47, 0x00, 0x70, 0x1e, 0x3b, 0x13, 0x35, 0xbe, 0xbe, 0xbf, 0x9b, 0x31, 0x7e, 0xca,
	0x3c, 0xfe, 0x7d, 0x7e, 0xe3, 0x63, 0xb5, 0x6c, 0xc5, 0x7f, 0xe1, 0x0e, 0x28, 0x8f, 0x2d, 0x1b,
	0xf3, 0xbd, 0x16, 0x99, 0xe1, 0x25, 0x0a, 0xd0, 0x1d, 0xda, 0x7f, 0x92, 0x40, 0x39, 0x59, 0x05,
	0xbf, 0x00, 0xb0, 0x3f, 0x18, 0x5d, 0x9c, 0x6b, 0xe7, 0xbf, 0x1c, 0xf5, 0xb4, 0x8b, 0xc1, 0xb3,
	0xc1, 0xf0, 0x17, 0x83, 0x66, 0x01, 0x6e, 0x82, 0xb5, 0x0c, 0xae, 0xf6, 0x8e, 0x86, 0xea, 0x71,
	0x7f, 0xd8, 0x94, 0xe0, 0x57, 0x60, 0x27, 0x23, 0x38, 0x19, 0xaa, 0xbd, 0xfe, 0x93, 0x41, 0x4a,
	0x58, 0xb8, 0x83, 0x70, 0x74, 0xf6, 0x42, 0x3b, 0xef, 0xbd, 0x3c, 0x6f, 0x16, 0x61, 0x1b, 0x28,
	0x19, 0x42, 0x7f, 0xf0, 0xe2, 0xe0, 0xb4, 0x7f, 0xac, 0x5d, 0x8c, 0x46, 0x3d, 0x55, 0x3b, 0x1c,
	0x5e, 0x0c, 0x8e, 0x9b, 0x8b, 0xed, 0x5f, 0x03, 0x38, 0x75, 0xd2, 0x33, 0x4c, 0x60, 0x0f, 0x34,
	0xb9, 0x73, 0xf4, 0x04, 0x96, 0xa5, 0x56, 0xb1, 0x53, 0xd9, 0xdf, 0xbe, 0xdb, 0x45, 0x6a, 0xc3,
	0xca, 0x03, 0xed, 0x67, 0x22, 0xca, 0x67, 0x2c, 0xe9, 0xfa, 0xee, 0xd8, 0xa3, 0x1e, 0x23, 0xc8,
	0xd4, 0x2c, 0xd7, 0xc0, 0xd7, 0x22, 0xd4, 0x25, 0x82, 0xcc, 0x3e, 0xfd, 0xa6, 0xc2, 0x4b, 0xa4,
	0x5f, 0x69, 0xd8, 0x30, 0x79, 0x9a, 0x95, 0xd4, 0x12, 0x05, 0x7a, 0x86, 0x89, 0xdb, 0x7f, 0x5d,
	0x01, 0xf5, 0x51, 0xe0, 0x51, 0xf7, 0xc6, 0x59, 0xfa, 0x33, 0xf0, 0xe5, 0xc4, 0x0a, 0x89, 0x67,
	0x06, 0xc8, 0xd1, 0x2c, 0x97, 0xe0, 0xe0, 0x15, 0xb2, 0xb5, 0xd0, 0x7a, 0x8d, 0xb5, 0x28, 0xc4,
	0x3a, 0xd3, 0x5f, 0x54, 0xb7, 0x12, 0x4e, 0x5f, 0x50, 0xce, 0xac, 0xd7, 0xf8, 0x22, 0xc4, 0x3a,
	0x7c, 0x04, 0x36, 0xdd, 0xc8, 0xd1, 0x66, 0x95, 0x84, 0x6c, 0xfb, 0xa2, 0xba, 0xe1, 0x46, 0xce,
	0xd3, 0xe9, 0xe5, 0x21, 0x3c, 0x00, 0x3b, 0xd8, 0x45, 0x97, 0x36, 0x16, 0xb9, 0xe6, 0x45, 0x84,
	0xfe, 0xd8, 0x88, 0x60, 0x57, 0xbf, 0x61, 0xd9, 0x54, 0x3a, 0x5c, 0x90, 0x25, 0x55, 0xe6, 0x34,
	0xe6, 0x85, 0x21, 0x23, 0x9d, 0x72, 0x0e, 0xfc, 0x3e, 0x68, 0x08, 0x15, 0xbe, 0x38, 0x14, 0x4b,
	0xa0, 0x92, 0x5a, 0xe7, 0x70, 0x7c, 0x54, 0xb8, 0x0f, 0x36, 0x04, 0x51, 0xd4, 0x6e, 0xbc, 0xcb,
	0x12, 0xa3, 0xaf, 0x71, 0x21, 0x77, 0x71, 0xac, 0x7c, 0x08, 0xbe, 0x89, 0xc2, 0xa4, 0x6c, 0x88,
	0xe5, 0xe0, 0x90, 0x20, 0xc7, 0xd7, 0xc6, 0x5e, 0xa0, 0x21, 0xc3, 0xc0, 0x86, 0x10, 0xc9, 0xcb,
	0x4c, 0x47, 0x2b, 0x0a, 0x45, 0x2d, 0x9d, 0xc7, 0xd4, 0x13, 0x2f, 0x38, 0xa0, 0x44, 0x0e, 0xc3,
	0x07, 0x00, 0x92, 0x00, 0xe9, 0x58, 0xb3, 0x3d, 0x53, 0xd3, 0x91, 0x8f, 0x74, 0x8b, 0xdc, 0xc8,
	0x2b, 0xcc, 0x47, 0x4d, 0x26, 0x39, 0xf5, 0xcc, 0x23, 0x81, 0xc3, 0x9f, 0x80, 0x6d, 0xce, 0xc6,
	0xaf, 0xb0, 0xcb, 0x2b, 0x2c, 0xd4, 0x0c, 0x2b, 0xa4, 0x86, 0x1a, 0x72, 0xa9, 0x55, 0xec, 0x2c,
	0xa9, 0x9b, 0x8c, 0xd1, 0xa3, 0x04, 0x5a, 0x1f, 0xe1, 0xb1, 0x10, 0xc3, 0x5d, 0x50, 0x4f, 0xb7,
	0xf2, 0x11, 0x99, 0xc8, 0x65, 0x96, 0x26, 0xd5, 0x78, 0x9b, 0x11, 0x22, 0x13, 0xf8, 0x2d, 0x68,
	0x64, 0x0c, 0xf2, 0x22, 0x97, 0xc8, 0xa0, 0x25, 0x75, 0x96, 0xd4, 0x5a, 0x62, 0x0d, 0x05, 0xe1,
	0x43, 0xb0, 0x99, 0xf2, 0x92, 0x14, 0x61, 0xd9, 0x51, 0x61, 0xd6, 0xaf, 0xc7, 0xfc, 0x38, 0xba,
	0x2c, 0x31, 0x7e, 0x00, 0x36, 0xd2, 0x65, 0x0e, 0x0a, 0x4c, 0xcb, 0xe5, 0x8b, 0xaa, 0x6c, 0x11,
	0x8c, 0x17, 0x3d, 0x67, 0x22, 0xb6, 0xe4, 0xa7, 0x60, 0x2b, 0x5d, 0x62, 0x44, 0x01, 0xa2, 0x25,
	0xc0, 0x3d, 0x10, 0xca, 0xb5, 0x24, 0x23, 0xbe, 0x88, 0x97, 0x1e, 0x0b, 0x0a, 0x73, 0x41, 0x08,
	0x1f, 0x03, 0x79, 0x8e, 0xa1, 0xfc, 0x64, 0x75, 0x76, 0xb2, 0x8d, 0x69, 0x4b, 0xf9, 0x09, 0x73,
	0xa1, 0x49, 0x9c, 0xdc, 0x60, 0x81, 0x4d, 0x42, 0x93, 0x78, 0xf7, 0x6b, 0x50, 0x13, 0xa1, 0x71,
	0x39, 0xb1, 0xc9, 0x88, 0xdc, 0xb9, 0x3d, 0x8e, 0x4d, 0xdb, 0x12, 0x12, 0xe4, 0x92, 0xf8, 0x24,
	0xab, 0x8c, 0x9f, 0xb1, 0x85, 0x49, 0xc5, 0x21, 0xee, 0x83, 0xd5, 0xcc, 0xb5, 0x3a, 0xb6, 0x6c,
	0x82, 0x03, 0x19, 0xb2, 0xf0, 0x35, 0x53, 0xc1, 0x09, 0xc3, 0xdb, 0xff, 0xa9, 0x83, 0x8d, 0xa3,
	0x04, 0x7c, 0x12, 0x20, 0x7f, 0x22, 0xea, 0xfa, 0x47, 0x60, 0xd1, 0xf5, 0x0c, 0x2c, 0x5a, 0xce,
	0x37, 0x99, 0x96, 0x33, 0x97, 0xdf, 0x1d, 0x78, 0x06, 0x56, 0xd9, 0x12, 0xd8, 0x03, 0xf5, 0xfc,
	0x15, 0x2b, 0x2f, 0x33, 0x25, 0x4a, 0x46, 0x09, 0xcf, 0xe9, 0x13, 0x2e, 0xe7, 0x2a, 0xd4, 0x9a,
	0x9f, 0x05, 0xe1, 0x10, 0x34, 0xa7, 0xef, 0x5f, 0x79, 0x85, 0x29, 0x6a, 0xcd, 0x28, 0x7a, 0x12,
	0x33, 0xb8, 0x2a, 0x16, 0xe5, 0x86, 0x9f, 0x17, 0xc1, 0xaf, 0x40, 0x85, 0x76, 0x1a, 0x32, 0x09,
	0x30, 0x32, 0x42, 0xb9, 0xc4, 0x22, 0x0a, 0xdc, 0xc8, 0x39, 0xe7, 0x08, 0x35, 0x3c, 0x7f, 0x8b,
	0xcb, 0xe5, 0x19, 0xc3, 0xcf, 0x18, 0xe1, 0x29, 0x97, 0xc7, 0x86, 0x87, 0x59, 0x10, 0x7e, 0x0f,
	0x54, 0x79, 0x4b, 0xe2, 0xcd, 0x42, 0x06, 0xec, 0xfe, 0xab, 0x58, 0x69, 0x1b, 0xa6, 0x29, 0x20,
	0xfa, 0x95, 0xe0, 0x34, 0x18, 0xa7, 0xca, 0x41, 0x41, 0xba, 0x07, 0x56, 0x85, 0x9e, 0xf4, 0xfe,
	0x95, 0x9b, 0x8c, 0xc8, 0xdb, 0xfc, 0x59, 0x72, 0xff, 0xd2, 0x0c, 0x8c, 0x15, 0x66, 0xc8, 0xab,
	0x8c, 0xdc, 0x14, 0x5a, 0x53, 0xf6, 0x2e, 0xa8, 0x3b, 0xe8, 0x5a, 0xfb, 0x4d, 0x84, 0x23, 0xcc,
	0x7a, 0x35, 0x2b, 0xc4, 0x25, 0xb5, 0xea, 0xa0, 0xeb, 0x9f, 0x53, 0x90, 0x76, 0x67, 0xda, 0x1e,
	0x03, 0xec, 0x7b, 0x01, 0xd1, 0x0c, 0x8c, 0x0c, 0xdb, 0xd3, 0xaf, 0xe4, 0x0d, 0xde, 0x1e, 0x39,
	0x7c, 0x2c, 0x50, 0x78, 0x01, 0xd6, 0xb3, 0x07, 0x4e, 0xbc, 0x57, 0x65, 0xe3, 0xc8, 0xd7, 0xd3,
	0xd7, 0x15, 0x3f, 0x5e, 0xde, 0x85, 0xd0, 0x9a, 0x91, 0xc0, 0x97, 0x60, 0x23, 0xe7, 0xa4, 0x44,
	0x6f, 0x8d, 0xe9, 0xcd, 0x4e, 0x0a, 0xc3, 0x8c, 0xdf, 0xf2, 0x8a, 0xd7, 0xbc, 0x59, 0x11, 0x7c,
	0x08, 0x4a, 0x58, 0x0c, 0x5b, 0x72, 0x9d, 0x85, 0x78, 0x2b, 0xa3, 0x2c, 0x3f, 0x87, 0xa9, 0x09,
	0x15, 0x1e, 0x82, 0x46, 0x7c, 0x51, 0x68, 0x3a, 0x13, 0xb2, 0xc2, 0xca, 0xaf, 0xce, 0xdf, 0x8f,
	0x6a, 0xdd, 0xcf, 0xdf, 0x97, 0x32, 0x58, 0xa1, 0xc1, 0x41, 0x26, 0x96, 0xd7, 0x58, 0x51, 0xc6,
	0x9f, 0xc9, 0x6c, 0xb7, 0x9e, 0x99, 0xed, 0x1e, 0xa5, 0xb3, 0xdd, 0x3f, 0x57, 0x3e, 0x7f, 0xb8,
	0x83, 0x3f, 0x06, 0x35, 0x93, 0x16, 0x67, 0x3c, 0x0e, 0xf3, 0x21, 0xac, 0xb2, 0xbf, 0xde, 0xe5,
	0x83, 0x75, 0x37, 0x1e, 0xac, 0xbb, 0x07, 0xee, 0x8d, 0x5a, 0x65, 0x5c, 0xa1, 0x64, 0xfb, 0xef,
	0xcb, 0x60, 0x91, 0x56, 0xf3, 0xdc, 0x69, 0x50, 0x01, 0x20, 0x6d, 0x22, 0x62, 0x0c, 0xcd, 0x20,
	0x33, 0xb9, 0x5f, 0xfc, 0x8c, 0xdc, 0x5f, 0xfc, 0xdc, 0xdc, 0x5f, 0xfa, 0x5f, 0x72, 0x7f, 0xf9,
	0x8e, 0xdc, 0xcf, 0xb8, 0x94, 0x7b, 0xf4, 0xcb, 0xb9, 0xbd, 0x6d, 0xc6, 0xa5, 0x8f, 0x41, 0x95,
	0x76, 0xb7, 0xc4, 0xa3, 0xa5, 0x8f, 0x38, 0xb4, 0x42, 0x99, 0x42, 0x03, 0x75, 0x49, 0xe8, 0x45,
	0x01, 0x6d, 0xe5, 0xe8, 0x86, 0xf5, 0x14, 0x5a, 0x6a, 0x15, 0x8e, 0x9d, 0x52, 0x88, 0xce, 0xd8,
	0x97, 0xd1, 0x78, 0x8c, 0x03, 0x3e, 0x38, 0x4d, 0xac, 0xe4, 0x2a, 0xad, 0x73, 0x9c, 0xd6, 0xe3,
	0x53, 0xcb, 0x25, 0x77, 0x96, 0x5a, 0xe5, 0x3b, 0x2a, 0xb5, 0xea, 0xff, 0x5b, 0x6a, 0x27, 0x49,
	0x20, 0xb9, 0x62, 0xcb, 0x1d, 0x7b, 0x72, 0x6d, 0xfe, 0x1c, 0x9b, 0xce, 0xa8, 0x71, 0x90, 0xd3,
	0xa1, 0x75, 0x3b, 0x57, 0xb2, 0x6c, 0x66, 0x4d, 0xea, 0xf2, 0x64, 0xb6, 0x2e, 0x1b, 0x9f, 0xa8,
	0x4b, 0x76, 0x43, 0x4c, 0xd7, 0x66, 0x1b, 0xd4, 0x68, 0x5b, 0xb4, 0x5c, 0x6d, 0x6c, 0x5b, 0xe6,
	0x84, 0xb0, 0x8b, 0x79, 0x49, 0xad, 0x38, 0xe8, 0xba, 0xef, 0x9e, 0x30, 0x88, 0x46, 0x93, 0x67,
	0x80, 0xf6, 0x0a, 0xd9, 0x11, 0x16, 0x2d, 0xb6, 0xc2, 0xb1, 0x17, 0x14, 0x82, 0xdf, 0x82, 0x7a,
	0xfe, 0x1d, 0x24, 0xff, 0x9b, 0x3f, 0x81, 0x6a, 0xb9, 0x27, 0xd0, 0xe1, 0x1f, 0xa5, 0x37, 0xef,
	0x94, 0xc2, 0xdb, 0x77, 0x4a, 0xe1, 0xc3, 0x3b, 0x45, 0xfa, 0xdd, 0xad, 0x22, 0xfd, 0xf9, 0x56,
	0x91, 0xfe, 0x72, 0xab, 0x48, 0x6f, 0x6e, 0x15, 0xe9, 0x6f, 0xb7, 0x8a, 0xf4, 0x8f, 0x5b, 0xa5,
	0xf0, 0xe1, 0x56, 0x91, 0xfe, 0xf0, 0x5e, 0x29, 0xbc, 0x79, 0xaf, 0x14, 0xde, 0xbe, 0x57, 0x0a,
	0x60, 0x5b, 0xf7, 0x9c, 0x38, 0xeb, 0xd2, 0xe3, 0xb1, 0xfc, 0x3b, 0x6c, 0xa4, 0x09, 0x3c, 0xa2,
	0xc0, 0xaf, 0xf6, 0x4c, 0x8b, 0x4c, 0xa2, 0xcb, 0xae, 0xee, 0x39, 0x7b, 0xe2, 0x4d, 0x9d, 0x3e,
	0x49, 0xe7, 0x3c, 0x4e, 0x47, 0x85, 0xcb, 0x65, 0xa6, 0xea, 0x87, 0xff, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0x3f, 0x4d, 0xc1, 0x19, 0xe3, 0x0f, 0x00, 0x00,
}

func (x InputCollection_InputType) String() string {
	s, ok := InputCollection_InputType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ExecutorConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecutorConfig)
	if !ok {
		that2, ok := that.(ExecutorConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *InputCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InputCollection)
	if !ok {
		that2, ok := that.(InputCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.SidePacketName) != len(that1.SidePacketName) {
		return false
	}
	for i := range this.SidePacketName {
		if this.SidePacketName[i] != that1.SidePacketName[i] {
			return false
		}
	}
	if len(this.ExternalInputName) != len(that1.ExternalInputName) {
		return false
	}
	for i := range this.ExternalInputName {
		if this.ExternalInputName[i] != that1.ExternalInputName[i] {
			return false
		}
	}
	if this.InputType != that1.InputType {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	return true
}
func (this *InputCollectionSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InputCollectionSet)
	if !ok {
		that2, ok := that.(InputCollectionSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InputCollection) != len(that1.InputCollection) {
		return false
	}
	for i := range this.InputCollection {
		if !this.InputCollection[i].Equal(that1.InputCollection[i]) {
			return false
		}
	}
	return true
}
func (this *InputStreamInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InputStreamInfo)
	if !ok {
		that2, ok := that.(InputStreamInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TagIndex != that1.TagIndex {
		return false
	}
	if this.BackEdge != that1.BackEdge {
		return false
	}
	return true
}
func (this *ProfilerConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProfilerConfig)
	if !ok {
		that2, ok := that.(ProfilerConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HistogramIntervalSizeUsec != that1.HistogramIntervalSizeUsec {
		return false
	}
	if this.NumHistogramIntervals != that1.NumHistogramIntervals {
		return false
	}
	if this.EnableInputOutputLatency != that1.EnableInputOutputLatency {
		return false
	}
	if this.EnableProfiler != that1.EnableProfiler {
		return false
	}
	if this.EnableStreamLatency != that1.EnableStreamLatency {
		return false
	}
	if this.UsePacketTimestampForAddedPacket != that1.UsePacketTimestampForAddedPacket {
		return false
	}
	if this.TraceLogCapacity != that1.TraceLogCapacity {
		return false
	}
	if len(this.TraceEventTypesDisabled) != len(that1.TraceEventTypesDisabled) {
		return false
	}
	for i := range this.TraceEventTypesDisabled {
		if this.TraceEventTypesDisabled[i] != that1.TraceEventTypesDisabled[i] {
			return false
		}
	}
	if this.TraceLogPath != that1.TraceLogPath {
		return false
	}
	if this.TraceLogCount != that1.TraceLogCount {
		return false
	}
	if this.TraceLogIntervalUsec != that1.TraceLogIntervalUsec {
		return false
	}
	if this.TraceLogMarginUsec != that1.TraceLogMarginUsec {
		return false
	}
	if this.TraceLogDurationEvents != that1.TraceLogDurationEvents {
		return false
	}
	if this.TraceLogIntervalCount != that1.TraceLogIntervalCount {
		return false
	}
	if this.TraceLogDisabled != that1.TraceLogDisabled {
		return false
	}
	if this.TraceEnabled != that1.TraceEnabled {
		return false
	}
	if this.TraceLogInstantEvents != that1.TraceLogInstantEvents {
		return false
	}
	if this.CalculatorFilter != that1.CalculatorFilter {
		return false
	}
	return true
}
func (this *CalculatorGraphConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalculatorGraphConfig)
	if !ok {
		that2, ok := that.(CalculatorGraphConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Node) != len(that1.Node) {
		return false
	}
	for i := range this.Node {
		if !this.Node[i].Equal(that1.Node[i]) {
			return false
		}
	}
	if len(this.PacketFactory) != len(that1.PacketFactory) {
		return false
	}
	for i := range this.PacketFactory {
		if !this.PacketFactory[i].Equal(that1.PacketFactory[i]) {
			return false
		}
	}
	if len(this.PacketGenerator) != len(that1.PacketGenerator) {
		return false
	}
	for i := range this.PacketGenerator {
		if !this.PacketGenerator[i].Equal(that1.PacketGenerator[i]) {
			return false
		}
	}
	if this.NumThreads != that1.NumThreads {
		return false
	}
	if len(this.StatusHandler) != len(that1.StatusHandler) {
		return false
	}
	for i := range this.StatusHandler {
		if !this.StatusHandler[i].Equal(that1.StatusHandler[i]) {
			return false
		}
	}
	if len(this.InputStream) != len(that1.InputStream) {
		return false
	}
	for i := range this.InputStream {
		if this.InputStream[i] != that1.InputStream[i] {
			return false
		}
	}
	if len(this.OutputStream) != len(that1.OutputStream) {
		return false
	}
	for i := range this.OutputStream {
		if this.OutputStream[i] != that1.OutputStream[i] {
			return false
		}
	}
	if len(this.InputSidePacket) != len(that1.InputSidePacket) {
		return false
	}
	for i := range this.InputSidePacket {
		if this.InputSidePacket[i] != that1.InputSidePacket[i] {
			return false
		}
	}
	if len(this.OutputSidePacket) != len(that1.OutputSidePacket) {
		return false
	}
	for i := range this.OutputSidePacket {
		if this.OutputSidePacket[i] != that1.OutputSidePacket[i] {
			return false
		}
	}
	if this.MaxQueueSize != that1.MaxQueueSize {
		return false
	}
	if this.ReportDeadlock != that1.ReportDeadlock {
		return false
	}
	if !this.InputStreamHandler.Equal(that1.InputStreamHandler) {
		return false
	}
	if !this.OutputStreamHandler.Equal(that1.OutputStreamHandler) {
		return false
	}
	if len(this.Executor) != len(that1.Executor) {
		return false
	}
	for i := range this.Executor {
		if !this.Executor[i].Equal(that1.Executor[i]) {
			return false
		}
	}
	if !this.ProfilerConfig.Equal(that1.ProfilerConfig) {
		return false
	}
	if this.Package != that1.Package {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if len(this.GraphOptions) != len(that1.GraphOptions) {
		return false
	}
	for i := range this.GraphOptions {
		if !this.GraphOptions[i].Equal(that1.GraphOptions[i]) {
			return false
		}
	}
	return true
}
func (this *CalculatorGraphConfig_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalculatorGraphConfig_Node)
	if !ok {
		that2, ok := that.(CalculatorGraphConfig_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Calculator != that1.Calculator {
		return false
	}
	if len(this.InputStream) != len(that1.InputStream) {
		return false
	}
	for i := range this.InputStream {
		if this.InputStream[i] != that1.InputStream[i] {
			return false
		}
	}
	if len(this.OutputStream) != len(that1.OutputStream) {
		return false
	}
	for i := range this.OutputStream {
		if this.OutputStream[i] != that1.OutputStream[i] {
			return false
		}
	}
	if len(this.InputSidePacket) != len(that1.InputSidePacket) {
		return false
	}
	for i := range this.InputSidePacket {
		if this.InputSidePacket[i] != that1.InputSidePacket[i] {
			return false
		}
	}
	if len(this.OutputSidePacket) != len(that1.OutputSidePacket) {
		return false
	}
	for i := range this.OutputSidePacket {
		if this.OutputSidePacket[i] != that1.OutputSidePacket[i] {
			return false
		}
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	if len(this.NodeOptions) != len(that1.NodeOptions) {
		return false
	}
	for i := range this.NodeOptions {
		if !this.NodeOptions[i].Equal(that1.NodeOptions[i]) {
			return false
		}
	}
	if this.SourceLayer != that1.SourceLayer {
		return false
	}
	if this.BufferSizeHint != that1.BufferSizeHint {
		return false
	}
	if !this.InputStreamHandler.Equal(that1.InputStreamHandler) {
		return false
	}
	if !this.OutputStreamHandler.Equal(that1.OutputStreamHandler) {
		return false
	}
	if len(this.InputStreamInfo) != len(that1.InputStreamInfo) {
		return false
	}
	for i := range this.InputStreamInfo {
		if !this.InputStreamInfo[i].Equal(that1.InputStreamInfo[i]) {
			return false
		}
	}
	if this.Executor != that1.Executor {
		return false
	}
	if !this.ProfilerConfig.Equal(that1.ProfilerConfig) {
		return false
	}
	if this.MaxInFlight != that1.MaxInFlight {
		return false
	}
	if len(this.OptionValue) != len(that1.OptionValue) {
		return false
	}
	for i := range this.OptionValue {
		if this.OptionValue[i] != that1.OptionValue[i] {
			return false
		}
	}
	if len(this.ExternalInput) != len(that1.ExternalInput) {
		return false
	}
	for i := range this.ExternalInput {
		if this.ExternalInput[i] != that1.ExternalInput[i] {
			return false
		}
	}
	return true
}
func (this *ExecutorConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&framework.ExecutorConfig{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InputCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&framework.InputCollection{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "SidePacketName: "+fmt.Sprintf("%#v", this.SidePacketName)+",\n")
	s = append(s, "ExternalInputName: "+fmt.Sprintf("%#v", this.ExternalInputName)+",\n")
	s = append(s, "InputType: "+fmt.Sprintf("%#v", this.InputType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InputCollectionSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&framework.InputCollectionSet{")
	if this.InputCollection != nil {
		s = append(s, "InputCollection: "+fmt.Sprintf("%#v", this.InputCollection)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InputStreamInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&framework.InputStreamInfo{")
	s = append(s, "TagIndex: "+fmt.Sprintf("%#v", this.TagIndex)+",\n")
	s = append(s, "BackEdge: "+fmt.Sprintf("%#v", this.BackEdge)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProfilerConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&framework.ProfilerConfig{")
	s = append(s, "HistogramIntervalSizeUsec: "+fmt.Sprintf("%#v", this.HistogramIntervalSizeUsec)+",\n")
	s = append(s, "NumHistogramIntervals: "+fmt.Sprintf("%#v", this.NumHistogramIntervals)+",\n")
	s = append(s, "EnableInputOutputLatency: "+fmt.Sprintf("%#v", this.EnableInputOutputLatency)+",\n")
	s = append(s, "EnableProfiler: "+fmt.Sprintf("%#v", this.EnableProfiler)+",\n")
	s = append(s, "EnableStreamLatency: "+fmt.Sprintf("%#v", this.EnableStreamLatency)+",\n")
	s = append(s, "UsePacketTimestampForAddedPacket: "+fmt.Sprintf("%#v", this.UsePacketTimestampForAddedPacket)+",\n")
	s = append(s, "TraceLogCapacity: "+fmt.Sprintf("%#v", this.TraceLogCapacity)+",\n")
	s = append(s, "TraceEventTypesDisabled: "+fmt.Sprintf("%#v", this.TraceEventTypesDisabled)+",\n")
	s = append(s, "TraceLogPath: "+fmt.Sprintf("%#v", this.TraceLogPath)+",\n")
	s = append(s, "TraceLogCount: "+fmt.Sprintf("%#v", this.TraceLogCount)+",\n")
	s = append(s, "TraceLogIntervalUsec: "+fmt.Sprintf("%#v", this.TraceLogIntervalUsec)+",\n")
	s = append(s, "TraceLogMarginUsec: "+fmt.Sprintf("%#v", this.TraceLogMarginUsec)+",\n")
	s = append(s, "TraceLogDurationEvents: "+fmt.Sprintf("%#v", this.TraceLogDurationEvents)+",\n")
	s = append(s, "TraceLogIntervalCount: "+fmt.Sprintf("%#v", this.TraceLogIntervalCount)+",\n")
	s = append(s, "TraceLogDisabled: "+fmt.Sprintf("%#v", this.TraceLogDisabled)+",\n")
	s = append(s, "TraceEnabled: "+fmt.Sprintf("%#v", this.TraceEnabled)+",\n")
	s = append(s, "TraceLogInstantEvents: "+fmt.Sprintf("%#v", this.TraceLogInstantEvents)+",\n")
	s = append(s, "CalculatorFilter: "+fmt.Sprintf("%#v", this.CalculatorFilter)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CalculatorGraphConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&framework.CalculatorGraphConfig{")
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	if this.PacketFactory != nil {
		s = append(s, "PacketFactory: "+fmt.Sprintf("%#v", this.PacketFactory)+",\n")
	}
	if this.PacketGenerator != nil {
		s = append(s, "PacketGenerator: "+fmt.Sprintf("%#v", this.PacketGenerator)+",\n")
	}
	s = append(s, "NumThreads: "+fmt.Sprintf("%#v", this.NumThreads)+",\n")
	if this.StatusHandler != nil {
		s = append(s, "StatusHandler: "+fmt.Sprintf("%#v", this.StatusHandler)+",\n")
	}
	s = append(s, "InputStream: "+fmt.Sprintf("%#v", this.InputStream)+",\n")
	s = append(s, "OutputStream: "+fmt.Sprintf("%#v", this.OutputStream)+",\n")
	s = append(s, "InputSidePacket: "+fmt.Sprintf("%#v", this.InputSidePacket)+",\n")
	s = append(s, "OutputSidePacket: "+fmt.Sprintf("%#v", this.OutputSidePacket)+",\n")
	s = append(s, "MaxQueueSize: "+fmt.Sprintf("%#v", this.MaxQueueSize)+",\n")
	s = append(s, "ReportDeadlock: "+fmt.Sprintf("%#v", this.ReportDeadlock)+",\n")
	if this.InputStreamHandler != nil {
		s = append(s, "InputStreamHandler: "+fmt.Sprintf("%#v", this.InputStreamHandler)+",\n")
	}
	if this.OutputStreamHandler != nil {
		s = append(s, "OutputStreamHandler: "+fmt.Sprintf("%#v", this.OutputStreamHandler)+",\n")
	}
	if this.Executor != nil {
		s = append(s, "Executor: "+fmt.Sprintf("%#v", this.Executor)+",\n")
	}
	if this.ProfilerConfig != nil {
		s = append(s, "ProfilerConfig: "+fmt.Sprintf("%#v", this.ProfilerConfig)+",\n")
	}
	s = append(s, "Package: "+fmt.Sprintf("%#v", this.Package)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	if this.GraphOptions != nil {
		s = append(s, "GraphOptions: "+fmt.Sprintf("%#v", this.GraphOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CalculatorGraphConfig_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&framework.CalculatorGraphConfig_Node{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Calculator: "+fmt.Sprintf("%#v", this.Calculator)+",\n")
	s = append(s, "InputStream: "+fmt.Sprintf("%#v", this.InputStream)+",\n")
	s = append(s, "OutputStream: "+fmt.Sprintf("%#v", this.OutputStream)+",\n")
	s = append(s, "InputSidePacket: "+fmt.Sprintf("%#v", this.InputSidePacket)+",\n")
	s = append(s, "OutputSidePacket: "+fmt.Sprintf("%#v", this.OutputSidePacket)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	if this.NodeOptions != nil {
		s = append(s, "NodeOptions: "+fmt.Sprintf("%#v", this.NodeOptions)+",\n")
	}
	s = append(s, "SourceLayer: "+fmt.Sprintf("%#v", this.SourceLayer)+",\n")
	s = append(s, "BufferSizeHint: "+fmt.Sprintf("%#v", this.BufferSizeHint)+",\n")
	if this.InputStreamHandler != nil {
		s = append(s, "InputStreamHandler: "+fmt.Sprintf("%#v", this.InputStreamHandler)+",\n")
	}
	if this.OutputStreamHandler != nil {
		s = append(s, "OutputStreamHandler: "+fmt.Sprintf("%#v", this.OutputStreamHandler)+",\n")
	}
	if this.InputStreamInfo != nil {
		s = append(s, "InputStreamInfo: "+fmt.Sprintf("%#v", this.InputStreamInfo)+",\n")
	}
	s = append(s, "Executor: "+fmt.Sprintf("%#v", this.Executor)+",\n")
	if this.ProfilerConfig != nil {
		s = append(s, "ProfilerConfig: "+fmt.Sprintf("%#v", this.ProfilerConfig)+",\n")
	}
	s = append(s, "MaxInFlight: "+fmt.Sprintf("%#v", this.MaxInFlight)+",\n")
	s = append(s, "OptionValue: "+fmt.Sprintf("%#v", this.OptionValue)+",\n")
	s = append(s, "ExternalInput: "+fmt.Sprintf("%#v", this.ExternalInput)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCalculator(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ExecutorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InputCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalInputName) > 0 {
		for iNdEx := len(m.ExternalInputName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExternalInputName[iNdEx])
			copy(dAtA[i:], m.ExternalInputName[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.ExternalInputName[iNdEx])))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x22
	}
	if m.InputType != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.InputType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SidePacketName) > 0 {
		for iNdEx := len(m.SidePacketName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SidePacketName[iNdEx])
			copy(dAtA[i:], m.SidePacketName[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.SidePacketName[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InputCollectionSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputCollectionSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputCollectionSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputCollection) > 0 {
		for iNdEx := len(m.InputCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InputStreamInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputStreamInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputStreamInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BackEdge {
		i--
		if m.BackEdge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TagIndex) > 0 {
		i -= len(m.TagIndex)
		copy(dAtA[i:], m.TagIndex)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.TagIndex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfilerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CalculatorFilter) > 0 {
		i -= len(m.CalculatorFilter)
		copy(dAtA[i:], m.CalculatorFilter)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.CalculatorFilter)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.TraceLogInstantEvents {
		i--
		if m.TraceLogInstantEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TraceEnabled {
		i--
		if m.TraceEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TraceLogDisabled {
		i--
		if m.TraceLogDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.TraceLogIntervalCount != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.TraceLogIntervalCount))
		i--
		dAtA[i] = 0x70
	}
	if m.TraceLogDurationEvents {
		i--
		if m.TraceLogDurationEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.TraceLogMarginUsec != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.TraceLogMarginUsec))
		i--
		dAtA[i] = 0x60
	}
	if m.TraceLogIntervalUsec != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.TraceLogIntervalUsec))
		i--
		dAtA[i] = 0x58
	}
	if m.TraceLogCount != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.TraceLogCount))
		i--
		dAtA[i] = 0x50
	}
	if len(m.TraceLogPath) > 0 {
		i -= len(m.TraceLogPath)
		copy(dAtA[i:], m.TraceLogPath)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.TraceLogPath)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TraceEventTypesDisabled) > 0 {
		dAtA3 := make([]byte, len(m.TraceEventTypesDisabled)*10)
		var j2 int
		for _, num1 := range m.TraceEventTypesDisabled {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintCalculator(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x42
	}
	if m.TraceLogCapacity != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.TraceLogCapacity))
		i--
		dAtA[i] = 0x38
	}
	if m.UsePacketTimestampForAddedPacket {
		i--
		if m.UsePacketTimestampForAddedPacket {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EnableStreamLatency {
		i--
		if m.EnableStreamLatency {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.EnableProfiler {
		i--
		if m.EnableProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EnableInputOutputLatency {
		i--
		if m.EnableInputOutputLatency {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NumHistogramIntervals != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.NumHistogramIntervals))
		i--
		dAtA[i] = 0x10
	}
	if m.HistogramIntervalSizeUsec != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.HistogramIntervalSizeUsec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CalculatorGraphConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculatorGraphConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculatorGraphConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GraphOptions) > 0 {
		for iNdEx := len(m.GraphOptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GraphOptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.ReportDeadlock {
		i--
		if m.ReportDeadlock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Package) > 0 {
		i -= len(m.Package)
		copy(dAtA[i:], m.Package)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Package)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ProfilerConfig != nil {
		{
			size, err := m.ProfilerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OutputSidePacket) > 0 {
		for iNdEx := len(m.OutputSidePacket) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutputSidePacket[iNdEx])
			copy(dAtA[i:], m.OutputSidePacket[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.OutputSidePacket[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.InputSidePacket) > 0 {
		for iNdEx := len(m.InputSidePacket) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputSidePacket[iNdEx])
			copy(dAtA[i:], m.InputSidePacket[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.InputSidePacket[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.OutputStream) > 0 {
		for iNdEx := len(m.OutputStream) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutputStream[iNdEx])
			copy(dAtA[i:], m.OutputStream[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.OutputStream[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Executor) > 0 {
		for iNdEx := len(m.Executor) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Executor[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.OutputStreamHandler != nil {
		{
			size, err := m.OutputStreamHandler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.InputStreamHandler != nil {
		{
			size, err := m.InputStreamHandler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MaxQueueSize != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.MaxQueueSize))
		i--
		dAtA[i] = 0x58
	}
	if len(m.InputStream) > 0 {
		for iNdEx := len(m.InputStream) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputStream[iNdEx])
			copy(dAtA[i:], m.InputStream[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.InputStream[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.StatusHandler) > 0 {
		for iNdEx := len(m.StatusHandler) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StatusHandler[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.NumThreads != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.NumThreads))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PacketGenerator) > 0 {
		for iNdEx := len(m.PacketGenerator) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PacketGenerator[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PacketFactory) > 0 {
		for iNdEx := len(m.PacketFactory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PacketFactory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Node) > 0 {
		for iNdEx := len(m.Node) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Node[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CalculatorGraphConfig_Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculatorGraphConfig_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculatorGraphConfig_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalInput) > 0 {
		for iNdEx := len(m.ExternalInput) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExternalInput[iNdEx])
			copy(dAtA[i:], m.ExternalInput[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.ExternalInput[iNdEx])))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.OptionValue) > 0 {
		for iNdEx := len(m.OptionValue) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OptionValue[iNdEx])
			copy(dAtA[i:], m.OptionValue[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.OptionValue[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.MaxInFlight != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.MaxInFlight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ProfilerConfig != nil {
		{
			size, err := m.ProfilerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Executor) > 0 {
		i -= len(m.Executor)
		copy(dAtA[i:], m.Executor)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Executor)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.InputStreamInfo) > 0 {
		for iNdEx := len(m.InputStreamInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputStreamInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.OutputStreamHandler != nil {
		{
			size, err := m.OutputStreamHandler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.InputStreamHandler != nil {
		{
			size, err := m.InputStreamHandler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.BufferSizeHint != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.BufferSizeHint))
		i--
		dAtA[i] = 0x50
	}
	if m.SourceLayer != 0 {
		i = encodeVarintCalculator(dAtA, i, uint64(m.SourceLayer))
		i--
		dAtA[i] = 0x48
	}
	if len(m.NodeOptions) > 0 {
		for iNdEx := len(m.NodeOptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeOptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCalculator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCalculator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OutputSidePacket) > 0 {
		for iNdEx := len(m.OutputSidePacket) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutputSidePacket[iNdEx])
			copy(dAtA[i:], m.OutputSidePacket[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.OutputSidePacket[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.InputSidePacket) > 0 {
		for iNdEx := len(m.InputSidePacket) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputSidePacket[iNdEx])
			copy(dAtA[i:], m.InputSidePacket[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.InputSidePacket[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OutputStream) > 0 {
		for iNdEx := len(m.OutputStream) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutputStream[iNdEx])
			copy(dAtA[i:], m.OutputStream[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.OutputStream[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InputStream) > 0 {
		for iNdEx := len(m.InputStream) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InputStream[iNdEx])
			copy(dAtA[i:], m.InputStream[iNdEx])
			i = encodeVarintCalculator(dAtA, i, uint64(len(m.InputStream[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Calculator) > 0 {
		i -= len(m.Calculator)
		copy(dAtA[i:], m.Calculator)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Calculator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCalculator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCalculator(dAtA []byte, offset int, v uint64) int {
	offset -= sovCalculator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ExecutorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	return n
}

func (m *InputCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.SidePacketName) > 0 {
		for _, s := range m.SidePacketName {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if m.InputType != 0 {
		n += 1 + sovCalculator(uint64(m.InputType))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.ExternalInputName) > 0 {
		for _, s := range m.ExternalInputName {
			l = len(s)
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	return n
}

func (m *InputCollectionSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InputCollection) > 0 {
		for _, e := range m.InputCollection {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	return n
}

func (m *InputStreamInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagIndex)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.BackEdge {
		n += 2
	}
	return n
}

func (m *ProfilerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HistogramIntervalSizeUsec != 0 {
		n += 1 + sovCalculator(uint64(m.HistogramIntervalSizeUsec))
	}
	if m.NumHistogramIntervals != 0 {
		n += 1 + sovCalculator(uint64(m.NumHistogramIntervals))
	}
	if m.EnableInputOutputLatency {
		n += 2
	}
	if m.EnableProfiler {
		n += 2
	}
	if m.EnableStreamLatency {
		n += 2
	}
	if m.UsePacketTimestampForAddedPacket {
		n += 2
	}
	if m.TraceLogCapacity != 0 {
		n += 1 + sovCalculator(uint64(m.TraceLogCapacity))
	}
	if len(m.TraceEventTypesDisabled) > 0 {
		l = 0
		for _, e := range m.TraceEventTypesDisabled {
			l += sovCalculator(uint64(e))
		}
		n += 1 + sovCalculator(uint64(l)) + l
	}
	l = len(m.TraceLogPath)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.TraceLogCount != 0 {
		n += 1 + sovCalculator(uint64(m.TraceLogCount))
	}
	if m.TraceLogIntervalUsec != 0 {
		n += 1 + sovCalculator(uint64(m.TraceLogIntervalUsec))
	}
	if m.TraceLogMarginUsec != 0 {
		n += 1 + sovCalculator(uint64(m.TraceLogMarginUsec))
	}
	if m.TraceLogDurationEvents {
		n += 2
	}
	if m.TraceLogIntervalCount != 0 {
		n += 1 + sovCalculator(uint64(m.TraceLogIntervalCount))
	}
	if m.TraceLogDisabled {
		n += 2
	}
	if m.TraceEnabled {
		n += 3
	}
	if m.TraceLogInstantEvents {
		n += 3
	}
	l = len(m.CalculatorFilter)
	if l > 0 {
		n += 2 + l + sovCalculator(uint64(l))
	}
	return n
}

func (m *CalculatorGraphConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.PacketFactory) > 0 {
		for _, e := range m.PacketFactory {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.PacketGenerator) > 0 {
		for _, e := range m.PacketGenerator {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if m.NumThreads != 0 {
		n += 1 + sovCalculator(uint64(m.NumThreads))
	}
	if len(m.StatusHandler) > 0 {
		for _, e := range m.StatusHandler {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.InputStream) > 0 {
		for _, s := range m.InputStream {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if m.MaxQueueSize != 0 {
		n += 1 + sovCalculator(uint64(m.MaxQueueSize))
	}
	if m.InputStreamHandler != nil {
		l = m.InputStreamHandler.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.OutputStreamHandler != nil {
		l = m.OutputStreamHandler.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.Executor) > 0 {
		for _, e := range m.Executor {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.OutputStream) > 0 {
		for _, s := range m.OutputStream {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.InputSidePacket) > 0 {
		for _, s := range m.InputSidePacket {
			l = len(s)
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.OutputSidePacket) > 0 {
		for _, s := range m.OutputSidePacket {
			l = len(s)
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	if m.ProfilerConfig != nil {
		l = m.ProfilerConfig.Size()
		n += 2 + l + sovCalculator(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 2 + l + sovCalculator(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovCalculator(uint64(l))
	}
	if m.ReportDeadlock {
		n += 3
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 2 + l + sovCalculator(uint64(l))
	}
	if len(m.GraphOptions) > 0 {
		for _, e := range m.GraphOptions {
			l = e.Size()
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	return n
}

func (m *CalculatorGraphConfig_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	l = len(m.Calculator)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.InputStream) > 0 {
		for _, s := range m.InputStream {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.OutputStream) > 0 {
		for _, s := range m.OutputStream {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.InputSidePacket) > 0 {
		for _, s := range m.InputSidePacket {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.OutputSidePacket) > 0 {
		for _, s := range m.OutputSidePacket {
			l = len(s)
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.NodeOptions) > 0 {
		for _, e := range m.NodeOptions {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	if m.SourceLayer != 0 {
		n += 1 + sovCalculator(uint64(m.SourceLayer))
	}
	if m.BufferSizeHint != 0 {
		n += 1 + sovCalculator(uint64(m.BufferSizeHint))
	}
	if m.InputStreamHandler != nil {
		l = m.InputStreamHandler.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.OutputStreamHandler != nil {
		l = m.OutputStreamHandler.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if len(m.InputStreamInfo) > 0 {
		for _, e := range m.InputStreamInfo {
			l = e.Size()
			n += 1 + l + sovCalculator(uint64(l))
		}
	}
	l = len(m.Executor)
	if l > 0 {
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.ProfilerConfig != nil {
		l = m.ProfilerConfig.Size()
		n += 1 + l + sovCalculator(uint64(l))
	}
	if m.MaxInFlight != 0 {
		n += 2 + sovCalculator(uint64(m.MaxInFlight))
	}
	if len(m.OptionValue) > 0 {
		for _, s := range m.OptionValue {
			l = len(s)
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	if len(m.ExternalInput) > 0 {
		for _, s := range m.ExternalInput {
			l = len(s)
			n += 2 + l + sovCalculator(uint64(l))
		}
	}
	return n
}

func sovCalculator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCalculator(x uint64) (n int) {
	return sovCalculator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ExecutorConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutorConfig{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "MediaPipeOptions", "MediaPipeOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InputCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InputCollection{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`SidePacketName:` + fmt.Sprintf("%v", this.SidePacketName) + `,`,
		`InputType:` + fmt.Sprintf("%v", this.InputType) + `,`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`ExternalInputName:` + fmt.Sprintf("%v", this.ExternalInputName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InputCollectionSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInputCollection := "[]*InputCollection{"
	for _, f := range this.InputCollection {
		repeatedStringForInputCollection += strings.Replace(f.String(), "InputCollection", "InputCollection", 1) + ","
	}
	repeatedStringForInputCollection += "}"
	s := strings.Join([]string{`&InputCollectionSet{`,
		`InputCollection:` + repeatedStringForInputCollection + `,`,
		`}`,
	}, "")
	return s
}
func (this *InputStreamInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InputStreamInfo{`,
		`TagIndex:` + fmt.Sprintf("%v", this.TagIndex) + `,`,
		`BackEdge:` + fmt.Sprintf("%v", this.BackEdge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProfilerConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProfilerConfig{`,
		`HistogramIntervalSizeUsec:` + fmt.Sprintf("%v", this.HistogramIntervalSizeUsec) + `,`,
		`NumHistogramIntervals:` + fmt.Sprintf("%v", this.NumHistogramIntervals) + `,`,
		`EnableInputOutputLatency:` + fmt.Sprintf("%v", this.EnableInputOutputLatency) + `,`,
		`EnableProfiler:` + fmt.Sprintf("%v", this.EnableProfiler) + `,`,
		`EnableStreamLatency:` + fmt.Sprintf("%v", this.EnableStreamLatency) + `,`,
		`UsePacketTimestampForAddedPacket:` + fmt.Sprintf("%v", this.UsePacketTimestampForAddedPacket) + `,`,
		`TraceLogCapacity:` + fmt.Sprintf("%v", this.TraceLogCapacity) + `,`,
		`TraceEventTypesDisabled:` + fmt.Sprintf("%v", this.TraceEventTypesDisabled) + `,`,
		`TraceLogPath:` + fmt.Sprintf("%v", this.TraceLogPath) + `,`,
		`TraceLogCount:` + fmt.Sprintf("%v", this.TraceLogCount) + `,`,
		`TraceLogIntervalUsec:` + fmt.Sprintf("%v", this.TraceLogIntervalUsec) + `,`,
		`TraceLogMarginUsec:` + fmt.Sprintf("%v", this.TraceLogMarginUsec) + `,`,
		`TraceLogDurationEvents:` + fmt.Sprintf("%v", this.TraceLogDurationEvents) + `,`,
		`TraceLogIntervalCount:` + fmt.Sprintf("%v", this.TraceLogIntervalCount) + `,`,
		`TraceLogDisabled:` + fmt.Sprintf("%v", this.TraceLogDisabled) + `,`,
		`TraceEnabled:` + fmt.Sprintf("%v", this.TraceEnabled) + `,`,
		`TraceLogInstantEvents:` + fmt.Sprintf("%v", this.TraceLogInstantEvents) + `,`,
		`CalculatorFilter:` + fmt.Sprintf("%v", this.CalculatorFilter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CalculatorGraphConfig) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNode := "[]*CalculatorGraphConfig_Node{"
	for _, f := range this.Node {
		repeatedStringForNode += strings.Replace(fmt.Sprintf("%v", f), "CalculatorGraphConfig_Node", "CalculatorGraphConfig_Node", 1) + ","
	}
	repeatedStringForNode += "}"
	repeatedStringForPacketFactory := "[]*PacketFactoryConfig{"
	for _, f := range this.PacketFactory {
		repeatedStringForPacketFactory += strings.Replace(fmt.Sprintf("%v", f), "PacketFactoryConfig", "PacketFactoryConfig", 1) + ","
	}
	repeatedStringForPacketFactory += "}"
	repeatedStringForPacketGenerator := "[]*PacketGeneratorConfig{"
	for _, f := range this.PacketGenerator {
		repeatedStringForPacketGenerator += strings.Replace(fmt.Sprintf("%v", f), "PacketGeneratorConfig", "PacketGeneratorConfig", 1) + ","
	}
	repeatedStringForPacketGenerator += "}"
	repeatedStringForStatusHandler := "[]*StatusHandlerConfig{"
	for _, f := range this.StatusHandler {
		repeatedStringForStatusHandler += strings.Replace(fmt.Sprintf("%v", f), "StatusHandlerConfig", "StatusHandlerConfig", 1) + ","
	}
	repeatedStringForStatusHandler += "}"
	repeatedStringForExecutor := "[]*ExecutorConfig{"
	for _, f := range this.Executor {
		repeatedStringForExecutor += strings.Replace(f.String(), "ExecutorConfig", "ExecutorConfig", 1) + ","
	}
	repeatedStringForExecutor += "}"
	repeatedStringForGraphOptions := "[]*Any{"
	for _, f := range this.GraphOptions {
		repeatedStringForGraphOptions += strings.Replace(fmt.Sprintf("%v", f), "Any", "types.Any", 1) + ","
	}
	repeatedStringForGraphOptions += "}"
	s := strings.Join([]string{`&CalculatorGraphConfig{`,
		`Node:` + repeatedStringForNode + `,`,
		`PacketFactory:` + repeatedStringForPacketFactory + `,`,
		`PacketGenerator:` + repeatedStringForPacketGenerator + `,`,
		`NumThreads:` + fmt.Sprintf("%v", this.NumThreads) + `,`,
		`StatusHandler:` + repeatedStringForStatusHandler + `,`,
		`InputStream:` + fmt.Sprintf("%v", this.InputStream) + `,`,
		`MaxQueueSize:` + fmt.Sprintf("%v", this.MaxQueueSize) + `,`,
		`InputStreamHandler:` + strings.Replace(fmt.Sprintf("%v", this.InputStreamHandler), "InputStreamHandlerConfig", "InputStreamHandlerConfig", 1) + `,`,
		`OutputStreamHandler:` + strings.Replace(fmt.Sprintf("%v", this.OutputStreamHandler), "OutputStreamHandlerConfig", "OutputStreamHandlerConfig", 1) + `,`,
		`Executor:` + repeatedStringForExecutor + `,`,
		`OutputStream:` + fmt.Sprintf("%v", this.OutputStream) + `,`,
		`InputSidePacket:` + fmt.Sprintf("%v", this.InputSidePacket) + `,`,
		`OutputSidePacket:` + fmt.Sprintf("%v", this.OutputSidePacket) + `,`,
		`ProfilerConfig:` + strings.Replace(this.ProfilerConfig.String(), "ProfilerConfig", "ProfilerConfig", 1) + `,`,
		`Package:` + fmt.Sprintf("%v", this.Package) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`ReportDeadlock:` + fmt.Sprintf("%v", this.ReportDeadlock) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "MediaPipeOptions", "MediaPipeOptions", 1) + `,`,
		`GraphOptions:` + repeatedStringForGraphOptions + `,`,
		`}`,
	}, "")
	return s
}
func (this *CalculatorGraphConfig_Node) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodeOptions := "[]*Any{"
	for _, f := range this.NodeOptions {
		repeatedStringForNodeOptions += strings.Replace(fmt.Sprintf("%v", f), "Any", "types.Any", 1) + ","
	}
	repeatedStringForNodeOptions += "}"
	repeatedStringForInputStreamInfo := "[]*InputStreamInfo{"
	for _, f := range this.InputStreamInfo {
		repeatedStringForInputStreamInfo += strings.Replace(f.String(), "InputStreamInfo", "InputStreamInfo", 1) + ","
	}
	repeatedStringForInputStreamInfo += "}"
	s := strings.Join([]string{`&CalculatorGraphConfig_Node{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Calculator:` + fmt.Sprintf("%v", this.Calculator) + `,`,
		`InputStream:` + fmt.Sprintf("%v", this.InputStream) + `,`,
		`OutputStream:` + fmt.Sprintf("%v", this.OutputStream) + `,`,
		`InputSidePacket:` + fmt.Sprintf("%v", this.InputSidePacket) + `,`,
		`OutputSidePacket:` + fmt.Sprintf("%v", this.OutputSidePacket) + `,`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "CalculatorOptions", "CalculatorOptions", 1) + `,`,
		`NodeOptions:` + repeatedStringForNodeOptions + `,`,
		`SourceLayer:` + fmt.Sprintf("%v", this.SourceLayer) + `,`,
		`BufferSizeHint:` + fmt.Sprintf("%v", this.BufferSizeHint) + `,`,
		`InputStreamHandler:` + strings.Replace(fmt.Sprintf("%v", this.InputStreamHandler), "InputStreamHandlerConfig", "InputStreamHandlerConfig", 1) + `,`,
		`OutputStreamHandler:` + strings.Replace(fmt.Sprintf("%v", this.OutputStreamHandler), "OutputStreamHandlerConfig", "OutputStreamHandlerConfig", 1) + `,`,
		`InputStreamInfo:` + repeatedStringForInputStreamInfo + `,`,
		`Executor:` + fmt.Sprintf("%v", this.Executor) + `,`,
		`ProfilerConfig:` + strings.Replace(this.ProfilerConfig.String(), "ProfilerConfig", "ProfilerConfig", 1) + `,`,
		`MaxInFlight:` + fmt.Sprintf("%v", this.MaxInFlight) + `,`,
		`OptionValue:` + fmt.Sprintf("%v", this.OptionValue) + `,`,
		`ExternalInput:` + fmt.Sprintf("%v", this.ExternalInput) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCalculator(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ExecutorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MediaPipeOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidePacketName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SidePacketName = append(m.SidePacketName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputType", wireType)
			}
			m.InputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputType |= InputCollection_InputType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalInputName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalInputName = append(m.ExternalInputName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputCollectionSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputCollectionSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputCollectionSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputCollection = append(m.InputCollection, &InputCollection{})
			if err := m.InputCollection[len(m.InputCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputStreamInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputStreamInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputStreamInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackEdge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BackEdge = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfilerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramIntervalSizeUsec", wireType)
			}
			m.HistogramIntervalSizeUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistogramIntervalSizeUsec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumHistogramIntervals", wireType)
			}
			m.NumHistogramIntervals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumHistogramIntervals |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInputOutputLatency", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableInputOutputLatency = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableProfiler = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStreamLatency", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStreamLatency = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePacketTimestampForAddedPacket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePacketTimestampForAddedPacket = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogCapacity", wireType)
			}
			m.TraceLogCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TraceEventTypesDisabled = append(m.TraceEventTypesDisabled, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalculator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalculator
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalculator
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TraceEventTypesDisabled) == 0 {
					m.TraceEventTypesDisabled = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalculator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TraceEventTypesDisabled = append(m.TraceEventTypesDisabled, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceEventTypesDisabled", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceLogPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogCount", wireType)
			}
			m.TraceLogCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogIntervalUsec", wireType)
			}
			m.TraceLogIntervalUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogIntervalUsec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogMarginUsec", wireType)
			}
			m.TraceLogMarginUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogMarginUsec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogDurationEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TraceLogDurationEvents = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogIntervalCount", wireType)
			}
			m.TraceLogIntervalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogIntervalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TraceLogDisabled = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TraceEnabled = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogInstantEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TraceLogInstantEvents = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculatorFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CalculatorFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalculatorGraphConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculatorGraphConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculatorGraphConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &CalculatorGraphConfig_Node{})
			if err := m.Node[len(m.Node)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketFactory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PacketFactory = append(m.PacketFactory, &PacketFactoryConfig{})
			if err := m.PacketFactory[len(m.PacketFactory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketGenerator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PacketGenerator = append(m.PacketGenerator, &PacketGeneratorConfig{})
			if err := m.PacketGenerator[len(m.PacketGenerator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumThreads |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusHandler = append(m.StatusHandler, &StatusHandlerConfig{})
			if err := m.StatusHandler[len(m.StatusHandler)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputStream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputStream = append(m.InputStream, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputStreamHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputStreamHandler == nil {
				m.InputStreamHandler = &InputStreamHandlerConfig{}
			}
			if err := m.InputStreamHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputStreamHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputStreamHandler == nil {
				m.OutputStreamHandler = &OutputStreamHandlerConfig{}
			}
			if err := m.OutputStreamHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executor = append(m.Executor, &ExecutorConfig{})
			if err := m.Executor[len(m.Executor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputStream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputStream = append(m.OutputStream, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSidePacket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSidePacket = append(m.InputSidePacket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSidePacket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputSidePacket = append(m.OutputSidePacket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfilerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfilerConfig == nil {
				m.ProfilerConfig = &ProfilerConfig{}
			}
			if err := m.ProfilerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDeadlock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportDeadlock = bool(v != 0)
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MediaPipeOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphOptions = append(m.GraphOptions, &types.Any{})
			if err := m.GraphOptions[len(m.GraphOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalculatorGraphConfig_Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calculator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calculator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputStream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputStream = append(m.InputStream, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputStream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputStream = append(m.OutputStream, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSidePacket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputSidePacket = append(m.InputSidePacket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSidePacket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputSidePacket = append(m.OutputSidePacket, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &CalculatorOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeOptions = append(m.NodeOptions, &types.Any{})
			if err := m.NodeOptions[len(m.NodeOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLayer", wireType)
			}
			m.SourceLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceLayer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSizeHint", wireType)
			}
			m.BufferSizeHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSizeHint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputStreamHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputStreamHandler == nil {
				m.InputStreamHandler = &InputStreamHandlerConfig{}
			}
			if err := m.InputStreamHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputStreamHandler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputStreamHandler == nil {
				m.OutputStreamHandler = &OutputStreamHandlerConfig{}
			}
			if err := m.OutputStreamHandler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputStreamInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputStreamInfo = append(m.InputStreamInfo, &InputStreamInfo{})
			if err := m.InputStreamInfo[len(m.InputStreamInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfilerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfilerConfig == nil {
				m.ProfilerConfig = &ProfilerConfig{}
			}
			if err := m.ProfilerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInFlight", wireType)
			}
			m.MaxInFlight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInFlight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionValue = append(m.OptionValue, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalInput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalculator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalculator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalInput = append(m.ExternalInput, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalculator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCalculator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCalculator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCalculator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalculator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCalculator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCalculator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCalculator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCalculator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCalculator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCalculator = fmt.Errorf("proto: unexpected end of group")
)
