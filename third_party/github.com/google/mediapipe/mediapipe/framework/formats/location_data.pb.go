// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/framework/formats/location_data.proto

package formats

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	annotation "github.com/google/mediapipe/mediapipe/framework/formats/annotation"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LocationData_Format int32

const (
	LOCATION_FORMAT_GLOBAL                LocationData_Format = 0
	LOCATION_FORMAT_BOUNDING_BOX          LocationData_Format = 1
	LOCATION_FORMAT_RELATIVE_BOUNDING_BOX LocationData_Format = 2
	LOCATION_FORMAT_MASK                  LocationData_Format = 3
)

var LocationData_Format_name = map[int32]string{
	0: "LOCATION_FORMAT_GLOBAL",
	1: "LOCATION_FORMAT_BOUNDING_BOX",
	2: "LOCATION_FORMAT_RELATIVE_BOUNDING_BOX",
	3: "LOCATION_FORMAT_MASK",
}

var LocationData_Format_value = map[string]int32{
	"LOCATION_FORMAT_GLOBAL":                0,
	"LOCATION_FORMAT_BOUNDING_BOX":          1,
	"LOCATION_FORMAT_RELATIVE_BOUNDING_BOX": 2,
	"LOCATION_FORMAT_MASK":                  3,
}

func (x LocationData_Format) Enum() *LocationData_Format {
	p := new(LocationData_Format)
	*p = x
	return p
}

func (x LocationData_Format) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(LocationData_Format_name, int32(x))
}

func (x *LocationData_Format) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LocationData_Format_value, data, "LocationData_Format")
	if err != nil {
		return err
	}
	*x = LocationData_Format(value)
	return nil
}

func (LocationData_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0, 0}
}

type LocationData struct {
	Format              LocationData_Format               `protobuf:"varint,1,opt,name=format,enum=mediapipe.LocationData_Format" json:"format"`
	BoundingBox         *LocationData_BoundingBox         `protobuf:"bytes,2,opt,name=bounding_box,json=boundingBox" json:"bounding_box,omitempty"`
	RelativeBoundingBox *LocationData_RelativeBoundingBox `protobuf:"bytes,3,opt,name=relative_bounding_box,json=relativeBoundingBox" json:"relative_bounding_box,omitempty"`
	Mask                *LocationData_BinaryMask          `protobuf:"bytes,4,opt,name=mask" json:"mask,omitempty"`
	RelativeKeypoints   []*LocationData_RelativeKeypoint  `protobuf:"bytes,5,rep,name=relative_keypoints,json=relativeKeypoints" json:"relative_keypoints,omitempty"`
}

func (m *LocationData) Reset()      { *m = LocationData{} }
func (*LocationData) ProtoMessage() {}
func (*LocationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0}
}
func (m *LocationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationData.Merge(m, src)
}
func (m *LocationData) XXX_Size() int {
	return m.Size()
}
func (m *LocationData) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationData.DiscardUnknown(m)
}

var xxx_messageInfo_LocationData proto.InternalMessageInfo

func (m *LocationData) GetFormat() LocationData_Format {
	if m != nil {
		return m.Format
	}
	return LOCATION_FORMAT_GLOBAL
}

func (m *LocationData) GetBoundingBox() *LocationData_BoundingBox {
	if m != nil {
		return m.BoundingBox
	}
	return nil
}

func (m *LocationData) GetRelativeBoundingBox() *LocationData_RelativeBoundingBox {
	if m != nil {
		return m.RelativeBoundingBox
	}
	return nil
}

func (m *LocationData) GetMask() *LocationData_BinaryMask {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *LocationData) GetRelativeKeypoints() []*LocationData_RelativeKeypoint {
	if m != nil {
		return m.RelativeKeypoints
	}
	return nil
}

type LocationData_BoundingBox struct {
	Xmin   int32 `protobuf:"varint,1,opt,name=xmin" json:"xmin"`
	Ymin   int32 `protobuf:"varint,2,opt,name=ymin" json:"ymin"`
	Width  int32 `protobuf:"varint,3,opt,name=width" json:"width"`
	Height int32 `protobuf:"varint,4,opt,name=height" json:"height"`
}

func (m *LocationData_BoundingBox) Reset()      { *m = LocationData_BoundingBox{} }
func (*LocationData_BoundingBox) ProtoMessage() {}
func (*LocationData_BoundingBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0, 0}
}
func (m *LocationData_BoundingBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationData_BoundingBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationData_BoundingBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationData_BoundingBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationData_BoundingBox.Merge(m, src)
}
func (m *LocationData_BoundingBox) XXX_Size() int {
	return m.Size()
}
func (m *LocationData_BoundingBox) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationData_BoundingBox.DiscardUnknown(m)
}

var xxx_messageInfo_LocationData_BoundingBox proto.InternalMessageInfo

func (m *LocationData_BoundingBox) GetXmin() int32 {
	if m != nil {
		return m.Xmin
	}
	return 0
}

func (m *LocationData_BoundingBox) GetYmin() int32 {
	if m != nil {
		return m.Ymin
	}
	return 0
}

func (m *LocationData_BoundingBox) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *LocationData_BoundingBox) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type LocationData_RelativeBoundingBox struct {
	Xmin   float32 `protobuf:"fixed32,1,opt,name=xmin" json:"xmin"`
	Ymin   float32 `protobuf:"fixed32,2,opt,name=ymin" json:"ymin"`
	Width  float32 `protobuf:"fixed32,3,opt,name=width" json:"width"`
	Height float32 `protobuf:"fixed32,4,opt,name=height" json:"height"`
}

func (m *LocationData_RelativeBoundingBox) Reset()      { *m = LocationData_RelativeBoundingBox{} }
func (*LocationData_RelativeBoundingBox) ProtoMessage() {}
func (*LocationData_RelativeBoundingBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0, 1}
}
func (m *LocationData_RelativeBoundingBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationData_RelativeBoundingBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationData_RelativeBoundingBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationData_RelativeBoundingBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationData_RelativeBoundingBox.Merge(m, src)
}
func (m *LocationData_RelativeBoundingBox) XXX_Size() int {
	return m.Size()
}
func (m *LocationData_RelativeBoundingBox) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationData_RelativeBoundingBox.DiscardUnknown(m)
}

var xxx_messageInfo_LocationData_RelativeBoundingBox proto.InternalMessageInfo

func (m *LocationData_RelativeBoundingBox) GetXmin() float32 {
	if m != nil {
		return m.Xmin
	}
	return 0
}

func (m *LocationData_RelativeBoundingBox) GetYmin() float32 {
	if m != nil {
		return m.Ymin
	}
	return 0
}

func (m *LocationData_RelativeBoundingBox) GetWidth() float32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *LocationData_RelativeBoundingBox) GetHeight() float32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type LocationData_BinaryMask struct {
	Width         int32                     `protobuf:"varint,1,opt,name=width" json:"width"`
	Height        int32                     `protobuf:"varint,2,opt,name=height" json:"height"`
	Rasterization *annotation.Rasterization `protobuf:"bytes,3,opt,name=rasterization" json:"rasterization,omitempty"`
}

func (m *LocationData_BinaryMask) Reset()      { *m = LocationData_BinaryMask{} }
func (*LocationData_BinaryMask) ProtoMessage() {}
func (*LocationData_BinaryMask) Descriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0, 2}
}
func (m *LocationData_BinaryMask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationData_BinaryMask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationData_BinaryMask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationData_BinaryMask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationData_BinaryMask.Merge(m, src)
}
func (m *LocationData_BinaryMask) XXX_Size() int {
	return m.Size()
}
func (m *LocationData_BinaryMask) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationData_BinaryMask.DiscardUnknown(m)
}

var xxx_messageInfo_LocationData_BinaryMask proto.InternalMessageInfo

func (m *LocationData_BinaryMask) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *LocationData_BinaryMask) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *LocationData_BinaryMask) GetRasterization() *annotation.Rasterization {
	if m != nil {
		return m.Rasterization
	}
	return nil
}

type LocationData_RelativeKeypoint struct {
	X             float32 `protobuf:"fixed32,1,opt,name=x" json:"x"`
	Y             float32 `protobuf:"fixed32,2,opt,name=y" json:"y"`
	KeypointLabel string  `protobuf:"bytes,3,opt,name=keypoint_label,json=keypointLabel" json:"keypoint_label"`
	Score         float32 `protobuf:"fixed32,4,opt,name=score" json:"score"`
}

func (m *LocationData_RelativeKeypoint) Reset()      { *m = LocationData_RelativeKeypoint{} }
func (*LocationData_RelativeKeypoint) ProtoMessage() {}
func (*LocationData_RelativeKeypoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_514fa11846932519, []int{0, 3}
}
func (m *LocationData_RelativeKeypoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationData_RelativeKeypoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationData_RelativeKeypoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationData_RelativeKeypoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationData_RelativeKeypoint.Merge(m, src)
}
func (m *LocationData_RelativeKeypoint) XXX_Size() int {
	return m.Size()
}
func (m *LocationData_RelativeKeypoint) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationData_RelativeKeypoint.DiscardUnknown(m)
}

var xxx_messageInfo_LocationData_RelativeKeypoint proto.InternalMessageInfo

func (m *LocationData_RelativeKeypoint) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *LocationData_RelativeKeypoint) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *LocationData_RelativeKeypoint) GetKeypointLabel() string {
	if m != nil {
		return m.KeypointLabel
	}
	return ""
}

func (m *LocationData_RelativeKeypoint) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func init() {
	proto.RegisterEnum("mediapipe.LocationData_Format", LocationData_Format_name, LocationData_Format_value)
	proto.RegisterType((*LocationData)(nil), "mediapipe.LocationData")
	proto.RegisterType((*LocationData_BoundingBox)(nil), "mediapipe.LocationData.BoundingBox")
	proto.RegisterType((*LocationData_RelativeBoundingBox)(nil), "mediapipe.LocationData.RelativeBoundingBox")
	proto.RegisterType((*LocationData_BinaryMask)(nil), "mediapipe.LocationData.BinaryMask")
	proto.RegisterType((*LocationData_RelativeKeypoint)(nil), "mediapipe.LocationData.RelativeKeypoint")
}

func init() {
	proto.RegisterFile("mediapipe/framework/formats/location_data.proto", fileDescriptor_514fa11846932519)
}

var fileDescriptor_514fa11846932519 = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xdd, 0x6b, 0xd3, 0x50,
	0x1c, 0xcd, 0xcd, 0xba, 0xe1, 0x6e, 0xb7, 0xd1, 0xdd, 0xa9, 0x84, 0x32, 0xae, 0xa5, 0x22, 0x54,
	0x06, 0x09, 0xec, 0x41, 0x41, 0x44, 0x68, 0xdc, 0x07, 0x63, 0xd9, 0x22, 0xb1, 0x7e, 0xe0, 0x4b,
	0xb8, 0x6d, 0xb3, 0xf6, 0xd2, 0x26, 0xb7, 0x24, 0x77, 0xae, 0xd5, 0x17, 0x41, 0xf0, 0xc5, 0x17,
	0xff, 0x08, 0x11, 0xff, 0x94, 0x3d, 0xf6, 0x71, 0x4f, 0x62, 0xd3, 0x17, 0x1f, 0xf7, 0x27, 0x48,
	0x3e, 0xda, 0x26, 0x99, 0xad, 0x8f, 0x39, 0xe7, 0xfc, 0x4e, 0xce, 0x3d, 0xf7, 0x03, 0x2a, 0xb6,
	0xd5, 0xa4, 0xa4, 0x47, 0x7b, 0x96, 0x72, 0xe6, 0x12, 0xdb, 0xba, 0x60, 0x6e, 0x47, 0x39, 0x63,
	0xae, 0x4d, 0xb8, 0xa7, 0x74, 0x59, 0x83, 0x70, 0xca, 0x1c, 0xb3, 0x49, 0x38, 0x91, 0x7b, 0x2e,
	0xe3, 0x0c, 0xad, 0x4e, 0x07, 0x8a, 0x4f, 0x16, 0xcd, 0x12, 0xc7, 0x61, 0x3c, 0x9c, 0x56, 0x5c,
	0xe2, 0x71, 0xcb, 0xa5, 0x1f, 0xc2, 0xaf, 0xc8, 0xa6, 0xfc, 0xe3, 0x16, 0x5c, 0xd3, 0x62, 0xfb,
	0x3d, 0xc2, 0x09, 0x7a, 0x0a, 0x57, 0xa2, 0x51, 0x09, 0x94, 0x40, 0x65, 0x63, 0x17, 0xcb, 0x53,
	0x77, 0x39, 0x29, 0x94, 0x0f, 0x42, 0x95, 0x9a, 0xbb, 0xfc, 0x75, 0x4f, 0x30, 0xe2, 0x19, 0x74,
	0x00, 0xd7, 0xea, 0xec, 0xdc, 0x69, 0x52, 0xa7, 0x65, 0xd6, 0x59, 0x5f, 0x12, 0x4b, 0xa0, 0x92,
	0xdf, 0xbd, 0x3f, 0xcf, 0x43, 0x8d, 0xb5, 0x2a, 0xeb, 0x1b, 0xf9, 0xfa, 0xec, 0x03, 0x99, 0xf0,
	0x8e, 0x6b, 0x75, 0x09, 0xa7, 0xef, 0x2d, 0x33, 0x65, 0xb8, 0x14, 0x1a, 0xee, 0xcc, 0x33, 0x34,
	0xe2, 0xa1, 0xa4, 0xf1, 0x96, 0x7b, 0x13, 0x44, 0x8f, 0x60, 0xce, 0x26, 0x5e, 0x47, 0xca, 0x85,
	0x7e, 0xe5, 0xb9, 0x01, 0xa9, 0x43, 0xdc, 0xc1, 0x09, 0xf1, 0x3a, 0x46, 0xa8, 0x47, 0x6f, 0x20,
	0x9a, 0x06, 0xeb, 0x58, 0x83, 0x1e, 0xa3, 0x0e, 0xf7, 0xa4, 0xe5, 0xd2, 0x52, 0x25, 0xbf, 0x5b,
	0xf9, 0x5f, 0xaa, 0xe3, 0x78, 0xc0, 0xd8, 0x74, 0x33, 0x88, 0x57, 0xfc, 0x08, 0xf3, 0xc9, 0x7c,
	0x12, 0xcc, 0xf5, 0x6d, 0xea, 0x84, 0x9b, 0xb0, 0x1c, 0x97, 0x1c, 0x22, 0x01, 0x33, 0x08, 0x18,
	0x31, 0xc9, 0x04, 0x08, 0x2a, 0xc2, 0xe5, 0x0b, 0xda, 0xe4, 0xed, 0xb0, 0xa4, 0x09, 0x15, 0x41,
	0x68, 0x1b, 0xae, 0xb4, 0x2d, 0xda, 0x6a, 0xf3, 0x70, 0xc5, 0x13, 0x32, 0xc6, 0x8a, 0x9f, 0x01,
	0xdc, 0xfa, 0x47, 0x75, 0xa9, 0x14, 0xe2, 0xdc, 0x14, 0xe2, 0xfc, 0x14, 0xe2, 0xa2, 0x14, 0x62,
	0x26, 0xc5, 0x17, 0x00, 0xe1, 0xac, 0xf0, 0x99, 0x11, 0x58, 0xb4, 0x1c, 0xf1, 0xe6, 0x72, 0xd0,
	0x33, 0xb8, 0x9e, 0x3a, 0xeb, 0xf1, 0xa9, 0x91, 0x12, 0xfb, 0x63, 0x24, 0x79, 0x23, 0x2d, 0x0f,
	0xea, 0x28, 0x64, 0xf7, 0x0c, 0x21, 0x08, 0xfa, 0xa9, 0x22, 0x40, 0x3f, 0xc0, 0x06, 0xa9, 0x0a,
	0xc0, 0x00, 0xed, 0xc0, 0x8d, 0xc9, 0xc1, 0x30, 0xbb, 0xa4, 0x6e, 0x75, 0xc3, 0xbf, 0xaf, 0xc6,
	0x82, 0xf5, 0x09, 0xa7, 0x05, 0x54, 0xb0, 0x46, 0xaf, 0xc1, 0x5c, 0x2b, 0xd5, 0x47, 0x04, 0x95,
	0xbf, 0x02, 0xb8, 0x12, 0x5d, 0x32, 0x54, 0x84, 0x77, 0x35, 0xfd, 0x79, 0xb5, 0x76, 0xa4, 0x9f,
	0x9a, 0x07, 0xba, 0x71, 0x52, 0xad, 0x99, 0x87, 0x9a, 0xae, 0x56, 0xb5, 0x82, 0x80, 0x4a, 0x70,
	0x3b, 0xcb, 0xa9, 0xfa, 0xab, 0xd3, 0xbd, 0xa3, 0xd3, 0x43, 0x53, 0xd5, 0xdf, 0x16, 0x00, 0x7a,
	0x08, 0x1f, 0x64, 0x15, 0xc6, 0xbe, 0x56, 0xad, 0x1d, 0xbd, 0xde, 0x4f, 0x4b, 0x45, 0x24, 0xc1,
	0xdb, 0x59, 0xe9, 0x49, 0xf5, 0xe5, 0x71, 0x61, 0x49, 0xfd, 0x0e, 0x86, 0x23, 0x2c, 0x5c, 0x8d,
	0xb0, 0x70, 0x3d, 0xc2, 0xe0, 0x93, 0x8f, 0xc1, 0x4f, 0x1f, 0x83, 0x4b, 0x1f, 0x83, 0xa1, 0x8f,
	0xc1, 0x6f, 0x1f, 0x83, 0x3f, 0x3e, 0x16, 0xae, 0x7d, 0x0c, 0xbe, 0x8d, 0xb1, 0x30, 0x1c, 0x63,
	0xe1, 0x6a, 0x8c, 0x05, 0x58, 0x6e, 0x30, 0x5b, 0x6e, 0x31, 0xd6, 0xea, 0x5a, 0x89, 0xf6, 0xe3,
	0xc7, 0x29, 0x7a, 0x83, 0xd4, 0xcd, 0xe4, 0x65, 0x79, 0x11, 0x40, 0xef, 0x1e, 0xb7, 0x28, 0x6f,
	0x9f, 0xd7, 0xe5, 0x06, 0xb3, 0x95, 0x68, 0x3a, 0xf1, 0x40, 0x2e, 0x78, 0xee, 0xfe, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x37, 0x29, 0xc2, 0x65, 0x48, 0x05, 0x00, 0x00,
}

func (x LocationData_Format) String() string {
	s, ok := LocationData_Format_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LocationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationData)
	if !ok {
		that2, ok := that.(LocationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if !this.BoundingBox.Equal(that1.BoundingBox) {
		return false
	}
	if !this.RelativeBoundingBox.Equal(that1.RelativeBoundingBox) {
		return false
	}
	if !this.Mask.Equal(that1.Mask) {
		return false
	}
	if len(this.RelativeKeypoints) != len(that1.RelativeKeypoints) {
		return false
	}
	for i := range this.RelativeKeypoints {
		if !this.RelativeKeypoints[i].Equal(that1.RelativeKeypoints[i]) {
			return false
		}
	}
	return true
}
func (this *LocationData_BoundingBox) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationData_BoundingBox)
	if !ok {
		that2, ok := that.(LocationData_BoundingBox)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Xmin != that1.Xmin {
		return false
	}
	if this.Ymin != that1.Ymin {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	return true
}
func (this *LocationData_RelativeBoundingBox) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationData_RelativeBoundingBox)
	if !ok {
		that2, ok := that.(LocationData_RelativeBoundingBox)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Xmin != that1.Xmin {
		return false
	}
	if this.Ymin != that1.Ymin {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	return true
}
func (this *LocationData_BinaryMask) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationData_BinaryMask)
	if !ok {
		that2, ok := that.(LocationData_BinaryMask)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if !this.Rasterization.Equal(that1.Rasterization) {
		return false
	}
	return true
}
func (this *LocationData_RelativeKeypoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocationData_RelativeKeypoint)
	if !ok {
		that2, ok := that.(LocationData_RelativeKeypoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X != that1.X {
		return false
	}
	if this.Y != that1.Y {
		return false
	}
	if this.KeypointLabel != that1.KeypointLabel {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	return true
}
func (this *LocationData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&formats.LocationData{")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	if this.BoundingBox != nil {
		s = append(s, "BoundingBox: "+fmt.Sprintf("%#v", this.BoundingBox)+",\n")
	}
	if this.RelativeBoundingBox != nil {
		s = append(s, "RelativeBoundingBox: "+fmt.Sprintf("%#v", this.RelativeBoundingBox)+",\n")
	}
	if this.Mask != nil {
		s = append(s, "Mask: "+fmt.Sprintf("%#v", this.Mask)+",\n")
	}
	if this.RelativeKeypoints != nil {
		s = append(s, "RelativeKeypoints: "+fmt.Sprintf("%#v", this.RelativeKeypoints)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocationData_BoundingBox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&formats.LocationData_BoundingBox{")
	s = append(s, "Xmin: "+fmt.Sprintf("%#v", this.Xmin)+",\n")
	s = append(s, "Ymin: "+fmt.Sprintf("%#v", this.Ymin)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocationData_RelativeBoundingBox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&formats.LocationData_RelativeBoundingBox{")
	s = append(s, "Xmin: "+fmt.Sprintf("%#v", this.Xmin)+",\n")
	s = append(s, "Ymin: "+fmt.Sprintf("%#v", this.Ymin)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocationData_BinaryMask) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&formats.LocationData_BinaryMask{")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	if this.Rasterization != nil {
		s = append(s, "Rasterization: "+fmt.Sprintf("%#v", this.Rasterization)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocationData_RelativeKeypoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&formats.LocationData_RelativeKeypoint{")
	s = append(s, "X: "+fmt.Sprintf("%#v", this.X)+",\n")
	s = append(s, "Y: "+fmt.Sprintf("%#v", this.Y)+",\n")
	s = append(s, "KeypointLabel: "+fmt.Sprintf("%#v", this.KeypointLabel)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringLocationData(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *LocationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelativeKeypoints) > 0 {
		for iNdEx := len(m.RelativeKeypoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelativeKeypoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLocationData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Mask != nil {
		{
			size, err := m.Mask.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocationData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RelativeBoundingBox != nil {
		{
			size, err := m.RelativeBoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocationData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BoundingBox != nil {
		{
			size, err := m.BoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocationData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintLocationData(dAtA, i, uint64(m.Format))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LocationData_BoundingBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationData_BoundingBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationData_BoundingBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintLocationData(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x20
	i = encodeVarintLocationData(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x18
	i = encodeVarintLocationData(dAtA, i, uint64(m.Ymin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintLocationData(dAtA, i, uint64(m.Xmin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LocationData_RelativeBoundingBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationData_RelativeBoundingBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationData_RelativeBoundingBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Height))))
	i--
	dAtA[i] = 0x25
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Width))))
	i--
	dAtA[i] = 0x1d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ymin))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Xmin))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *LocationData_BinaryMask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationData_BinaryMask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationData_BinaryMask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rasterization != nil {
		{
			size, err := m.Rasterization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLocationData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintLocationData(dAtA, i, uint64(m.Height))
	i--
	dAtA[i] = 0x10
	i = encodeVarintLocationData(dAtA, i, uint64(m.Width))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LocationData_RelativeKeypoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationData_RelativeKeypoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationData_RelativeKeypoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
	i--
	dAtA[i] = 0x25
	i -= len(m.KeypointLabel)
	copy(dAtA[i:], m.KeypointLabel)
	i = encodeVarintLocationData(dAtA, i, uint64(len(m.KeypointLabel)))
	i--
	dAtA[i] = 0x1a
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func encodeVarintLocationData(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocationData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovLocationData(uint64(m.Format))
	if m.BoundingBox != nil {
		l = m.BoundingBox.Size()
		n += 1 + l + sovLocationData(uint64(l))
	}
	if m.RelativeBoundingBox != nil {
		l = m.RelativeBoundingBox.Size()
		n += 1 + l + sovLocationData(uint64(l))
	}
	if m.Mask != nil {
		l = m.Mask.Size()
		n += 1 + l + sovLocationData(uint64(l))
	}
	if len(m.RelativeKeypoints) > 0 {
		for _, e := range m.RelativeKeypoints {
			l = e.Size()
			n += 1 + l + sovLocationData(uint64(l))
		}
	}
	return n
}

func (m *LocationData_BoundingBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovLocationData(uint64(m.Xmin))
	n += 1 + sovLocationData(uint64(m.Ymin))
	n += 1 + sovLocationData(uint64(m.Width))
	n += 1 + sovLocationData(uint64(m.Height))
	return n
}

func (m *LocationData_RelativeBoundingBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	n += 5
	return n
}

func (m *LocationData_BinaryMask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovLocationData(uint64(m.Width))
	n += 1 + sovLocationData(uint64(m.Height))
	if m.Rasterization != nil {
		l = m.Rasterization.Size()
		n += 1 + l + sovLocationData(uint64(l))
	}
	return n
}

func (m *LocationData_RelativeKeypoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	l = len(m.KeypointLabel)
	n += 1 + l + sovLocationData(uint64(l))
	n += 5
	return n
}

func sovLocationData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLocationData(x uint64) (n int) {
	return sovLocationData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LocationData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRelativeKeypoints := "[]*LocationData_RelativeKeypoint{"
	for _, f := range this.RelativeKeypoints {
		repeatedStringForRelativeKeypoints += strings.Replace(fmt.Sprintf("%v", f), "LocationData_RelativeKeypoint", "LocationData_RelativeKeypoint", 1) + ","
	}
	repeatedStringForRelativeKeypoints += "}"
	s := strings.Join([]string{`&LocationData{`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`BoundingBox:` + strings.Replace(fmt.Sprintf("%v", this.BoundingBox), "LocationData_BoundingBox", "LocationData_BoundingBox", 1) + `,`,
		`RelativeBoundingBox:` + strings.Replace(fmt.Sprintf("%v", this.RelativeBoundingBox), "LocationData_RelativeBoundingBox", "LocationData_RelativeBoundingBox", 1) + `,`,
		`Mask:` + strings.Replace(fmt.Sprintf("%v", this.Mask), "LocationData_BinaryMask", "LocationData_BinaryMask", 1) + `,`,
		`RelativeKeypoints:` + repeatedStringForRelativeKeypoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocationData_BoundingBox) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocationData_BoundingBox{`,
		`Xmin:` + fmt.Sprintf("%v", this.Xmin) + `,`,
		`Ymin:` + fmt.Sprintf("%v", this.Ymin) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocationData_RelativeBoundingBox) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocationData_RelativeBoundingBox{`,
		`Xmin:` + fmt.Sprintf("%v", this.Xmin) + `,`,
		`Ymin:` + fmt.Sprintf("%v", this.Ymin) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocationData_BinaryMask) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocationData_BinaryMask{`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`Rasterization:` + strings.Replace(fmt.Sprintf("%v", this.Rasterization), "Rasterization", "annotation.Rasterization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocationData_RelativeKeypoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocationData_RelativeKeypoint{`,
		`X:` + fmt.Sprintf("%v", this.X) + `,`,
		`Y:` + fmt.Sprintf("%v", this.Y) + `,`,
		`KeypointLabel:` + fmt.Sprintf("%v", this.KeypointLabel) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLocationData(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LocationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= LocationData_Format(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingBox == nil {
				m.BoundingBox = &LocationData_BoundingBox{}
			}
			if err := m.BoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeBoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelativeBoundingBox == nil {
				m.RelativeBoundingBox = &LocationData_RelativeBoundingBox{}
			}
			if err := m.RelativeBoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mask == nil {
				m.Mask = &LocationData_BinaryMask{}
			}
			if err := m.Mask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeKeypoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeKeypoints = append(m.RelativeKeypoints, &LocationData_RelativeKeypoint{})
			if err := m.RelativeKeypoints[len(m.RelativeKeypoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocationData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocationData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationData_BoundingBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundingBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundingBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmin", wireType)
			}
			m.Xmin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xmin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymin", wireType)
			}
			m.Ymin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ymin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocationData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocationData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationData_RelativeBoundingBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelativeBoundingBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelativeBoundingBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Xmin = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ymin = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Width = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Height = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLocationData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocationData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationData_BinaryMask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryMask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryMask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rasterization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rasterization == nil {
				m.Rasterization = &annotation.Rasterization{}
			}
			if err := m.Rasterization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLocationData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocationData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationData_RelativeKeypoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelativeKeypoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelativeKeypoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeypointLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocationData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocationData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeypointLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLocationData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocationData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocationData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocationData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocationData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocationData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocationData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocationData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocationData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocationData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocationData = fmt.Errorf("proto: unexpected end of group")
)
