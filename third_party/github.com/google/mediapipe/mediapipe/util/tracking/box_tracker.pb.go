// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/box_tracker.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BoxTrackerOptions struct {
	CachingChunkSizeMsec *int32            `protobuf:"varint,1,opt,name=caching_chunk_size_msec,json=cachingChunkSizeMsec,def=2500" json:"caching_chunk_size_msec,omitempty"`
	CacheFileFormat      *string           `protobuf:"bytes,2,opt,name=cache_file_format,json=cacheFileFormat,def=chunk_%04d" json:"cache_file_format,omitempty"`
	NumTrackingWorkers   *int32            `protobuf:"varint,3,opt,name=num_tracking_workers,json=numTrackingWorkers,def=8" json:"num_tracking_workers,omitempty"`
	ReadChunkTimeoutMsec *int32            `protobuf:"varint,4,opt,name=read_chunk_timeout_msec,json=readChunkTimeoutMsec,def=60000" json:"read_chunk_timeout_msec,omitempty"`
	RecordPathStates     *bool             `protobuf:"varint,5,opt,name=record_path_states,json=recordPathStates,def=0" json:"record_path_states,omitempty"`
	TrackStepOptions     *TrackStepOptions `protobuf:"bytes,6,opt,name=track_step_options,json=trackStepOptions" json:"track_step_options,omitempty"`
}

func (m *BoxTrackerOptions) Reset()      { *m = BoxTrackerOptions{} }
func (*BoxTrackerOptions) ProtoMessage() {}
func (*BoxTrackerOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_400c796bb86f49b9, []int{0}
}
func (m *BoxTrackerOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoxTrackerOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoxTrackerOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoxTrackerOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoxTrackerOptions.Merge(m, src)
}
func (m *BoxTrackerOptions) XXX_Size() int {
	return m.Size()
}
func (m *BoxTrackerOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_BoxTrackerOptions.DiscardUnknown(m)
}

var xxx_messageInfo_BoxTrackerOptions proto.InternalMessageInfo

const Default_BoxTrackerOptions_CachingChunkSizeMsec int32 = 2500
const Default_BoxTrackerOptions_CacheFileFormat string = "chunk_%04d"
const Default_BoxTrackerOptions_NumTrackingWorkers int32 = 8
const Default_BoxTrackerOptions_ReadChunkTimeoutMsec int32 = 60000
const Default_BoxTrackerOptions_RecordPathStates bool = false

func (m *BoxTrackerOptions) GetCachingChunkSizeMsec() int32 {
	if m != nil && m.CachingChunkSizeMsec != nil {
		return *m.CachingChunkSizeMsec
	}
	return Default_BoxTrackerOptions_CachingChunkSizeMsec
}

func (m *BoxTrackerOptions) GetCacheFileFormat() string {
	if m != nil && m.CacheFileFormat != nil {
		return *m.CacheFileFormat
	}
	return Default_BoxTrackerOptions_CacheFileFormat
}

func (m *BoxTrackerOptions) GetNumTrackingWorkers() int32 {
	if m != nil && m.NumTrackingWorkers != nil {
		return *m.NumTrackingWorkers
	}
	return Default_BoxTrackerOptions_NumTrackingWorkers
}

func (m *BoxTrackerOptions) GetReadChunkTimeoutMsec() int32 {
	if m != nil && m.ReadChunkTimeoutMsec != nil {
		return *m.ReadChunkTimeoutMsec
	}
	return Default_BoxTrackerOptions_ReadChunkTimeoutMsec
}

func (m *BoxTrackerOptions) GetRecordPathStates() bool {
	if m != nil && m.RecordPathStates != nil {
		return *m.RecordPathStates
	}
	return Default_BoxTrackerOptions_RecordPathStates
}

func (m *BoxTrackerOptions) GetTrackStepOptions() *TrackStepOptions {
	if m != nil {
		return m.TrackStepOptions
	}
	return nil
}

type TimedBoxProto struct {
	Top             float32              `protobuf:"fixed32,1,opt,name=top" json:"top"`
	Left            float32              `protobuf:"fixed32,2,opt,name=left" json:"left"`
	Bottom          float32              `protobuf:"fixed32,3,opt,name=bottom" json:"bottom"`
	Right           float32              `protobuf:"fixed32,4,opt,name=right" json:"right"`
	Rotation        float32              `protobuf:"fixed32,7,opt,name=rotation" json:"rotation"`
	Quad            *MotionBoxState_Quad `protobuf:"bytes,9,opt,name=quad" json:"quad,omitempty"`
	TimeMsec        *int64               `protobuf:"varint,5,opt,name=time_msec,json=timeMsec,def=0" json:"time_msec,omitempty"`
	Id              *int32               `protobuf:"varint,6,opt,name=id,def=-1" json:"id,omitempty"`
	Label           string               `protobuf:"bytes,13,opt,name=label" json:"label"`
	Confidence      float32              `protobuf:"fixed32,8,opt,name=confidence" json:"confidence"`
	AspectRatio     float32              `protobuf:"fixed32,10,opt,name=aspect_ratio,json=aspectRatio" json:"aspect_ratio"`
	Reacquisition   *bool                `protobuf:"varint,11,opt,name=reacquisition,def=0" json:"reacquisition,omitempty"`
	RequestGrouping *bool                `protobuf:"varint,12,opt,name=request_grouping,json=requestGrouping,def=0" json:"request_grouping,omitempty"`
}

func (m *TimedBoxProto) Reset()      { *m = TimedBoxProto{} }
func (*TimedBoxProto) ProtoMessage() {}
func (*TimedBoxProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_400c796bb86f49b9, []int{1}
}
func (m *TimedBoxProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedBoxProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedBoxProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedBoxProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedBoxProto.Merge(m, src)
}
func (m *TimedBoxProto) XXX_Size() int {
	return m.Size()
}
func (m *TimedBoxProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedBoxProto.DiscardUnknown(m)
}

var xxx_messageInfo_TimedBoxProto proto.InternalMessageInfo

const Default_TimedBoxProto_TimeMsec int64 = 0
const Default_TimedBoxProto_Id int32 = -1
const Default_TimedBoxProto_Reacquisition bool = false
const Default_TimedBoxProto_RequestGrouping bool = false

func (m *TimedBoxProto) GetTop() float32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *TimedBoxProto) GetLeft() float32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *TimedBoxProto) GetBottom() float32 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

func (m *TimedBoxProto) GetRight() float32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *TimedBoxProto) GetRotation() float32 {
	if m != nil {
		return m.Rotation
	}
	return 0
}

func (m *TimedBoxProto) GetQuad() *MotionBoxState_Quad {
	if m != nil {
		return m.Quad
	}
	return nil
}

func (m *TimedBoxProto) GetTimeMsec() int64 {
	if m != nil && m.TimeMsec != nil {
		return *m.TimeMsec
	}
	return Default_TimedBoxProto_TimeMsec
}

func (m *TimedBoxProto) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return Default_TimedBoxProto_Id
}

func (m *TimedBoxProto) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *TimedBoxProto) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *TimedBoxProto) GetAspectRatio() float32 {
	if m != nil {
		return m.AspectRatio
	}
	return 0
}

func (m *TimedBoxProto) GetReacquisition() bool {
	if m != nil && m.Reacquisition != nil {
		return *m.Reacquisition
	}
	return Default_TimedBoxProto_Reacquisition
}

func (m *TimedBoxProto) GetRequestGrouping() bool {
	if m != nil && m.RequestGrouping != nil {
		return *m.RequestGrouping
	}
	return Default_TimedBoxProto_RequestGrouping
}

type TimedBoxProtoList struct {
	Box []*TimedBoxProto `protobuf:"bytes,1,rep,name=box" json:"box,omitempty"`
}

func (m *TimedBoxProtoList) Reset()      { *m = TimedBoxProtoList{} }
func (*TimedBoxProtoList) ProtoMessage() {}
func (*TimedBoxProtoList) Descriptor() ([]byte, []int) {
	return fileDescriptor_400c796bb86f49b9, []int{2}
}
func (m *TimedBoxProtoList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedBoxProtoList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedBoxProtoList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedBoxProtoList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedBoxProtoList.Merge(m, src)
}
func (m *TimedBoxProtoList) XXX_Size() int {
	return m.Size()
}
func (m *TimedBoxProtoList) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedBoxProtoList.DiscardUnknown(m)
}

var xxx_messageInfo_TimedBoxProtoList proto.InternalMessageInfo

func (m *TimedBoxProtoList) GetBox() []*TimedBoxProto {
	if m != nil {
		return m.Box
	}
	return nil
}

func init() {
	proto.RegisterType((*BoxTrackerOptions)(nil), "mediapipe.BoxTrackerOptions")
	proto.RegisterType((*TimedBoxProto)(nil), "mediapipe.TimedBoxProto")
	proto.RegisterType((*TimedBoxProtoList)(nil), "mediapipe.TimedBoxProtoList")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/box_tracker.proto", fileDescriptor_400c796bb86f49b9)
}

var fileDescriptor_400c796bb86f49b9 = []byte{
	// 694 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xcd, 0x6e, 0x13, 0x3d,
	0x14, 0x8d, 0xf3, 0xd3, 0x2f, 0x71, 0x5a, 0xb5, 0xb5, 0xaa, 0xaf, 0x56, 0x01, 0x13, 0x55, 0xfc,
	0x04, 0x10, 0x49, 0x48, 0xa1, 0x42, 0x01, 0x09, 0x29, 0x48, 0x45, 0x48, 0x54, 0x94, 0x69, 0x25,
	0x24, 0x36, 0x96, 0x33, 0xe3, 0x4c, 0xac, 0xce, 0x8c, 0xa7, 0x1e, 0x8f, 0x88, 0xba, 0xe2, 0x11,
	0xd8, 0xf2, 0x06, 0x3c, 0x4a, 0x77, 0x74, 0xd9, 0x15, 0xa2, 0xe9, 0x86, 0x65, 0xf7, 0x6c, 0x90,
	0x3d, 0x49, 0x3b, 0x45, 0xea, 0x6e, 0xe6, 0x9c, 0x73, 0xed, 0x73, 0xcf, 0xb5, 0x0d, 0x1f, 0x84,
	0xdc, 0x13, 0x2c, 0x16, 0x31, 0x6f, 0xa7, 0x5a, 0x04, 0x6d, 0xad, 0x98, 0xbb, 0x2f, 0x22, 0xbf,
	0x3d, 0x90, 0x63, 0x6a, 0x7f, 0xb8, 0x6a, 0xc5, 0x4a, 0x6a, 0x89, 0x6a, 0x17, 0xd2, 0xb5, 0x7b,
	0xd7, 0x55, 0xcd, 0x3e, 0xb2, 0x92, 0xf5, 0x3f, 0x45, 0xb8, 0xdc, 0x97, 0xe3, 0xbd, 0x6c, 0x9d,
	0xf7, 0xb1, 0x16, 0x32, 0x4a, 0xd0, 0x0b, 0xb8, 0xea, 0x32, 0x77, 0x24, 0x22, 0x9f, 0xba, 0xa3,
	0x34, 0xda, 0xa7, 0x89, 0x38, 0xe4, 0x34, 0x4c, 0xb8, 0x8b, 0x41, 0x03, 0x34, 0x2b, 0xbd, 0x72,
	0xf7, 0x59, 0xa7, 0xe3, 0xac, 0x4c, 0x45, 0xaf, 0x8d, 0x66, 0x57, 0x1c, 0xf2, 0xed, 0x84, 0xbb,
	0x68, 0x13, 0x2e, 0x1b, 0x9c, 0xd3, 0xa1, 0x08, 0x38, 0x1d, 0x4a, 0x15, 0x32, 0x8d, 0x8b, 0x0d,
	0xd0, 0xac, 0xf5, 0x60, 0xb6, 0xda, 0xdd, 0xce, 0x53, 0xcf, 0x59, 0xb4, 0xa2, 0x2d, 0x11, 0xf0,
	0x2d, 0x2b, 0x41, 0x1b, 0x70, 0x25, 0x4a, 0x43, 0x3a, 0x33, 0x48, 0x3f, 0x4b, 0xb5, 0xcf, 0x55,
	0x82, 0x4b, 0x76, 0x47, 0xf0, 0xdc, 0x41, 0x51, 0x1a, 0xee, 0x4d, 0xd9, 0x8f, 0x19, 0x89, 0x5e,
	0xc2, 0x55, 0xc5, 0x99, 0x37, 0xb5, 0xa9, 0x45, 0xc8, 0x65, 0xaa, 0x33, 0xa7, 0x65, 0x5b, 0x57,
	0xd9, 0xec, 0x74, 0x8c, 0x55, 0xa3, 0xb2, 0x3e, 0xf7, 0x32, 0x8d, 0xb5, 0xba, 0x01, 0x91, 0xe2,
	0xae, 0x54, 0x1e, 0x8d, 0x99, 0x1e, 0xd1, 0x44, 0x33, 0xcd, 0x13, 0x5c, 0x69, 0x80, 0x66, 0xb5,
	0x57, 0x19, 0xb2, 0x20, 0xe1, 0xce, 0x52, 0x26, 0xd8, 0x61, 0x7a, 0xb4, 0x6b, 0x69, 0xf4, 0x16,
	0x22, 0xeb, 0x91, 0x26, 0x9a, 0xc7, 0x54, 0x66, 0x91, 0xe1, 0xb9, 0x06, 0x68, 0xd6, 0xbb, 0x37,
	0x5a, 0x17, 0xb9, 0xb7, 0xac, 0xd5, 0x5d, 0xcd, 0xe3, 0x69, 0xaa, 0xce, 0x92, 0xfe, 0x07, 0x59,
	0xff, 0x51, 0x82, 0x0b, 0xc6, 0x8f, 0xd7, 0x97, 0xe3, 0x1d, 0x3b, 0xc2, 0xff, 0x61, 0x49, 0xcb,
	0xd8, 0xa6, 0x5c, 0xec, 0x97, 0x8f, 0x7e, 0xde, 0x2e, 0x38, 0x06, 0x40, 0x18, 0x96, 0x03, 0x3e,
	0xcc, 0x72, 0x9c, 0x11, 0x16, 0x41, 0x37, 0xe1, 0xdc, 0x40, 0x6a, 0x2d, 0x43, 0x1b, 0xd4, 0x8c,
	0x9b, 0x62, 0x68, 0x0d, 0x56, 0x94, 0xf0, 0x47, 0xda, 0xa6, 0x31, 0x23, 0x33, 0x08, 0x35, 0x60,
	0x55, 0x49, 0xcd, 0x8c, 0x15, 0xfc, 0x5f, 0x8e, 0xbe, 0x40, 0x51, 0x17, 0x96, 0x0f, 0x52, 0xe6,
	0xe1, 0x9a, 0x6d, 0x8e, 0xe4, 0x9a, 0xdb, 0x96, 0x46, 0xd0, 0x97, 0x63, 0x1b, 0x4a, 0xeb, 0x43,
	0xca, 0x3c, 0xc7, 0x6a, 0x11, 0x81, 0x35, 0x33, 0x86, 0x6c, 0x06, 0x26, 0xca, 0x52, 0x0f, 0x74,
	0x9c, 0xaa, 0xc1, 0x6c, 0xe6, 0x08, 0x16, 0x85, 0x67, 0xe3, 0xaa, 0xf4, 0x8a, 0x8f, 0x9f, 0x38,
	0x45, 0xe1, 0x19, 0x97, 0x01, 0x1b, 0xf0, 0x00, 0x2f, 0x98, 0x63, 0x32, 0x73, 0x69, 0x21, 0x74,
	0x07, 0x42, 0x57, 0x46, 0x43, 0xe1, 0xf1, 0xc8, 0xe5, 0xb8, 0x9a, 0xf3, 0x99, 0xc3, 0xd1, 0x7d,
	0x38, 0xcf, 0x92, 0x98, 0xbb, 0x9a, 0x2a, 0x63, 0x1d, 0xc3, 0x9c, 0xae, 0x9e, 0x31, 0x8e, 0x21,
	0xd0, 0x23, 0xb8, 0xa0, 0x38, 0x73, 0x0f, 0x52, 0x91, 0x08, 0xdb, 0x79, 0x3d, 0x3f, 0xed, 0xab,
	0x1c, 0xea, 0xc0, 0x25, 0xc5, 0x0f, 0x52, 0x9e, 0x68, 0xea, 0x2b, 0x99, 0xc6, 0x22, 0xf2, 0xf1,
	0x7c, 0x5e, 0xbf, 0x38, 0xa5, 0xdf, 0x4c, 0xd9, 0xf5, 0x57, 0x70, 0xf9, 0xca, 0x40, 0xdf, 0x89,
	0x44, 0xa3, 0x87, 0xb0, 0x34, 0x90, 0x63, 0x0c, 0x1a, 0xa5, 0x66, 0xbd, 0x8b, 0xf3, 0x47, 0x24,
	0x2f, 0x75, 0x8c, 0xa8, 0xff, 0x0d, 0x1c, 0x9f, 0x92, 0xc2, 0xc9, 0x29, 0x29, 0x9c, 0x9f, 0x12,
	0xf0, 0x65, 0x42, 0xc0, 0xf7, 0x09, 0x01, 0x47, 0x13, 0x02, 0x8e, 0x27, 0x04, 0xfc, 0x9a, 0x10,
	0xf0, 0x7b, 0x42, 0x0a, 0xe7, 0x13, 0x02, 0xbe, 0x9e, 0x91, 0xc2, 0xf1, 0x19, 0x29, 0x9c, 0x9c,
	0x91, 0x02, 0xbc, 0xe5, 0xca, 0xb0, 0xe5, 0x4b, 0xe9, 0x07, 0x3c, 0xb7, 0xfe, 0xec, 0x2e, 0xf5,
	0x17, 0x2f, 0xef, 0xb8, 0xdd, 0xeb, 0xd3, 0x86, 0x2f, 0xf4, 0x28, 0x1d, 0xb4, 0x5c, 0x19, 0xb6,
	0xb3, 0xb2, 0xf6, 0xe5, 0x8b, 0x71, 0xcd, 0xdb, 0xf1, 0x37, 0x00, 0x00, 0xff, 0xff, 0x41, 0x6f,
	0x8d, 0xb2, 0x8b, 0x04, 0x00, 0x00,
}

func (this *BoxTrackerOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoxTrackerOptions)
	if !ok {
		that2, ok := that.(BoxTrackerOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CachingChunkSizeMsec != nil && that1.CachingChunkSizeMsec != nil {
		if *this.CachingChunkSizeMsec != *that1.CachingChunkSizeMsec {
			return false
		}
	} else if this.CachingChunkSizeMsec != nil {
		return false
	} else if that1.CachingChunkSizeMsec != nil {
		return false
	}
	if this.CacheFileFormat != nil && that1.CacheFileFormat != nil {
		if *this.CacheFileFormat != *that1.CacheFileFormat {
			return false
		}
	} else if this.CacheFileFormat != nil {
		return false
	} else if that1.CacheFileFormat != nil {
		return false
	}
	if this.NumTrackingWorkers != nil && that1.NumTrackingWorkers != nil {
		if *this.NumTrackingWorkers != *that1.NumTrackingWorkers {
			return false
		}
	} else if this.NumTrackingWorkers != nil {
		return false
	} else if that1.NumTrackingWorkers != nil {
		return false
	}
	if this.ReadChunkTimeoutMsec != nil && that1.ReadChunkTimeoutMsec != nil {
		if *this.ReadChunkTimeoutMsec != *that1.ReadChunkTimeoutMsec {
			return false
		}
	} else if this.ReadChunkTimeoutMsec != nil {
		return false
	} else if that1.ReadChunkTimeoutMsec != nil {
		return false
	}
	if this.RecordPathStates != nil && that1.RecordPathStates != nil {
		if *this.RecordPathStates != *that1.RecordPathStates {
			return false
		}
	} else if this.RecordPathStates != nil {
		return false
	} else if that1.RecordPathStates != nil {
		return false
	}
	if !this.TrackStepOptions.Equal(that1.TrackStepOptions) {
		return false
	}
	return true
}
func (this *TimedBoxProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimedBoxProto)
	if !ok {
		that2, ok := that.(TimedBoxProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Top != that1.Top {
		return false
	}
	if this.Left != that1.Left {
		return false
	}
	if this.Bottom != that1.Bottom {
		return false
	}
	if this.Right != that1.Right {
		return false
	}
	if this.Rotation != that1.Rotation {
		return false
	}
	if !this.Quad.Equal(that1.Quad) {
		return false
	}
	if this.TimeMsec != nil && that1.TimeMsec != nil {
		if *this.TimeMsec != *that1.TimeMsec {
			return false
		}
	} else if this.TimeMsec != nil {
		return false
	} else if that1.TimeMsec != nil {
		return false
	}
	if this.Id != nil && that1.Id != nil {
		if *this.Id != *that1.Id {
			return false
		}
	} else if this.Id != nil {
		return false
	} else if that1.Id != nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Confidence != that1.Confidence {
		return false
	}
	if this.AspectRatio != that1.AspectRatio {
		return false
	}
	if this.Reacquisition != nil && that1.Reacquisition != nil {
		if *this.Reacquisition != *that1.Reacquisition {
			return false
		}
	} else if this.Reacquisition != nil {
		return false
	} else if that1.Reacquisition != nil {
		return false
	}
	if this.RequestGrouping != nil && that1.RequestGrouping != nil {
		if *this.RequestGrouping != *that1.RequestGrouping {
			return false
		}
	} else if this.RequestGrouping != nil {
		return false
	} else if that1.RequestGrouping != nil {
		return false
	}
	return true
}
func (this *TimedBoxProtoList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimedBoxProtoList)
	if !ok {
		that2, ok := that.(TimedBoxProtoList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Box) != len(that1.Box) {
		return false
	}
	for i := range this.Box {
		if !this.Box[i].Equal(that1.Box[i]) {
			return false
		}
	}
	return true
}
func (this *BoxTrackerOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.BoxTrackerOptions{")
	if this.CachingChunkSizeMsec != nil {
		s = append(s, "CachingChunkSizeMsec: "+valueToGoStringBoxTracker(this.CachingChunkSizeMsec, "int32")+",\n")
	}
	if this.CacheFileFormat != nil {
		s = append(s, "CacheFileFormat: "+valueToGoStringBoxTracker(this.CacheFileFormat, "string")+",\n")
	}
	if this.NumTrackingWorkers != nil {
		s = append(s, "NumTrackingWorkers: "+valueToGoStringBoxTracker(this.NumTrackingWorkers, "int32")+",\n")
	}
	if this.ReadChunkTimeoutMsec != nil {
		s = append(s, "ReadChunkTimeoutMsec: "+valueToGoStringBoxTracker(this.ReadChunkTimeoutMsec, "int32")+",\n")
	}
	if this.RecordPathStates != nil {
		s = append(s, "RecordPathStates: "+valueToGoStringBoxTracker(this.RecordPathStates, "bool")+",\n")
	}
	if this.TrackStepOptions != nil {
		s = append(s, "TrackStepOptions: "+fmt.Sprintf("%#v", this.TrackStepOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimedBoxProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&tracking.TimedBoxProto{")
	s = append(s, "Top: "+fmt.Sprintf("%#v", this.Top)+",\n")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Bottom: "+fmt.Sprintf("%#v", this.Bottom)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	s = append(s, "Rotation: "+fmt.Sprintf("%#v", this.Rotation)+",\n")
	if this.Quad != nil {
		s = append(s, "Quad: "+fmt.Sprintf("%#v", this.Quad)+",\n")
	}
	if this.TimeMsec != nil {
		s = append(s, "TimeMsec: "+valueToGoStringBoxTracker(this.TimeMsec, "int64")+",\n")
	}
	if this.Id != nil {
		s = append(s, "Id: "+valueToGoStringBoxTracker(this.Id, "int32")+",\n")
	}
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Confidence: "+fmt.Sprintf("%#v", this.Confidence)+",\n")
	s = append(s, "AspectRatio: "+fmt.Sprintf("%#v", this.AspectRatio)+",\n")
	if this.Reacquisition != nil {
		s = append(s, "Reacquisition: "+valueToGoStringBoxTracker(this.Reacquisition, "bool")+",\n")
	}
	if this.RequestGrouping != nil {
		s = append(s, "RequestGrouping: "+valueToGoStringBoxTracker(this.RequestGrouping, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimedBoxProtoList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.TimedBoxProtoList{")
	if this.Box != nil {
		s = append(s, "Box: "+fmt.Sprintf("%#v", this.Box)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBoxTracker(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BoxTrackerOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoxTrackerOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoxTrackerOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrackStepOptions != nil {
		{
			size, err := m.TrackStepOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBoxTracker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RecordPathStates != nil {
		i--
		if *m.RecordPathStates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ReadChunkTimeoutMsec != nil {
		i = encodeVarintBoxTracker(dAtA, i, uint64(*m.ReadChunkTimeoutMsec))
		i--
		dAtA[i] = 0x20
	}
	if m.NumTrackingWorkers != nil {
		i = encodeVarintBoxTracker(dAtA, i, uint64(*m.NumTrackingWorkers))
		i--
		dAtA[i] = 0x18
	}
	if m.CacheFileFormat != nil {
		i -= len(*m.CacheFileFormat)
		copy(dAtA[i:], *m.CacheFileFormat)
		i = encodeVarintBoxTracker(dAtA, i, uint64(len(*m.CacheFileFormat)))
		i--
		dAtA[i] = 0x12
	}
	if m.CachingChunkSizeMsec != nil {
		i = encodeVarintBoxTracker(dAtA, i, uint64(*m.CachingChunkSizeMsec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimedBoxProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedBoxProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedBoxProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Label)
	copy(dAtA[i:], m.Label)
	i = encodeVarintBoxTracker(dAtA, i, uint64(len(m.Label)))
	i--
	dAtA[i] = 0x6a
	if m.RequestGrouping != nil {
		i--
		if *m.RequestGrouping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Reacquisition != nil {
		i--
		if *m.Reacquisition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AspectRatio))))
	i--
	dAtA[i] = 0x55
	if m.Quad != nil {
		{
			size, err := m.Quad.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBoxTracker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Confidence))))
	i--
	dAtA[i] = 0x45
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotation))))
	i--
	dAtA[i] = 0x3d
	if m.Id != nil {
		i = encodeVarintBoxTracker(dAtA, i, uint64(*m.Id))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeMsec != nil {
		i = encodeVarintBoxTracker(dAtA, i, uint64(*m.TimeMsec))
		i--
		dAtA[i] = 0x28
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Right))))
	i--
	dAtA[i] = 0x25
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Bottom))))
	i--
	dAtA[i] = 0x1d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Left))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Top))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *TimedBoxProtoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedBoxProtoList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedBoxProtoList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Box) > 0 {
		for iNdEx := len(m.Box) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Box[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBoxTracker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBoxTracker(dAtA []byte, offset int, v uint64) int {
	offset -= sovBoxTracker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BoxTrackerOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CachingChunkSizeMsec != nil {
		n += 1 + sovBoxTracker(uint64(*m.CachingChunkSizeMsec))
	}
	if m.CacheFileFormat != nil {
		l = len(*m.CacheFileFormat)
		n += 1 + l + sovBoxTracker(uint64(l))
	}
	if m.NumTrackingWorkers != nil {
		n += 1 + sovBoxTracker(uint64(*m.NumTrackingWorkers))
	}
	if m.ReadChunkTimeoutMsec != nil {
		n += 1 + sovBoxTracker(uint64(*m.ReadChunkTimeoutMsec))
	}
	if m.RecordPathStates != nil {
		n += 2
	}
	if m.TrackStepOptions != nil {
		l = m.TrackStepOptions.Size()
		n += 1 + l + sovBoxTracker(uint64(l))
	}
	return n
}

func (m *TimedBoxProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	n += 5
	if m.TimeMsec != nil {
		n += 1 + sovBoxTracker(uint64(*m.TimeMsec))
	}
	if m.Id != nil {
		n += 1 + sovBoxTracker(uint64(*m.Id))
	}
	n += 5
	n += 5
	if m.Quad != nil {
		l = m.Quad.Size()
		n += 1 + l + sovBoxTracker(uint64(l))
	}
	n += 5
	if m.Reacquisition != nil {
		n += 2
	}
	if m.RequestGrouping != nil {
		n += 2
	}
	l = len(m.Label)
	n += 1 + l + sovBoxTracker(uint64(l))
	return n
}

func (m *TimedBoxProtoList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Box) > 0 {
		for _, e := range m.Box {
			l = e.Size()
			n += 1 + l + sovBoxTracker(uint64(l))
		}
	}
	return n
}

func sovBoxTracker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBoxTracker(x uint64) (n int) {
	return sovBoxTracker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BoxTrackerOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoxTrackerOptions{`,
		`CachingChunkSizeMsec:` + valueToStringBoxTracker(this.CachingChunkSizeMsec) + `,`,
		`CacheFileFormat:` + valueToStringBoxTracker(this.CacheFileFormat) + `,`,
		`NumTrackingWorkers:` + valueToStringBoxTracker(this.NumTrackingWorkers) + `,`,
		`ReadChunkTimeoutMsec:` + valueToStringBoxTracker(this.ReadChunkTimeoutMsec) + `,`,
		`RecordPathStates:` + valueToStringBoxTracker(this.RecordPathStates) + `,`,
		`TrackStepOptions:` + strings.Replace(fmt.Sprintf("%v", this.TrackStepOptions), "TrackStepOptions", "TrackStepOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimedBoxProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimedBoxProto{`,
		`Top:` + fmt.Sprintf("%v", this.Top) + `,`,
		`Left:` + fmt.Sprintf("%v", this.Left) + `,`,
		`Bottom:` + fmt.Sprintf("%v", this.Bottom) + `,`,
		`Right:` + fmt.Sprintf("%v", this.Right) + `,`,
		`TimeMsec:` + valueToStringBoxTracker(this.TimeMsec) + `,`,
		`Id:` + valueToStringBoxTracker(this.Id) + `,`,
		`Rotation:` + fmt.Sprintf("%v", this.Rotation) + `,`,
		`Confidence:` + fmt.Sprintf("%v", this.Confidence) + `,`,
		`Quad:` + strings.Replace(fmt.Sprintf("%v", this.Quad), "MotionBoxState_Quad", "MotionBoxState_Quad", 1) + `,`,
		`AspectRatio:` + fmt.Sprintf("%v", this.AspectRatio) + `,`,
		`Reacquisition:` + valueToStringBoxTracker(this.Reacquisition) + `,`,
		`RequestGrouping:` + valueToStringBoxTracker(this.RequestGrouping) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimedBoxProtoList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBox := "[]*TimedBoxProto{"
	for _, f := range this.Box {
		repeatedStringForBox += strings.Replace(f.String(), "TimedBoxProto", "TimedBoxProto", 1) + ","
	}
	repeatedStringForBox += "}"
	s := strings.Join([]string{`&TimedBoxProtoList{`,
		`Box:` + repeatedStringForBox + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBoxTracker(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BoxTrackerOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBoxTracker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoxTrackerOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoxTrackerOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachingChunkSizeMsec", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CachingChunkSizeMsec = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheFileFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBoxTracker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CacheFileFormat = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTrackingWorkers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumTrackingWorkers = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadChunkTimeoutMsec", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadChunkTimeoutMsec = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordPathStates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RecordPathStates = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackStepOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBoxTracker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrackStepOptions == nil {
				m.TrackStepOptions = &TrackStepOptions{}
			}
			if err := m.TrackStepOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBoxTracker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedBoxProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBoxTracker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedBoxProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedBoxProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Top = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Left = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Bottom = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Right = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeMsec", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeMsec = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotation = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Confidence = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quad", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBoxTracker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quad == nil {
				m.Quad = &MotionBoxState_Quad{}
			}
			if err := m.Quad.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AspectRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AspectRatio = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reacquisition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reacquisition = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestGrouping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RequestGrouping = &b
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBoxTracker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBoxTracker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedBoxProtoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBoxTracker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedBoxProtoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedBoxProtoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Box", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBoxTracker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Box = append(m.Box, &TimedBoxProto{})
			if err := m.Box[len(m.Box)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBoxTracker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBoxTracker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBoxTracker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBoxTracker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBoxTracker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBoxTracker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBoxTracker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBoxTracker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBoxTracker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBoxTracker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBoxTracker = fmt.Errorf("proto: unexpected end of group")
)
