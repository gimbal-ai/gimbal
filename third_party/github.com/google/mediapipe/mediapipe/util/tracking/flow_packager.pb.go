// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/flow_packager.proto

package tracking

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TrackingData_FrameFlags int32

const (
	TRACKING_FLAG_PROFILE_BASELINE      TrackingData_FrameFlags = 0
	TRACKING_FLAG_PROFILE_HIGH          TrackingData_FrameFlags = 1
	TRACKING_FLAG_HIGH_FIDELITY_VECTORS TrackingData_FrameFlags = 2
	TRACKING_FLAG_BACKGROUND_UNSTABLE   TrackingData_FrameFlags = 4
	TRACKING_FLAG_DUPLICATED            TrackingData_FrameFlags = 8
	TRACKING_FLAG_CHUNK_BOUNDARY        TrackingData_FrameFlags = 16
)

var TrackingData_FrameFlags_name = map[int32]string{
	0:  "TRACKING_FLAG_PROFILE_BASELINE",
	1:  "TRACKING_FLAG_PROFILE_HIGH",
	2:  "TRACKING_FLAG_HIGH_FIDELITY_VECTORS",
	4:  "TRACKING_FLAG_BACKGROUND_UNSTABLE",
	8:  "TRACKING_FLAG_DUPLICATED",
	16: "TRACKING_FLAG_CHUNK_BOUNDARY",
}

var TrackingData_FrameFlags_value = map[string]int32{
	"TRACKING_FLAG_PROFILE_BASELINE":      0,
	"TRACKING_FLAG_PROFILE_HIGH":          1,
	"TRACKING_FLAG_HIGH_FIDELITY_VECTORS": 2,
	"TRACKING_FLAG_BACKGROUND_UNSTABLE":   4,
	"TRACKING_FLAG_DUPLICATED":            8,
	"TRACKING_FLAG_CHUNK_BOUNDARY":        16,
}

func (x TrackingData_FrameFlags) Enum() *TrackingData_FrameFlags {
	p := new(TrackingData_FrameFlags)
	*p = x
	return p
}

func (x TrackingData_FrameFlags) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackingData_FrameFlags_name, int32(x))
}

func (x *TrackingData_FrameFlags) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackingData_FrameFlags_value, data, "TrackingData_FrameFlags")
	if err != nil {
		return err
	}
	*x = TrackingData_FrameFlags(value)
	return nil
}

func (TrackingData_FrameFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{0, 0}
}

type FlowPackagerOptions_HighProfileEncoding int32

const (
	ADVANCE_FLAG        FlowPackagerOptions_HighProfileEncoding = 128
	DOUBLE_INDEX_ENCODE FlowPackagerOptions_HighProfileEncoding = 64
	INDEX_MASK          FlowPackagerOptions_HighProfileEncoding = 63
)

var FlowPackagerOptions_HighProfileEncoding_name = map[int32]string{
	128: "ADVANCE_FLAG",
	64:  "DOUBLE_INDEX_ENCODE",
	63:  "INDEX_MASK",
}

var FlowPackagerOptions_HighProfileEncoding_value = map[string]int32{
	"ADVANCE_FLAG":        128,
	"DOUBLE_INDEX_ENCODE": 64,
	"INDEX_MASK":          63,
}

func (x FlowPackagerOptions_HighProfileEncoding) Enum() *FlowPackagerOptions_HighProfileEncoding {
	p := new(FlowPackagerOptions_HighProfileEncoding)
	*p = x
	return p
}

func (x FlowPackagerOptions_HighProfileEncoding) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(FlowPackagerOptions_HighProfileEncoding_name, int32(x))
}

func (x *FlowPackagerOptions_HighProfileEncoding) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FlowPackagerOptions_HighProfileEncoding_value, data, "FlowPackagerOptions_HighProfileEncoding")
	if err != nil {
		return err
	}
	*x = FlowPackagerOptions_HighProfileEncoding(value)
	return nil
}

func (FlowPackagerOptions_HighProfileEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{7, 0}
}

type TrackingData struct {
	FrameFlags             *int32                   `protobuf:"varint,1,opt,name=frame_flags,json=frameFlags,def=0" json:"frame_flags,omitempty"`
	DomainWidth            int32                    `protobuf:"varint,2,opt,name=domain_width,json=domainWidth" json:"domain_width"`
	DomainHeight           int32                    `protobuf:"varint,3,opt,name=domain_height,json=domainHeight" json:"domain_height"`
	FrameAspect            *float32                 `protobuf:"fixed32,6,opt,name=frame_aspect,json=frameAspect,def=1" json:"frame_aspect,omitempty"`
	BackgroundModel        *Homography              `protobuf:"bytes,4,opt,name=background_model,json=backgroundModel" json:"background_model,omitempty"`
	MotionData             *TrackingData_MotionData `protobuf:"bytes,5,opt,name=motion_data,json=motionData" json:"motion_data,omitempty"`
	GlobalFeatureCount     uint32                   `protobuf:"varint,7,opt,name=global_feature_count,json=globalFeatureCount" json:"global_feature_count"`
	AverageMotionMagnitude float32                  `protobuf:"fixed32,8,opt,name=average_motion_magnitude,json=averageMotionMagnitude" json:"average_motion_magnitude"`
}

func (m *TrackingData) Reset()      { *m = TrackingData{} }
func (*TrackingData) ProtoMessage() {}
func (*TrackingData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{0}
}
func (m *TrackingData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingData.Merge(m, src)
}
func (m *TrackingData) XXX_Size() int {
	return m.Size()
}
func (m *TrackingData) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingData.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingData proto.InternalMessageInfo

const Default_TrackingData_FrameFlags int32 = 0
const Default_TrackingData_FrameAspect float32 = 1

func (m *TrackingData) GetFrameFlags() int32 {
	if m != nil && m.FrameFlags != nil {
		return *m.FrameFlags
	}
	return Default_TrackingData_FrameFlags
}

func (m *TrackingData) GetDomainWidth() int32 {
	if m != nil {
		return m.DomainWidth
	}
	return 0
}

func (m *TrackingData) GetDomainHeight() int32 {
	if m != nil {
		return m.DomainHeight
	}
	return 0
}

func (m *TrackingData) GetFrameAspect() float32 {
	if m != nil && m.FrameAspect != nil {
		return *m.FrameAspect
	}
	return Default_TrackingData_FrameAspect
}

func (m *TrackingData) GetBackgroundModel() *Homography {
	if m != nil {
		return m.BackgroundModel
	}
	return nil
}

func (m *TrackingData) GetMotionData() *TrackingData_MotionData {
	if m != nil {
		return m.MotionData
	}
	return nil
}

func (m *TrackingData) GetGlobalFeatureCount() uint32 {
	if m != nil {
		return m.GlobalFeatureCount
	}
	return 0
}

func (m *TrackingData) GetAverageMotionMagnitude() float32 {
	if m != nil {
		return m.AverageMotionMagnitude
	}
	return 0
}

type TrackingData_MotionData struct {
	NumElements                 int32                      `protobuf:"varint,1,opt,name=num_elements,json=numElements" json:"num_elements"`
	VectorData                  []float32                  `protobuf:"fixed32,2,rep,packed,name=vector_data,json=vectorData" json:"vector_data,omitempty"`
	TrackId                     []int32                    `protobuf:"varint,3,rep,packed,name=track_id,json=trackId" json:"track_id,omitempty"`
	RowIndices                  []int32                    `protobuf:"varint,4,rep,packed,name=row_indices,json=rowIndices" json:"row_indices,omitempty"`
	ColStarts                   []int32                    `protobuf:"varint,5,rep,packed,name=col_starts,json=colStarts" json:"col_starts,omitempty"`
	FeatureDescriptors          []*BinaryFeatureDescriptor `protobuf:"bytes,6,rep,name=feature_descriptors,json=featureDescriptors" json:"feature_descriptors,omitempty"`
	ActivelyDiscardedTrackedIds []int32                    `protobuf:"varint,7,rep,name=actively_discarded_tracked_ids,json=activelyDiscardedTrackedIds" json:"actively_discarded_tracked_ids,omitempty"`
}

func (m *TrackingData_MotionData) Reset()      { *m = TrackingData_MotionData{} }
func (*TrackingData_MotionData) ProtoMessage() {}
func (*TrackingData_MotionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{0, 0}
}
func (m *TrackingData_MotionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingData_MotionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingData_MotionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingData_MotionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingData_MotionData.Merge(m, src)
}
func (m *TrackingData_MotionData) XXX_Size() int {
	return m.Size()
}
func (m *TrackingData_MotionData) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingData_MotionData.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingData_MotionData proto.InternalMessageInfo

func (m *TrackingData_MotionData) GetNumElements() int32 {
	if m != nil {
		return m.NumElements
	}
	return 0
}

func (m *TrackingData_MotionData) GetVectorData() []float32 {
	if m != nil {
		return m.VectorData
	}
	return nil
}

func (m *TrackingData_MotionData) GetTrackId() []int32 {
	if m != nil {
		return m.TrackId
	}
	return nil
}

func (m *TrackingData_MotionData) GetRowIndices() []int32 {
	if m != nil {
		return m.RowIndices
	}
	return nil
}

func (m *TrackingData_MotionData) GetColStarts() []int32 {
	if m != nil {
		return m.ColStarts
	}
	return nil
}

func (m *TrackingData_MotionData) GetFeatureDescriptors() []*BinaryFeatureDescriptor {
	if m != nil {
		return m.FeatureDescriptors
	}
	return nil
}

func (m *TrackingData_MotionData) GetActivelyDiscardedTrackedIds() []int32 {
	if m != nil {
		return m.ActivelyDiscardedTrackedIds
	}
	return nil
}

type TrackingDataChunk struct {
	Item       []*TrackingDataChunk_Item `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	LastChunk  *bool                     `protobuf:"varint,2,opt,name=last_chunk,json=lastChunk,def=0" json:"last_chunk,omitempty"`
	FirstChunk *bool                     `protobuf:"varint,3,opt,name=first_chunk,json=firstChunk,def=0" json:"first_chunk,omitempty"`
}

func (m *TrackingDataChunk) Reset()      { *m = TrackingDataChunk{} }
func (*TrackingDataChunk) ProtoMessage() {}
func (*TrackingDataChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{1}
}
func (m *TrackingDataChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingDataChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingDataChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingDataChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingDataChunk.Merge(m, src)
}
func (m *TrackingDataChunk) XXX_Size() int {
	return m.Size()
}
func (m *TrackingDataChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingDataChunk.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingDataChunk proto.InternalMessageInfo

const Default_TrackingDataChunk_LastChunk bool = false
const Default_TrackingDataChunk_FirstChunk bool = false

func (m *TrackingDataChunk) GetItem() []*TrackingDataChunk_Item {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *TrackingDataChunk) GetLastChunk() bool {
	if m != nil && m.LastChunk != nil {
		return *m.LastChunk
	}
	return Default_TrackingDataChunk_LastChunk
}

func (m *TrackingDataChunk) GetFirstChunk() bool {
	if m != nil && m.FirstChunk != nil {
		return *m.FirstChunk
	}
	return Default_TrackingDataChunk_FirstChunk
}

type TrackingDataChunk_Item struct {
	TrackingData      *TrackingData `protobuf:"bytes,1,opt,name=tracking_data,json=trackingData" json:"tracking_data,omitempty"`
	FrameIdx          int32         `protobuf:"varint,2,opt,name=frame_idx,json=frameIdx" json:"frame_idx"`
	TimestampUsec     int64         `protobuf:"varint,3,opt,name=timestamp_usec,json=timestampUsec" json:"timestamp_usec"`
	PrevTimestampUsec int64         `protobuf:"varint,4,opt,name=prev_timestamp_usec,json=prevTimestampUsec" json:"prev_timestamp_usec"`
}

func (m *TrackingDataChunk_Item) Reset()      { *m = TrackingDataChunk_Item{} }
func (*TrackingDataChunk_Item) ProtoMessage() {}
func (*TrackingDataChunk_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{1, 0}
}
func (m *TrackingDataChunk_Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingDataChunk_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingDataChunk_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingDataChunk_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingDataChunk_Item.Merge(m, src)
}
func (m *TrackingDataChunk_Item) XXX_Size() int {
	return m.Size()
}
func (m *TrackingDataChunk_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingDataChunk_Item.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingDataChunk_Item proto.InternalMessageInfo

func (m *TrackingDataChunk_Item) GetTrackingData() *TrackingData {
	if m != nil {
		return m.TrackingData
	}
	return nil
}

func (m *TrackingDataChunk_Item) GetFrameIdx() int32 {
	if m != nil {
		return m.FrameIdx
	}
	return 0
}

func (m *TrackingDataChunk_Item) GetTimestampUsec() int64 {
	if m != nil {
		return m.TimestampUsec
	}
	return 0
}

func (m *TrackingDataChunk_Item) GetPrevTimestampUsec() int64 {
	if m != nil {
		return m.PrevTimestampUsec
	}
	return 0
}

type BinaryTrackingData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data" json:"data"`
}

func (m *BinaryTrackingData) Reset()      { *m = BinaryTrackingData{} }
func (*BinaryTrackingData) ProtoMessage() {}
func (*BinaryTrackingData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{2}
}
func (m *BinaryTrackingData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryTrackingData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryTrackingData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryTrackingData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryTrackingData.Merge(m, src)
}
func (m *BinaryTrackingData) XXX_Size() int {
	return m.Size()
}
func (m *BinaryTrackingData) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryTrackingData.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryTrackingData proto.InternalMessageInfo

func (m *BinaryTrackingData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type MetaData struct {
	NumFrames    uint32                  `protobuf:"fixed32,2,opt,name=num_frames,json=numFrames" json:"num_frames"`
	TrackOffsets []*MetaData_TrackOffset `protobuf:"bytes,3,rep,name=track_offsets,json=trackOffsets" json:"track_offsets,omitempty"`
}

func (m *MetaData) Reset()      { *m = MetaData{} }
func (*MetaData) ProtoMessage() {}
func (*MetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{3}
}
func (m *MetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaData.Merge(m, src)
}
func (m *MetaData) XXX_Size() int {
	return m.Size()
}
func (m *MetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaData.DiscardUnknown(m)
}

var xxx_messageInfo_MetaData proto.InternalMessageInfo

func (m *MetaData) GetNumFrames() uint32 {
	if m != nil {
		return m.NumFrames
	}
	return 0
}

func (m *MetaData) GetTrackOffsets() []*MetaData_TrackOffset {
	if m != nil {
		return m.TrackOffsets
	}
	return nil
}

type MetaData_TrackOffset struct {
	Msec         uint32 `protobuf:"fixed32,1,opt,name=msec" json:"msec"`
	StreamOffset uint32 `protobuf:"fixed32,2,opt,name=stream_offset,json=streamOffset" json:"stream_offset"`
}

func (m *MetaData_TrackOffset) Reset()      { *m = MetaData_TrackOffset{} }
func (*MetaData_TrackOffset) ProtoMessage() {}
func (*MetaData_TrackOffset) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{3, 0}
}
func (m *MetaData_TrackOffset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaData_TrackOffset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaData_TrackOffset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaData_TrackOffset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaData_TrackOffset.Merge(m, src)
}
func (m *MetaData_TrackOffset) XXX_Size() int {
	return m.Size()
}
func (m *MetaData_TrackOffset) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaData_TrackOffset.DiscardUnknown(m)
}

var xxx_messageInfo_MetaData_TrackOffset proto.InternalMessageInfo

func (m *MetaData_TrackOffset) GetMsec() uint32 {
	if m != nil {
		return m.Msec
	}
	return 0
}

func (m *MetaData_TrackOffset) GetStreamOffset() uint32 {
	if m != nil {
		return m.StreamOffset
	}
	return 0
}

type TrackingContainer struct {
	Header  string  `protobuf:"bytes,1,opt,name=header" json:"header"`
	Version *uint32 `protobuf:"fixed32,2,opt,name=version,def=1" json:"version,omitempty"`
	Size_   uint32  `protobuf:"fixed32,3,opt,name=size" json:"size"`
	Data    []byte  `protobuf:"bytes,4,opt,name=data" json:"data"`
}

func (m *TrackingContainer) Reset()      { *m = TrackingContainer{} }
func (*TrackingContainer) ProtoMessage() {}
func (*TrackingContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{4}
}
func (m *TrackingContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingContainer.Merge(m, src)
}
func (m *TrackingContainer) XXX_Size() int {
	return m.Size()
}
func (m *TrackingContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingContainer.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingContainer proto.InternalMessageInfo

const Default_TrackingContainer_Version uint32 = 1

func (m *TrackingContainer) GetHeader() string {
	if m != nil {
		return m.Header
	}
	return ""
}

func (m *TrackingContainer) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_TrackingContainer_Version
}

func (m *TrackingContainer) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *TrackingContainer) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TrackingContainerFormat struct {
	MetaData  *TrackingContainer   `protobuf:"bytes,1,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
	TrackData []*TrackingContainer `protobuf:"bytes,2,rep,name=track_data,json=trackData" json:"track_data,omitempty"`
	TermData  *TrackingContainer   `protobuf:"bytes,3,opt,name=term_data,json=termData" json:"term_data,omitempty"`
}

func (m *TrackingContainerFormat) Reset()      { *m = TrackingContainerFormat{} }
func (*TrackingContainerFormat) ProtoMessage() {}
func (*TrackingContainerFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{5}
}
func (m *TrackingContainerFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingContainerFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingContainerFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingContainerFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingContainerFormat.Merge(m, src)
}
func (m *TrackingContainerFormat) XXX_Size() int {
	return m.Size()
}
func (m *TrackingContainerFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingContainerFormat.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingContainerFormat proto.InternalMessageInfo

func (m *TrackingContainerFormat) GetMetaData() *TrackingContainer {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *TrackingContainerFormat) GetTrackData() []*TrackingContainer {
	if m != nil {
		return m.TrackData
	}
	return nil
}

func (m *TrackingContainerFormat) GetTermData() *TrackingContainer {
	if m != nil {
		return m.TermData
	}
	return nil
}

type TrackingContainerProto struct {
	MetaData  *MetaData             `protobuf:"bytes,1,opt,name=meta_data,json=metaData" json:"meta_data,omitempty"`
	TrackData []*BinaryTrackingData `protobuf:"bytes,2,rep,name=track_data,json=trackData" json:"track_data,omitempty"`
}

func (m *TrackingContainerProto) Reset()      { *m = TrackingContainerProto{} }
func (*TrackingContainerProto) ProtoMessage() {}
func (*TrackingContainerProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{6}
}
func (m *TrackingContainerProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingContainerProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingContainerProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingContainerProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingContainerProto.Merge(m, src)
}
func (m *TrackingContainerProto) XXX_Size() int {
	return m.Size()
}
func (m *TrackingContainerProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingContainerProto.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingContainerProto proto.InternalMessageInfo

func (m *TrackingContainerProto) GetMetaData() *MetaData {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *TrackingContainerProto) GetTrackData() []*BinaryTrackingData {
	if m != nil {
		return m.TrackData
	}
	return nil
}

type FlowPackagerOptions struct {
	DomainWidth               *int32   `protobuf:"varint,1,opt,name=domain_width,json=domainWidth,def=256" json:"domain_width,omitempty"`
	DomainHeight              *int32   `protobuf:"varint,2,opt,name=domain_height,json=domainHeight,def=192" json:"domain_height,omitempty"`
	BinaryTrackingDataSupport *bool    `protobuf:"varint,6,opt,name=binary_tracking_data_support,json=binaryTrackingDataSupport,def=1" json:"binary_tracking_data_support,omitempty"`
	UseHighProfile            *bool    `protobuf:"varint,3,opt,name=use_high_profile,json=useHighProfile,def=0" json:"use_high_profile,omitempty"`
	HighFidelity_16BitEncode  *bool    `protobuf:"varint,4,opt,name=high_fidelity_16bit_encode,json=highFidelity16bitEncode,def=1" json:"high_fidelity_16bit_encode,omitempty"`
	HighProfileReuseThreshold *float32 `protobuf:"fixed32,5,opt,name=high_profile_reuse_threshold,json=highProfileReuseThreshold,def=0.5" json:"high_profile_reuse_threshold,omitempty"`
}

func (m *FlowPackagerOptions) Reset()      { *m = FlowPackagerOptions{} }
func (*FlowPackagerOptions) ProtoMessage() {}
func (*FlowPackagerOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_21cd8c98b491be48, []int{7}
}
func (m *FlowPackagerOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowPackagerOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowPackagerOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowPackagerOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowPackagerOptions.Merge(m, src)
}
func (m *FlowPackagerOptions) XXX_Size() int {
	return m.Size()
}
func (m *FlowPackagerOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowPackagerOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FlowPackagerOptions proto.InternalMessageInfo

const Default_FlowPackagerOptions_DomainWidth int32 = 256
const Default_FlowPackagerOptions_DomainHeight int32 = 192
const Default_FlowPackagerOptions_BinaryTrackingDataSupport bool = true
const Default_FlowPackagerOptions_UseHighProfile bool = false
const Default_FlowPackagerOptions_HighFidelity_16BitEncode bool = true
const Default_FlowPackagerOptions_HighProfileReuseThreshold float32 = 0.5

func (m *FlowPackagerOptions) GetDomainWidth() int32 {
	if m != nil && m.DomainWidth != nil {
		return *m.DomainWidth
	}
	return Default_FlowPackagerOptions_DomainWidth
}

func (m *FlowPackagerOptions) GetDomainHeight() int32 {
	if m != nil && m.DomainHeight != nil {
		return *m.DomainHeight
	}
	return Default_FlowPackagerOptions_DomainHeight
}

func (m *FlowPackagerOptions) GetBinaryTrackingDataSupport() bool {
	if m != nil && m.BinaryTrackingDataSupport != nil {
		return *m.BinaryTrackingDataSupport
	}
	return Default_FlowPackagerOptions_BinaryTrackingDataSupport
}

func (m *FlowPackagerOptions) GetUseHighProfile() bool {
	if m != nil && m.UseHighProfile != nil {
		return *m.UseHighProfile
	}
	return Default_FlowPackagerOptions_UseHighProfile
}

func (m *FlowPackagerOptions) GetHighFidelity_16BitEncode() bool {
	if m != nil && m.HighFidelity_16BitEncode != nil {
		return *m.HighFidelity_16BitEncode
	}
	return Default_FlowPackagerOptions_HighFidelity_16BitEncode
}

func (m *FlowPackagerOptions) GetHighProfileReuseThreshold() float32 {
	if m != nil && m.HighProfileReuseThreshold != nil {
		return *m.HighProfileReuseThreshold
	}
	return Default_FlowPackagerOptions_HighProfileReuseThreshold
}

func init() {
	proto.RegisterEnum("mediapipe.TrackingData_FrameFlags", TrackingData_FrameFlags_name, TrackingData_FrameFlags_value)
	proto.RegisterEnum("mediapipe.FlowPackagerOptions_HighProfileEncoding", FlowPackagerOptions_HighProfileEncoding_name, FlowPackagerOptions_HighProfileEncoding_value)
	proto.RegisterType((*TrackingData)(nil), "mediapipe.TrackingData")
	proto.RegisterType((*TrackingData_MotionData)(nil), "mediapipe.TrackingData.MotionData")
	proto.RegisterType((*TrackingDataChunk)(nil), "mediapipe.TrackingDataChunk")
	proto.RegisterType((*TrackingDataChunk_Item)(nil), "mediapipe.TrackingDataChunk.Item")
	proto.RegisterType((*BinaryTrackingData)(nil), "mediapipe.BinaryTrackingData")
	proto.RegisterType((*MetaData)(nil), "mediapipe.MetaData")
	proto.RegisterType((*MetaData_TrackOffset)(nil), "mediapipe.MetaData.TrackOffset")
	proto.RegisterType((*TrackingContainer)(nil), "mediapipe.TrackingContainer")
	proto.RegisterType((*TrackingContainerFormat)(nil), "mediapipe.TrackingContainerFormat")
	proto.RegisterType((*TrackingContainerProto)(nil), "mediapipe.TrackingContainerProto")
	proto.RegisterType((*FlowPackagerOptions)(nil), "mediapipe.FlowPackagerOptions")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/flow_packager.proto", fileDescriptor_21cd8c98b491be48)
}

var fileDescriptor_21cd8c98b491be48 = []byte{
	// 1392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0x5d, 0x6f, 0x13, 0x47,
	0x17, 0x80, 0xbd, 0xb6, 0x43, 0xec, 0xe3, 0x84, 0xd7, 0x4c, 0xde, 0x97, 0x2c, 0x21, 0x2c, 0x8e,
	0xe1, 0x85, 0x20, 0x24, 0x07, 0xd2, 0x82, 0x44, 0x8a, 0x5a, 0xfc, 0x99, 0x58, 0x49, 0x9c, 0x74,
	0xe3, 0xd0, 0xd2, 0x9b, 0xd1, 0x64, 0x77, 0xbc, 0x1e, 0x65, 0x3f, 0xac, 0xdd, 0x71, 0x42, 0x7a,
	0x85, 0x7a, 0xd5, 0xcb, 0xfe, 0x8c, 0xfe, 0x87, 0xfe, 0x01, 0x5a, 0xf5, 0x82, 0x4b, 0xa4, 0x4a,
	0x15, 0x04, 0x55, 0xea, 0x45, 0x2f, 0xf8, 0x09, 0xd5, 0xcc, 0xac, 0x1d, 0x3b, 0x1f, 0x6a, 0xef,
	0x9c, 0x73, 0x9e, 0xf3, 0x39, 0x67, 0x4f, 0x0e, 0xdc, 0xf7, 0xa8, 0xcd, 0x48, 0x8f, 0xf5, 0xe8,
	0x52, 0x9f, 0x33, 0x77, 0x89, 0x87, 0xc4, 0xda, 0x67, 0xbe, 0xb3, 0xd4, 0x71, 0x83, 0x43, 0xdc,
	0x23, 0xd6, 0x3e, 0x71, 0x68, 0x58, 0xea, 0x85, 0x01, 0x0f, 0x50, 0x76, 0x08, 0xcf, 0x5d, 0x68,
	0xe7, 0x05, 0x9c, 0x05, 0x3e, 0xf6, 0x02, 0x9b, 0xba, 0x91, 0xb2, 0x9b, 0xbb, 0x77, 0x11, 0x1c,
	0x52, 0x47, 0xc0, 0x22, 0x96, 0x42, 0x8b, 0x7f, 0x4d, 0xc2, 0x54, 0x3b, 0x56, 0xd7, 0x08, 0x27,
	0xa8, 0x08, 0xb9, 0x4e, 0x48, 0x3c, 0x8a, 0x3b, 0x2e, 0x71, 0x22, 0x5d, 0x2b, 0x68, 0x8b, 0x13,
	0x2b, 0xda, 0x03, 0x13, 0xa4, 0xb4, 0x21, 0x84, 0xe8, 0x2e, 0x4c, 0xd9, 0x81, 0x47, 0x98, 0x8f,
	0x0f, 0x99, 0xcd, 0xbb, 0x7a, 0x52, 0x40, 0x95, 0xf4, 0xeb, 0xdf, 0x6f, 0x26, 0xcc, 0x9c, 0xd2,
	0x7c, 0x25, 0x14, 0xe8, 0x1e, 0x4c, 0xc7, 0x60, 0x97, 0x32, 0xa7, 0xcb, 0xf5, 0xd4, 0x08, 0x19,
	0xfb, 0x58, 0x93, 0x1a, 0x74, 0x1b, 0xa6, 0x54, 0x5c, 0x12, 0xf5, 0xa8, 0xc5, 0xf5, 0x4b, 0x05,
	0x6d, 0x31, 0xb9, 0xa2, 0x3d, 0x34, 0x55, 0x3a, 0x65, 0x29, 0x45, 0xcf, 0x20, 0xbf, 0x47, 0xac,
	0x7d, 0x27, 0x0c, 0xfa, 0xbe, 0xad, 0x8a, 0xd6, 0xd3, 0x05, 0x6d, 0x31, 0xb7, 0xfc, 0xbf, 0xd2,
	0xb0, 0xe8, 0xd2, 0x5a, 0xe0, 0x05, 0x4e, 0x48, 0x7a, 0xdd, 0x23, 0xf3, 0x3f, 0x27, 0xf8, 0xa6,
	0xa0, 0x51, 0x15, 0x72, 0x71, 0xcb, 0x6c, 0xc2, 0x89, 0x3e, 0x21, 0x8d, 0x8b, 0x23, 0xc6, 0xa3,
	0xdd, 0x28, 0x6d, 0x4a, 0x54, 0xfc, 0x34, 0xc1, 0x1b, 0xfe, 0x46, 0x8f, 0xe1, 0xbf, 0x8e, 0x1b,
	0xec, 0x11, 0x17, 0x77, 0x28, 0xe1, 0xfd, 0x90, 0x62, 0x2b, 0xe8, 0xfb, 0x5c, 0x9f, 0x2c, 0x68,
	0x8b, 0xd3, 0x71, 0x79, 0x48, 0x11, 0x0d, 0x05, 0x54, 0x85, 0x1e, 0x7d, 0x0e, 0x3a, 0x39, 0xa0,
	0x21, 0x71, 0x28, 0x1e, 0xbc, 0x1b, 0x71, 0x7c, 0xc6, 0xfb, 0x36, 0xd5, 0x33, 0xa2, 0xe0, 0xd8,
	0xf6, 0x6a, 0x4c, 0xa9, 0xf0, 0x9b, 0x03, 0x66, 0xee, 0xb7, 0x24, 0xc0, 0x49, 0x4a, 0xe2, 0x1d,
	0xfc, 0xbe, 0x87, 0xa9, 0x4b, 0x3d, 0xea, 0xf3, 0xf8, 0xb1, 0x06, 0xef, 0xe0, 0xf7, 0xbd, 0x7a,
	0xac, 0x40, 0xb7, 0x20, 0x77, 0x40, 0x2d, 0x1e, 0x84, 0xaa, 0xe8, 0x64, 0x21, 0xb5, 0x98, 0xac,
	0x24, 0xf3, 0x9a, 0x09, 0x4a, 0x2c, 0xbd, 0xdd, 0x80, 0x8c, 0x1c, 0x14, 0xcc, 0x6c, 0x3d, 0x55,
	0x48, 0x2d, 0x4e, 0x48, 0x62, 0x52, 0xca, 0x9a, 0xb6, 0xf0, 0x11, 0x06, 0x87, 0x98, 0xf9, 0x36,
	0xb3, 0x68, 0xa4, 0xa7, 0x87, 0x04, 0x84, 0xc1, 0x61, 0x53, 0x49, 0xd1, 0x02, 0x80, 0x15, 0xb8,
	0x38, 0xe2, 0x24, 0xe4, 0x91, 0x3e, 0x31, 0x64, 0xb2, 0x56, 0xe0, 0xee, 0x48, 0x21, 0xda, 0x81,
	0x99, 0x41, 0xd3, 0x6c, 0x1a, 0x59, 0x21, 0xeb, 0xf1, 0x20, 0x8c, 0xf4, 0x4b, 0x85, 0xd4, 0xa9,
	0x87, 0xa8, 0x30, 0x9f, 0x84, 0x47, 0x71, 0xff, 0x6a, 0x43, 0xd4, 0x44, 0x9d, 0xd3, 0xa2, 0x08,
	0x55, 0xc1, 0x20, 0x16, 0x67, 0x07, 0xd4, 0x3d, 0xc2, 0x36, 0x8b, 0x2c, 0x12, 0xda, 0xd4, 0xc6,
	0x32, 0x75, 0x6a, 0x63, 0x66, 0x47, 0xfa, 0xa4, 0xc8, 0xc5, 0xbc, 0x3e, 0xa0, 0x6a, 0x03, 0xa8,
	0xad, 0x98, 0xa6, 0x1d, 0x15, 0xdf, 0x69, 0x00, 0x8d, 0x93, 0x29, 0x2f, 0x82, 0xd1, 0x36, 0xcb,
	0xd5, 0xf5, 0x66, 0x6b, 0x15, 0x37, 0x36, 0xca, 0xab, 0x78, 0xdb, 0xdc, 0x6a, 0x34, 0x37, 0xea,
	0xb8, 0x52, 0xde, 0xa9, 0x6f, 0x34, 0x5b, 0xf5, 0x7c, 0x02, 0x19, 0x30, 0x77, 0x3e, 0xb3, 0xd6,
	0x5c, 0x5d, 0xcb, 0x6b, 0xe8, 0x2e, 0xdc, 0x1a, 0xd7, 0x0b, 0x39, 0x6e, 0x34, 0x6b, 0xf5, 0x8d,
	0x66, 0xfb, 0x05, 0x7e, 0x5e, 0xaf, 0xb6, 0xb7, 0xcc, 0x9d, 0x7c, 0x12, 0xfd, 0x1f, 0x16, 0xc6,
	0xc1, 0x4a, 0xb9, 0xba, 0xbe, 0x6a, 0x6e, 0xed, 0xb6, 0x6a, 0x78, 0xb7, 0xb5, 0xd3, 0x2e, 0x57,
	0x36, 0xea, 0xf9, 0x34, 0x9a, 0x07, 0x7d, 0x1c, 0xab, 0xed, 0x6e, 0x6f, 0x34, 0xab, 0xe5, 0x76,
	0xbd, 0x96, 0xcf, 0xa0, 0x02, 0xcc, 0x8f, 0x6b, 0xab, 0x6b, 0xbb, 0xad, 0x75, 0x5c, 0x11, 0x5e,
	0xca, 0xe6, 0x8b, 0x7c, 0xbe, 0xf8, 0x47, 0x12, 0xae, 0x8c, 0x0e, 0x78, 0xb5, 0xdb, 0xf7, 0xf7,
	0xd1, 0x23, 0x48, 0x33, 0x4e, 0x3d, 0x5d, 0x93, 0x6f, 0xb0, 0x70, 0xc1, 0xc7, 0x20, 0xd9, 0x52,
	0x93, 0x53, 0xcf, 0x94, 0x38, 0xba, 0x0d, 0xe0, 0x92, 0x88, 0x63, 0x4b, 0x28, 0xe4, 0x12, 0xc8,
	0xac, 0x4c, 0x74, 0x88, 0x1b, 0x51, 0x33, 0x2b, 0x14, 0xca, 0xf9, 0x1d, 0xc8, 0x75, 0x58, 0x38,
	0xc4, 0x52, 0xa3, 0x18, 0x48, 0x8d, 0xe4, 0xe6, 0x7e, 0xd1, 0x20, 0x2d, 0x9c, 0xa3, 0xa7, 0x30,
	0x3d, 0x58, 0x58, 0x6a, 0x5c, 0x35, 0xf9, 0x8d, 0xce, 0x5e, 0x90, 0x96, 0x39, 0xc5, 0x47, 0xf7,
	0xd7, 0x02, 0x64, 0xd5, 0x1e, 0x61, 0xf6, 0xcb, 0xb1, 0xc5, 0x94, 0x91, 0xe2, 0xa6, 0xfd, 0x12,
	0xdd, 0x87, 0xcb, 0x9c, 0x79, 0x34, 0xe2, 0xc4, 0xeb, 0xe1, 0x7e, 0x44, 0x2d, 0x99, 0x54, 0x2a,
	0xe6, 0xa6, 0x87, 0xba, 0xdd, 0x88, 0x5a, 0xe8, 0x53, 0x98, 0xe9, 0x85, 0xf4, 0x00, 0x9f, 0xb2,
	0x48, 0x8f, 0x58, 0x5c, 0x11, 0x40, 0x7b, 0xd4, 0xaa, 0x58, 0x02, 0xa4, 0xc6, 0x77, 0x6c, 0xb7,
	0xea, 0x90, 0x1e, 0x16, 0x34, 0x15, 0x1b, 0x4b, 0x49, 0xf1, 0x67, 0x0d, 0x32, 0x9b, 0x94, 0x13,
	0x89, 0xdd, 0x02, 0x10, 0x9f, 0xb5, 0xcc, 0x37, 0x92, 0x35, 0x4c, 0xc6, 0x70, 0xd6, 0xef, 0x7b,
	0x72, 0x42, 0x23, 0x54, 0x8b, 0xbb, 0x84, 0x83, 0x4e, 0x27, 0xa2, 0x3c, 0x92, 0x9f, 0x6c, 0x6e,
	0xf9, 0xe6, 0x48, 0x97, 0x06, 0x0e, 0x55, 0xbb, 0xb6, 0x24, 0x17, 0x77, 0x4b, 0xfd, 0x11, 0xcd,
	0x99, 0x90, 0x1b, 0x51, 0x8a, 0x04, 0x3d, 0x51, 0x9d, 0x36, 0x12, 0x53, 0x4a, 0xc4, 0x26, 0x8f,
	0x78, 0x48, 0x89, 0x17, 0xc7, 0x1b, 0x4b, 0x6b, 0x4a, 0xa9, 0x94, 0x93, 0xe2, 0x77, 0xda, 0xc9,
	0x8c, 0x55, 0x03, 0x9f, 0x13, 0xe6, 0xd3, 0x10, 0xcd, 0xc3, 0xa5, 0x2e, 0x25, 0x36, 0x0d, 0xa5,
	0xf3, 0x6c, 0x6c, 0x19, 0xcb, 0xd0, 0x75, 0x98, 0x3c, 0xa0, 0x61, 0xc4, 0x02, 0x5f, 0x39, 0x16,
	0x8b, 0x7f, 0x20, 0x11, 0x59, 0x45, 0xec, 0x5b, 0x2a, 0x5f, 0x69, 0x98, 0x95, 0x90, 0x0c, 0x1b,
	0x9a, 0x3e, 0xd3, 0xd0, 0x5f, 0x35, 0x98, 0x3d, 0x93, 0x44, 0x23, 0x08, 0x3d, 0xc2, 0xd1, 0x13,
	0xc8, 0x7a, 0x94, 0x93, 0xd1, 0xe1, 0x9a, 0x3f, 0x67, 0xb8, 0x86, 0x66, 0x66, 0xc6, 0x1b, 0x3c,
	0xcd, 0x67, 0x00, 0xaa, 0xeb, 0xc3, 0x3d, 0xfa, 0x4f, 0xb6, 0x59, 0xc9, 0x4b, 0xe3, 0x27, 0x90,
	0xe5, 0x34, 0xf4, 0x94, 0x6d, 0xea, 0xdf, 0xc4, 0x15, 0xb8, 0x30, 0x2d, 0x7e, 0xaf, 0xc1, 0xd5,
	0x33, 0xfa, 0x6d, 0x79, 0x24, 0x3c, 0x38, 0x5b, 0xcd, 0xcc, 0x39, 0x43, 0x30, 0x52, 0xc4, 0xd3,
	0x73, 0x8a, 0xb8, 0x71, 0x66, 0xf1, 0x8e, 0x7d, 0x63, 0x27, 0x55, 0x14, 0x7f, 0x4a, 0xc1, 0x4c,
	0xc3, 0x0d, 0x0e, 0xb7, 0xe3, 0x5b, 0x65, 0xab, 0x27, 0xfe, 0x1f, 0x45, 0xe8, 0xce, 0xa9, 0xa3,
	0x40, 0x5d, 0x0e, 0xa9, 0xe5, 0x47, 0x8f, 0xc7, 0x6f, 0x82, 0xc5, 0xd3, 0x37, 0x41, 0x52, 0x81,
	0x0f, 0x9f, 0x2c, 0x9f, 0x3a, 0x09, 0xea, 0x30, 0xbf, 0x27, 0x53, 0xc1, 0x63, 0xfb, 0x00, 0x47,
	0xfd, 0x5e, 0x2f, 0x08, 0xd5, 0x89, 0x90, 0x59, 0x49, 0xf3, 0xb0, 0x4f, 0xcd, 0x6b, 0x7b, 0x67,
	0x92, 0xde, 0x51, 0x18, 0x5a, 0x82, 0x7c, 0x3f, 0xa2, 0xb8, 0xcb, 0x9c, 0x2e, 0xee, 0x85, 0x41,
	0x87, 0xb9, 0x74, 0x7c, 0x0b, 0x5d, 0xee, 0x47, 0x74, 0x8d, 0x39, 0xdd, 0x6d, 0xa5, 0x44, 0x65,
	0x98, 0x93, 0x70, 0x87, 0xd9, 0xd4, 0x65, 0xfc, 0x08, 0x3f, 0x7c, 0xbc, 0xc7, 0x38, 0xa6, 0xbe,
	0x15, 0xd8, 0x54, 0xce, 0xda, 0x20, 0xea, 0xac, 0xe0, 0x1a, 0x31, 0x26, 0xa9, 0xba, 0x84, 0x50,
	0x0d, 0xe6, 0x47, 0xe3, 0xe1, 0x90, 0x8a, 0x14, 0x78, 0x37, 0xa4, 0x51, 0x37, 0x70, 0x6d, 0x79,
	0x76, 0x24, 0x57, 0x52, 0x0f, 0x4a, 0x8f, 0xcc, 0x6b, 0xdd, 0x93, 0xd0, 0xa6, 0xc0, 0xda, 0x03,
	0xaa, 0xf8, 0x25, 0xcc, 0x8c, 0xe4, 0x25, 0x5d, 0x33, 0xdf, 0x41, 0x57, 0x60, 0xaa, 0x5c, 0x7b,
	0x5e, 0x6e, 0x55, 0xeb, 0x72, 0xcb, 0xe7, 0x5f, 0x69, 0x68, 0x16, 0x66, 0x6a, 0x5b, 0xbb, 0x95,
	0x8d, 0x3a, 0x6e, 0xb6, 0x6a, 0xf5, 0xaf, 0x71, 0xbd, 0x55, 0xdd, 0xaa, 0xd5, 0xf3, 0xcf, 0xd0,
	0x65, 0x00, 0x25, 0xd9, 0x2c, 0xef, 0xac, 0xe7, 0xbf, 0xa8, 0xb0, 0x37, 0xef, 0x8d, 0xc4, 0xdb,
	0xf7, 0x46, 0xe2, 0xe3, 0x7b, 0x43, 0x7b, 0x75, 0x6c, 0x68, 0x3f, 0x1e, 0x1b, 0xda, 0xeb, 0x63,
	0x43, 0x7b, 0x73, 0x6c, 0x68, 0xef, 0x8e, 0x0d, 0xed, 0xcf, 0x63, 0x23, 0xf1, 0xf1, 0xd8, 0xd0,
	0x7e, 0xf8, 0x60, 0x24, 0xde, 0x7c, 0x30, 0x12, 0x6f, 0x3f, 0x18, 0x89, 0x6f, 0x3e, 0x71, 0x18,
	0xef, 0xf6, 0xf7, 0x4a, 0x56, 0xe0, 0x2d, 0x39, 0x41, 0xe0, 0xb8, 0x74, 0xe9, 0xe4, 0xc4, 0xbc,
	0xe0, 0xd8, 0xfc, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x6a, 0x67, 0xa1, 0xeb, 0x0a, 0x00, 0x00,
}

func (x TrackingData_FrameFlags) String() string {
	s, ok := TrackingData_FrameFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FlowPackagerOptions_HighProfileEncoding) String() string {
	s, ok := FlowPackagerOptions_HighProfileEncoding_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TrackingData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingData)
	if !ok {
		that2, ok := that.(TrackingData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FrameFlags != nil && that1.FrameFlags != nil {
		if *this.FrameFlags != *that1.FrameFlags {
			return false
		}
	} else if this.FrameFlags != nil {
		return false
	} else if that1.FrameFlags != nil {
		return false
	}
	if this.DomainWidth != that1.DomainWidth {
		return false
	}
	if this.DomainHeight != that1.DomainHeight {
		return false
	}
	if this.FrameAspect != nil && that1.FrameAspect != nil {
		if *this.FrameAspect != *that1.FrameAspect {
			return false
		}
	} else if this.FrameAspect != nil {
		return false
	} else if that1.FrameAspect != nil {
		return false
	}
	if !this.BackgroundModel.Equal(that1.BackgroundModel) {
		return false
	}
	if !this.MotionData.Equal(that1.MotionData) {
		return false
	}
	if this.GlobalFeatureCount != that1.GlobalFeatureCount {
		return false
	}
	if this.AverageMotionMagnitude != that1.AverageMotionMagnitude {
		return false
	}
	return true
}
func (this *TrackingData_MotionData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingData_MotionData)
	if !ok {
		that2, ok := that.(TrackingData_MotionData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumElements != that1.NumElements {
		return false
	}
	if len(this.VectorData) != len(that1.VectorData) {
		return false
	}
	for i := range this.VectorData {
		if this.VectorData[i] != that1.VectorData[i] {
			return false
		}
	}
	if len(this.TrackId) != len(that1.TrackId) {
		return false
	}
	for i := range this.TrackId {
		if this.TrackId[i] != that1.TrackId[i] {
			return false
		}
	}
	if len(this.RowIndices) != len(that1.RowIndices) {
		return false
	}
	for i := range this.RowIndices {
		if this.RowIndices[i] != that1.RowIndices[i] {
			return false
		}
	}
	if len(this.ColStarts) != len(that1.ColStarts) {
		return false
	}
	for i := range this.ColStarts {
		if this.ColStarts[i] != that1.ColStarts[i] {
			return false
		}
	}
	if len(this.FeatureDescriptors) != len(that1.FeatureDescriptors) {
		return false
	}
	for i := range this.FeatureDescriptors {
		if !this.FeatureDescriptors[i].Equal(that1.FeatureDescriptors[i]) {
			return false
		}
	}
	if len(this.ActivelyDiscardedTrackedIds) != len(that1.ActivelyDiscardedTrackedIds) {
		return false
	}
	for i := range this.ActivelyDiscardedTrackedIds {
		if this.ActivelyDiscardedTrackedIds[i] != that1.ActivelyDiscardedTrackedIds[i] {
			return false
		}
	}
	return true
}
func (this *TrackingDataChunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingDataChunk)
	if !ok {
		that2, ok := that.(TrackingDataChunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Item) != len(that1.Item) {
		return false
	}
	for i := range this.Item {
		if !this.Item[i].Equal(that1.Item[i]) {
			return false
		}
	}
	if this.LastChunk != nil && that1.LastChunk != nil {
		if *this.LastChunk != *that1.LastChunk {
			return false
		}
	} else if this.LastChunk != nil {
		return false
	} else if that1.LastChunk != nil {
		return false
	}
	if this.FirstChunk != nil && that1.FirstChunk != nil {
		if *this.FirstChunk != *that1.FirstChunk {
			return false
		}
	} else if this.FirstChunk != nil {
		return false
	} else if that1.FirstChunk != nil {
		return false
	}
	return true
}
func (this *TrackingDataChunk_Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingDataChunk_Item)
	if !ok {
		that2, ok := that.(TrackingDataChunk_Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrackingData.Equal(that1.TrackingData) {
		return false
	}
	if this.FrameIdx != that1.FrameIdx {
		return false
	}
	if this.TimestampUsec != that1.TimestampUsec {
		return false
	}
	if this.PrevTimestampUsec != that1.PrevTimestampUsec {
		return false
	}
	return true
}
func (this *BinaryTrackingData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinaryTrackingData)
	if !ok {
		that2, ok := that.(BinaryTrackingData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *MetaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetaData)
	if !ok {
		that2, ok := that.(MetaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumFrames != that1.NumFrames {
		return false
	}
	if len(this.TrackOffsets) != len(that1.TrackOffsets) {
		return false
	}
	for i := range this.TrackOffsets {
		if !this.TrackOffsets[i].Equal(that1.TrackOffsets[i]) {
			return false
		}
	}
	return true
}
func (this *MetaData_TrackOffset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetaData_TrackOffset)
	if !ok {
		that2, ok := that.(MetaData_TrackOffset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Msec != that1.Msec {
		return false
	}
	if this.StreamOffset != that1.StreamOffset {
		return false
	}
	return true
}
func (this *TrackingContainer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingContainer)
	if !ok {
		that2, ok := that.(TrackingContainer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Header != that1.Header {
		return false
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return false
		}
	} else if this.Version != nil {
		return false
	} else if that1.Version != nil {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *TrackingContainerFormat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingContainerFormat)
	if !ok {
		that2, ok := that.(TrackingContainerFormat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetaData.Equal(that1.MetaData) {
		return false
	}
	if len(this.TrackData) != len(that1.TrackData) {
		return false
	}
	for i := range this.TrackData {
		if !this.TrackData[i].Equal(that1.TrackData[i]) {
			return false
		}
	}
	if !this.TermData.Equal(that1.TermData) {
		return false
	}
	return true
}
func (this *TrackingContainerProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingContainerProto)
	if !ok {
		that2, ok := that.(TrackingContainerProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetaData.Equal(that1.MetaData) {
		return false
	}
	if len(this.TrackData) != len(that1.TrackData) {
		return false
	}
	for i := range this.TrackData {
		if !this.TrackData[i].Equal(that1.TrackData[i]) {
			return false
		}
	}
	return true
}
func (this *FlowPackagerOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FlowPackagerOptions)
	if !ok {
		that2, ok := that.(FlowPackagerOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainWidth != nil && that1.DomainWidth != nil {
		if *this.DomainWidth != *that1.DomainWidth {
			return false
		}
	} else if this.DomainWidth != nil {
		return false
	} else if that1.DomainWidth != nil {
		return false
	}
	if this.DomainHeight != nil && that1.DomainHeight != nil {
		if *this.DomainHeight != *that1.DomainHeight {
			return false
		}
	} else if this.DomainHeight != nil {
		return false
	} else if that1.DomainHeight != nil {
		return false
	}
	if this.BinaryTrackingDataSupport != nil && that1.BinaryTrackingDataSupport != nil {
		if *this.BinaryTrackingDataSupport != *that1.BinaryTrackingDataSupport {
			return false
		}
	} else if this.BinaryTrackingDataSupport != nil {
		return false
	} else if that1.BinaryTrackingDataSupport != nil {
		return false
	}
	if this.UseHighProfile != nil && that1.UseHighProfile != nil {
		if *this.UseHighProfile != *that1.UseHighProfile {
			return false
		}
	} else if this.UseHighProfile != nil {
		return false
	} else if that1.UseHighProfile != nil {
		return false
	}
	if this.HighFidelity_16BitEncode != nil && that1.HighFidelity_16BitEncode != nil {
		if *this.HighFidelity_16BitEncode != *that1.HighFidelity_16BitEncode {
			return false
		}
	} else if this.HighFidelity_16BitEncode != nil {
		return false
	} else if that1.HighFidelity_16BitEncode != nil {
		return false
	}
	if this.HighProfileReuseThreshold != nil && that1.HighProfileReuseThreshold != nil {
		if *this.HighProfileReuseThreshold != *that1.HighProfileReuseThreshold {
			return false
		}
	} else if this.HighProfileReuseThreshold != nil {
		return false
	} else if that1.HighProfileReuseThreshold != nil {
		return false
	}
	return true
}
func (this *TrackingData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tracking.TrackingData{")
	if this.FrameFlags != nil {
		s = append(s, "FrameFlags: "+valueToGoStringFlowPackager(this.FrameFlags, "int32")+",\n")
	}
	s = append(s, "DomainWidth: "+fmt.Sprintf("%#v", this.DomainWidth)+",\n")
	s = append(s, "DomainHeight: "+fmt.Sprintf("%#v", this.DomainHeight)+",\n")
	if this.FrameAspect != nil {
		s = append(s, "FrameAspect: "+valueToGoStringFlowPackager(this.FrameAspect, "float32")+",\n")
	}
	if this.BackgroundModel != nil {
		s = append(s, "BackgroundModel: "+fmt.Sprintf("%#v", this.BackgroundModel)+",\n")
	}
	if this.MotionData != nil {
		s = append(s, "MotionData: "+fmt.Sprintf("%#v", this.MotionData)+",\n")
	}
	s = append(s, "GlobalFeatureCount: "+fmt.Sprintf("%#v", this.GlobalFeatureCount)+",\n")
	s = append(s, "AverageMotionMagnitude: "+fmt.Sprintf("%#v", this.AverageMotionMagnitude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingData_MotionData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&tracking.TrackingData_MotionData{")
	s = append(s, "NumElements: "+fmt.Sprintf("%#v", this.NumElements)+",\n")
	if this.VectorData != nil {
		s = append(s, "VectorData: "+fmt.Sprintf("%#v", this.VectorData)+",\n")
	}
	if this.TrackId != nil {
		s = append(s, "TrackId: "+fmt.Sprintf("%#v", this.TrackId)+",\n")
	}
	if this.RowIndices != nil {
		s = append(s, "RowIndices: "+fmt.Sprintf("%#v", this.RowIndices)+",\n")
	}
	if this.ColStarts != nil {
		s = append(s, "ColStarts: "+fmt.Sprintf("%#v", this.ColStarts)+",\n")
	}
	if this.FeatureDescriptors != nil {
		s = append(s, "FeatureDescriptors: "+fmt.Sprintf("%#v", this.FeatureDescriptors)+",\n")
	}
	if this.ActivelyDiscardedTrackedIds != nil {
		s = append(s, "ActivelyDiscardedTrackedIds: "+fmt.Sprintf("%#v", this.ActivelyDiscardedTrackedIds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingDataChunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.TrackingDataChunk{")
	if this.Item != nil {
		s = append(s, "Item: "+fmt.Sprintf("%#v", this.Item)+",\n")
	}
	if this.LastChunk != nil {
		s = append(s, "LastChunk: "+valueToGoStringFlowPackager(this.LastChunk, "bool")+",\n")
	}
	if this.FirstChunk != nil {
		s = append(s, "FirstChunk: "+valueToGoStringFlowPackager(this.FirstChunk, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingDataChunk_Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.TrackingDataChunk_Item{")
	if this.TrackingData != nil {
		s = append(s, "TrackingData: "+fmt.Sprintf("%#v", this.TrackingData)+",\n")
	}
	s = append(s, "FrameIdx: "+fmt.Sprintf("%#v", this.FrameIdx)+",\n")
	s = append(s, "TimestampUsec: "+fmt.Sprintf("%#v", this.TimestampUsec)+",\n")
	s = append(s, "PrevTimestampUsec: "+fmt.Sprintf("%#v", this.PrevTimestampUsec)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinaryTrackingData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.BinaryTrackingData{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.MetaData{")
	s = append(s, "NumFrames: "+fmt.Sprintf("%#v", this.NumFrames)+",\n")
	if this.TrackOffsets != nil {
		s = append(s, "TrackOffsets: "+fmt.Sprintf("%#v", this.TrackOffsets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetaData_TrackOffset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.MetaData_TrackOffset{")
	s = append(s, "Msec: "+fmt.Sprintf("%#v", this.Msec)+",\n")
	s = append(s, "StreamOffset: "+fmt.Sprintf("%#v", this.StreamOffset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingContainer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.TrackingContainer{")
	s = append(s, "Header: "+fmt.Sprintf("%#v", this.Header)+",\n")
	if this.Version != nil {
		s = append(s, "Version: "+valueToGoStringFlowPackager(this.Version, "uint32")+",\n")
	}
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingContainerFormat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.TrackingContainerFormat{")
	if this.MetaData != nil {
		s = append(s, "MetaData: "+fmt.Sprintf("%#v", this.MetaData)+",\n")
	}
	if this.TrackData != nil {
		s = append(s, "TrackData: "+fmt.Sprintf("%#v", this.TrackData)+",\n")
	}
	if this.TermData != nil {
		s = append(s, "TermData: "+fmt.Sprintf("%#v", this.TermData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingContainerProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.TrackingContainerProto{")
	if this.MetaData != nil {
		s = append(s, "MetaData: "+fmt.Sprintf("%#v", this.MetaData)+",\n")
	}
	if this.TrackData != nil {
		s = append(s, "TrackData: "+fmt.Sprintf("%#v", this.TrackData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FlowPackagerOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.FlowPackagerOptions{")
	if this.DomainWidth != nil {
		s = append(s, "DomainWidth: "+valueToGoStringFlowPackager(this.DomainWidth, "int32")+",\n")
	}
	if this.DomainHeight != nil {
		s = append(s, "DomainHeight: "+valueToGoStringFlowPackager(this.DomainHeight, "int32")+",\n")
	}
	if this.BinaryTrackingDataSupport != nil {
		s = append(s, "BinaryTrackingDataSupport: "+valueToGoStringFlowPackager(this.BinaryTrackingDataSupport, "bool")+",\n")
	}
	if this.UseHighProfile != nil {
		s = append(s, "UseHighProfile: "+valueToGoStringFlowPackager(this.UseHighProfile, "bool")+",\n")
	}
	if this.HighFidelity_16BitEncode != nil {
		s = append(s, "HighFidelity_16BitEncode: "+valueToGoStringFlowPackager(this.HighFidelity_16BitEncode, "bool")+",\n")
	}
	if this.HighProfileReuseThreshold != nil {
		s = append(s, "HighProfileReuseThreshold: "+valueToGoStringFlowPackager(this.HighProfileReuseThreshold, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringFlowPackager(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TrackingData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AverageMotionMagnitude))))
	i--
	dAtA[i] = 0x45
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.GlobalFeatureCount))
	i--
	dAtA[i] = 0x38
	if m.FrameAspect != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FrameAspect))))
		i--
		dAtA[i] = 0x35
	}
	if m.MotionData != nil {
		{
			size, err := m.MotionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BackgroundModel != nil {
		{
			size, err := m.BackgroundModel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.DomainHeight))
	i--
	dAtA[i] = 0x18
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.DomainWidth))
	i--
	dAtA[i] = 0x10
	if m.FrameFlags != nil {
		i = encodeVarintFlowPackager(dAtA, i, uint64(*m.FrameFlags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrackingData_MotionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingData_MotionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingData_MotionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActivelyDiscardedTrackedIds) > 0 {
		for iNdEx := len(m.ActivelyDiscardedTrackedIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFlowPackager(dAtA, i, uint64(m.ActivelyDiscardedTrackedIds[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.FeatureDescriptors) > 0 {
		for iNdEx := len(m.FeatureDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeatureDescriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowPackager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ColStarts) > 0 {
		dAtA4 := make([]byte, len(m.ColStarts)*10)
		var j3 int
		for _, num1 := range m.ColStarts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintFlowPackager(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RowIndices) > 0 {
		dAtA6 := make([]byte, len(m.RowIndices)*10)
		var j5 int
		for _, num1 := range m.RowIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintFlowPackager(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TrackId) > 0 {
		dAtA8 := make([]byte, len(m.TrackId)*10)
		var j7 int
		for _, num1 := range m.TrackId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintFlowPackager(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VectorData) > 0 {
		for iNdEx := len(m.VectorData) - 1; iNdEx >= 0; iNdEx-- {
			f9 := math.Float32bits(float32(m.VectorData[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f9))
		}
		i = encodeVarintFlowPackager(dAtA, i, uint64(len(m.VectorData)*4))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.NumElements))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TrackingDataChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingDataChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingDataChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FirstChunk != nil {
		i--
		if *m.FirstChunk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.LastChunk != nil {
		i--
		if *m.LastChunk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Item) > 0 {
		for iNdEx := len(m.Item) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Item[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowPackager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TrackingDataChunk_Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingDataChunk_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingDataChunk_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.PrevTimestampUsec))
	i--
	dAtA[i] = 0x20
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.TimestampUsec))
	i--
	dAtA[i] = 0x18
	i = encodeVarintFlowPackager(dAtA, i, uint64(m.FrameIdx))
	i--
	dAtA[i] = 0x10
	if m.TrackingData != nil {
		{
			size, err := m.TrackingData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BinaryTrackingData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryTrackingData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryTrackingData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFlowPackager(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrackOffsets) > 0 {
		for iNdEx := len(m.TrackOffsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackOffsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowPackager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NumFrames))
	i--
	dAtA[i] = 0x15
	return len(dAtA) - i, nil
}

func (m *MetaData_TrackOffset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaData_TrackOffset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaData_TrackOffset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.StreamOffset))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Msec))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *TrackingContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFlowPackager(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.Size_))
	i--
	dAtA[i] = 0x1d
	if m.Version != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Version))
		i--
		dAtA[i] = 0x15
	}
	i -= len(m.Header)
	copy(dAtA[i:], m.Header)
	i = encodeVarintFlowPackager(dAtA, i, uint64(len(m.Header)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TrackingContainerFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingContainerFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingContainerFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TermData != nil {
		{
			size, err := m.TermData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrackData) > 0 {
		for iNdEx := len(m.TrackData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowPackager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MetaData != nil {
		{
			size, err := m.MetaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrackingContainerProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingContainerProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingContainerProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrackData) > 0 {
		for iNdEx := len(m.TrackData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowPackager(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MetaData != nil {
		{
			size, err := m.MetaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowPackager(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowPackagerOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowPackagerOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowPackagerOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BinaryTrackingDataSupport != nil {
		i--
		if *m.BinaryTrackingDataSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HighProfileReuseThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.HighProfileReuseThreshold))))
		i--
		dAtA[i] = 0x2d
	}
	if m.HighFidelity_16BitEncode != nil {
		i--
		if *m.HighFidelity_16BitEncode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UseHighProfile != nil {
		i--
		if *m.UseHighProfile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DomainHeight != nil {
		i = encodeVarintFlowPackager(dAtA, i, uint64(*m.DomainHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.DomainWidth != nil {
		i = encodeVarintFlowPackager(dAtA, i, uint64(*m.DomainWidth))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlowPackager(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlowPackager(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TrackingData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FrameFlags != nil {
		n += 1 + sovFlowPackager(uint64(*m.FrameFlags))
	}
	n += 1 + sovFlowPackager(uint64(m.DomainWidth))
	n += 1 + sovFlowPackager(uint64(m.DomainHeight))
	if m.BackgroundModel != nil {
		l = m.BackgroundModel.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	if m.MotionData != nil {
		l = m.MotionData.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	if m.FrameAspect != nil {
		n += 5
	}
	n += 1 + sovFlowPackager(uint64(m.GlobalFeatureCount))
	n += 5
	return n
}

func (m *TrackingData_MotionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovFlowPackager(uint64(m.NumElements))
	if len(m.VectorData) > 0 {
		n += 1 + sovFlowPackager(uint64(len(m.VectorData)*4)) + len(m.VectorData)*4
	}
	if len(m.TrackId) > 0 {
		l = 0
		for _, e := range m.TrackId {
			l += sovFlowPackager(uint64(e))
		}
		n += 1 + sovFlowPackager(uint64(l)) + l
	}
	if len(m.RowIndices) > 0 {
		l = 0
		for _, e := range m.RowIndices {
			l += sovFlowPackager(uint64(e))
		}
		n += 1 + sovFlowPackager(uint64(l)) + l
	}
	if len(m.ColStarts) > 0 {
		l = 0
		for _, e := range m.ColStarts {
			l += sovFlowPackager(uint64(e))
		}
		n += 1 + sovFlowPackager(uint64(l)) + l
	}
	if len(m.FeatureDescriptors) > 0 {
		for _, e := range m.FeatureDescriptors {
			l = e.Size()
			n += 1 + l + sovFlowPackager(uint64(l))
		}
	}
	if len(m.ActivelyDiscardedTrackedIds) > 0 {
		for _, e := range m.ActivelyDiscardedTrackedIds {
			n += 1 + sovFlowPackager(uint64(e))
		}
	}
	return n
}

func (m *TrackingDataChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovFlowPackager(uint64(l))
		}
	}
	if m.LastChunk != nil {
		n += 2
	}
	if m.FirstChunk != nil {
		n += 2
	}
	return n
}

func (m *TrackingDataChunk_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackingData != nil {
		l = m.TrackingData.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	n += 1 + sovFlowPackager(uint64(m.FrameIdx))
	n += 1 + sovFlowPackager(uint64(m.TimestampUsec))
	n += 1 + sovFlowPackager(uint64(m.PrevTimestampUsec))
	return n
}

func (m *BinaryTrackingData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	return n
}

func (m *MetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	if len(m.TrackOffsets) > 0 {
		for _, e := range m.TrackOffsets {
			l = e.Size()
			n += 1 + l + sovFlowPackager(uint64(l))
		}
	}
	return n
}

func (m *MetaData_TrackOffset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func (m *TrackingContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	n += 1 + l + sovFlowPackager(uint64(l))
	if m.Version != nil {
		n += 5
	}
	n += 5
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	return n
}

func (m *TrackingContainerFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	if len(m.TrackData) > 0 {
		for _, e := range m.TrackData {
			l = e.Size()
			n += 1 + l + sovFlowPackager(uint64(l))
		}
	}
	if m.TermData != nil {
		l = m.TermData.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	return n
}

func (m *TrackingContainerProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovFlowPackager(uint64(l))
	}
	if len(m.TrackData) > 0 {
		for _, e := range m.TrackData {
			l = e.Size()
			n += 1 + l + sovFlowPackager(uint64(l))
		}
	}
	return n
}

func (m *FlowPackagerOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainWidth != nil {
		n += 1 + sovFlowPackager(uint64(*m.DomainWidth))
	}
	if m.DomainHeight != nil {
		n += 1 + sovFlowPackager(uint64(*m.DomainHeight))
	}
	if m.UseHighProfile != nil {
		n += 2
	}
	if m.HighFidelity_16BitEncode != nil {
		n += 2
	}
	if m.HighProfileReuseThreshold != nil {
		n += 5
	}
	if m.BinaryTrackingDataSupport != nil {
		n += 2
	}
	return n
}

func sovFlowPackager(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlowPackager(x uint64) (n int) {
	return sovFlowPackager(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TrackingData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingData{`,
		`FrameFlags:` + valueToStringFlowPackager(this.FrameFlags) + `,`,
		`DomainWidth:` + fmt.Sprintf("%v", this.DomainWidth) + `,`,
		`DomainHeight:` + fmt.Sprintf("%v", this.DomainHeight) + `,`,
		`BackgroundModel:` + strings.Replace(fmt.Sprintf("%v", this.BackgroundModel), "Homography", "Homography", 1) + `,`,
		`MotionData:` + strings.Replace(fmt.Sprintf("%v", this.MotionData), "TrackingData_MotionData", "TrackingData_MotionData", 1) + `,`,
		`FrameAspect:` + valueToStringFlowPackager(this.FrameAspect) + `,`,
		`GlobalFeatureCount:` + fmt.Sprintf("%v", this.GlobalFeatureCount) + `,`,
		`AverageMotionMagnitude:` + fmt.Sprintf("%v", this.AverageMotionMagnitude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingData_MotionData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFeatureDescriptors := "[]*BinaryFeatureDescriptor{"
	for _, f := range this.FeatureDescriptors {
		repeatedStringForFeatureDescriptors += strings.Replace(fmt.Sprintf("%v", f), "BinaryFeatureDescriptor", "BinaryFeatureDescriptor", 1) + ","
	}
	repeatedStringForFeatureDescriptors += "}"
	s := strings.Join([]string{`&TrackingData_MotionData{`,
		`NumElements:` + fmt.Sprintf("%v", this.NumElements) + `,`,
		`VectorData:` + fmt.Sprintf("%v", this.VectorData) + `,`,
		`TrackId:` + fmt.Sprintf("%v", this.TrackId) + `,`,
		`RowIndices:` + fmt.Sprintf("%v", this.RowIndices) + `,`,
		`ColStarts:` + fmt.Sprintf("%v", this.ColStarts) + `,`,
		`FeatureDescriptors:` + repeatedStringForFeatureDescriptors + `,`,
		`ActivelyDiscardedTrackedIds:` + fmt.Sprintf("%v", this.ActivelyDiscardedTrackedIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingDataChunk) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItem := "[]*TrackingDataChunk_Item{"
	for _, f := range this.Item {
		repeatedStringForItem += strings.Replace(fmt.Sprintf("%v", f), "TrackingDataChunk_Item", "TrackingDataChunk_Item", 1) + ","
	}
	repeatedStringForItem += "}"
	s := strings.Join([]string{`&TrackingDataChunk{`,
		`Item:` + repeatedStringForItem + `,`,
		`LastChunk:` + valueToStringFlowPackager(this.LastChunk) + `,`,
		`FirstChunk:` + valueToStringFlowPackager(this.FirstChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingDataChunk_Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingDataChunk_Item{`,
		`TrackingData:` + strings.Replace(this.TrackingData.String(), "TrackingData", "TrackingData", 1) + `,`,
		`FrameIdx:` + fmt.Sprintf("%v", this.FrameIdx) + `,`,
		`TimestampUsec:` + fmt.Sprintf("%v", this.TimestampUsec) + `,`,
		`PrevTimestampUsec:` + fmt.Sprintf("%v", this.PrevTimestampUsec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinaryTrackingData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinaryTrackingData{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetaData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrackOffsets := "[]*MetaData_TrackOffset{"
	for _, f := range this.TrackOffsets {
		repeatedStringForTrackOffsets += strings.Replace(fmt.Sprintf("%v", f), "MetaData_TrackOffset", "MetaData_TrackOffset", 1) + ","
	}
	repeatedStringForTrackOffsets += "}"
	s := strings.Join([]string{`&MetaData{`,
		`NumFrames:` + fmt.Sprintf("%v", this.NumFrames) + `,`,
		`TrackOffsets:` + repeatedStringForTrackOffsets + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetaData_TrackOffset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetaData_TrackOffset{`,
		`Msec:` + fmt.Sprintf("%v", this.Msec) + `,`,
		`StreamOffset:` + fmt.Sprintf("%v", this.StreamOffset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingContainer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingContainer{`,
		`Header:` + fmt.Sprintf("%v", this.Header) + `,`,
		`Version:` + valueToStringFlowPackager(this.Version) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingContainerFormat) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrackData := "[]*TrackingContainer{"
	for _, f := range this.TrackData {
		repeatedStringForTrackData += strings.Replace(f.String(), "TrackingContainer", "TrackingContainer", 1) + ","
	}
	repeatedStringForTrackData += "}"
	s := strings.Join([]string{`&TrackingContainerFormat{`,
		`MetaData:` + strings.Replace(this.MetaData.String(), "TrackingContainer", "TrackingContainer", 1) + `,`,
		`TrackData:` + repeatedStringForTrackData + `,`,
		`TermData:` + strings.Replace(this.TermData.String(), "TrackingContainer", "TrackingContainer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingContainerProto) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrackData := "[]*BinaryTrackingData{"
	for _, f := range this.TrackData {
		repeatedStringForTrackData += strings.Replace(f.String(), "BinaryTrackingData", "BinaryTrackingData", 1) + ","
	}
	repeatedStringForTrackData += "}"
	s := strings.Join([]string{`&TrackingContainerProto{`,
		`MetaData:` + strings.Replace(this.MetaData.String(), "MetaData", "MetaData", 1) + `,`,
		`TrackData:` + repeatedStringForTrackData + `,`,
		`}`,
	}, "")
	return s
}
func (this *FlowPackagerOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FlowPackagerOptions{`,
		`DomainWidth:` + valueToStringFlowPackager(this.DomainWidth) + `,`,
		`DomainHeight:` + valueToStringFlowPackager(this.DomainHeight) + `,`,
		`UseHighProfile:` + valueToStringFlowPackager(this.UseHighProfile) + `,`,
		`HighFidelity_16BitEncode:` + valueToStringFlowPackager(this.HighFidelity_16BitEncode) + `,`,
		`HighProfileReuseThreshold:` + valueToStringFlowPackager(this.HighProfileReuseThreshold) + `,`,
		`BinaryTrackingDataSupport:` + valueToStringFlowPackager(this.BinaryTrackingDataSupport) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringFlowPackager(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TrackingData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameFlags", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FrameFlags = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainWidth", wireType)
			}
			m.DomainWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainHeight", wireType)
			}
			m.DomainHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundModel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackgroundModel == nil {
				m.BackgroundModel = &Homography{}
			}
			if err := m.BackgroundModel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MotionData == nil {
				m.MotionData = &TrackingData_MotionData{}
			}
			if err := m.MotionData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameAspect", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FrameAspect = &v2
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalFeatureCount", wireType)
			}
			m.GlobalFeatureCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalFeatureCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageMotionMagnitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AverageMotionMagnitude = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingData_MotionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MotionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MotionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumElements", wireType)
			}
			m.NumElements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumElements |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.VectorData = append(m.VectorData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowPackager
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowPackager
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.VectorData) == 0 {
					m.VectorData = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.VectorData = append(m.VectorData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorData", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TrackId = append(m.TrackId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowPackager
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowPackager
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TrackId) == 0 {
					m.TrackId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowPackager
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TrackId = append(m.TrackId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RowIndices = append(m.RowIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowPackager
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowPackager
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RowIndices) == 0 {
					m.RowIndices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowPackager
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RowIndices = append(m.RowIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIndices", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColStarts = append(m.ColStarts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowPackager
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowPackager
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColStarts) == 0 {
					m.ColStarts = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowPackager
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColStarts = append(m.ColStarts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColStarts", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureDescriptors = append(m.FeatureDescriptors, &BinaryFeatureDescriptor{})
			if err := m.FeatureDescriptors[len(m.FeatureDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivelyDiscardedTrackedIds = append(m.ActivelyDiscardedTrackedIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowPackager
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowPackager
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowPackager
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivelyDiscardedTrackedIds) == 0 {
					m.ActivelyDiscardedTrackedIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowPackager
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivelyDiscardedTrackedIds = append(m.ActivelyDiscardedTrackedIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivelyDiscardedTrackedIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingDataChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingDataChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingDataChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &TrackingDataChunk_Item{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChunk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LastChunk = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstChunk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FirstChunk = &b
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingDataChunk_Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrackingData == nil {
				m.TrackingData = &TrackingData{}
			}
			if err := m.TrackingData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameIdx", wireType)
			}
			m.FrameIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUsec", wireType)
			}
			m.TimestampUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampUsec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevTimestampUsec", wireType)
			}
			m.PrevTimestampUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevTimestampUsec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryTrackingData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryTrackingData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryTrackingData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFrames", wireType)
			}
			m.NumFrames = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.NumFrames = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackOffsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackOffsets = append(m.TrackOffsets, &MetaData_TrackOffset{})
			if err := m.TrackOffsets[len(m.TrackOffsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaData_TrackOffset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackOffset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackOffset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msec", wireType)
			}
			m.Msec = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Msec = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamOffset", wireType)
			}
			m.StreamOffset = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamOffset = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Version = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingContainerFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingContainerFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingContainerFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaData == nil {
				m.MetaData = &TrackingContainer{}
			}
			if err := m.MetaData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackData = append(m.TrackData, &TrackingContainer{})
			if err := m.TrackData[len(m.TrackData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TermData == nil {
				m.TermData = &TrackingContainer{}
			}
			if err := m.TermData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingContainerProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingContainerProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingContainerProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaData == nil {
				m.MetaData = &MetaData{}
			}
			if err := m.MetaData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowPackager
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackData = append(m.TrackData, &BinaryTrackingData{})
			if err := m.TrackData[len(m.TrackData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowPackagerOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowPackagerOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowPackagerOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainWidth = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DomainHeight = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHighProfile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseHighProfile = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighFidelity_16BitEncode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HighFidelity_16BitEncode = &b
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighProfileReuseThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.HighProfileReuseThreshold = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryTrackingDataSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BinaryTrackingDataSupport = &b
		default:
			iNdEx = preIndex
			skippy, err := skipFlowPackager(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowPackager
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlowPackager(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlowPackager
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowPackager
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlowPackager
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlowPackager
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlowPackager
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlowPackager        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlowPackager          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlowPackager = fmt.Errorf("proto: unexpected end of group")
)
