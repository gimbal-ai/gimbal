// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/motion_estimation.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	sort "sort"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MotionEstimationOptions_LinearSimilarityEstimation int32

const (
	ESTIMATION_LS_NONE      MotionEstimationOptions_LinearSimilarityEstimation = 0
	ESTIMATION_LS_L2        MotionEstimationOptions_LinearSimilarityEstimation = 1
	ESTIMATION_LS_IRLS      MotionEstimationOptions_LinearSimilarityEstimation = 4
	ESTIMATION_LS_L2_RANSAC MotionEstimationOptions_LinearSimilarityEstimation = 2
	ESTIMATION_LS_L1        MotionEstimationOptions_LinearSimilarityEstimation = 3
)

var MotionEstimationOptions_LinearSimilarityEstimation_name = map[int32]string{
	0: "ESTIMATION_LS_NONE",
	1: "ESTIMATION_LS_L2",
	4: "ESTIMATION_LS_IRLS",
	2: "ESTIMATION_LS_L2_RANSAC",
	3: "ESTIMATION_LS_L1",
}

var MotionEstimationOptions_LinearSimilarityEstimation_value = map[string]int32{
	"ESTIMATION_LS_NONE":      0,
	"ESTIMATION_LS_L2":        1,
	"ESTIMATION_LS_IRLS":      4,
	"ESTIMATION_LS_L2_RANSAC": 2,
	"ESTIMATION_LS_L1":        3,
}

func (x MotionEstimationOptions_LinearSimilarityEstimation) Enum() *MotionEstimationOptions_LinearSimilarityEstimation {
	p := new(MotionEstimationOptions_LinearSimilarityEstimation)
	*p = x
	return p
}

func (x MotionEstimationOptions_LinearSimilarityEstimation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_LinearSimilarityEstimation_name, int32(x))
}

func (x *MotionEstimationOptions_LinearSimilarityEstimation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_LinearSimilarityEstimation_value, data, "MotionEstimationOptions_LinearSimilarityEstimation")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_LinearSimilarityEstimation(value)
	return nil
}

func (MotionEstimationOptions_LinearSimilarityEstimation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 0}
}

type MotionEstimationOptions_AffineEstimation int32

const (
	ESTIMATION_AFFINE_NONE MotionEstimationOptions_AffineEstimation = 0
	ESTIMATION_AFFINE_L2   MotionEstimationOptions_AffineEstimation = 1
	ESTIMATION_AFFINE_IRLS MotionEstimationOptions_AffineEstimation = 2
)

var MotionEstimationOptions_AffineEstimation_name = map[int32]string{
	0: "ESTIMATION_AFFINE_NONE",
	1: "ESTIMATION_AFFINE_L2",
	2: "ESTIMATION_AFFINE_IRLS",
}

var MotionEstimationOptions_AffineEstimation_value = map[string]int32{
	"ESTIMATION_AFFINE_NONE": 0,
	"ESTIMATION_AFFINE_L2":   1,
	"ESTIMATION_AFFINE_IRLS": 2,
}

func (x MotionEstimationOptions_AffineEstimation) Enum() *MotionEstimationOptions_AffineEstimation {
	p := new(MotionEstimationOptions_AffineEstimation)
	*p = x
	return p
}

func (x MotionEstimationOptions_AffineEstimation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_AffineEstimation_name, int32(x))
}

func (x *MotionEstimationOptions_AffineEstimation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_AffineEstimation_value, data, "MotionEstimationOptions_AffineEstimation")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_AffineEstimation(value)
	return nil
}

func (MotionEstimationOptions_AffineEstimation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 1}
}

type MotionEstimationOptions_HomographyEstimation int32

const (
	ESTIMATION_HOMOG_NONE MotionEstimationOptions_HomographyEstimation = 0
	ESTIMATION_HOMOG_L2   MotionEstimationOptions_HomographyEstimation = 1
	ESTIMATION_HOMOG_IRLS MotionEstimationOptions_HomographyEstimation = 2
)

var MotionEstimationOptions_HomographyEstimation_name = map[int32]string{
	0: "ESTIMATION_HOMOG_NONE",
	1: "ESTIMATION_HOMOG_L2",
	2: "ESTIMATION_HOMOG_IRLS",
}

var MotionEstimationOptions_HomographyEstimation_value = map[string]int32{
	"ESTIMATION_HOMOG_NONE": 0,
	"ESTIMATION_HOMOG_L2":   1,
	"ESTIMATION_HOMOG_IRLS": 2,
}

func (x MotionEstimationOptions_HomographyEstimation) Enum() *MotionEstimationOptions_HomographyEstimation {
	p := new(MotionEstimationOptions_HomographyEstimation)
	*p = x
	return p
}

func (x MotionEstimationOptions_HomographyEstimation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_HomographyEstimation_name, int32(x))
}

func (x *MotionEstimationOptions_HomographyEstimation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_HomographyEstimation_value, data, "MotionEstimationOptions_HomographyEstimation")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_HomographyEstimation(value)
	return nil
}

func (MotionEstimationOptions_HomographyEstimation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 2}
}

type MotionEstimationOptions_MixtureHomographyEstimation int32

const (
	ESTIMATION_HOMOG_MIX_NONE MotionEstimationOptions_MixtureHomographyEstimation = 0
	ESTIMATION_HOMOG_MIX_L2   MotionEstimationOptions_MixtureHomographyEstimation = 1
	ESTIMATION_HOMOG_MIX_IRLS MotionEstimationOptions_MixtureHomographyEstimation = 2
)

var MotionEstimationOptions_MixtureHomographyEstimation_name = map[int32]string{
	0: "ESTIMATION_HOMOG_MIX_NONE",
	1: "ESTIMATION_HOMOG_MIX_L2",
	2: "ESTIMATION_HOMOG_MIX_IRLS",
}

var MotionEstimationOptions_MixtureHomographyEstimation_value = map[string]int32{
	"ESTIMATION_HOMOG_MIX_NONE": 0,
	"ESTIMATION_HOMOG_MIX_L2":   1,
	"ESTIMATION_HOMOG_MIX_IRLS": 2,
}

func (x MotionEstimationOptions_MixtureHomographyEstimation) Enum() *MotionEstimationOptions_MixtureHomographyEstimation {
	p := new(MotionEstimationOptions_MixtureHomographyEstimation)
	*p = x
	return p
}

func (x MotionEstimationOptions_MixtureHomographyEstimation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_MixtureHomographyEstimation_name, int32(x))
}

func (x *MotionEstimationOptions_MixtureHomographyEstimation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_MixtureHomographyEstimation_value, data, "MotionEstimationOptions_MixtureHomographyEstimation")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_MixtureHomographyEstimation(value)
	return nil
}

func (MotionEstimationOptions_MixtureHomographyEstimation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 3}
}

type MotionEstimationOptions_EstimationPolicy int32

const (
	UNKNOWN                    MotionEstimationOptions_EstimationPolicy = 0
	INDEPENDENT_PARALLEL       MotionEstimationOptions_EstimationPolicy = 1
	TEMPORAL_IRLS_MASK         MotionEstimationOptions_EstimationPolicy = 2
	TEMPORAL_LONG_FEATURE_BIAS MotionEstimationOptions_EstimationPolicy = 4
	JOINTLY_FROM_TRACKS        MotionEstimationOptions_EstimationPolicy = 3
)

var MotionEstimationOptions_EstimationPolicy_name = map[int32]string{
	0: "UNKNOWN",
	1: "INDEPENDENT_PARALLEL",
	2: "TEMPORAL_IRLS_MASK",
	4: "TEMPORAL_LONG_FEATURE_BIAS",
	3: "JOINTLY_FROM_TRACKS",
}

var MotionEstimationOptions_EstimationPolicy_value = map[string]int32{
	"UNKNOWN":                    0,
	"INDEPENDENT_PARALLEL":       1,
	"TEMPORAL_IRLS_MASK":         2,
	"TEMPORAL_LONG_FEATURE_BIAS": 4,
	"JOINTLY_FROM_TRACKS":        3,
}

func (x MotionEstimationOptions_EstimationPolicy) Enum() *MotionEstimationOptions_EstimationPolicy {
	p := new(MotionEstimationOptions_EstimationPolicy)
	*p = x
	return p
}

func (x MotionEstimationOptions_EstimationPolicy) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_EstimationPolicy_name, int32(x))
}

func (x *MotionEstimationOptions_EstimationPolicy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_EstimationPolicy_value, data, "MotionEstimationOptions_EstimationPolicy")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_EstimationPolicy(value)
	return nil
}

func (MotionEstimationOptions_EstimationPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 4}
}

type MotionEstimationOptions_MixtureModelMode int32

const (
	FULL_MIXTURE          MotionEstimationOptions_MixtureModelMode = 0
	TRANSLATION_MIXTURE   MotionEstimationOptions_MixtureModelMode = 1
	SKEW_ROTATION_MIXTURE MotionEstimationOptions_MixtureModelMode = 2
)

var MotionEstimationOptions_MixtureModelMode_name = map[int32]string{
	0: "FULL_MIXTURE",
	1: "TRANSLATION_MIXTURE",
	2: "SKEW_ROTATION_MIXTURE",
}

var MotionEstimationOptions_MixtureModelMode_value = map[string]int32{
	"FULL_MIXTURE":          0,
	"TRANSLATION_MIXTURE":   1,
	"SKEW_ROTATION_MIXTURE": 2,
}

func (x MotionEstimationOptions_MixtureModelMode) Enum() *MotionEstimationOptions_MixtureModelMode {
	p := new(MotionEstimationOptions_MixtureModelMode)
	*p = x
	return p
}

func (x MotionEstimationOptions_MixtureModelMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_MixtureModelMode_name, int32(x))
}

func (x *MotionEstimationOptions_MixtureModelMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_MixtureModelMode_value, data, "MotionEstimationOptions_MixtureModelMode")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_MixtureModelMode(value)
	return nil
}

func (MotionEstimationOptions_MixtureModelMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 5}
}

type MotionEstimationOptions_IRLSWeightFilter int32

const (
	IRLS_FILTER_NONE            MotionEstimationOptions_IRLSWeightFilter = 0
	IRLS_FILTER_TEXTURE         MotionEstimationOptions_IRLSWeightFilter = 1
	IRLS_FILTER_CORNER_RESPONSE MotionEstimationOptions_IRLSWeightFilter = 2
)

var MotionEstimationOptions_IRLSWeightFilter_name = map[int32]string{
	0: "IRLS_FILTER_NONE",
	1: "IRLS_FILTER_TEXTURE",
	2: "IRLS_FILTER_CORNER_RESPONSE",
}

var MotionEstimationOptions_IRLSWeightFilter_value = map[string]int32{
	"IRLS_FILTER_NONE":            0,
	"IRLS_FILTER_TEXTURE":         1,
	"IRLS_FILTER_CORNER_RESPONSE": 2,
}

func (x MotionEstimationOptions_IRLSWeightFilter) Enum() *MotionEstimationOptions_IRLSWeightFilter {
	p := new(MotionEstimationOptions_IRLSWeightFilter)
	*p = x
	return p
}

func (x MotionEstimationOptions_IRLSWeightFilter) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_IRLSWeightFilter_name, int32(x))
}

func (x *MotionEstimationOptions_IRLSWeightFilter) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_IRLSWeightFilter_value, data, "MotionEstimationOptions_IRLSWeightFilter")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_IRLSWeightFilter(value)
	return nil
}

func (MotionEstimationOptions_IRLSWeightFilter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 6}
}

type MotionEstimationOptions_HomographyIrlsWeightInitialization int32

const (
	IRLS_WEIGHT_UNKNOWN            MotionEstimationOptions_HomographyIrlsWeightInitialization = 0
	IRLS_WEIGHT_CONSTANT_ONE       MotionEstimationOptions_HomographyIrlsWeightInitialization = 1
	IRLS_WEIGHT_CENTER_GAUSSIAN    MotionEstimationOptions_HomographyIrlsWeightInitialization = 2
	IRLS_WEIGHT_PERIMETER_GAUSSIAN MotionEstimationOptions_HomographyIrlsWeightInitialization = 3
)

var MotionEstimationOptions_HomographyIrlsWeightInitialization_name = map[int32]string{
	0: "IRLS_WEIGHT_UNKNOWN",
	1: "IRLS_WEIGHT_CONSTANT_ONE",
	2: "IRLS_WEIGHT_CENTER_GAUSSIAN",
	3: "IRLS_WEIGHT_PERIMETER_GAUSSIAN",
}

var MotionEstimationOptions_HomographyIrlsWeightInitialization_value = map[string]int32{
	"IRLS_WEIGHT_UNKNOWN":            0,
	"IRLS_WEIGHT_CONSTANT_ONE":       1,
	"IRLS_WEIGHT_CENTER_GAUSSIAN":    2,
	"IRLS_WEIGHT_PERIMETER_GAUSSIAN": 3,
}

func (x MotionEstimationOptions_HomographyIrlsWeightInitialization) Enum() *MotionEstimationOptions_HomographyIrlsWeightInitialization {
	p := new(MotionEstimationOptions_HomographyIrlsWeightInitialization)
	*p = x
	return p
}

func (x MotionEstimationOptions_HomographyIrlsWeightInitialization) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionEstimationOptions_HomographyIrlsWeightInitialization_name, int32(x))
}

func (x *MotionEstimationOptions_HomographyIrlsWeightInitialization) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionEstimationOptions_HomographyIrlsWeightInitialization_value, data, "MotionEstimationOptions_HomographyIrlsWeightInitialization")
	if err != nil {
		return err
	}
	*x = MotionEstimationOptions_HomographyIrlsWeightInitialization(value)
	return nil
}

func (MotionEstimationOptions_HomographyIrlsWeightInitialization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 7}
}

type MotionEstimationOptions struct {
	EstimateTranslationIrls              *bool                                                       `protobuf:"varint,1,opt,name=estimate_translation_irls,json=estimateTranslationIrls,def=1" json:"estimate_translation_irls,omitempty"`
	LinearSimilarityEstimation           *MotionEstimationOptions_LinearSimilarityEstimation         `protobuf:"varint,3,opt,name=linear_similarity_estimation,json=linearSimilarityEstimation,enum=mediapipe.MotionEstimationOptions_LinearSimilarityEstimation,def=4" json:"linear_similarity_estimation,omitempty"`
	AffineEstimation                     *MotionEstimationOptions_AffineEstimation                   `protobuf:"varint,30,opt,name=affine_estimation,json=affineEstimation,enum=mediapipe.MotionEstimationOptions_AffineEstimation,def=0" json:"affine_estimation,omitempty"`
	HomographyEstimation                 *MotionEstimationOptions_HomographyEstimation               `protobuf:"varint,5,opt,name=homography_estimation,json=homographyEstimation,enum=mediapipe.MotionEstimationOptions_HomographyEstimation,def=2" json:"homography_estimation,omitempty"`
	HomographyExactDenominatorScaling    *bool                                                       `protobuf:"varint,53,opt,name=homography_exact_denominator_scaling,json=homographyExactDenominatorScaling,def=0" json:"homography_exact_denominator_scaling,omitempty"`
	UseExactHomographyEstimation         *bool                                                       `protobuf:"varint,54,opt,name=use_exact_homography_estimation,json=useExactHomographyEstimation,def=1" json:"use_exact_homography_estimation,omitempty"`
	UseHighestAccuracyForNormalEquations *bool                                                       `protobuf:"varint,55,opt,name=use_highest_accuracy_for_normal_equations,json=useHighestAccuracyForNormalEquations,def=1" json:"use_highest_accuracy_for_normal_equations,omitempty"`
	HomographyPerspectiveRegularizer     *float32                                                    `protobuf:"fixed32,61,opt,name=homography_perspective_regularizer,json=homographyPerspectiveRegularizer,def=0" json:"homography_perspective_regularizer,omitempty"`
	MixHomographyEstimation              *MotionEstimationOptions_MixtureHomographyEstimation        `protobuf:"varint,12,opt,name=mix_homography_estimation,json=mixHomographyEstimation,enum=mediapipe.MotionEstimationOptions_MixtureHomographyEstimation,def=0" json:"mix_homography_estimation,omitempty"`
	NumMixtures                          *int32                                                      `protobuf:"varint,13,opt,name=num_mixtures,json=numMixtures,def=10" json:"num_mixtures,omitempty"`
	MixtureRowSigma                      *float32                                                    `protobuf:"fixed32,14,opt,name=mixture_row_sigma,json=mixtureRowSigma,def=0.1" json:"mixture_row_sigma,omitempty"`
	MixtureRegularizer                   *float32                                                    `protobuf:"fixed32,15,opt,name=mixture_regularizer,json=mixtureRegularizer,def=0.0001" json:"mixture_regularizer,omitempty"`
	MixtureRegularizerLevels             *float32                                                    `protobuf:"fixed32,42,opt,name=mixture_regularizer_levels,json=mixtureRegularizerLevels,def=3" json:"mixture_regularizer_levels,omitempty"`
	MixtureRegularizerBase               *float32                                                    `protobuf:"fixed32,43,opt,name=mixture_regularizer_base,json=mixtureRegularizerBase,def=2.2" json:"mixture_regularizer_base,omitempty"`
	MixtureRsAnalysisLevel               *int32                                                      `protobuf:"varint,44,opt,name=mixture_rs_analysis_level,json=mixtureRsAnalysisLevel,def=2" json:"mixture_rs_analysis_level,omitempty"`
	IrlsRounds                           *int32                                                      `protobuf:"varint,17,opt,name=irls_rounds,json=irlsRounds,def=10" json:"irls_rounds,omitempty"`
	IrlsPriorScale                       *float32                                                    `protobuf:"fixed32,50,opt,name=irls_prior_scale,json=irlsPriorScale,def=0.2" json:"irls_prior_scale,omitempty"`
	IrlsMotionMagnitudeFraction          *float32                                                    `protobuf:"fixed32,31,opt,name=irls_motion_magnitude_fraction,json=irlsMotionMagnitudeFraction,def=0.08" json:"irls_motion_magnitude_fraction,omitempty"`
	IrlsMixtureFractionScale             *float32                                                    `protobuf:"fixed32,68,opt,name=irls_mixture_fraction_scale,json=irlsMixtureFractionScale,def=1.5" json:"irls_mixture_fraction_scale,omitempty"`
	IrlsWeightsPreinitialized            *bool                                                       `protobuf:"varint,39,opt,name=irls_weights_preinitialized,json=irlsWeightsPreinitialized,def=0" json:"irls_weights_preinitialized,omitempty"`
	FilterInitializedIrlsWeights         *bool                                                       `protobuf:"varint,67,opt,name=filter_initialized_irls_weights,json=filterInitializedIrlsWeights,def=0" json:"filter_initialized_irls_weights,omitempty"`
	IrlsInitialization                   *MotionEstimationOptions_IrlsOutlierInitialization          `protobuf:"bytes,56,opt,name=irls_initialization,json=irlsInitialization" json:"irls_initialization,omitempty"`
	FeatureDensityNormalization          *bool                                                       `protobuf:"varint,62,opt,name=feature_density_normalization,json=featureDensityNormalization,def=0" json:"feature_density_normalization,omitempty"`
	FeatureMaskSize                      *int32                                                      `protobuf:"varint,63,opt,name=feature_mask_size,json=featureMaskSize,def=10" json:"feature_mask_size,omitempty"`
	LongFeatureInitialization            *MotionEstimationOptions_LongFeatureInitialization          `protobuf:"bytes,66,opt,name=long_feature_initialization,json=longFeatureInitialization" json:"long_feature_initialization,omitempty"`
	IrlsMaskOptions                      *MotionEstimationOptions_IrlsMaskOptions                    `protobuf:"bytes,57,opt,name=irls_mask_options,json=irlsMaskOptions" json:"irls_mask_options,omitempty"`
	JointTrackEstimation                 *MotionEstimationOptions_JointTrackEstimationOptions        `protobuf:"bytes,59,opt,name=joint_track_estimation,json=jointTrackEstimation" json:"joint_track_estimation,omitempty"`
	LongFeatureBiasOptions               *MotionEstimationOptions_LongFeatureBiasOptions             `protobuf:"bytes,64,opt,name=long_feature_bias_options,json=longFeatureBiasOptions" json:"long_feature_bias_options,omitempty"`
	EstimationPolicy                     *MotionEstimationOptions_EstimationPolicy                   `protobuf:"varint,58,opt,name=estimation_policy,json=estimationPolicy,enum=mediapipe.MotionEstimationOptions_EstimationPolicy,def=1" json:"estimation_policy,omitempty"`
	CoverageGridSize                     *int32                                                      `protobuf:"varint,51,opt,name=coverage_grid_size,json=coverageGridSize,def=10" json:"coverage_grid_size,omitempty"`
	MixtureModelMode                     *MotionEstimationOptions_MixtureModelMode                   `protobuf:"varint,23,opt,name=mixture_model_mode,json=mixtureModelMode,enum=mediapipe.MotionEstimationOptions_MixtureModelMode,def=2" json:"mixture_model_mode,omitempty"`
	UseOnlyLinSimInliersForHomography    *bool                                                       `protobuf:"varint,6,opt,name=use_only_lin_sim_inliers_for_homography,json=useOnlyLinSimInliersForHomography,def=1" json:"use_only_lin_sim_inliers_for_homography,omitempty"`
	LinSimInlierThreshold                *float32                                                    `protobuf:"fixed32,20,opt,name=lin_sim_inlier_threshold,json=linSimInlierThreshold,def=0.003" json:"lin_sim_inlier_threshold,omitempty"`
	StableTranslationBounds              *MotionEstimationOptions_TranslationBounds                  `protobuf:"bytes,32,opt,name=stable_translation_bounds,json=stableTranslationBounds" json:"stable_translation_bounds,omitempty"`
	StableSimilarityBounds               *MotionEstimationOptions_SimilarityBounds                   `protobuf:"bytes,33,opt,name=stable_similarity_bounds,json=stableSimilarityBounds" json:"stable_similarity_bounds,omitempty"`
	StableHomographyBounds               *MotionEstimationOptions_HomographyBounds                   `protobuf:"bytes,11,opt,name=stable_homography_bounds,json=stableHomographyBounds" json:"stable_homography_bounds,omitempty"`
	StableMixtureHomographyBounds        *MotionEstimationOptions_MixtureHomographyBounds            `protobuf:"bytes,34,opt,name=stable_mixture_homography_bounds,json=stableMixtureHomographyBounds" json:"stable_mixture_homography_bounds,omitempty"`
	StrictCoverageScale                  *float32                                                    `protobuf:"fixed32,41,opt,name=strict_coverage_scale,json=strictCoverageScale,def=1.333" json:"strict_coverage_scale,omitempty"`
	LabelEmptyFramesAsValid              *bool                                                       `protobuf:"varint,22,opt,name=label_empty_frames_as_valid,json=labelEmptyFramesAsValid,def=1" json:"label_empty_frames_as_valid,omitempty"`
	FeatureGridSize                      *float32                                                    `protobuf:"fixed32,24,opt,name=feature_grid_size,json=featureGridSize,def=0.05" json:"feature_grid_size,omitempty"`
	SpatialSigma                         *float32                                                    `protobuf:"fixed32,25,opt,name=spatial_sigma,json=spatialSigma,def=0.01" json:"spatial_sigma,omitempty"`
	TemporalIrlsDiameter                 *int32                                                      `protobuf:"varint,26,opt,name=temporal_irls_diameter,json=temporalIrlsDiameter,def=20" json:"temporal_irls_diameter,omitempty"`
	TemporalSigma                        *float32                                                    `protobuf:"fixed32,27,opt,name=temporal_sigma,json=temporalSigma,def=5" json:"temporal_sigma,omitempty"`
	FeatureSigma                         *float32                                                    `protobuf:"fixed32,28,opt,name=feature_sigma,json=featureSigma,def=30" json:"feature_sigma,omitempty"`
	Filter_5Taps                         *bool                                                       `protobuf:"varint,29,opt,name=filter_5_taps,json=filter5Taps,def=0" json:"filter_5_taps,omitempty"`
	FrameConfidenceWeighting             *bool                                                       `protobuf:"varint,48,opt,name=frame_confidence_weighting,json=frameConfidenceWeighting,def=1" json:"frame_confidence_weighting,omitempty"`
	ResetConfidenceThreshold             *float32                                                    `protobuf:"fixed32,49,opt,name=reset_confidence_threshold,json=resetConfidenceThreshold,def=0.4" json:"reset_confidence_threshold,omitempty"`
	IrlsWeightFilter                     *MotionEstimationOptions_IRLSWeightFilter                   `protobuf:"varint,35,opt,name=irls_weight_filter,json=irlsWeightFilter,enum=mediapipe.MotionEstimationOptions_IRLSWeightFilter,def=0" json:"irls_weight_filter,omitempty"`
	OverlayDetection                     *bool                                                       `protobuf:"varint,36,opt,name=overlay_detection,json=overlayDetection,def=0" json:"overlay_detection,omitempty"`
	OverlayAnalysisChunkSize             *int32                                                      `protobuf:"varint,37,opt,name=overlay_analysis_chunk_size,json=overlayAnalysisChunkSize,def=8" json:"overlay_analysis_chunk_size,omitempty"`
	OverlayDetectionOptions              *MotionEstimationOptions_OverlayDetectionOptions            `protobuf:"bytes,38,opt,name=overlay_detection_options,json=overlayDetectionOptions" json:"overlay_detection_options,omitempty"`
	ShotBoundaryOptions                  *MotionEstimationOptions_ShotBoundaryOptions                `protobuf:"bytes,60,opt,name=shot_boundary_options,json=shotBoundaryOptions" json:"shot_boundary_options,omitempty"`
	OutputRefinedIrlsWeights             *bool                                                       `protobuf:"varint,40,opt,name=output_refined_irls_weights,json=outputRefinedIrlsWeights,def=1" json:"output_refined_irls_weights,omitempty"`
	HomographyIrlsWeightInitialization   *MotionEstimationOptions_HomographyIrlsWeightInitialization `protobuf:"varint,45,opt,name=homography_irls_weight_initialization,json=homographyIrlsWeightInitialization,enum=mediapipe.MotionEstimationOptions_HomographyIrlsWeightInitialization,def=3" json:"homography_irls_weight_initialization,omitempty"`
	IrlsUseL0Norm                        *bool                                                       `protobuf:"varint,46,opt,name=irls_use_l0_norm,json=irlsUseL0Norm,def=1" json:"irls_use_l0_norm,omitempty"`
	DomainLimitedIrlsScaling             *bool                                                       `protobuf:"varint,65,opt,name=domain_limited_irls_scaling,json=domainLimitedIrlsScaling,def=0" json:"domain_limited_irls_scaling,omitempty"`
	DeactivateStableMotionEstimation     *bool                                                       `protobuf:"varint,47,opt,name=deactivate_stable_motion_estimation,json=deactivateStableMotionEstimation,def=0" json:"deactivate_stable_motion_estimation,omitempty"`
	ProjectValidMotionsDown              *bool                                                       `protobuf:"varint,52,opt,name=project_valid_motions_down,json=projectValidMotionsDown,def=0" json:"project_valid_motions_down,omitempty"`
	EstimateSimilarity                   bool                                                        `protobuf:"varint,2,opt,name=estimate_similarity,json=estimateSimilarity" json:"estimate_similarity"` // Deprecated: Do not use.
	proto.XXX_InternalExtensions         `json:"-"`
}

func (m *MotionEstimationOptions) Reset()      { *m = MotionEstimationOptions{} }
func (*MotionEstimationOptions) ProtoMessage() {}
func (*MotionEstimationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0}
}

var extRange_MotionEstimationOptions = []proto.ExtensionRange{
	{Start: 7, End: 7},
	{Start: 8, End: 8},
	{Start: 16, End: 16},
}

func (*MotionEstimationOptions) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_MotionEstimationOptions
}

func (m *MotionEstimationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions.Merge(m, src)
}
func (m *MotionEstimationOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_EstimateTranslationIrls bool = true
const Default_MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions_LinearSimilarityEstimation = ESTIMATION_LS_IRLS
const Default_MotionEstimationOptions_AffineEstimation MotionEstimationOptions_AffineEstimation = ESTIMATION_AFFINE_NONE
const Default_MotionEstimationOptions_HomographyEstimation MotionEstimationOptions_HomographyEstimation = ESTIMATION_HOMOG_IRLS
const Default_MotionEstimationOptions_HomographyExactDenominatorScaling bool = false
const Default_MotionEstimationOptions_UseExactHomographyEstimation bool = true
const Default_MotionEstimationOptions_UseHighestAccuracyForNormalEquations bool = true
const Default_MotionEstimationOptions_HomographyPerspectiveRegularizer float32 = 0
const Default_MotionEstimationOptions_MixHomographyEstimation MotionEstimationOptions_MixtureHomographyEstimation = ESTIMATION_HOMOG_MIX_NONE
const Default_MotionEstimationOptions_NumMixtures int32 = 10
const Default_MotionEstimationOptions_MixtureRowSigma float32 = 0.1
const Default_MotionEstimationOptions_MixtureRegularizer float32 = 0.0001
const Default_MotionEstimationOptions_MixtureRegularizerLevels float32 = 3
const Default_MotionEstimationOptions_MixtureRegularizerBase float32 = 2.2
const Default_MotionEstimationOptions_MixtureRsAnalysisLevel int32 = 2
const Default_MotionEstimationOptions_IrlsRounds int32 = 10
const Default_MotionEstimationOptions_IrlsPriorScale float32 = 0.2
const Default_MotionEstimationOptions_IrlsMotionMagnitudeFraction float32 = 0.08
const Default_MotionEstimationOptions_IrlsMixtureFractionScale float32 = 1.5
const Default_MotionEstimationOptions_IrlsWeightsPreinitialized bool = false
const Default_MotionEstimationOptions_FilterInitializedIrlsWeights bool = false
const Default_MotionEstimationOptions_FeatureDensityNormalization bool = false
const Default_MotionEstimationOptions_FeatureMaskSize int32 = 10
const Default_MotionEstimationOptions_EstimationPolicy MotionEstimationOptions_EstimationPolicy = INDEPENDENT_PARALLEL
const Default_MotionEstimationOptions_CoverageGridSize int32 = 10
const Default_MotionEstimationOptions_MixtureModelMode MotionEstimationOptions_MixtureModelMode = SKEW_ROTATION_MIXTURE
const Default_MotionEstimationOptions_UseOnlyLinSimInliersForHomography bool = true
const Default_MotionEstimationOptions_LinSimInlierThreshold float32 = 0.003
const Default_MotionEstimationOptions_StrictCoverageScale float32 = 1.333
const Default_MotionEstimationOptions_LabelEmptyFramesAsValid bool = true
const Default_MotionEstimationOptions_FeatureGridSize float32 = 0.05
const Default_MotionEstimationOptions_SpatialSigma float32 = 0.01
const Default_MotionEstimationOptions_TemporalIrlsDiameter int32 = 20
const Default_MotionEstimationOptions_TemporalSigma float32 = 5
const Default_MotionEstimationOptions_FeatureSigma float32 = 30
const Default_MotionEstimationOptions_Filter_5Taps bool = false
const Default_MotionEstimationOptions_FrameConfidenceWeighting bool = true
const Default_MotionEstimationOptions_ResetConfidenceThreshold float32 = 0.4
const Default_MotionEstimationOptions_IrlsWeightFilter MotionEstimationOptions_IRLSWeightFilter = IRLS_FILTER_NONE
const Default_MotionEstimationOptions_OverlayDetection bool = false
const Default_MotionEstimationOptions_OverlayAnalysisChunkSize int32 = 8
const Default_MotionEstimationOptions_OutputRefinedIrlsWeights bool = true
const Default_MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions_HomographyIrlsWeightInitialization = IRLS_WEIGHT_PERIMETER_GAUSSIAN
const Default_MotionEstimationOptions_IrlsUseL0Norm bool = true
const Default_MotionEstimationOptions_DomainLimitedIrlsScaling bool = false
const Default_MotionEstimationOptions_DeactivateStableMotionEstimation bool = false
const Default_MotionEstimationOptions_ProjectValidMotionsDown bool = false

func (m *MotionEstimationOptions) GetEstimateTranslationIrls() bool {
	if m != nil && m.EstimateTranslationIrls != nil {
		return *m.EstimateTranslationIrls
	}
	return Default_MotionEstimationOptions_EstimateTranslationIrls
}

func (m *MotionEstimationOptions) GetLinearSimilarityEstimation() MotionEstimationOptions_LinearSimilarityEstimation {
	if m != nil && m.LinearSimilarityEstimation != nil {
		return *m.LinearSimilarityEstimation
	}
	return Default_MotionEstimationOptions_LinearSimilarityEstimation
}

func (m *MotionEstimationOptions) GetAffineEstimation() MotionEstimationOptions_AffineEstimation {
	if m != nil && m.AffineEstimation != nil {
		return *m.AffineEstimation
	}
	return Default_MotionEstimationOptions_AffineEstimation
}

func (m *MotionEstimationOptions) GetHomographyEstimation() MotionEstimationOptions_HomographyEstimation {
	if m != nil && m.HomographyEstimation != nil {
		return *m.HomographyEstimation
	}
	return Default_MotionEstimationOptions_HomographyEstimation
}

func (m *MotionEstimationOptions) GetHomographyExactDenominatorScaling() bool {
	if m != nil && m.HomographyExactDenominatorScaling != nil {
		return *m.HomographyExactDenominatorScaling
	}
	return Default_MotionEstimationOptions_HomographyExactDenominatorScaling
}

func (m *MotionEstimationOptions) GetUseExactHomographyEstimation() bool {
	if m != nil && m.UseExactHomographyEstimation != nil {
		return *m.UseExactHomographyEstimation
	}
	return Default_MotionEstimationOptions_UseExactHomographyEstimation
}

func (m *MotionEstimationOptions) GetUseHighestAccuracyForNormalEquations() bool {
	if m != nil && m.UseHighestAccuracyForNormalEquations != nil {
		return *m.UseHighestAccuracyForNormalEquations
	}
	return Default_MotionEstimationOptions_UseHighestAccuracyForNormalEquations
}

func (m *MotionEstimationOptions) GetHomographyPerspectiveRegularizer() float32 {
	if m != nil && m.HomographyPerspectiveRegularizer != nil {
		return *m.HomographyPerspectiveRegularizer
	}
	return Default_MotionEstimationOptions_HomographyPerspectiveRegularizer
}

func (m *MotionEstimationOptions) GetMixHomographyEstimation() MotionEstimationOptions_MixtureHomographyEstimation {
	if m != nil && m.MixHomographyEstimation != nil {
		return *m.MixHomographyEstimation
	}
	return Default_MotionEstimationOptions_MixHomographyEstimation
}

func (m *MotionEstimationOptions) GetNumMixtures() int32 {
	if m != nil && m.NumMixtures != nil {
		return *m.NumMixtures
	}
	return Default_MotionEstimationOptions_NumMixtures
}

func (m *MotionEstimationOptions) GetMixtureRowSigma() float32 {
	if m != nil && m.MixtureRowSigma != nil {
		return *m.MixtureRowSigma
	}
	return Default_MotionEstimationOptions_MixtureRowSigma
}

func (m *MotionEstimationOptions) GetMixtureRegularizer() float32 {
	if m != nil && m.MixtureRegularizer != nil {
		return *m.MixtureRegularizer
	}
	return Default_MotionEstimationOptions_MixtureRegularizer
}

func (m *MotionEstimationOptions) GetMixtureRegularizerLevels() float32 {
	if m != nil && m.MixtureRegularizerLevels != nil {
		return *m.MixtureRegularizerLevels
	}
	return Default_MotionEstimationOptions_MixtureRegularizerLevels
}

func (m *MotionEstimationOptions) GetMixtureRegularizerBase() float32 {
	if m != nil && m.MixtureRegularizerBase != nil {
		return *m.MixtureRegularizerBase
	}
	return Default_MotionEstimationOptions_MixtureRegularizerBase
}

func (m *MotionEstimationOptions) GetMixtureRsAnalysisLevel() int32 {
	if m != nil && m.MixtureRsAnalysisLevel != nil {
		return *m.MixtureRsAnalysisLevel
	}
	return Default_MotionEstimationOptions_MixtureRsAnalysisLevel
}

func (m *MotionEstimationOptions) GetIrlsRounds() int32 {
	if m != nil && m.IrlsRounds != nil {
		return *m.IrlsRounds
	}
	return Default_MotionEstimationOptions_IrlsRounds
}

func (m *MotionEstimationOptions) GetIrlsPriorScale() float32 {
	if m != nil && m.IrlsPriorScale != nil {
		return *m.IrlsPriorScale
	}
	return Default_MotionEstimationOptions_IrlsPriorScale
}

func (m *MotionEstimationOptions) GetIrlsMotionMagnitudeFraction() float32 {
	if m != nil && m.IrlsMotionMagnitudeFraction != nil {
		return *m.IrlsMotionMagnitudeFraction
	}
	return Default_MotionEstimationOptions_IrlsMotionMagnitudeFraction
}

func (m *MotionEstimationOptions) GetIrlsMixtureFractionScale() float32 {
	if m != nil && m.IrlsMixtureFractionScale != nil {
		return *m.IrlsMixtureFractionScale
	}
	return Default_MotionEstimationOptions_IrlsMixtureFractionScale
}

func (m *MotionEstimationOptions) GetIrlsWeightsPreinitialized() bool {
	if m != nil && m.IrlsWeightsPreinitialized != nil {
		return *m.IrlsWeightsPreinitialized
	}
	return Default_MotionEstimationOptions_IrlsWeightsPreinitialized
}

func (m *MotionEstimationOptions) GetFilterInitializedIrlsWeights() bool {
	if m != nil && m.FilterInitializedIrlsWeights != nil {
		return *m.FilterInitializedIrlsWeights
	}
	return Default_MotionEstimationOptions_FilterInitializedIrlsWeights
}

func (m *MotionEstimationOptions) GetIrlsInitialization() *MotionEstimationOptions_IrlsOutlierInitialization {
	if m != nil {
		return m.IrlsInitialization
	}
	return nil
}

func (m *MotionEstimationOptions) GetFeatureDensityNormalization() bool {
	if m != nil && m.FeatureDensityNormalization != nil {
		return *m.FeatureDensityNormalization
	}
	return Default_MotionEstimationOptions_FeatureDensityNormalization
}

func (m *MotionEstimationOptions) GetFeatureMaskSize() int32 {
	if m != nil && m.FeatureMaskSize != nil {
		return *m.FeatureMaskSize
	}
	return Default_MotionEstimationOptions_FeatureMaskSize
}

func (m *MotionEstimationOptions) GetLongFeatureInitialization() *MotionEstimationOptions_LongFeatureInitialization {
	if m != nil {
		return m.LongFeatureInitialization
	}
	return nil
}

func (m *MotionEstimationOptions) GetIrlsMaskOptions() *MotionEstimationOptions_IrlsMaskOptions {
	if m != nil {
		return m.IrlsMaskOptions
	}
	return nil
}

func (m *MotionEstimationOptions) GetJointTrackEstimation() *MotionEstimationOptions_JointTrackEstimationOptions {
	if m != nil {
		return m.JointTrackEstimation
	}
	return nil
}

func (m *MotionEstimationOptions) GetLongFeatureBiasOptions() *MotionEstimationOptions_LongFeatureBiasOptions {
	if m != nil {
		return m.LongFeatureBiasOptions
	}
	return nil
}

func (m *MotionEstimationOptions) GetEstimationPolicy() MotionEstimationOptions_EstimationPolicy {
	if m != nil && m.EstimationPolicy != nil {
		return *m.EstimationPolicy
	}
	return Default_MotionEstimationOptions_EstimationPolicy
}

func (m *MotionEstimationOptions) GetCoverageGridSize() int32 {
	if m != nil && m.CoverageGridSize != nil {
		return *m.CoverageGridSize
	}
	return Default_MotionEstimationOptions_CoverageGridSize
}

func (m *MotionEstimationOptions) GetMixtureModelMode() MotionEstimationOptions_MixtureModelMode {
	if m != nil && m.MixtureModelMode != nil {
		return *m.MixtureModelMode
	}
	return Default_MotionEstimationOptions_MixtureModelMode
}

func (m *MotionEstimationOptions) GetUseOnlyLinSimInliersForHomography() bool {
	if m != nil && m.UseOnlyLinSimInliersForHomography != nil {
		return *m.UseOnlyLinSimInliersForHomography
	}
	return Default_MotionEstimationOptions_UseOnlyLinSimInliersForHomography
}

func (m *MotionEstimationOptions) GetLinSimInlierThreshold() float32 {
	if m != nil && m.LinSimInlierThreshold != nil {
		return *m.LinSimInlierThreshold
	}
	return Default_MotionEstimationOptions_LinSimInlierThreshold
}

func (m *MotionEstimationOptions) GetStableTranslationBounds() *MotionEstimationOptions_TranslationBounds {
	if m != nil {
		return m.StableTranslationBounds
	}
	return nil
}

func (m *MotionEstimationOptions) GetStableSimilarityBounds() *MotionEstimationOptions_SimilarityBounds {
	if m != nil {
		return m.StableSimilarityBounds
	}
	return nil
}

func (m *MotionEstimationOptions) GetStableHomographyBounds() *MotionEstimationOptions_HomographyBounds {
	if m != nil {
		return m.StableHomographyBounds
	}
	return nil
}

func (m *MotionEstimationOptions) GetStableMixtureHomographyBounds() *MotionEstimationOptions_MixtureHomographyBounds {
	if m != nil {
		return m.StableMixtureHomographyBounds
	}
	return nil
}

func (m *MotionEstimationOptions) GetStrictCoverageScale() float32 {
	if m != nil && m.StrictCoverageScale != nil {
		return *m.StrictCoverageScale
	}
	return Default_MotionEstimationOptions_StrictCoverageScale
}

func (m *MotionEstimationOptions) GetLabelEmptyFramesAsValid() bool {
	if m != nil && m.LabelEmptyFramesAsValid != nil {
		return *m.LabelEmptyFramesAsValid
	}
	return Default_MotionEstimationOptions_LabelEmptyFramesAsValid
}

func (m *MotionEstimationOptions) GetFeatureGridSize() float32 {
	if m != nil && m.FeatureGridSize != nil {
		return *m.FeatureGridSize
	}
	return Default_MotionEstimationOptions_FeatureGridSize
}

func (m *MotionEstimationOptions) GetSpatialSigma() float32 {
	if m != nil && m.SpatialSigma != nil {
		return *m.SpatialSigma
	}
	return Default_MotionEstimationOptions_SpatialSigma
}

func (m *MotionEstimationOptions) GetTemporalIrlsDiameter() int32 {
	if m != nil && m.TemporalIrlsDiameter != nil {
		return *m.TemporalIrlsDiameter
	}
	return Default_MotionEstimationOptions_TemporalIrlsDiameter
}

func (m *MotionEstimationOptions) GetTemporalSigma() float32 {
	if m != nil && m.TemporalSigma != nil {
		return *m.TemporalSigma
	}
	return Default_MotionEstimationOptions_TemporalSigma
}

func (m *MotionEstimationOptions) GetFeatureSigma() float32 {
	if m != nil && m.FeatureSigma != nil {
		return *m.FeatureSigma
	}
	return Default_MotionEstimationOptions_FeatureSigma
}

func (m *MotionEstimationOptions) GetFilter_5Taps() bool {
	if m != nil && m.Filter_5Taps != nil {
		return *m.Filter_5Taps
	}
	return Default_MotionEstimationOptions_Filter_5Taps
}

func (m *MotionEstimationOptions) GetFrameConfidenceWeighting() bool {
	if m != nil && m.FrameConfidenceWeighting != nil {
		return *m.FrameConfidenceWeighting
	}
	return Default_MotionEstimationOptions_FrameConfidenceWeighting
}

func (m *MotionEstimationOptions) GetResetConfidenceThreshold() float32 {
	if m != nil && m.ResetConfidenceThreshold != nil {
		return *m.ResetConfidenceThreshold
	}
	return Default_MotionEstimationOptions_ResetConfidenceThreshold
}

func (m *MotionEstimationOptions) GetIrlsWeightFilter() MotionEstimationOptions_IRLSWeightFilter {
	if m != nil && m.IrlsWeightFilter != nil {
		return *m.IrlsWeightFilter
	}
	return Default_MotionEstimationOptions_IrlsWeightFilter
}

func (m *MotionEstimationOptions) GetOverlayDetection() bool {
	if m != nil && m.OverlayDetection != nil {
		return *m.OverlayDetection
	}
	return Default_MotionEstimationOptions_OverlayDetection
}

func (m *MotionEstimationOptions) GetOverlayAnalysisChunkSize() int32 {
	if m != nil && m.OverlayAnalysisChunkSize != nil {
		return *m.OverlayAnalysisChunkSize
	}
	return Default_MotionEstimationOptions_OverlayAnalysisChunkSize
}

func (m *MotionEstimationOptions) GetOverlayDetectionOptions() *MotionEstimationOptions_OverlayDetectionOptions {
	if m != nil {
		return m.OverlayDetectionOptions
	}
	return nil
}

func (m *MotionEstimationOptions) GetShotBoundaryOptions() *MotionEstimationOptions_ShotBoundaryOptions {
	if m != nil {
		return m.ShotBoundaryOptions
	}
	return nil
}

func (m *MotionEstimationOptions) GetOutputRefinedIrlsWeights() bool {
	if m != nil && m.OutputRefinedIrlsWeights != nil {
		return *m.OutputRefinedIrlsWeights
	}
	return Default_MotionEstimationOptions_OutputRefinedIrlsWeights
}

func (m *MotionEstimationOptions) GetHomographyIrlsWeightInitialization() MotionEstimationOptions_HomographyIrlsWeightInitialization {
	if m != nil && m.HomographyIrlsWeightInitialization != nil {
		return *m.HomographyIrlsWeightInitialization
	}
	return Default_MotionEstimationOptions_HomographyIrlsWeightInitialization
}

func (m *MotionEstimationOptions) GetIrlsUseL0Norm() bool {
	if m != nil && m.IrlsUseL0Norm != nil {
		return *m.IrlsUseL0Norm
	}
	return Default_MotionEstimationOptions_IrlsUseL0Norm
}

func (m *MotionEstimationOptions) GetDomainLimitedIrlsScaling() bool {
	if m != nil && m.DomainLimitedIrlsScaling != nil {
		return *m.DomainLimitedIrlsScaling
	}
	return Default_MotionEstimationOptions_DomainLimitedIrlsScaling
}

func (m *MotionEstimationOptions) GetDeactivateStableMotionEstimation() bool {
	if m != nil && m.DeactivateStableMotionEstimation != nil {
		return *m.DeactivateStableMotionEstimation
	}
	return Default_MotionEstimationOptions_DeactivateStableMotionEstimation
}

func (m *MotionEstimationOptions) GetProjectValidMotionsDown() bool {
	if m != nil && m.ProjectValidMotionsDown != nil {
		return *m.ProjectValidMotionsDown
	}
	return Default_MotionEstimationOptions_ProjectValidMotionsDown
}

// Deprecated: Do not use.
func (m *MotionEstimationOptions) GetEstimateSimilarity() bool {
	if m != nil {
		return m.EstimateSimilarity
	}
	return false
}

type MotionEstimationOptions_IrlsOutlierInitialization struct {
	Activated *bool    `protobuf:"varint,1,opt,name=activated,def=0" json:"activated,omitempty"`
	Rounds    *int32   `protobuf:"varint,2,opt,name=rounds,def=100" json:"rounds,omitempty"`
	Cutoff    *float32 `protobuf:"fixed32,3,opt,name=cutoff,def=0.003" json:"cutoff,omitempty"`
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) Reset() {
	*m = MotionEstimationOptions_IrlsOutlierInitialization{}
}
func (*MotionEstimationOptions_IrlsOutlierInitialization) ProtoMessage() {}
func (*MotionEstimationOptions_IrlsOutlierInitialization) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 0}
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_IrlsOutlierInitialization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_IrlsOutlierInitialization.Merge(m, src)
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_IrlsOutlierInitialization.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_IrlsOutlierInitialization proto.InternalMessageInfo

const Default_MotionEstimationOptions_IrlsOutlierInitialization_Activated bool = false
const Default_MotionEstimationOptions_IrlsOutlierInitialization_Rounds int32 = 100
const Default_MotionEstimationOptions_IrlsOutlierInitialization_Cutoff float32 = 0.003

func (m *MotionEstimationOptions_IrlsOutlierInitialization) GetActivated() bool {
	if m != nil && m.Activated != nil {
		return *m.Activated
	}
	return Default_MotionEstimationOptions_IrlsOutlierInitialization_Activated
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) GetRounds() int32 {
	if m != nil && m.Rounds != nil {
		return *m.Rounds
	}
	return Default_MotionEstimationOptions_IrlsOutlierInitialization_Rounds
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) GetCutoff() float32 {
	if m != nil && m.Cutoff != nil {
		return *m.Cutoff
	}
	return Default_MotionEstimationOptions_IrlsOutlierInitialization_Cutoff
}

type MotionEstimationOptions_LongFeatureInitialization struct {
	Activated           *bool    `protobuf:"varint,1,opt,name=activated,def=0" json:"activated,omitempty"`
	MinLengthPercentile *float32 `protobuf:"fixed32,2,opt,name=min_length_percentile,json=minLengthPercentile,def=0.95" json:"min_length_percentile,omitempty"`
	UpweightMultiplier  *float32 `protobuf:"fixed32,3,opt,name=upweight_multiplier,json=upweightMultiplier,def=5" json:"upweight_multiplier,omitempty"`
}

func (m *MotionEstimationOptions_LongFeatureInitialization) Reset() {
	*m = MotionEstimationOptions_LongFeatureInitialization{}
}
func (*MotionEstimationOptions_LongFeatureInitialization) ProtoMessage() {}
func (*MotionEstimationOptions_LongFeatureInitialization) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 1}
}
func (m *MotionEstimationOptions_LongFeatureInitialization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_LongFeatureInitialization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_LongFeatureInitialization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_LongFeatureInitialization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_LongFeatureInitialization.Merge(m, src)
}
func (m *MotionEstimationOptions_LongFeatureInitialization) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_LongFeatureInitialization) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_LongFeatureInitialization.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_LongFeatureInitialization proto.InternalMessageInfo

const Default_MotionEstimationOptions_LongFeatureInitialization_Activated bool = false
const Default_MotionEstimationOptions_LongFeatureInitialization_MinLengthPercentile float32 = 0.95
const Default_MotionEstimationOptions_LongFeatureInitialization_UpweightMultiplier float32 = 5

func (m *MotionEstimationOptions_LongFeatureInitialization) GetActivated() bool {
	if m != nil && m.Activated != nil {
		return *m.Activated
	}
	return Default_MotionEstimationOptions_LongFeatureInitialization_Activated
}

func (m *MotionEstimationOptions_LongFeatureInitialization) GetMinLengthPercentile() float32 {
	if m != nil && m.MinLengthPercentile != nil {
		return *m.MinLengthPercentile
	}
	return Default_MotionEstimationOptions_LongFeatureInitialization_MinLengthPercentile
}

func (m *MotionEstimationOptions_LongFeatureInitialization) GetUpweightMultiplier() float32 {
	if m != nil && m.UpweightMultiplier != nil {
		return *m.UpweightMultiplier
	}
	return Default_MotionEstimationOptions_LongFeatureInitialization_UpweightMultiplier
}

type MotionEstimationOptions_IrlsMaskOptions struct {
	Decay                        *float32 `protobuf:"fixed32,2,opt,name=decay,def=0.7" json:"decay,omitempty"`
	InlierScore                  *float32 `protobuf:"fixed32,3,opt,name=inlier_score,json=inlierScore,def=0.4" json:"inlier_score,omitempty"`
	BaseScore                    *float32 `protobuf:"fixed32,4,opt,name=base_score,json=baseScore,def=0.2" json:"base_score,omitempty"`
	MinTranslationNorm           *float32 `protobuf:"fixed32,5,opt,name=min_translation_norm,json=minTranslationNorm,def=0.002" json:"min_translation_norm,omitempty"`
	TranslationBlendAlpha        *float32 `protobuf:"fixed32,6,opt,name=translation_blend_alpha,json=translationBlendAlpha,def=0.7" json:"translation_blend_alpha,omitempty"`
	TranslationPriorIncrease     *float32 `protobuf:"fixed32,7,opt,name=translation_prior_increase,json=translationPriorIncrease,def=0.2" json:"translation_prior_increase,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
}

func (m *MotionEstimationOptions_IrlsMaskOptions) Reset() {
	*m = MotionEstimationOptions_IrlsMaskOptions{}
}
func (*MotionEstimationOptions_IrlsMaskOptions) ProtoMessage() {}
func (*MotionEstimationOptions_IrlsMaskOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 2}
}

var extRange_MotionEstimationOptions_IrlsMaskOptions = []proto.ExtensionRange{
	{Start: 1, End: 1},
}

func (*MotionEstimationOptions_IrlsMaskOptions) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_MotionEstimationOptions_IrlsMaskOptions
}

func (m *MotionEstimationOptions_IrlsMaskOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_IrlsMaskOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_IrlsMaskOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_IrlsMaskOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_IrlsMaskOptions.Merge(m, src)
}
func (m *MotionEstimationOptions_IrlsMaskOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_IrlsMaskOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_IrlsMaskOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_IrlsMaskOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_IrlsMaskOptions_Decay float32 = 0.7
const Default_MotionEstimationOptions_IrlsMaskOptions_InlierScore float32 = 0.4
const Default_MotionEstimationOptions_IrlsMaskOptions_BaseScore float32 = 0.2
const Default_MotionEstimationOptions_IrlsMaskOptions_MinTranslationNorm float32 = 0.002
const Default_MotionEstimationOptions_IrlsMaskOptions_TranslationBlendAlpha float32 = 0.7
const Default_MotionEstimationOptions_IrlsMaskOptions_TranslationPriorIncrease float32 = 0.2

func (m *MotionEstimationOptions_IrlsMaskOptions) GetDecay() float32 {
	if m != nil && m.Decay != nil {
		return *m.Decay
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_Decay
}

func (m *MotionEstimationOptions_IrlsMaskOptions) GetInlierScore() float32 {
	if m != nil && m.InlierScore != nil {
		return *m.InlierScore
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_InlierScore
}

func (m *MotionEstimationOptions_IrlsMaskOptions) GetBaseScore() float32 {
	if m != nil && m.BaseScore != nil {
		return *m.BaseScore
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_BaseScore
}

func (m *MotionEstimationOptions_IrlsMaskOptions) GetMinTranslationNorm() float32 {
	if m != nil && m.MinTranslationNorm != nil {
		return *m.MinTranslationNorm
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_MinTranslationNorm
}

func (m *MotionEstimationOptions_IrlsMaskOptions) GetTranslationBlendAlpha() float32 {
	if m != nil && m.TranslationBlendAlpha != nil {
		return *m.TranslationBlendAlpha
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_TranslationBlendAlpha
}

func (m *MotionEstimationOptions_IrlsMaskOptions) GetTranslationPriorIncrease() float32 {
	if m != nil && m.TranslationPriorIncrease != nil {
		return *m.TranslationPriorIncrease
	}
	return Default_MotionEstimationOptions_IrlsMaskOptions_TranslationPriorIncrease
}

type MotionEstimationOptions_JointTrackEstimationOptions struct {
	NumMotionModels   *int32 `protobuf:"varint,1,opt,name=num_motion_models,json=numMotionModels,def=3" json:"num_motion_models,omitempty"`
	MotionStride      *int32 `protobuf:"varint,2,opt,name=motion_stride,json=motionStride,def=15" json:"motion_stride,omitempty"`
	TemporalSmoothing *bool  `protobuf:"varint,3,opt,name=temporal_smoothing,json=temporalSmoothing,def=0" json:"temporal_smoothing,omitempty"`
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) Reset() {
	*m = MotionEstimationOptions_JointTrackEstimationOptions{}
}
func (*MotionEstimationOptions_JointTrackEstimationOptions) ProtoMessage() {}
func (*MotionEstimationOptions_JointTrackEstimationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 3}
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_JointTrackEstimationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_JointTrackEstimationOptions.Merge(m, src)
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_JointTrackEstimationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_JointTrackEstimationOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_JointTrackEstimationOptions_NumMotionModels int32 = 3
const Default_MotionEstimationOptions_JointTrackEstimationOptions_MotionStride int32 = 15
const Default_MotionEstimationOptions_JointTrackEstimationOptions_TemporalSmoothing bool = false

func (m *MotionEstimationOptions_JointTrackEstimationOptions) GetNumMotionModels() int32 {
	if m != nil && m.NumMotionModels != nil {
		return *m.NumMotionModels
	}
	return Default_MotionEstimationOptions_JointTrackEstimationOptions_NumMotionModels
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) GetMotionStride() int32 {
	if m != nil && m.MotionStride != nil {
		return *m.MotionStride
	}
	return Default_MotionEstimationOptions_JointTrackEstimationOptions_MotionStride
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) GetTemporalSmoothing() bool {
	if m != nil && m.TemporalSmoothing != nil {
		return *m.TemporalSmoothing
	}
	return Default_MotionEstimationOptions_JointTrackEstimationOptions_TemporalSmoothing
}

type MotionEstimationOptions_LongFeatureBiasOptions struct {
	TotalRounds                 *int32   `protobuf:"varint,13,opt,name=total_rounds,json=totalRounds,def=1" json:"total_rounds,omitempty"`
	InlierBias                  *float32 `protobuf:"fixed32,1,opt,name=inlier_bias,json=inlierBias,def=0.98" json:"inlier_bias,omitempty"`
	OutlierBias                 *float32 `protobuf:"fixed32,2,opt,name=outlier_bias,json=outlierBias,def=0.7" json:"outlier_bias,omitempty"`
	NumIrlsObservations         *int32   `protobuf:"varint,3,opt,name=num_irls_observations,json=numIrlsObservations,def=10" json:"num_irls_observations,omitempty"`
	MaxIrlsChangeRatio          *float32 `protobuf:"fixed32,4,opt,name=max_irls_change_ratio,json=maxIrlsChangeRatio,def=10" json:"max_irls_change_ratio,omitempty"`
	InlierIrlsWeight            *float32 `protobuf:"fixed32,5,opt,name=inlier_irls_weight,json=inlierIrlsWeight,def=0.2" json:"inlier_irls_weight,omitempty"`
	BiasStdev                   *float32 `protobuf:"fixed32,12,opt,name=bias_stdev,json=biasStdev,def=1" json:"bias_stdev,omitempty"`
	UseSpatialBias              *bool    `protobuf:"varint,6,opt,name=use_spatial_bias,json=useSpatialBias,def=1" json:"use_spatial_bias,omitempty"`
	GridSize                    *float32 `protobuf:"fixed32,7,opt,name=grid_size,json=gridSize,def=0.04" json:"grid_size,omitempty"`
	SpatialSigma                *float32 `protobuf:"fixed32,8,opt,name=spatial_sigma,json=spatialSigma,def=0.02" json:"spatial_sigma,omitempty"`
	ColorSigma                  *float32 `protobuf:"fixed32,9,opt,name=color_sigma,json=colorSigma,def=20" json:"color_sigma,omitempty"`
	LongTrackThreshold          *int32   `protobuf:"varint,10,opt,name=long_track_threshold,json=longTrackThreshold,def=30" json:"long_track_threshold,omitempty"`
	LongTrackConfidenceFraction *float32 `protobuf:"fixed32,11,opt,name=long_track_confidence_fraction,json=longTrackConfidenceFraction,def=0.25" json:"long_track_confidence_fraction,omitempty"`
	SeedPriorsFromBias          *bool    `protobuf:"varint,14,opt,name=seed_priors_from_bias,json=seedPriorsFromBias,def=0" json:"seed_priors_from_bias,omitempty"`
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) Reset() {
	*m = MotionEstimationOptions_LongFeatureBiasOptions{}
}
func (*MotionEstimationOptions_LongFeatureBiasOptions) ProtoMessage() {}
func (*MotionEstimationOptions_LongFeatureBiasOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 4}
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_LongFeatureBiasOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_LongFeatureBiasOptions.Merge(m, src)
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_LongFeatureBiasOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_LongFeatureBiasOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_LongFeatureBiasOptions_TotalRounds int32 = 1
const Default_MotionEstimationOptions_LongFeatureBiasOptions_InlierBias float32 = 0.98
const Default_MotionEstimationOptions_LongFeatureBiasOptions_OutlierBias float32 = 0.7
const Default_MotionEstimationOptions_LongFeatureBiasOptions_NumIrlsObservations int32 = 10
const Default_MotionEstimationOptions_LongFeatureBiasOptions_MaxIrlsChangeRatio float32 = 10
const Default_MotionEstimationOptions_LongFeatureBiasOptions_InlierIrlsWeight float32 = 0.2
const Default_MotionEstimationOptions_LongFeatureBiasOptions_BiasStdev float32 = 1
const Default_MotionEstimationOptions_LongFeatureBiasOptions_UseSpatialBias bool = true
const Default_MotionEstimationOptions_LongFeatureBiasOptions_GridSize float32 = 0.04
const Default_MotionEstimationOptions_LongFeatureBiasOptions_SpatialSigma float32 = 0.02
const Default_MotionEstimationOptions_LongFeatureBiasOptions_ColorSigma float32 = 20
const Default_MotionEstimationOptions_LongFeatureBiasOptions_LongTrackThreshold int32 = 30
const Default_MotionEstimationOptions_LongFeatureBiasOptions_LongTrackConfidenceFraction float32 = 0.25
const Default_MotionEstimationOptions_LongFeatureBiasOptions_SeedPriorsFromBias bool = false

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetTotalRounds() int32 {
	if m != nil && m.TotalRounds != nil {
		return *m.TotalRounds
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_TotalRounds
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetInlierBias() float32 {
	if m != nil && m.InlierBias != nil {
		return *m.InlierBias
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_InlierBias
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetOutlierBias() float32 {
	if m != nil && m.OutlierBias != nil {
		return *m.OutlierBias
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_OutlierBias
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetNumIrlsObservations() int32 {
	if m != nil && m.NumIrlsObservations != nil {
		return *m.NumIrlsObservations
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_NumIrlsObservations
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetMaxIrlsChangeRatio() float32 {
	if m != nil && m.MaxIrlsChangeRatio != nil {
		return *m.MaxIrlsChangeRatio
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_MaxIrlsChangeRatio
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetInlierIrlsWeight() float32 {
	if m != nil && m.InlierIrlsWeight != nil {
		return *m.InlierIrlsWeight
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_InlierIrlsWeight
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetBiasStdev() float32 {
	if m != nil && m.BiasStdev != nil {
		return *m.BiasStdev
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_BiasStdev
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetUseSpatialBias() bool {
	if m != nil && m.UseSpatialBias != nil {
		return *m.UseSpatialBias
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_UseSpatialBias
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetGridSize() float32 {
	if m != nil && m.GridSize != nil {
		return *m.GridSize
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_GridSize
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetSpatialSigma() float32 {
	if m != nil && m.SpatialSigma != nil {
		return *m.SpatialSigma
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_SpatialSigma
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetColorSigma() float32 {
	if m != nil && m.ColorSigma != nil {
		return *m.ColorSigma
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_ColorSigma
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetLongTrackThreshold() int32 {
	if m != nil && m.LongTrackThreshold != nil {
		return *m.LongTrackThreshold
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_LongTrackThreshold
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetLongTrackConfidenceFraction() float32 {
	if m != nil && m.LongTrackConfidenceFraction != nil {
		return *m.LongTrackConfidenceFraction
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_LongTrackConfidenceFraction
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) GetSeedPriorsFromBias() bool {
	if m != nil && m.SeedPriorsFromBias != nil {
		return *m.SeedPriorsFromBias
	}
	return Default_MotionEstimationOptions_LongFeatureBiasOptions_SeedPriorsFromBias
}

type MotionEstimationOptions_TranslationBounds struct {
	MinFeatures             *int32   `protobuf:"varint,1,opt,name=min_features,json=minFeatures,def=3" json:"min_features,omitempty"`
	FracMaxMotionMagnitude  *float32 `protobuf:"fixed32,2,opt,name=frac_max_motion_magnitude,json=fracMaxMotionMagnitude,def=0.15" json:"frac_max_motion_magnitude,omitempty"`
	MaxMotionStdevThreshold *float32 `protobuf:"fixed32,4,opt,name=max_motion_stdev_threshold,json=maxMotionStdevThreshold,def=0.01" json:"max_motion_stdev_threshold,omitempty"`
	MaxMotionStdev          *float32 `protobuf:"fixed32,3,opt,name=max_motion_stdev,json=maxMotionStdev,def=0.065" json:"max_motion_stdev,omitempty"`
	MaxAcceleration         *float32 `protobuf:"fixed32,5,opt,name=max_acceleration,json=maxAcceleration,def=20" json:"max_acceleration,omitempty"`
}

func (m *MotionEstimationOptions_TranslationBounds) Reset() {
	*m = MotionEstimationOptions_TranslationBounds{}
}
func (*MotionEstimationOptions_TranslationBounds) ProtoMessage() {}
func (*MotionEstimationOptions_TranslationBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 5}
}
func (m *MotionEstimationOptions_TranslationBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_TranslationBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_TranslationBounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_TranslationBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_TranslationBounds.Merge(m, src)
}
func (m *MotionEstimationOptions_TranslationBounds) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_TranslationBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_TranslationBounds.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_TranslationBounds proto.InternalMessageInfo

const Default_MotionEstimationOptions_TranslationBounds_MinFeatures int32 = 3
const Default_MotionEstimationOptions_TranslationBounds_FracMaxMotionMagnitude float32 = 0.15
const Default_MotionEstimationOptions_TranslationBounds_MaxMotionStdevThreshold float32 = 0.01
const Default_MotionEstimationOptions_TranslationBounds_MaxMotionStdev float32 = 0.065
const Default_MotionEstimationOptions_TranslationBounds_MaxAcceleration float32 = 20

func (m *MotionEstimationOptions_TranslationBounds) GetMinFeatures() int32 {
	if m != nil && m.MinFeatures != nil {
		return *m.MinFeatures
	}
	return Default_MotionEstimationOptions_TranslationBounds_MinFeatures
}

func (m *MotionEstimationOptions_TranslationBounds) GetFracMaxMotionMagnitude() float32 {
	if m != nil && m.FracMaxMotionMagnitude != nil {
		return *m.FracMaxMotionMagnitude
	}
	return Default_MotionEstimationOptions_TranslationBounds_FracMaxMotionMagnitude
}

func (m *MotionEstimationOptions_TranslationBounds) GetMaxMotionStdevThreshold() float32 {
	if m != nil && m.MaxMotionStdevThreshold != nil {
		return *m.MaxMotionStdevThreshold
	}
	return Default_MotionEstimationOptions_TranslationBounds_MaxMotionStdevThreshold
}

func (m *MotionEstimationOptions_TranslationBounds) GetMaxMotionStdev() float32 {
	if m != nil && m.MaxMotionStdev != nil {
		return *m.MaxMotionStdev
	}
	return Default_MotionEstimationOptions_TranslationBounds_MaxMotionStdev
}

func (m *MotionEstimationOptions_TranslationBounds) GetMaxAcceleration() float32 {
	if m != nil && m.MaxAcceleration != nil {
		return *m.MaxAcceleration
	}
	return Default_MotionEstimationOptions_TranslationBounds_MaxAcceleration
}

type MotionEstimationOptions_SimilarityBounds struct {
	OnlyStableInput       *bool    `protobuf:"varint,1,opt,name=only_stable_input,json=onlyStableInput,def=1" json:"only_stable_input,omitempty"`
	MinInlierFraction     *float32 `protobuf:"fixed32,2,opt,name=min_inlier_fraction,json=minInlierFraction,def=0.2" json:"min_inlier_fraction,omitempty"`
	MinInliers            *float32 `protobuf:"fixed32,3,opt,name=min_inliers,json=minInliers,def=30" json:"min_inliers,omitempty"`
	LowerScale            *float32 `protobuf:"fixed32,4,opt,name=lower_scale,json=lowerScale,def=0.8" json:"lower_scale,omitempty"`
	UpperScale            *float32 `protobuf:"fixed32,5,opt,name=upper_scale,json=upperScale,def=1.25" json:"upper_scale,omitempty"`
	LimitRotation         *float32 `protobuf:"fixed32,6,opt,name=limit_rotation,json=limitRotation,def=0.25" json:"limit_rotation,omitempty"`
	InlierThreshold       *float32 `protobuf:"fixed32,7,opt,name=inlier_threshold,json=inlierThreshold,def=4" json:"inlier_threshold,omitempty"`
	FracInlierThreshold   *float32 `protobuf:"fixed32,8,opt,name=frac_inlier_threshold,json=fracInlierThreshold,def=0" json:"frac_inlier_threshold,omitempty"`
	StrictInlierThreshold *float32 `protobuf:"fixed32,9,opt,name=strict_inlier_threshold,json=strictInlierThreshold,def=0.5" json:"strict_inlier_threshold,omitempty"`
}

func (m *MotionEstimationOptions_SimilarityBounds) Reset() {
	*m = MotionEstimationOptions_SimilarityBounds{}
}
func (*MotionEstimationOptions_SimilarityBounds) ProtoMessage() {}
func (*MotionEstimationOptions_SimilarityBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 6}
}
func (m *MotionEstimationOptions_SimilarityBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_SimilarityBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_SimilarityBounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_SimilarityBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_SimilarityBounds.Merge(m, src)
}
func (m *MotionEstimationOptions_SimilarityBounds) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_SimilarityBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_SimilarityBounds.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_SimilarityBounds proto.InternalMessageInfo

const Default_MotionEstimationOptions_SimilarityBounds_OnlyStableInput bool = true
const Default_MotionEstimationOptions_SimilarityBounds_MinInlierFraction float32 = 0.2
const Default_MotionEstimationOptions_SimilarityBounds_MinInliers float32 = 30
const Default_MotionEstimationOptions_SimilarityBounds_LowerScale float32 = 0.8
const Default_MotionEstimationOptions_SimilarityBounds_UpperScale float32 = 1.25
const Default_MotionEstimationOptions_SimilarityBounds_LimitRotation float32 = 0.25
const Default_MotionEstimationOptions_SimilarityBounds_InlierThreshold float32 = 4
const Default_MotionEstimationOptions_SimilarityBounds_FracInlierThreshold float32 = 0
const Default_MotionEstimationOptions_SimilarityBounds_StrictInlierThreshold float32 = 0.5

func (m *MotionEstimationOptions_SimilarityBounds) GetOnlyStableInput() bool {
	if m != nil && m.OnlyStableInput != nil {
		return *m.OnlyStableInput
	}
	return Default_MotionEstimationOptions_SimilarityBounds_OnlyStableInput
}

func (m *MotionEstimationOptions_SimilarityBounds) GetMinInlierFraction() float32 {
	if m != nil && m.MinInlierFraction != nil {
		return *m.MinInlierFraction
	}
	return Default_MotionEstimationOptions_SimilarityBounds_MinInlierFraction
}

func (m *MotionEstimationOptions_SimilarityBounds) GetMinInliers() float32 {
	if m != nil && m.MinInliers != nil {
		return *m.MinInliers
	}
	return Default_MotionEstimationOptions_SimilarityBounds_MinInliers
}

func (m *MotionEstimationOptions_SimilarityBounds) GetLowerScale() float32 {
	if m != nil && m.LowerScale != nil {
		return *m.LowerScale
	}
	return Default_MotionEstimationOptions_SimilarityBounds_LowerScale
}

func (m *MotionEstimationOptions_SimilarityBounds) GetUpperScale() float32 {
	if m != nil && m.UpperScale != nil {
		return *m.UpperScale
	}
	return Default_MotionEstimationOptions_SimilarityBounds_UpperScale
}

func (m *MotionEstimationOptions_SimilarityBounds) GetLimitRotation() float32 {
	if m != nil && m.LimitRotation != nil {
		return *m.LimitRotation
	}
	return Default_MotionEstimationOptions_SimilarityBounds_LimitRotation
}

func (m *MotionEstimationOptions_SimilarityBounds) GetInlierThreshold() float32 {
	if m != nil && m.InlierThreshold != nil {
		return *m.InlierThreshold
	}
	return Default_MotionEstimationOptions_SimilarityBounds_InlierThreshold
}

func (m *MotionEstimationOptions_SimilarityBounds) GetFracInlierThreshold() float32 {
	if m != nil && m.FracInlierThreshold != nil {
		return *m.FracInlierThreshold
	}
	return Default_MotionEstimationOptions_SimilarityBounds_FracInlierThreshold
}

func (m *MotionEstimationOptions_SimilarityBounds) GetStrictInlierThreshold() float32 {
	if m != nil && m.StrictInlierThreshold != nil {
		return *m.StrictInlierThreshold
	}
	return Default_MotionEstimationOptions_SimilarityBounds_StrictInlierThreshold
}

type MotionEstimationOptions_HomographyBounds struct {
	LowerScale                *float32 `protobuf:"fixed32,1,opt,name=lower_scale,json=lowerScale,def=0.8" json:"lower_scale,omitempty"`
	UpperScale                *float32 `protobuf:"fixed32,2,opt,name=upper_scale,json=upperScale,def=1.25" json:"upper_scale,omitempty"`
	LimitRotation             *float32 `protobuf:"fixed32,3,opt,name=limit_rotation,json=limitRotation,def=0.25" json:"limit_rotation,omitempty"`
	LimitPerspective          *float32 `protobuf:"fixed32,4,opt,name=limit_perspective,json=limitPerspective,def=0.0004" json:"limit_perspective,omitempty"`
	RegistrationThreshold     *float32 `protobuf:"fixed32,5,opt,name=registration_threshold,json=registrationThreshold,def=0.1" json:"registration_threshold,omitempty"`
	FracRegistrationThreshold *float32 `protobuf:"fixed32,8,opt,name=frac_registration_threshold,json=fracRegistrationThreshold,def=0" json:"frac_registration_threshold,omitempty"`
	MinInlierCoverage         *float32 `protobuf:"fixed32,6,opt,name=min_inlier_coverage,json=minInlierCoverage,def=0.3" json:"min_inlier_coverage,omitempty"`
	FracInlierThreshold       *float32 `protobuf:"fixed32,7,opt,name=frac_inlier_threshold,json=fracInlierThreshold,def=0.002" json:"frac_inlier_threshold,omitempty"`
}

func (m *MotionEstimationOptions_HomographyBounds) Reset() {
	*m = MotionEstimationOptions_HomographyBounds{}
}
func (*MotionEstimationOptions_HomographyBounds) ProtoMessage() {}
func (*MotionEstimationOptions_HomographyBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 7}
}
func (m *MotionEstimationOptions_HomographyBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_HomographyBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_HomographyBounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_HomographyBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_HomographyBounds.Merge(m, src)
}
func (m *MotionEstimationOptions_HomographyBounds) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_HomographyBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_HomographyBounds.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_HomographyBounds proto.InternalMessageInfo

const Default_MotionEstimationOptions_HomographyBounds_LowerScale float32 = 0.8
const Default_MotionEstimationOptions_HomographyBounds_UpperScale float32 = 1.25
const Default_MotionEstimationOptions_HomographyBounds_LimitRotation float32 = 0.25
const Default_MotionEstimationOptions_HomographyBounds_LimitPerspective float32 = 0.0004
const Default_MotionEstimationOptions_HomographyBounds_RegistrationThreshold float32 = 0.1
const Default_MotionEstimationOptions_HomographyBounds_FracRegistrationThreshold float32 = 0
const Default_MotionEstimationOptions_HomographyBounds_MinInlierCoverage float32 = 0.3
const Default_MotionEstimationOptions_HomographyBounds_FracInlierThreshold float32 = 0.002

func (m *MotionEstimationOptions_HomographyBounds) GetLowerScale() float32 {
	if m != nil && m.LowerScale != nil {
		return *m.LowerScale
	}
	return Default_MotionEstimationOptions_HomographyBounds_LowerScale
}

func (m *MotionEstimationOptions_HomographyBounds) GetUpperScale() float32 {
	if m != nil && m.UpperScale != nil {
		return *m.UpperScale
	}
	return Default_MotionEstimationOptions_HomographyBounds_UpperScale
}

func (m *MotionEstimationOptions_HomographyBounds) GetLimitRotation() float32 {
	if m != nil && m.LimitRotation != nil {
		return *m.LimitRotation
	}
	return Default_MotionEstimationOptions_HomographyBounds_LimitRotation
}

func (m *MotionEstimationOptions_HomographyBounds) GetLimitPerspective() float32 {
	if m != nil && m.LimitPerspective != nil {
		return *m.LimitPerspective
	}
	return Default_MotionEstimationOptions_HomographyBounds_LimitPerspective
}

func (m *MotionEstimationOptions_HomographyBounds) GetRegistrationThreshold() float32 {
	if m != nil && m.RegistrationThreshold != nil {
		return *m.RegistrationThreshold
	}
	return Default_MotionEstimationOptions_HomographyBounds_RegistrationThreshold
}

func (m *MotionEstimationOptions_HomographyBounds) GetFracRegistrationThreshold() float32 {
	if m != nil && m.FracRegistrationThreshold != nil {
		return *m.FracRegistrationThreshold
	}
	return Default_MotionEstimationOptions_HomographyBounds_FracRegistrationThreshold
}

func (m *MotionEstimationOptions_HomographyBounds) GetMinInlierCoverage() float32 {
	if m != nil && m.MinInlierCoverage != nil {
		return *m.MinInlierCoverage
	}
	return Default_MotionEstimationOptions_HomographyBounds_MinInlierCoverage
}

func (m *MotionEstimationOptions_HomographyBounds) GetFracInlierThreshold() float32 {
	if m != nil && m.FracInlierThreshold != nil {
		return *m.FracInlierThreshold
	}
	return Default_MotionEstimationOptions_HomographyBounds_FracInlierThreshold
}

type MotionEstimationOptions_MixtureHomographyBounds struct {
	MinInlierCoverage        *float32 `protobuf:"fixed32,1,opt,name=min_inlier_coverage,json=minInlierCoverage,def=0.4" json:"min_inlier_coverage,omitempty"`
	MaxAdjacentOutlierBlocks *int32   `protobuf:"varint,2,opt,name=max_adjacent_outlier_blocks,json=maxAdjacentOutlierBlocks,def=5" json:"max_adjacent_outlier_blocks,omitempty"`
	MaxAdjacentEmptyBlocks   *int32   `protobuf:"varint,3,opt,name=max_adjacent_empty_blocks,json=maxAdjacentEmptyBlocks,def=3" json:"max_adjacent_empty_blocks,omitempty"`
	FracInlierThreshold      *float32 `protobuf:"fixed32,7,opt,name=frac_inlier_threshold,json=fracInlierThreshold,def=0.0025" json:"frac_inlier_threshold,omitempty"`
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) Reset() {
	*m = MotionEstimationOptions_MixtureHomographyBounds{}
}
func (*MotionEstimationOptions_MixtureHomographyBounds) ProtoMessage() {}
func (*MotionEstimationOptions_MixtureHomographyBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 8}
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_MixtureHomographyBounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_MixtureHomographyBounds.Merge(m, src)
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_MixtureHomographyBounds.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_MixtureHomographyBounds proto.InternalMessageInfo

const Default_MotionEstimationOptions_MixtureHomographyBounds_MinInlierCoverage float32 = 0.4
const Default_MotionEstimationOptions_MixtureHomographyBounds_MaxAdjacentOutlierBlocks int32 = 5
const Default_MotionEstimationOptions_MixtureHomographyBounds_MaxAdjacentEmptyBlocks int32 = 3
const Default_MotionEstimationOptions_MixtureHomographyBounds_FracInlierThreshold float32 = 0.0025

func (m *MotionEstimationOptions_MixtureHomographyBounds) GetMinInlierCoverage() float32 {
	if m != nil && m.MinInlierCoverage != nil {
		return *m.MinInlierCoverage
	}
	return Default_MotionEstimationOptions_MixtureHomographyBounds_MinInlierCoverage
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) GetMaxAdjacentOutlierBlocks() int32 {
	if m != nil && m.MaxAdjacentOutlierBlocks != nil {
		return *m.MaxAdjacentOutlierBlocks
	}
	return Default_MotionEstimationOptions_MixtureHomographyBounds_MaxAdjacentOutlierBlocks
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) GetMaxAdjacentEmptyBlocks() int32 {
	if m != nil && m.MaxAdjacentEmptyBlocks != nil {
		return *m.MaxAdjacentEmptyBlocks
	}
	return Default_MotionEstimationOptions_MixtureHomographyBounds_MaxAdjacentEmptyBlocks
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) GetFracInlierThreshold() float32 {
	if m != nil && m.FracInlierThreshold != nil {
		return *m.FracInlierThreshold
	}
	return Default_MotionEstimationOptions_MixtureHomographyBounds_FracInlierThreshold
}

type MotionEstimationOptions_OverlayDetectionOptions struct {
	AnalysisMaskSize          *int32   `protobuf:"varint,1,opt,name=analysis_mask_size,json=analysisMaskSize,def=10" json:"analysis_mask_size,omitempty"`
	StrictNearZeroMotion      *float32 `protobuf:"fixed32,2,opt,name=strict_near_zero_motion,json=strictNearZeroMotion,def=0.2" json:"strict_near_zero_motion,omitempty"`
	StrictMaxTranslationRatio *float32 `protobuf:"fixed32,3,opt,name=strict_max_translation_ratio,json=strictMaxTranslationRatio,def=0.2" json:"strict_max_translation_ratio,omitempty"`
	StrictMinTexturedness     *float32 `protobuf:"fixed32,5,opt,name=strict_min_texturedness,json=strictMinTexturedness,def=0.1" json:"strict_min_texturedness,omitempty"`
	LooseNearZeroMotion       *float32 `protobuf:"fixed32,4,opt,name=loose_near_zero_motion,json=looseNearZeroMotion,def=1" json:"loose_near_zero_motion,omitempty"`
	OverlayMinRatio           *float32 `protobuf:"fixed32,6,opt,name=overlay_min_ratio,json=overlayMinRatio,def=0.3" json:"overlay_min_ratio,omitempty"`
	OverlayMinFeatures        *float32 `protobuf:"fixed32,7,opt,name=overlay_min_features,json=overlayMinFeatures,def=10" json:"overlay_min_features,omitempty"`
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) Reset() {
	*m = MotionEstimationOptions_OverlayDetectionOptions{}
}
func (*MotionEstimationOptions_OverlayDetectionOptions) ProtoMessage() {}
func (*MotionEstimationOptions_OverlayDetectionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 9}
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_OverlayDetectionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_OverlayDetectionOptions.Merge(m, src)
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_OverlayDetectionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_OverlayDetectionOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_OverlayDetectionOptions_AnalysisMaskSize int32 = 10
const Default_MotionEstimationOptions_OverlayDetectionOptions_StrictNearZeroMotion float32 = 0.2
const Default_MotionEstimationOptions_OverlayDetectionOptions_StrictMaxTranslationRatio float32 = 0.2
const Default_MotionEstimationOptions_OverlayDetectionOptions_StrictMinTexturedness float32 = 0.1
const Default_MotionEstimationOptions_OverlayDetectionOptions_LooseNearZeroMotion float32 = 1
const Default_MotionEstimationOptions_OverlayDetectionOptions_OverlayMinRatio float32 = 0.3
const Default_MotionEstimationOptions_OverlayDetectionOptions_OverlayMinFeatures float32 = 10

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetAnalysisMaskSize() int32 {
	if m != nil && m.AnalysisMaskSize != nil {
		return *m.AnalysisMaskSize
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_AnalysisMaskSize
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetStrictNearZeroMotion() float32 {
	if m != nil && m.StrictNearZeroMotion != nil {
		return *m.StrictNearZeroMotion
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_StrictNearZeroMotion
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetStrictMaxTranslationRatio() float32 {
	if m != nil && m.StrictMaxTranslationRatio != nil {
		return *m.StrictMaxTranslationRatio
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_StrictMaxTranslationRatio
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetStrictMinTexturedness() float32 {
	if m != nil && m.StrictMinTexturedness != nil {
		return *m.StrictMinTexturedness
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_StrictMinTexturedness
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetLooseNearZeroMotion() float32 {
	if m != nil && m.LooseNearZeroMotion != nil {
		return *m.LooseNearZeroMotion
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_LooseNearZeroMotion
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetOverlayMinRatio() float32 {
	if m != nil && m.OverlayMinRatio != nil {
		return *m.OverlayMinRatio
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_OverlayMinRatio
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) GetOverlayMinFeatures() float32 {
	if m != nil && m.OverlayMinFeatures != nil {
		return *m.OverlayMinFeatures
	}
	return Default_MotionEstimationOptions_OverlayDetectionOptions_OverlayMinFeatures
}

type MotionEstimationOptions_ShotBoundaryOptions struct {
	MotionConsistencyThreshold     *float32 `protobuf:"fixed32,1,opt,name=motion_consistency_threshold,json=motionConsistencyThreshold,def=0.02" json:"motion_consistency_threshold,omitempty"`
	AppearanceConsistencyThreshold *float32 `protobuf:"fixed32,2,opt,name=appearance_consistency_threshold,json=appearanceConsistencyThreshold,def=0.075" json:"appearance_consistency_threshold,omitempty"`
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) Reset() {
	*m = MotionEstimationOptions_ShotBoundaryOptions{}
}
func (*MotionEstimationOptions_ShotBoundaryOptions) ProtoMessage() {}
func (*MotionEstimationOptions_ShotBoundaryOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b546c7786b5e93af, []int{0, 10}
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionEstimationOptions_ShotBoundaryOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionEstimationOptions_ShotBoundaryOptions.Merge(m, src)
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) XXX_Size() int {
	return m.Size()
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionEstimationOptions_ShotBoundaryOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MotionEstimationOptions_ShotBoundaryOptions proto.InternalMessageInfo

const Default_MotionEstimationOptions_ShotBoundaryOptions_MotionConsistencyThreshold float32 = 0.02
const Default_MotionEstimationOptions_ShotBoundaryOptions_AppearanceConsistencyThreshold float32 = 0.075

func (m *MotionEstimationOptions_ShotBoundaryOptions) GetMotionConsistencyThreshold() float32 {
	if m != nil && m.MotionConsistencyThreshold != nil {
		return *m.MotionConsistencyThreshold
	}
	return Default_MotionEstimationOptions_ShotBoundaryOptions_MotionConsistencyThreshold
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) GetAppearanceConsistencyThreshold() float32 {
	if m != nil && m.AppearanceConsistencyThreshold != nil {
		return *m.AppearanceConsistencyThreshold
	}
	return Default_MotionEstimationOptions_ShotBoundaryOptions_AppearanceConsistencyThreshold
}

func init() {
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_LinearSimilarityEstimation", MotionEstimationOptions_LinearSimilarityEstimation_name, MotionEstimationOptions_LinearSimilarityEstimation_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_AffineEstimation", MotionEstimationOptions_AffineEstimation_name, MotionEstimationOptions_AffineEstimation_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_HomographyEstimation", MotionEstimationOptions_HomographyEstimation_name, MotionEstimationOptions_HomographyEstimation_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_MixtureHomographyEstimation", MotionEstimationOptions_MixtureHomographyEstimation_name, MotionEstimationOptions_MixtureHomographyEstimation_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_EstimationPolicy", MotionEstimationOptions_EstimationPolicy_name, MotionEstimationOptions_EstimationPolicy_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_MixtureModelMode", MotionEstimationOptions_MixtureModelMode_name, MotionEstimationOptions_MixtureModelMode_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_IRLSWeightFilter", MotionEstimationOptions_IRLSWeightFilter_name, MotionEstimationOptions_IRLSWeightFilter_value)
	proto.RegisterEnum("mediapipe.MotionEstimationOptions_HomographyIrlsWeightInitialization", MotionEstimationOptions_HomographyIrlsWeightInitialization_name, MotionEstimationOptions_HomographyIrlsWeightInitialization_value)
	proto.RegisterType((*MotionEstimationOptions)(nil), "mediapipe.MotionEstimationOptions")
	proto.RegisterType((*MotionEstimationOptions_IrlsOutlierInitialization)(nil), "mediapipe.MotionEstimationOptions.IrlsOutlierInitialization")
	proto.RegisterType((*MotionEstimationOptions_LongFeatureInitialization)(nil), "mediapipe.MotionEstimationOptions.LongFeatureInitialization")
	proto.RegisterType((*MotionEstimationOptions_IrlsMaskOptions)(nil), "mediapipe.MotionEstimationOptions.IrlsMaskOptions")
	proto.RegisterType((*MotionEstimationOptions_JointTrackEstimationOptions)(nil), "mediapipe.MotionEstimationOptions.JointTrackEstimationOptions")
	proto.RegisterType((*MotionEstimationOptions_LongFeatureBiasOptions)(nil), "mediapipe.MotionEstimationOptions.LongFeatureBiasOptions")
	proto.RegisterType((*MotionEstimationOptions_TranslationBounds)(nil), "mediapipe.MotionEstimationOptions.TranslationBounds")
	proto.RegisterType((*MotionEstimationOptions_SimilarityBounds)(nil), "mediapipe.MotionEstimationOptions.SimilarityBounds")
	proto.RegisterType((*MotionEstimationOptions_HomographyBounds)(nil), "mediapipe.MotionEstimationOptions.HomographyBounds")
	proto.RegisterType((*MotionEstimationOptions_MixtureHomographyBounds)(nil), "mediapipe.MotionEstimationOptions.MixtureHomographyBounds")
	proto.RegisterType((*MotionEstimationOptions_OverlayDetectionOptions)(nil), "mediapipe.MotionEstimationOptions.OverlayDetectionOptions")
	proto.RegisterType((*MotionEstimationOptions_ShotBoundaryOptions)(nil), "mediapipe.MotionEstimationOptions.ShotBoundaryOptions")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/motion_estimation.proto", fileDescriptor_b546c7786b5e93af)
}

var fileDescriptor_b546c7786b5e93af = []byte{
	// 3550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x5a, 0xcb, 0x6f, 0x1b, 0x49,
	0x7a, 0x57, 0x53, 0x92, 0x2d, 0x7f, 0x92, 0xad, 0x56, 0xe9, 0xd5, 0x22, 0x6d, 0x5a, 0x23, 0xdb,
	0x3b, 0x1e, 0xef, 0x8e, 0x44, 0x3d, 0xe8, 0x87, 0xe6, 0x49, 0x49, 0x94, 0x87, 0x6b, 0x3e, 0x84,
	0x22, 0xbd, 0x9e, 0x2c, 0x90, 0x34, 0xda, 0x64, 0x89, 0x6c, 0xbb, 0x1f, 0x4c, 0x57, 0x53, 0x96,
	0x8c, 0x3d, 0x04, 0xc8, 0x6d, 0x4f, 0x01, 0x82, 0x3d, 0x06, 0xc8, 0x31, 0x41, 0x80, 0x24, 0xb7,
	0x04, 0xb9, 0xe5, 0xb6, 0xc7, 0x39, 0xee, 0x29, 0xc8, 0x78, 0x2e, 0x39, 0xee, 0x9f, 0x10, 0xd4,
	0xa3, 0xbb, 0x8b, 0xaf, 0x59, 0xce, 0x5e, 0x04, 0xbb, 0xbe, 0xdf, 0xf7, 0xa8, 0xaf, 0xbe, 0xaa,
	0xef, 0xd1, 0x84, 0x1d, 0x97, 0xb4, 0x6c, 0xab, 0x6b, 0x77, 0xc9, 0x4e, 0x2f, 0xb4, 0x9d, 0x9d,
	0x30, 0xb0, 0x9a, 0x6f, 0x6d, 0xaf, 0xbd, 0xe3, 0xfa, 0xa1, 0xed, 0x7b, 0x26, 0xa1, 0xa1, 0xed,
	0x5a, 0xec, 0x9f, 0xdb, 0xdd, 0xc0, 0x0f, 0x7d, 0x74, 0x23, 0x66, 0xd8, 0xfa, 0xef, 0x12, 0xac,
	0x57, 0x38, 0xac, 0x18, 0xa3, 0x6a, 0x5d, 0xf6, 0x97, 0xa2, 0xaf, 0x61, 0x43, 0xb2, 0x12, 0x33,
	0x0c, 0x2c, 0x8f, 0x3a, 0x9c, 0x6c, 0xda, 0x81, 0x43, 0x0d, 0x6d, 0x53, 0x7b, 0x38, 0x77, 0x38,
	0x13, 0x06, 0x3d, 0x82, 0xd7, 0x23, 0x58, 0x23, 0x41, 0x95, 0x02, 0x87, 0xa2, 0xbf, 0xd7, 0xe0,
	0xb6, 0x63, 0x7b, 0xc4, 0x0a, 0x4c, 0x6a, 0xbb, 0xb6, 0x63, 0x05, 0x76, 0x78, 0xa5, 0xd8, 0x63,
	0x4c, 0x6f, 0x6a, 0x0f, 0x6f, 0xed, 0x7d, 0xb1, 0x1d, 0x1b, 0xb4, 0x3d, 0xc6, 0x98, 0xed, 0x32,
	0x17, 0x53, 0x8f, 0xa5, 0x24, 0x88, 0x43, 0x54, 0xac, 0x37, 0x4a, 0x95, 0x42, 0xa3, 0x54, 0xab,
	0x9a, 0xe5, 0xba, 0x59, 0xc2, 0xe5, 0x3a, 0x4e, 0x3b, 0x63, 0xf1, 0xe8, 0x12, 0x96, 0xac, 0xf3,
	0x73, 0xdb, 0x23, 0xaa, 0x25, 0x59, 0x6e, 0xc9, 0xfe, 0x04, 0x96, 0x14, 0x38, 0xaf, 0xa2, 0x7f,
	0x4d, 0xd1, 0x5f, 0x38, 0x3d, 0x2d, 0x55, 0x8b, 0x66, 0xb5, 0x56, 0x2d, 0x62, 0xdd, 0x1a, 0x40,
	0xa2, 0xbf, 0xd5, 0x60, 0xb5, 0xe3, 0xbb, 0x7e, 0x3b, 0xb0, 0xba, 0x9d, 0x3e, 0x47, 0xcc, 0x72,
	0xf5, 0x4f, 0x26, 0x50, 0xff, 0x4d, 0xcc, 0xaf, 0x98, 0xb0, 0xaa, 0x98, 0xf0, 0x4d, 0xad, 0x52,
	0x7b, 0x2e, 0xbc, 0xb0, 0xd2, 0x19, 0x01, 0x46, 0xbf, 0x82, 0xfb, 0xaa, 0x11, 0x97, 0x56, 0x33,
	0x34, 0x5b, 0xc4, 0xf3, 0x5d, 0xdb, 0xb3, 0x42, 0x3f, 0x30, 0x69, 0xd3, 0x72, 0x6c, 0xaf, 0x6d,
	0xe4, 0xf9, 0x11, 0xcf, 0x9e, 0x5b, 0x0e, 0x25, 0xf8, 0x23, 0x45, 0x14, 0xe3, 0x38, 0x49, 0x18,
	0xea, 0x02, 0x8f, 0x5e, 0xc0, 0xdd, 0x1e, 0x25, 0x52, 0xe0, 0xe8, 0x6d, 0x3e, 0x56, 0xa2, 0xe6,
	0x76, 0x8f, 0x12, 0x2e, 0x6a, 0xd4, 0x8e, 0xd0, 0x5f, 0xc2, 0x27, 0x4c, 0x58, 0xc7, 0x6e, 0x77,
	0x08, 0x0d, 0x4d, 0xab, 0xd9, 0xec, 0x05, 0x56, 0xf3, 0xca, 0x3c, 0xf7, 0x03, 0xd3, 0xf3, 0x03,
	0xd7, 0x72, 0x4c, 0xf2, 0xd7, 0x3d, 0x8e, 0xa5, 0xc6, 0x13, 0x45, 0xec, 0xfd, 0x1e, 0x25, 0xdf,
	0x08, 0xae, 0x82, 0x64, 0x3a, 0xf5, 0x83, 0x2a, 0x67, 0x29, 0x46, 0x1c, 0xa8, 0x06, 0x5b, 0x8a,
	0x85, 0x5d, 0x12, 0xd0, 0x2e, 0x69, 0x86, 0xf6, 0x05, 0x31, 0x03, 0xd2, 0xee, 0xb1, 0x90, 0x79,
	0x4f, 0x02, 0xe3, 0x8b, 0x4d, 0xed, 0x61, 0xea, 0x50, 0xcb, 0xe1, 0xcd, 0x04, 0x7c, 0x96, 0x60,
	0x71, 0x02, 0x45, 0xbf, 0xd3, 0x60, 0xc3, 0xb5, 0x2f, 0xc7, 0xec, 0x7b, 0x81, 0x1f, 0xef, 0x97,
	0x13, 0x1c, 0x6f, 0xc5, 0xbe, 0x0c, 0x7b, 0x01, 0x19, 0x79, 0xca, 0x1b, 0x43, 0xa7, 0x5c, 0x29,
	0x7d, 0x2b, 0x62, 0x6d, 0xdd, 0xb5, 0x2f, 0x47, 0xfa, 0xf1, 0x01, 0x2c, 0x78, 0x3d, 0xd7, 0x74,
	0x85, 0x58, 0x6a, 0xdc, 0xdc, 0xd4, 0x1e, 0xce, 0x1e, 0xa6, 0x76, 0x73, 0x78, 0xde, 0xeb, 0xb9,
	0x52, 0x1b, 0x45, 0x3b, 0xb0, 0x24, 0x21, 0x66, 0xe0, 0xbf, 0x33, 0xa9, 0xdd, 0x76, 0x2d, 0xe3,
	0x16, 0xdf, 0xfe, 0x74, 0x6e, 0x7b, 0x17, 0x2f, 0x4a, 0x2a, 0xf6, 0xdf, 0xd5, 0x19, 0x0d, 0x3d,
	0x81, 0xe5, 0x98, 0x41, 0xf1, 0xd8, 0x22, 0x67, 0xb9, 0x96, 0xdb, 0xce, 0xe5, 0x72, 0xbb, 0x18,
	0x45, 0x5c, 0x8a, 0xa3, 0xbe, 0x82, 0xf4, 0x08, 0x46, 0xd3, 0x21, 0x17, 0xc4, 0xa1, 0xc6, 0x23,
	0xe1, 0xf1, 0x7d, 0x6c, 0x0c, 0xb3, 0x96, 0x39, 0x04, 0x7d, 0x01, 0xc6, 0x28, 0x01, 0xaf, 0x2d,
	0x4a, 0x8c, 0x9f, 0x0b, 0x8b, 0xf7, 0xb6, 0xf7, 0xf0, 0xda, 0xb0, 0x80, 0x23, 0x8b, 0x12, 0xf4,
	0x39, 0x3f, 0x27, 0xc1, 0x4e, 0x4d, 0xcb, 0xb3, 0x9c, 0x2b, 0x6a, 0x53, 0xa1, 0xdf, 0xf8, 0x05,
	0xf7, 0x8e, 0xa6, 0x70, 0xd3, 0x82, 0x44, 0x70, 0xed, 0xe8, 0x1e, 0xcc, 0xb3, 0xe7, 0xcf, 0x0c,
	0xfc, 0x9e, 0xd7, 0xa2, 0xc6, 0x52, 0xec, 0x4d, 0x60, 0xcb, 0x98, 0xaf, 0xa2, 0x4f, 0x41, 0xe7,
	0xa0, 0x6e, 0x60, 0xcb, 0xeb, 0x44, 0x8c, 0xbd, 0xc8, 0x97, 0x7b, 0xf8, 0x16, 0x23, 0x9e, 0x31,
	0x1a, 0xbb, 0x39, 0x04, 0x95, 0x20, 0xcb, 0xe1, 0xf2, 0xb9, 0x76, 0xad, 0xb6, 0x67, 0x87, 0xbd,
	0x16, 0x31, 0xcf, 0x03, 0xab, 0xc9, 0xc3, 0xe7, 0x2e, 0x67, 0x9e, 0xc9, 0x6d, 0xe7, 0x9e, 0xe2,
	0x0c, 0xc3, 0x8a, 0xe8, 0xa9, 0x44, 0xc8, 0x53, 0x09, 0x44, 0x47, 0x90, 0x11, 0xa2, 0xe4, 0x0e,
	0x23, 0x09, 0xd2, 0x88, 0x13, 0x61, 0xc4, 0xee, 0x76, 0x1e, 0x1b, 0x5c, 0x8c, 0x80, 0x45, 0xec,
	0xc2, 0x9c, 0xa2, 0x94, 0xf1, 0x8e, 0xd8, 0xed, 0x4e, 0xc8, 0x76, 0x41, 0x6c, 0xcf, 0x0e, 0x6d,
	0xcb, 0xb1, 0xdf, 0x93, 0x96, 0xf1, 0xb1, 0xfa, 0x2a, 0x6c, 0x30, 0xe4, 0x2b, 0x01, 0x3c, 0xeb,
	0xc3, 0xa1, 0x32, 0xdc, 0x3d, 0xb7, 0x9d, 0x90, 0x04, 0xa6, 0xb2, 0x6a, 0xaa, 0x92, 0x8d, 0x63,
	0x55, 0xd4, 0x6d, 0x81, 0x2e, 0x25, 0xe0, 0x52, 0x22, 0x1b, 0xb9, 0xb0, 0xcc, 0x59, 0x63, 0x59,
	0xe2, 0x5e, 0x3d, 0xdd, 0xd4, 0x1e, 0xce, 0xef, 0x7d, 0x3e, 0xc1, 0xbd, 0x62, 0xc2, 0x6a, 0xbd,
	0xd0, 0xb1, 0x15, 0x15, 0x1c, 0x80, 0x11, 0x13, 0xdc, 0xbf, 0x86, 0x4a, 0x70, 0xe7, 0x9c, 0x58,
	0xdc, 0x85, 0x2d, 0xe2, 0x51, 0x96, 0xb5, 0xc4, 0xa3, 0x13, 0x29, 0xfe, 0x52, 0x35, 0x3d, 0x23,
	0xb1, 0x27, 0x02, 0x5a, 0x55, 0x91, 0x68, 0x1b, 0x96, 0x22, 0x51, 0xae, 0x45, 0xdf, 0x9a, 0xd4,
	0x7e, 0x4f, 0x8c, 0xaf, 0xe2, 0xb8, 0x59, 0x94, 0xc4, 0x8a, 0x45, 0xdf, 0xd6, 0xed, 0xf7, 0x04,
	0xfd, 0x06, 0x32, 0x8e, 0xef, 0xb5, 0xcd, 0x88, 0x69, 0x60, 0xc7, 0x47, 0x13, 0xef, 0xb8, 0xec,
	0x7b, 0xed, 0x53, 0x21, 0x64, 0x60, 0xc7, 0x1b, 0xce, 0x38, 0x12, 0xfa, 0x2b, 0x58, 0x12, 0x01,
	0xc4, 0x4c, 0xf5, 0x85, 0x24, 0xe3, 0x19, 0xd7, 0xb9, 0x37, 0xa1, 0x97, 0xd9, 0x4e, 0xe4, 0xff,
	0xf1, 0xa2, 0xdd, 0xbf, 0x80, 0x42, 0x58, 0x7b, 0xe3, 0xdb, 0x5e, 0x68, 0xf2, 0x22, 0x45, 0x7d,
	0x22, 0x3f, 0xe3, 0x4a, 0x26, 0x79, 0x22, 0x7f, 0xc9, 0x04, 0x34, 0x18, 0xff, 0x10, 0x0d, 0xaf,
	0xbc, 0x19, 0x41, 0x44, 0x21, 0x6c, 0xf4, 0xf9, 0xf4, 0xb5, 0x6d, 0xd1, 0x78, 0x77, 0x5f, 0x73,
	0xc5, 0xcf, 0x7e, 0x9a, 0x47, 0x8f, 0x6c, 0x8b, 0x46, 0x3a, 0xd7, 0x9c, 0x91, 0xeb, 0xe8, 0x02,
	0x96, 0x92, 0xfd, 0x99, 0x5d, 0xdf, 0xb1, 0x9b, 0x57, 0xc6, 0xe1, 0xc4, 0x75, 0x46, 0xb2, 0x72,
	0xc6, 0x59, 0x0f, 0x57, 0x4a, 0xd5, 0x93, 0xe2, 0x59, 0xb1, 0x7a, 0x52, 0xac, 0x36, 0xcc, 0xb3,
	0x02, 0x2e, 0x94, 0xcb, 0xc5, 0x32, 0xd6, 0xc9, 0x00, 0x0e, 0xe5, 0x00, 0x35, 0xfd, 0x0b, 0x12,
	0x58, 0x6d, 0x62, 0xb6, 0x03, 0xbb, 0x25, 0x42, 0x6e, 0x3f, 0x0e, 0x39, 0x3d, 0xa2, 0x3e, 0x0f,
	0xec, 0x16, 0x8f, 0xb9, 0x4b, 0x88, 0x5e, 0x6a, 0xd3, 0xf5, 0x5b, 0xc4, 0xe1, 0x7f, 0x8d, 0xf5,
	0x89, 0x4d, 0x95, 0xef, 0x48, 0x85, 0xf1, 0xb2, 0x3f, 0x87, 0xab, 0xf5, 0x17, 0xc5, 0x57, 0x26,
	0xae, 0x35, 0x44, 0xb2, 0xaa, 0x94, 0xbe, 0x6d, 0xbc, 0xc4, 0x45, 0xac, 0xbb, 0x03, 0x40, 0xf4,
	0x2d, 0x7c, 0xcc, 0xd2, 0xbc, 0xef, 0x39, 0x57, 0xa6, 0x63, 0x7b, 0xac, 0x4c, 0x34, 0x6d, 0x8f,
	0xdd, 0x52, 0xca, 0x53, 0x7d, 0x92, 0x4e, 0x8d, 0x6b, 0x4a, 0x92, 0xff, 0xa8, 0x47, 0x49, 0xcd,
	0x73, 0xae, 0xca, 0xb6, 0x57, 0xb7, 0xdd, 0x92, 0x60, 0x38, 0xf5, 0x83, 0x24, 0x05, 0xa2, 0x2f,
	0xc1, 0xe8, 0x17, 0x68, 0x86, 0x9d, 0x80, 0xd0, 0x8e, 0xef, 0xb4, 0x8c, 0x15, 0xfe, 0x0e, 0xce,
	0xb2, 0x2c, 0xb5, 0x8f, 0x57, 0x1d, 0x45, 0x48, 0x23, 0xc2, 0xa0, 0x2e, 0x6c, 0xd0, 0xd0, 0x7a,
	0xed, 0xf4, 0xd7, 0xbe, 0xaf, 0xc5, 0xbb, 0xbf, 0xc9, 0x63, 0xe6, 0x60, 0x02, 0xd7, 0x28, 0x25,
	0xf1, 0x11, 0xe7, 0xc5, 0xeb, 0x42, 0xec, 0x10, 0x01, 0xb9, 0x60, 0x48, 0x8d, 0x4a, 0xb1, 0x2c,
	0x15, 0x7e, 0xc4, 0x15, 0x4e, 0x72, 0x16, 0x49, 0xc9, 0x2b, 0xf5, 0xad, 0x09, 0xa1, 0x83, 0xeb,
	0x8a, 0x3a, 0xa5, 0x66, 0x91, 0xea, 0xe6, 0x27, 0x56, 0x97, 0x78, 0xbc, 0x5f, 0xdd, 0xe0, 0x3a,
	0xab, 0x7d, 0x37, 0xa5, 0xbe, 0x28, 0xd6, 0x86, 0xf5, 0x6e, 0x71, 0xbd, 0x87, 0x7f, 0x4e, 0x9d,
	0x24, 0xd5, 0xdf, 0x11, 0x3a, 0xc6, 0x90, 0xd1, 0x33, 0x58, 0xa5, 0x61, 0x60, 0x37, 0x43, 0x33,
	0xbe, 0x22, 0x22, 0x35, 0x7e, 0x22, 0x42, 0x62, 0x77, 0x7b, 0x7f, 0x7f, 0x1f, 0x2f, 0x0b, 0xcc,
	0xb1, 0x84, 0x88, 0xbc, 0x78, 0x04, 0x19, 0xc7, 0x7a, 0x4d, 0x1c, 0x93, 0xb8, 0xdd, 0xf0, 0x8a,
	0xa5, 0x56, 0x97, 0x50, 0xd3, 0xa2, 0xe6, 0x85, 0xe5, 0xd8, 0x2d, 0x63, 0x4d, 0x6d, 0x88, 0x38,
	0xb0, 0xc8, 0x70, 0xa7, 0x1c, 0x56, 0xa0, 0xbf, 0x62, 0x20, 0x94, 0x4b, 0x92, 0x41, 0x72, 0x33,
	0x8d, 0x38, 0xbb, 0xe7, 0xe3, 0x74, 0x10, 0x5f, 0xcd, 0x4f, 0xe0, 0x26, 0xed, 0x5a, 0xec, 0x89,
	0x96, 0x45, 0xd9, 0x46, 0x8c, 0xde, 0xc5, 0x0b, 0x92, 0x24, 0x4a, 0xb2, 0xa7, 0xb0, 0x16, 0x12,
	0xb7, 0xeb, 0x07, 0x96, 0x23, 0xf2, 0x6c, 0xcb, 0xb6, 0x5c, 0x12, 0x92, 0xc0, 0x48, 0x8b, 0xbb,
	0xbf, 0x97, 0xc3, 0x2b, 0x11, 0x82, 0xbd, 0xd4, 0x27, 0x92, 0x8e, 0x1e, 0xc2, 0xad, 0x98, 0x53,
	0x68, 0xc9, 0x88, 0x3a, 0x2c, 0x8f, 0x6f, 0x46, 0x04, 0xa1, 0xe3, 0x63, 0xb8, 0x19, 0x6d, 0x40,
	0x00, 0x6f, 0x73, 0x60, 0x6a, 0x3f, 0x87, 0x17, 0x24, 0x41, 0x00, 0x3f, 0x81, 0x9b, 0x32, 0xfd,
	0xe7, 0xcd, 0xd0, 0xea, 0x52, 0xe3, 0x8e, 0x9a, 0x31, 0xe7, 0x05, 0x2d, 0xdf, 0xb0, 0xba, 0x14,
	0x1d, 0x41, 0x9a, 0x3b, 0xd3, 0x6c, 0xfa, 0xde, 0xb9, 0xdd, 0x22, 0x5e, 0x93, 0xc8, 0x12, 0x81,
	0x75, 0x21, 0x39, 0xc5, 0xaf, 0x06, 0xc7, 0x1d, 0xc7, 0xb0, 0x57, 0x11, 0x0a, 0x15, 0x20, 0x1d,
	0x10, 0x4a, 0x42, 0x55, 0x46, 0x72, 0xdf, 0x77, 0xa3, 0xe2, 0xeb, 0x00, 0x1b, 0x1c, 0x96, 0x88,
	0x48, 0x2e, 0x3c, 0x05, 0xa4, 0x54, 0x27, 0xa6, 0xb0, 0xd0, 0xb8, 0x37, 0xf1, 0x23, 0xc8, 0x3a,
	0x2e, 0x61, 0xd0, 0x29, 0x67, 0x3d, 0xd4, 0xd9, 0x8a, 0x79, 0x5a, 0x2a, 0x37, 0x8a, 0x58, 0x76,
	0x84, 0x49, 0xb9, 0x24, 0x30, 0x68, 0x0f, 0x96, 0x58, 0x90, 0x39, 0xd6, 0x95, 0xd9, 0x22, 0x21,
	0x11, 0xe5, 0xde, 0x7d, 0xd5, 0x55, 0xba, 0xa4, 0x9f, 0x44, 0x64, 0xf4, 0x35, 0x64, 0x22, 0x9e,
	0xb8, 0x7c, 0x6d, 0x76, 0x7a, 0x9e, 0xac, 0x2d, 0x1e, 0x88, 0x1a, 0xf6, 0x29, 0x36, 0x24, 0x2a,
	0xaa, 0x60, 0x8f, 0x19, 0x86, 0x07, 0xd5, 0x05, 0x6c, 0x0c, 0x69, 0x8d, 0xf3, 0xe1, 0xcf, 0x26,
	0xbe, 0x83, 0xb5, 0x01, 0xcb, 0xa2, 0x84, 0xb8, 0xee, 0x8f, 0x26, 0xa0, 0x37, 0xb0, 0x4a, 0x3b,
	0x7e, 0x28, 0x6e, 0xbb, 0x15, 0x5c, 0xc5, 0x3a, 0x3f, 0xe7, 0x3a, 0x1f, 0x4f, 0xf2, 0xbc, 0x75,
	0xfc, 0xf0, 0x48, 0xb2, 0x47, 0xfa, 0x96, 0xe9, 0xf0, 0x22, 0x3a, 0x86, 0x8c, 0xdf, 0x0b, 0xbb,
	0xbd, 0xd0, 0x0c, 0x08, 0x6b, 0xc3, 0x07, 0x6a, 0xcf, 0x87, 0x6a, 0x58, 0x09, 0x20, 0x16, 0x38,
	0xb5, 0xec, 0xfc, 0x4f, 0x0d, 0x1e, 0x28, 0xaf, 0x94, 0x1a, 0x1f, 0x03, 0x75, 0xd9, 0xa7, 0x3c,
	0x4e, 0x8a, 0x3f, 0xe9, 0xc5, 0x4c, 0x34, 0xf5, 0x57, 0x61, 0x87, 0x59, 0x1e, 0x39, 0xaf, 0x8a,
	0xa5, 0xe7, 0xdf, 0x34, 0xcc, 0xb3, 0x22, 0x2e, 0x55, 0x8a, 0x2c, 0x86, 0x9e, 0x17, 0x5e, 0xd6,
	0xeb, 0xa5, 0x42, 0x15, 0x2b, 0xbd, 0xeb, 0x38, 0x19, 0x71, 0x13, 0xc2, 0xd2, 0xab, 0x93, 0xe3,
	0xe5, 0xab, 0xb1, 0xad, 0x6c, 0xfa, 0x26, 0xa3, 0xbe, 0xa4, 0xa4, 0x9c, 0x63, 0xf5, 0x2a, 0x3a,
	0x81, 0x4c, 0xcb, 0x77, 0x2d, 0xdb, 0x33, 0x1d, 0xdb, 0xb5, 0xc3, 0xc8, 0x5d, 0xd1, 0x2c, 0xa0,
	0xa0, 0x86, 0xa4, 0x21, 0x90, 0x65, 0x01, 0x64, 0x16, 0x44, 0x23, 0x80, 0x06, 0xdc, 0x6b, 0x11,
	0xd6, 0x4c, 0x5c, 0x58, 0x21, 0x31, 0xa3, 0xe7, 0x7e, 0x70, 0x0c, 0x65, 0xec, 0xa8, 0xd2, 0x36,
	0x13, 0x8e, 0xba, 0x78, 0xbb, 0x07, 0x1c, 0xc7, 0x1e, 0x88, 0x6e, 0xe0, 0xbf, 0x21, 0xcd, 0x50,
	0xbc, 0xb5, 0x52, 0x22, 0x35, 0x5b, 0xfe, 0x3b, 0xcf, 0x38, 0x50, 0x85, 0xad, 0x4b, 0x20, 0x7f,
	0x6e, 0x85, 0x20, 0x7a, 0xe2, 0xbf, 0xf3, 0x58, 0xbf, 0x1a, 0x0f, 0xb3, 0x92, 0xf4, 0x6a, 0xa4,
	0x18, 0xf3, 0xd1, 0xb5, 0xdf, 0xff, 0xcf, 0xdd, 0x29, 0x43, 0xc3, 0x28, 0x82, 0x24, 0xc9, 0x32,
	0xfd, 0x1b, 0xd8, 0x18, 0xdb, 0x3b, 0xa0, 0x7b, 0x70, 0x23, 0xb2, 0xbd, 0x25, 0x47, 0x62, 0xd2,
	0x90, 0x64, 0x1d, 0x65, 0xe0, 0x9a, 0x6c, 0x17, 0x53, 0xfc, 0x6a, 0x4e, 0xef, 0xe6, 0x72, 0x58,
	0x2e, 0xa1, 0x3b, 0x70, 0xad, 0xd9, 0x0b, 0xfd, 0xf3, 0x73, 0x3e, 0x0b, 0x8b, 0x8b, 0x12, 0xb9,
	0x98, 0xfe, 0x57, 0x0d, 0x36, 0xc6, 0x16, 0xf2, 0x93, 0xa9, 0x7f, 0x0a, 0xab, 0x2e, 0x3b, 0x56,
	0xe2, 0xb5, 0xc3, 0x8e, 0xd9, 0x25, 0x41, 0x93, 0x78, 0xa1, 0xed, 0x10, 0x6e, 0x0d, 0xcf, 0x24,
	0xcf, 0xf2, 0x78, 0xd9, 0xb5, 0xbd, 0x32, 0x47, 0x9c, 0xc5, 0x00, 0xb4, 0x07, 0xcb, 0xbd, 0xae,
	0x0c, 0x77, 0xb7, 0xe7, 0x84, 0x76, 0x97, 0xb9, 0x40, 0x1a, 0xaa, 0xe5, 0x31, 0x8a, 0xa8, 0x95,
	0x98, 0x98, 0xfe, 0x8f, 0x14, 0x2c, 0x0e, 0x74, 0x01, 0x68, 0x03, 0x66, 0x5b, 0xa4, 0x69, 0x5d,
	0x49, 0x8d, 0xd3, 0xb9, 0xed, 0x27, 0x58, 0xac, 0xa0, 0x9f, 0xc1, 0x82, 0xac, 0xce, 0x68, 0xd3,
	0x0f, 0x88, 0x94, 0xcd, 0x5f, 0xea, 0x79, 0x41, 0xa8, 0xb3, 0x75, 0xb4, 0x05, 0xc0, 0x1a, 0x7c,
	0x89, 0x9a, 0x49, 0x9a, 0xe9, 0x1b, 0x6c, 0x59, 0x60, 0x9e, 0xc0, 0x0a, 0xdb, 0xa8, 0x5a, 0xae,
	0xf1, 0xa8, 0x9f, 0x4d, 0x1c, 0xbb, 0x87, 0x91, 0x6b, 0x7b, 0x4a, 0xe9, 0xc5, 0x63, 0xff, 0x33,
	0x58, 0xef, 0xab, 0xf1, 0x1c, 0xe2, 0xb5, 0x4c, 0xcb, 0xe9, 0x76, 0x2c, 0x5e, 0x74, 0x4a, 0x8b,
	0x57, 0x15, 0xcc, 0x11, 0x83, 0x14, 0x18, 0x82, 0x65, 0x1e, 0x95, 0x59, 0xf4, 0xfc, 0xb6, 0xd7,
	0x0c, 0x88, 0x45, 0x89, 0x71, 0x3d, 0xb1, 0xd4, 0x50, 0x60, 0xbc, 0xfb, 0x2f, 0x49, 0xd0, 0xa3,
	0x99, 0x39, 0x4d, 0x4f, 0xa5, 0xff, 0x45, 0x83, 0xcc, 0x8f, 0xb4, 0x36, 0xe8, 0x53, 0x58, 0xe2,
	0x93, 0x1c, 0x39, 0x25, 0x60, 0x25, 0xb4, 0x18, 0xc3, 0xce, 0x1e, 0x6a, 0xfb, 0x78, 0xd1, 0xeb,
	0xb9, 0x72, 0x2a, 0xc0, 0x29, 0x2c, 0x53, 0x4b, 0x28, 0x2b, 0x66, 0x5a, 0x44, 0x06, 0x5f, 0x6a,
	0x37, 0x8f, 0x17, 0x04, 0xa1, 0xce, 0xd7, 0xd1, 0x01, 0xa0, 0x24, 0xf9, 0xbb, 0xbe, 0x1f, 0x76,
	0xd8, 0x85, 0x9f, 0x56, 0xa3, 0x69, 0x29, 0x2e, 0x02, 0x22, 0x7a, 0xfa, 0xdf, 0x66, 0x61, 0x6d,
	0x74, 0x3f, 0x84, 0xee, 0xc3, 0x42, 0xe8, 0x87, 0x96, 0x13, 0x0d, 0x49, 0xc4, 0xc8, 0x49, 0xdb,
	0xc5, 0xf3, 0x7c, 0x59, 0x0e, 0x49, 0x1e, 0x80, 0x3c, 0x60, 0xde, 0x8d, 0xf1, 0x8d, 0x88, 0x60,
	0x7c, 0x8a, 0x41, 0x10, 0x98, 0x4c, 0x16, 0x20, 0xbe, 0xb8, 0x7a, 0x02, 0xa7, 0x84, 0xd0, 0xbc,
	0x24, 0x70, 0xdc, 0x63, 0x58, 0x65, 0xde, 0xe1, 0x8f, 0x96, 0xff, 0x9a, 0x92, 0xe0, 0x42, 0xce,
	0x06, 0xa7, 0xe3, 0xbe, 0x67, 0xd9, 0xeb, 0xb9, 0xfc, 0x2a, 0x2b, 0x64, 0x94, 0x87, 0x55, 0xd7,
	0xba, 0x14, 0x7c, 0xcd, 0x8e, 0xe5, 0xb5, 0x89, 0x19, 0x30, 0x92, 0x8c, 0x31, 0xc6, 0x87, 0x5c,
	0xeb, 0x92, 0xf1, 0x1d, 0x73, 0x32, 0x66, 0x54, 0xb4, 0x0b, 0x48, 0x5a, 0xaf, 0xe4, 0x04, 0x19,
	0x69, 0xfc, 0xb4, 0x75, 0x41, 0x4e, 0x9e, 0x67, 0xb4, 0x09, 0xc0, 0xfb, 0x4e, 0x1a, 0xb6, 0xc8,
	0x05, 0x9f, 0x08, 0xa6, 0x98, 0x53, 0x6e, 0xb0, 0xc5, 0x3a, 0x5b, 0x43, 0xdb, 0xa0, 0xb3, 0xd7,
	0x3a, 0xaa, 0xf7, 0xf8, 0x7e, 0xd5, 0xae, 0xe7, 0x56, 0x8f, 0x92, 0xba, 0x20, 0xf2, 0x3d, 0x7f,
	0x04, 0x37, 0x92, 0x2a, 0xf2, 0x7a, 0x5c, 0x17, 0x1e, 0xe0, 0xb9, 0xf6, 0xd8, 0xf2, 0x71, 0x2e,
	0x86, 0xed, 0x0d, 0x94, 0x8f, 0xf7, 0x60, 0xbe, 0xe9, 0x3b, 0x7e, 0x20, 0x81, 0x37, 0xc4, 0xfe,
	0xf7, 0x72, 0x18, 0xf8, 0xb2, 0x00, 0x1d, 0xc0, 0x0a, 0xef, 0xa4, 0x45, 0xfb, 0x9e, 0x54, 0x58,
	0x20, 0xbc, 0xbc, 0x9f, 0xc3, 0x88, 0xd1, 0x79, 0x08, 0x27, 0xa5, 0x55, 0x09, 0xb2, 0x0a, 0x97,
	0x52, 0xa2, 0xc5, 0x13, 0xae, 0xf9, 0xc8, 0xac, 0xbd, 0x3c, 0xce, 0xc4, 0x12, 0x92, 0x32, 0x2d,
	0x9e, 0x70, 0x3d, 0x85, 0x55, 0x4a, 0x48, 0x4b, 0xdc, 0x33, 0x6a, 0x9e, 0x07, 0xbe, 0x2b, 0x1c,
	0x75, 0x4b, 0x0d, 0x58, 0xc4, 0x30, 0xfc, 0x92, 0xd1, 0xd3, 0xc0, 0x77, 0x99, 0xb7, 0xd2, 0xff,
	0x90, 0x82, 0xa5, 0xe1, 0xa6, 0xeb, 0x3e, 0x2c, 0xb0, 0x47, 0x43, 0xd6, 0xae, 0xca, 0x85, 0x9a,
	0x77, 0x6d, 0x4f, 0x06, 0x37, 0x45, 0x5f, 0xc1, 0x06, 0x33, 0xd5, 0x64, 0xa1, 0x32, 0x38, 0xa6,
	0x4b, 0xde, 0xd1, 0xdd, 0x3c, 0x5e, 0x63, 0xb0, 0x8a, 0x75, 0x39, 0x30, 0xa0, 0x63, 0xaf, 0x84,
	0xc2, 0xcb, 0x43, 0x40, 0xf1, 0xde, 0x8c, 0x52, 0xd3, 0xaf, 0xbb, 0x11, 0x37, 0x0f, 0x8a, 0xc4,
	0x89, 0x3b, 0xa0, 0x0f, 0x8a, 0x50, 0x72, 0xc6, 0xe3, 0x3c, 0xbe, 0xd5, 0xcf, 0xc9, 0x2a, 0x00,
	0xc6, 0x60, 0x35, 0x9b, 0xc4, 0x21, 0x41, 0xf2, 0x9d, 0x41, 0x9c, 0xea, 0xa2, 0x6b, 0x5d, 0x16,
	0x14, 0x52, 0xfa, 0xbf, 0xa6, 0x41, 0x1f, 0x6a, 0x12, 0x73, 0xb0, 0xc4, 0x7b, 0x73, 0x99, 0xca,
	0x6d, 0xaf, 0xdb, 0x0b, 0xfb, 0xbe, 0xfd, 0x2c, 0x32, 0xb2, 0xc8, 0xdb, 0x25, 0x46, 0x44, 0xfb,
	0xc0, 0x72, 0x49, 0xd4, 0x73, 0xc7, 0x07, 0x9c, 0x4a, 0xae, 0xc6, 0x92, 0x6b, 0x7b, 0xa2, 0xdb,
	0x8e, 0x4f, 0xf5, 0x1e, 0xcc, 0x27, 0x4c, 0x54, 0x6e, 0x8b, 0x45, 0x13, 0xc4, 0x58, 0x76, 0x54,
	0xf3, 0x8e, 0xff, 0x8e, 0x44, 0x13, 0xd5, 0x38, 0x09, 0x3c, 0xc5, 0xc0, 0xd7, 0x45, 0x9b, 0xf6,
	0x00, 0xe6, 0x7b, 0xdd, 0x6e, 0x8c, 0x12, 0x1b, 0x9e, 0xd9, 0x65, 0x81, 0x05, 0x9c, 0x20, 0x60,
	0x3f, 0x87, 0x5b, 0xbc, 0xd0, 0x31, 0x03, 0x3f, 0x14, 0xae, 0xb9, 0xa6, 0x84, 0xe0, 0x4d, 0x4e,
	0xc3, 0x92, 0x84, 0x7e, 0x01, 0xfa, 0xd0, 0x0c, 0x41, 0xdc, 0x37, 0xed, 0x00, 0x2f, 0xda, 0x03,
	0x93, 0x83, 0x3c, 0xac, 0xf2, 0x60, 0x19, 0x62, 0x99, 0x8b, 0x3e, 0x27, 0x2c, 0x33, 0xfa, 0xe0,
	0xc0, 0xe1, 0x33, 0x58, 0x97, 0xad, 0xe9, 0x10, 0xe3, 0x8d, 0x68, 0xab, 0x79, 0x2c, 0xdb, 0xd7,
	0x01, 0xe6, 0xf4, 0xbf, 0x4f, 0x83, 0x3e, 0xd4, 0xec, 0x0e, 0x38, 0x4c, 0x9b, 0xc8, 0x61, 0xa9,
	0x89, 0x1d, 0x36, 0x3d, 0xde, 0x61, 0xfb, 0xb0, 0x24, 0xc0, 0xca, 0x97, 0x15, 0x79, 0x60, 0xe2,
	0xdb, 0xc0, 0x01, 0xd6, 0x39, 0x40, 0xf9, 0x9a, 0x82, 0x0e, 0x61, 0x2d, 0x20, 0x6d, 0x9b, 0x86,
	0x22, 0x20, 0x95, 0xfd, 0xcf, 0x26, 0x1f, 0x22, 0x56, 0x55, 0x48, 0xe2, 0xbc, 0x02, 0x64, 0xb8,
	0xcf, 0xc7, 0x08, 0x88, 0x3d, 0xcf, 0xaf, 0x31, 0x1e, 0x29, 0xa2, 0x3f, 0x70, 0xa3, 0xf1, 0x40,
	0x52, 0x01, 0xec, 0x2b, 0x81, 0x1b, 0x4d, 0x06, 0xd0, 0xb3, 0x71, 0x67, 0x7d, 0x5d, 0x2d, 0x3a,
	0x46, 0x9d, 0x77, 0xfa, 0xb7, 0x29, 0x58, 0x1f, 0x37, 0xa6, 0x18, 0x63, 0x8b, 0x96, 0x54, 0x47,
	0x23, 0x6c, 0xf9, 0x1a, 0x32, 0xfc, 0xbe, 0xb7, 0xde, 0x58, 0xac, 0x82, 0x33, 0xe3, 0xbc, 0xe9,
	0xf8, 0xcd, 0xb7, 0x51, 0xf1, 0xa9, 0xe5, 0xb1, 0xc1, 0x6e, 0xbe, 0x04, 0xc9, 0xb2, 0xf6, 0x88,
	0x43, 0xf8, 0xb7, 0x11, 0x55, 0x82, 0x98, 0x74, 0x48, 0xfe, 0xe9, 0xe8, 0x65, 0x5c, 0x53, 0xf8,
	0xf9, 0x8c, 0x43, 0x72, 0x1f, 0xfe, 0xb8, 0x2f, 0xf8, 0xc1, 0xef, 0xe5, 0x47, 0x3b, 0xe3, 0x9f,
	0xa7, 0x61, 0x7d, 0x4c, 0x3b, 0x89, 0x72, 0x80, 0xe2, 0x3e, 0x37, 0x19, 0xa1, 0x6b, 0xc9, 0x3c,
	0x33, 0xa2, 0xc6, 0x33, 0xf4, 0xc3, 0xf8, 0x2a, 0xf1, 0x6f, 0xcf, 0xef, 0x49, 0xe0, 0xcb, 0x77,
	0x53, 0x7d, 0x87, 0x56, 0x04, 0xa6, 0x4a, 0xac, 0xe0, 0xd7, 0x24, 0xf0, 0xc5, 0xd3, 0x89, 0x4e,
	0xe0, 0xb6, 0xe4, 0x65, 0xae, 0x50, 0x4b, 0x3b, 0x51, 0x17, 0x4c, 0x27, 0x02, 0x36, 0x04, 0xb0,
	0x62, 0x5d, 0x2a, 0x79, 0x45, 0xd4, 0x07, 0xc9, 0x65, 0xe6, 0x25, 0x29, 0xe1, 0xc7, 0xdc, 0xf2,
	0x08, 0xa5, 0x7d, 0xc1, 0x2c, 0x05, 0xd8, 0x5e, 0x43, 0x41, 0xa0, 0xc7, 0xb0, 0xe6, 0xf8, 0x3e,
	0x25, 0xc3, 0xd6, 0xcf, 0x44, 0x55, 0xc3, 0x32, 0x07, 0x0c, 0x98, 0xbe, 0x93, 0x0c, 0x13, 0x98,
	0x56, 0x61, 0xaf, 0x12, 0xbf, 0x8b, 0x92, 0x5a, 0xb1, 0xa5, 0x95, 0x07, 0xb0, 0xa2, 0x32, 0xc4,
	0x49, 0xf0, 0x7a, 0x52, 0xfb, 0x24, 0x2c, 0x51, 0x32, 0x64, 0x3d, 0xc9, 0xf2, 0x88, 0x36, 0x1c,
	0x9d, 0xc2, 0x6d, 0x99, 0x9c, 0x9a, 0xbe, 0x47, 0x6d, 0x1a, 0x12, 0xaf, 0x79, 0xa5, 0x84, 0x81,
	0xa6, 0x94, 0x1e, 0x69, 0x81, 0x3c, 0x4e, 0x80, 0xc9, 0x45, 0xac, 0xc1, 0xa6, 0xd5, 0xed, 0x12,
	0x2b, 0xb0, 0x58, 0x89, 0x30, 0x5a, 0x56, 0x2a, 0xbe, 0x5e, 0x4f, 0xf2, 0x38, 0x9b, 0xc0, 0x47,
	0x09, 0xdc, 0xfa, 0x9d, 0x06, 0xe9, 0xf1, 0xbf, 0x1f, 0x40, 0x6b, 0x30, 0xf0, 0x0b, 0x82, 0x6a,
	0xad, 0x5a, 0xd4, 0xa7, 0xd0, 0x0a, 0xe8, 0xfd, 0xeb, 0xe5, 0x3d, 0x5d, 0x1b, 0x46, 0xb3, 0x5e,
	0x5d, 0x9f, 0x41, 0x19, 0x58, 0x1f, 0x44, 0x9b, 0xb8, 0x50, 0xad, 0x17, 0x8e, 0xf5, 0xd4, 0x08,
	0x51, 0xbb, 0xfa, 0xf4, 0x56, 0x0b, 0xf4, 0xc1, 0x1f, 0x13, 0xa0, 0x34, 0x8c, 0xf9, 0x39, 0x81,
	0x3e, 0x85, 0x0c, 0x58, 0x19, 0xa6, 0x71, 0xa3, 0x46, 0x72, 0x71, 0xc3, 0x52, 0x5b, 0x04, 0x56,
	0x46, 0x7e, 0x19, 0xde, 0x80, 0xe1, 0x5f, 0x0d, 0x48, 0x45, 0xeb, 0xb0, 0x3c, 0x44, 0xe2, 0x7a,
	0x46, 0xf1, 0x48, 0x35, 0x97, 0x90, 0xf9, 0x91, 0x6f, 0xd7, 0xe8, 0x0e, 0x8c, 0xff, 0x7a, 0xad,
	0x4f, 0x0d, 0x78, 0x2f, 0x21, 0x73, 0xad, 0xe3, 0x78, 0xa5, 0xe6, 0xdf, 0x6a, 0xa0, 0x0f, 0x7e,
	0x2c, 0x41, 0xf3, 0x70, 0xfd, 0x65, 0xf5, 0x45, 0xb5, 0xf6, 0xaa, 0x2a, 0x1c, 0x37, 0xea, 0xdb,
	0x89, 0x38, 0xcd, 0x46, 0xb1, 0x72, 0x56, 0xc3, 0x85, 0x32, 0x17, 0x67, 0x56, 0x0a, 0xf5, 0x17,
	0x7a, 0x0a, 0x65, 0x21, 0x1d, 0xaf, 0x97, 0x6b, 0xd5, 0xe7, 0xe6, 0x69, 0xb1, 0xd0, 0x78, 0x89,
	0x8b, 0xe6, 0x51, 0xa9, 0xc0, 0x4e, 0x7b, 0x1d, 0x96, 0x7f, 0x59, 0x2b, 0x55, 0x1b, 0xe5, 0xbf,
	0x30, 0x4f, 0x71, 0xad, 0x62, 0x36, 0x70, 0xe1, 0xf8, 0x45, 0x5d, 0x9f, 0xde, 0xfa, 0x16, 0xf4,
	0xc1, 0xaf, 0x21, 0x48, 0x87, 0x85, 0xd3, 0x97, 0xe5, 0x72, 0xf4, 0x19, 0x44, 0x38, 0xb8, 0xc1,
	0x82, 0xa3, 0xdc, 0xf7, 0x7d, 0x44, 0x38, 0x78, 0xe4, 0xa7, 0x13, 0x3d, 0xb5, 0xf5, 0x1a, 0xf4,
	0xc1, 0x11, 0x23, 0x8b, 0xab, 0xc1, 0x21, 0xa3, 0x90, 0xae, 0xae, 0x36, 0x8a, 0x91, 0xf4, 0xbb,
	0x90, 0x51, 0x09, 0xc7, 0x35, 0x5c, 0x2d, 0x62, 0x13, 0x17, 0xeb, 0x67, 0xb5, 0x6a, 0x9d, 0xe9,
	0xf8, 0x47, 0x0d, 0xb6, 0xfe, 0xf4, 0x7c, 0x2a, 0x56, 0x20, 0x27, 0x54, 0x89, 0xa3, 0x6f, 0x83,
	0xa1, 0x12, 0x8e, 0x6b, 0xd5, 0x7a, 0xa3, 0x50, 0x6d, 0x98, 0xcc, 0xae, 0x44, 0x7d, 0x44, 0x2d,
	0x56, 0xd5, 0xa9, 0x96, 0x9e, 0x42, 0x5b, 0xf0, 0x27, 0x26, 0x5f, 0xfa, 0xf4, 0xa3, 0x99, 0xb9,
	0xeb, 0xfa, 0xdc, 0xa3, 0x99, 0xb9, 0x39, 0xfd, 0xc6, 0xa3, 0x99, 0x39, 0x5d, 0x5f, 0x3a, 0xb2,
	0xbf, 0xfb, 0x3e, 0x3b, 0xf5, 0x87, 0xef, 0xb3, 0x53, 0x7f, 0xfc, 0x3e, 0xab, 0xfd, 0xcd, 0x87,
	0xac, 0xf6, 0x4f, 0x1f, 0xb2, 0xda, 0xef, 0x3f, 0x64, 0xb5, 0xef, 0x3e, 0x64, 0xb5, 0xff, 0xfd,
	0x90, 0xd5, 0xfe, 0xef, 0x43, 0x76, 0xea, 0x8f, 0x1f, 0xb2, 0xda, 0xdf, 0xfd, 0x90, 0x9d, 0xfa,
	0xee, 0x87, 0xec, 0xd4, 0x1f, 0x7e, 0xc8, 0x4e, 0xfd, 0x7a, 0xbf, 0x6d, 0x87, 0x9d, 0xde, 0xeb,
	0xed, 0xa6, 0xef, 0xee, 0xb4, 0x7d, 0xbf, 0xed, 0x10, 0xe5, 0x77, 0x54, 0x63, 0x7e, 0x51, 0xf5,
	0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa8, 0x4b, 0xbc, 0xfb, 0x6b, 0x25, 0x00, 0x00,
}

func (x MotionEstimationOptions_LinearSimilarityEstimation) String() string {
	s, ok := MotionEstimationOptions_LinearSimilarityEstimation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_AffineEstimation) String() string {
	s, ok := MotionEstimationOptions_AffineEstimation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_HomographyEstimation) String() string {
	s, ok := MotionEstimationOptions_HomographyEstimation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_MixtureHomographyEstimation) String() string {
	s, ok := MotionEstimationOptions_MixtureHomographyEstimation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_EstimationPolicy) String() string {
	s, ok := MotionEstimationOptions_EstimationPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_MixtureModelMode) String() string {
	s, ok := MotionEstimationOptions_MixtureModelMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_IRLSWeightFilter) String() string {
	s, ok := MotionEstimationOptions_IRLSWeightFilter_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MotionEstimationOptions_HomographyIrlsWeightInitialization) String() string {
	s, ok := MotionEstimationOptions_HomographyIrlsWeightInitialization_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MotionEstimationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EstimateTranslationIrls != nil && that1.EstimateTranslationIrls != nil {
		if *this.EstimateTranslationIrls != *that1.EstimateTranslationIrls {
			return false
		}
	} else if this.EstimateTranslationIrls != nil {
		return false
	} else if that1.EstimateTranslationIrls != nil {
		return false
	}
	if this.LinearSimilarityEstimation != nil && that1.LinearSimilarityEstimation != nil {
		if *this.LinearSimilarityEstimation != *that1.LinearSimilarityEstimation {
			return false
		}
	} else if this.LinearSimilarityEstimation != nil {
		return false
	} else if that1.LinearSimilarityEstimation != nil {
		return false
	}
	if this.AffineEstimation != nil && that1.AffineEstimation != nil {
		if *this.AffineEstimation != *that1.AffineEstimation {
			return false
		}
	} else if this.AffineEstimation != nil {
		return false
	} else if that1.AffineEstimation != nil {
		return false
	}
	if this.HomographyEstimation != nil && that1.HomographyEstimation != nil {
		if *this.HomographyEstimation != *that1.HomographyEstimation {
			return false
		}
	} else if this.HomographyEstimation != nil {
		return false
	} else if that1.HomographyEstimation != nil {
		return false
	}
	if this.HomographyExactDenominatorScaling != nil && that1.HomographyExactDenominatorScaling != nil {
		if *this.HomographyExactDenominatorScaling != *that1.HomographyExactDenominatorScaling {
			return false
		}
	} else if this.HomographyExactDenominatorScaling != nil {
		return false
	} else if that1.HomographyExactDenominatorScaling != nil {
		return false
	}
	if this.UseExactHomographyEstimation != nil && that1.UseExactHomographyEstimation != nil {
		if *this.UseExactHomographyEstimation != *that1.UseExactHomographyEstimation {
			return false
		}
	} else if this.UseExactHomographyEstimation != nil {
		return false
	} else if that1.UseExactHomographyEstimation != nil {
		return false
	}
	if this.UseHighestAccuracyForNormalEquations != nil && that1.UseHighestAccuracyForNormalEquations != nil {
		if *this.UseHighestAccuracyForNormalEquations != *that1.UseHighestAccuracyForNormalEquations {
			return false
		}
	} else if this.UseHighestAccuracyForNormalEquations != nil {
		return false
	} else if that1.UseHighestAccuracyForNormalEquations != nil {
		return false
	}
	if this.HomographyPerspectiveRegularizer != nil && that1.HomographyPerspectiveRegularizer != nil {
		if *this.HomographyPerspectiveRegularizer != *that1.HomographyPerspectiveRegularizer {
			return false
		}
	} else if this.HomographyPerspectiveRegularizer != nil {
		return false
	} else if that1.HomographyPerspectiveRegularizer != nil {
		return false
	}
	if this.MixHomographyEstimation != nil && that1.MixHomographyEstimation != nil {
		if *this.MixHomographyEstimation != *that1.MixHomographyEstimation {
			return false
		}
	} else if this.MixHomographyEstimation != nil {
		return false
	} else if that1.MixHomographyEstimation != nil {
		return false
	}
	if this.NumMixtures != nil && that1.NumMixtures != nil {
		if *this.NumMixtures != *that1.NumMixtures {
			return false
		}
	} else if this.NumMixtures != nil {
		return false
	} else if that1.NumMixtures != nil {
		return false
	}
	if this.MixtureRowSigma != nil && that1.MixtureRowSigma != nil {
		if *this.MixtureRowSigma != *that1.MixtureRowSigma {
			return false
		}
	} else if this.MixtureRowSigma != nil {
		return false
	} else if that1.MixtureRowSigma != nil {
		return false
	}
	if this.MixtureRegularizer != nil && that1.MixtureRegularizer != nil {
		if *this.MixtureRegularizer != *that1.MixtureRegularizer {
			return false
		}
	} else if this.MixtureRegularizer != nil {
		return false
	} else if that1.MixtureRegularizer != nil {
		return false
	}
	if this.MixtureRegularizerLevels != nil && that1.MixtureRegularizerLevels != nil {
		if *this.MixtureRegularizerLevels != *that1.MixtureRegularizerLevels {
			return false
		}
	} else if this.MixtureRegularizerLevels != nil {
		return false
	} else if that1.MixtureRegularizerLevels != nil {
		return false
	}
	if this.MixtureRegularizerBase != nil && that1.MixtureRegularizerBase != nil {
		if *this.MixtureRegularizerBase != *that1.MixtureRegularizerBase {
			return false
		}
	} else if this.MixtureRegularizerBase != nil {
		return false
	} else if that1.MixtureRegularizerBase != nil {
		return false
	}
	if this.MixtureRsAnalysisLevel != nil && that1.MixtureRsAnalysisLevel != nil {
		if *this.MixtureRsAnalysisLevel != *that1.MixtureRsAnalysisLevel {
			return false
		}
	} else if this.MixtureRsAnalysisLevel != nil {
		return false
	} else if that1.MixtureRsAnalysisLevel != nil {
		return false
	}
	if this.IrlsRounds != nil && that1.IrlsRounds != nil {
		if *this.IrlsRounds != *that1.IrlsRounds {
			return false
		}
	} else if this.IrlsRounds != nil {
		return false
	} else if that1.IrlsRounds != nil {
		return false
	}
	if this.IrlsPriorScale != nil && that1.IrlsPriorScale != nil {
		if *this.IrlsPriorScale != *that1.IrlsPriorScale {
			return false
		}
	} else if this.IrlsPriorScale != nil {
		return false
	} else if that1.IrlsPriorScale != nil {
		return false
	}
	if this.IrlsMotionMagnitudeFraction != nil && that1.IrlsMotionMagnitudeFraction != nil {
		if *this.IrlsMotionMagnitudeFraction != *that1.IrlsMotionMagnitudeFraction {
			return false
		}
	} else if this.IrlsMotionMagnitudeFraction != nil {
		return false
	} else if that1.IrlsMotionMagnitudeFraction != nil {
		return false
	}
	if this.IrlsMixtureFractionScale != nil && that1.IrlsMixtureFractionScale != nil {
		if *this.IrlsMixtureFractionScale != *that1.IrlsMixtureFractionScale {
			return false
		}
	} else if this.IrlsMixtureFractionScale != nil {
		return false
	} else if that1.IrlsMixtureFractionScale != nil {
		return false
	}
	if this.IrlsWeightsPreinitialized != nil && that1.IrlsWeightsPreinitialized != nil {
		if *this.IrlsWeightsPreinitialized != *that1.IrlsWeightsPreinitialized {
			return false
		}
	} else if this.IrlsWeightsPreinitialized != nil {
		return false
	} else if that1.IrlsWeightsPreinitialized != nil {
		return false
	}
	if this.FilterInitializedIrlsWeights != nil && that1.FilterInitializedIrlsWeights != nil {
		if *this.FilterInitializedIrlsWeights != *that1.FilterInitializedIrlsWeights {
			return false
		}
	} else if this.FilterInitializedIrlsWeights != nil {
		return false
	} else if that1.FilterInitializedIrlsWeights != nil {
		return false
	}
	if !this.IrlsInitialization.Equal(that1.IrlsInitialization) {
		return false
	}
	if this.FeatureDensityNormalization != nil && that1.FeatureDensityNormalization != nil {
		if *this.FeatureDensityNormalization != *that1.FeatureDensityNormalization {
			return false
		}
	} else if this.FeatureDensityNormalization != nil {
		return false
	} else if that1.FeatureDensityNormalization != nil {
		return false
	}
	if this.FeatureMaskSize != nil && that1.FeatureMaskSize != nil {
		if *this.FeatureMaskSize != *that1.FeatureMaskSize {
			return false
		}
	} else if this.FeatureMaskSize != nil {
		return false
	} else if that1.FeatureMaskSize != nil {
		return false
	}
	if !this.LongFeatureInitialization.Equal(that1.LongFeatureInitialization) {
		return false
	}
	if !this.IrlsMaskOptions.Equal(that1.IrlsMaskOptions) {
		return false
	}
	if !this.JointTrackEstimation.Equal(that1.JointTrackEstimation) {
		return false
	}
	if !this.LongFeatureBiasOptions.Equal(that1.LongFeatureBiasOptions) {
		return false
	}
	if this.EstimationPolicy != nil && that1.EstimationPolicy != nil {
		if *this.EstimationPolicy != *that1.EstimationPolicy {
			return false
		}
	} else if this.EstimationPolicy != nil {
		return false
	} else if that1.EstimationPolicy != nil {
		return false
	}
	if this.CoverageGridSize != nil && that1.CoverageGridSize != nil {
		if *this.CoverageGridSize != *that1.CoverageGridSize {
			return false
		}
	} else if this.CoverageGridSize != nil {
		return false
	} else if that1.CoverageGridSize != nil {
		return false
	}
	if this.MixtureModelMode != nil && that1.MixtureModelMode != nil {
		if *this.MixtureModelMode != *that1.MixtureModelMode {
			return false
		}
	} else if this.MixtureModelMode != nil {
		return false
	} else if that1.MixtureModelMode != nil {
		return false
	}
	if this.UseOnlyLinSimInliersForHomography != nil && that1.UseOnlyLinSimInliersForHomography != nil {
		if *this.UseOnlyLinSimInliersForHomography != *that1.UseOnlyLinSimInliersForHomography {
			return false
		}
	} else if this.UseOnlyLinSimInliersForHomography != nil {
		return false
	} else if that1.UseOnlyLinSimInliersForHomography != nil {
		return false
	}
	if this.LinSimInlierThreshold != nil && that1.LinSimInlierThreshold != nil {
		if *this.LinSimInlierThreshold != *that1.LinSimInlierThreshold {
			return false
		}
	} else if this.LinSimInlierThreshold != nil {
		return false
	} else if that1.LinSimInlierThreshold != nil {
		return false
	}
	if !this.StableTranslationBounds.Equal(that1.StableTranslationBounds) {
		return false
	}
	if !this.StableSimilarityBounds.Equal(that1.StableSimilarityBounds) {
		return false
	}
	if !this.StableHomographyBounds.Equal(that1.StableHomographyBounds) {
		return false
	}
	if !this.StableMixtureHomographyBounds.Equal(that1.StableMixtureHomographyBounds) {
		return false
	}
	if this.StrictCoverageScale != nil && that1.StrictCoverageScale != nil {
		if *this.StrictCoverageScale != *that1.StrictCoverageScale {
			return false
		}
	} else if this.StrictCoverageScale != nil {
		return false
	} else if that1.StrictCoverageScale != nil {
		return false
	}
	if this.LabelEmptyFramesAsValid != nil && that1.LabelEmptyFramesAsValid != nil {
		if *this.LabelEmptyFramesAsValid != *that1.LabelEmptyFramesAsValid {
			return false
		}
	} else if this.LabelEmptyFramesAsValid != nil {
		return false
	} else if that1.LabelEmptyFramesAsValid != nil {
		return false
	}
	if this.FeatureGridSize != nil && that1.FeatureGridSize != nil {
		if *this.FeatureGridSize != *that1.FeatureGridSize {
			return false
		}
	} else if this.FeatureGridSize != nil {
		return false
	} else if that1.FeatureGridSize != nil {
		return false
	}
	if this.SpatialSigma != nil && that1.SpatialSigma != nil {
		if *this.SpatialSigma != *that1.SpatialSigma {
			return false
		}
	} else if this.SpatialSigma != nil {
		return false
	} else if that1.SpatialSigma != nil {
		return false
	}
	if this.TemporalIrlsDiameter != nil && that1.TemporalIrlsDiameter != nil {
		if *this.TemporalIrlsDiameter != *that1.TemporalIrlsDiameter {
			return false
		}
	} else if this.TemporalIrlsDiameter != nil {
		return false
	} else if that1.TemporalIrlsDiameter != nil {
		return false
	}
	if this.TemporalSigma != nil && that1.TemporalSigma != nil {
		if *this.TemporalSigma != *that1.TemporalSigma {
			return false
		}
	} else if this.TemporalSigma != nil {
		return false
	} else if that1.TemporalSigma != nil {
		return false
	}
	if this.FeatureSigma != nil && that1.FeatureSigma != nil {
		if *this.FeatureSigma != *that1.FeatureSigma {
			return false
		}
	} else if this.FeatureSigma != nil {
		return false
	} else if that1.FeatureSigma != nil {
		return false
	}
	if this.Filter_5Taps != nil && that1.Filter_5Taps != nil {
		if *this.Filter_5Taps != *that1.Filter_5Taps {
			return false
		}
	} else if this.Filter_5Taps != nil {
		return false
	} else if that1.Filter_5Taps != nil {
		return false
	}
	if this.FrameConfidenceWeighting != nil && that1.FrameConfidenceWeighting != nil {
		if *this.FrameConfidenceWeighting != *that1.FrameConfidenceWeighting {
			return false
		}
	} else if this.FrameConfidenceWeighting != nil {
		return false
	} else if that1.FrameConfidenceWeighting != nil {
		return false
	}
	if this.ResetConfidenceThreshold != nil && that1.ResetConfidenceThreshold != nil {
		if *this.ResetConfidenceThreshold != *that1.ResetConfidenceThreshold {
			return false
		}
	} else if this.ResetConfidenceThreshold != nil {
		return false
	} else if that1.ResetConfidenceThreshold != nil {
		return false
	}
	if this.IrlsWeightFilter != nil && that1.IrlsWeightFilter != nil {
		if *this.IrlsWeightFilter != *that1.IrlsWeightFilter {
			return false
		}
	} else if this.IrlsWeightFilter != nil {
		return false
	} else if that1.IrlsWeightFilter != nil {
		return false
	}
	if this.OverlayDetection != nil && that1.OverlayDetection != nil {
		if *this.OverlayDetection != *that1.OverlayDetection {
			return false
		}
	} else if this.OverlayDetection != nil {
		return false
	} else if that1.OverlayDetection != nil {
		return false
	}
	if this.OverlayAnalysisChunkSize != nil && that1.OverlayAnalysisChunkSize != nil {
		if *this.OverlayAnalysisChunkSize != *that1.OverlayAnalysisChunkSize {
			return false
		}
	} else if this.OverlayAnalysisChunkSize != nil {
		return false
	} else if that1.OverlayAnalysisChunkSize != nil {
		return false
	}
	if !this.OverlayDetectionOptions.Equal(that1.OverlayDetectionOptions) {
		return false
	}
	if !this.ShotBoundaryOptions.Equal(that1.ShotBoundaryOptions) {
		return false
	}
	if this.OutputRefinedIrlsWeights != nil && that1.OutputRefinedIrlsWeights != nil {
		if *this.OutputRefinedIrlsWeights != *that1.OutputRefinedIrlsWeights {
			return false
		}
	} else if this.OutputRefinedIrlsWeights != nil {
		return false
	} else if that1.OutputRefinedIrlsWeights != nil {
		return false
	}
	if this.HomographyIrlsWeightInitialization != nil && that1.HomographyIrlsWeightInitialization != nil {
		if *this.HomographyIrlsWeightInitialization != *that1.HomographyIrlsWeightInitialization {
			return false
		}
	} else if this.HomographyIrlsWeightInitialization != nil {
		return false
	} else if that1.HomographyIrlsWeightInitialization != nil {
		return false
	}
	if this.IrlsUseL0Norm != nil && that1.IrlsUseL0Norm != nil {
		if *this.IrlsUseL0Norm != *that1.IrlsUseL0Norm {
			return false
		}
	} else if this.IrlsUseL0Norm != nil {
		return false
	} else if that1.IrlsUseL0Norm != nil {
		return false
	}
	if this.DomainLimitedIrlsScaling != nil && that1.DomainLimitedIrlsScaling != nil {
		if *this.DomainLimitedIrlsScaling != *that1.DomainLimitedIrlsScaling {
			return false
		}
	} else if this.DomainLimitedIrlsScaling != nil {
		return false
	} else if that1.DomainLimitedIrlsScaling != nil {
		return false
	}
	if this.DeactivateStableMotionEstimation != nil && that1.DeactivateStableMotionEstimation != nil {
		if *this.DeactivateStableMotionEstimation != *that1.DeactivateStableMotionEstimation {
			return false
		}
	} else if this.DeactivateStableMotionEstimation != nil {
		return false
	} else if that1.DeactivateStableMotionEstimation != nil {
		return false
	}
	if this.ProjectValidMotionsDown != nil && that1.ProjectValidMotionsDown != nil {
		if *this.ProjectValidMotionsDown != *that1.ProjectValidMotionsDown {
			return false
		}
	} else if this.ProjectValidMotionsDown != nil {
		return false
	} else if that1.ProjectValidMotionsDown != nil {
		return false
	}
	if this.EstimateSimilarity != that1.EstimateSimilarity {
		return false
	}
	thismap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(this)
	thatmap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(that1)
	for k, v := range thismap {
		if v2, ok := thatmap[k]; ok {
			if !v.Equal(&v2) {
				return false
			}
		} else {
			return false
		}
	}
	for k, _ := range thatmap {
		if _, ok := thismap[k]; !ok {
			return false
		}
	}
	return true
}
func (this *MotionEstimationOptions_IrlsOutlierInitialization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_IrlsOutlierInitialization)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_IrlsOutlierInitialization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Activated != nil && that1.Activated != nil {
		if *this.Activated != *that1.Activated {
			return false
		}
	} else if this.Activated != nil {
		return false
	} else if that1.Activated != nil {
		return false
	}
	if this.Rounds != nil && that1.Rounds != nil {
		if *this.Rounds != *that1.Rounds {
			return false
		}
	} else if this.Rounds != nil {
		return false
	} else if that1.Rounds != nil {
		return false
	}
	if this.Cutoff != nil && that1.Cutoff != nil {
		if *this.Cutoff != *that1.Cutoff {
			return false
		}
	} else if this.Cutoff != nil {
		return false
	} else if that1.Cutoff != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_LongFeatureInitialization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_LongFeatureInitialization)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_LongFeatureInitialization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Activated != nil && that1.Activated != nil {
		if *this.Activated != *that1.Activated {
			return false
		}
	} else if this.Activated != nil {
		return false
	} else if that1.Activated != nil {
		return false
	}
	if this.MinLengthPercentile != nil && that1.MinLengthPercentile != nil {
		if *this.MinLengthPercentile != *that1.MinLengthPercentile {
			return false
		}
	} else if this.MinLengthPercentile != nil {
		return false
	} else if that1.MinLengthPercentile != nil {
		return false
	}
	if this.UpweightMultiplier != nil && that1.UpweightMultiplier != nil {
		if *this.UpweightMultiplier != *that1.UpweightMultiplier {
			return false
		}
	} else if this.UpweightMultiplier != nil {
		return false
	} else if that1.UpweightMultiplier != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_IrlsMaskOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_IrlsMaskOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_IrlsMaskOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Decay != nil && that1.Decay != nil {
		if *this.Decay != *that1.Decay {
			return false
		}
	} else if this.Decay != nil {
		return false
	} else if that1.Decay != nil {
		return false
	}
	if this.InlierScore != nil && that1.InlierScore != nil {
		if *this.InlierScore != *that1.InlierScore {
			return false
		}
	} else if this.InlierScore != nil {
		return false
	} else if that1.InlierScore != nil {
		return false
	}
	if this.BaseScore != nil && that1.BaseScore != nil {
		if *this.BaseScore != *that1.BaseScore {
			return false
		}
	} else if this.BaseScore != nil {
		return false
	} else if that1.BaseScore != nil {
		return false
	}
	if this.MinTranslationNorm != nil && that1.MinTranslationNorm != nil {
		if *this.MinTranslationNorm != *that1.MinTranslationNorm {
			return false
		}
	} else if this.MinTranslationNorm != nil {
		return false
	} else if that1.MinTranslationNorm != nil {
		return false
	}
	if this.TranslationBlendAlpha != nil && that1.TranslationBlendAlpha != nil {
		if *this.TranslationBlendAlpha != *that1.TranslationBlendAlpha {
			return false
		}
	} else if this.TranslationBlendAlpha != nil {
		return false
	} else if that1.TranslationBlendAlpha != nil {
		return false
	}
	if this.TranslationPriorIncrease != nil && that1.TranslationPriorIncrease != nil {
		if *this.TranslationPriorIncrease != *that1.TranslationPriorIncrease {
			return false
		}
	} else if this.TranslationPriorIncrease != nil {
		return false
	} else if that1.TranslationPriorIncrease != nil {
		return false
	}
	thismap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(this)
	thatmap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(that1)
	for k, v := range thismap {
		if v2, ok := thatmap[k]; ok {
			if !v.Equal(&v2) {
				return false
			}
		} else {
			return false
		}
	}
	for k, _ := range thatmap {
		if _, ok := thismap[k]; !ok {
			return false
		}
	}
	return true
}
func (this *MotionEstimationOptions_JointTrackEstimationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_JointTrackEstimationOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_JointTrackEstimationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumMotionModels != nil && that1.NumMotionModels != nil {
		if *this.NumMotionModels != *that1.NumMotionModels {
			return false
		}
	} else if this.NumMotionModels != nil {
		return false
	} else if that1.NumMotionModels != nil {
		return false
	}
	if this.MotionStride != nil && that1.MotionStride != nil {
		if *this.MotionStride != *that1.MotionStride {
			return false
		}
	} else if this.MotionStride != nil {
		return false
	} else if that1.MotionStride != nil {
		return false
	}
	if this.TemporalSmoothing != nil && that1.TemporalSmoothing != nil {
		if *this.TemporalSmoothing != *that1.TemporalSmoothing {
			return false
		}
	} else if this.TemporalSmoothing != nil {
		return false
	} else if that1.TemporalSmoothing != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_LongFeatureBiasOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_LongFeatureBiasOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_LongFeatureBiasOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalRounds != nil && that1.TotalRounds != nil {
		if *this.TotalRounds != *that1.TotalRounds {
			return false
		}
	} else if this.TotalRounds != nil {
		return false
	} else if that1.TotalRounds != nil {
		return false
	}
	if this.InlierBias != nil && that1.InlierBias != nil {
		if *this.InlierBias != *that1.InlierBias {
			return false
		}
	} else if this.InlierBias != nil {
		return false
	} else if that1.InlierBias != nil {
		return false
	}
	if this.OutlierBias != nil && that1.OutlierBias != nil {
		if *this.OutlierBias != *that1.OutlierBias {
			return false
		}
	} else if this.OutlierBias != nil {
		return false
	} else if that1.OutlierBias != nil {
		return false
	}
	if this.NumIrlsObservations != nil && that1.NumIrlsObservations != nil {
		if *this.NumIrlsObservations != *that1.NumIrlsObservations {
			return false
		}
	} else if this.NumIrlsObservations != nil {
		return false
	} else if that1.NumIrlsObservations != nil {
		return false
	}
	if this.MaxIrlsChangeRatio != nil && that1.MaxIrlsChangeRatio != nil {
		if *this.MaxIrlsChangeRatio != *that1.MaxIrlsChangeRatio {
			return false
		}
	} else if this.MaxIrlsChangeRatio != nil {
		return false
	} else if that1.MaxIrlsChangeRatio != nil {
		return false
	}
	if this.InlierIrlsWeight != nil && that1.InlierIrlsWeight != nil {
		if *this.InlierIrlsWeight != *that1.InlierIrlsWeight {
			return false
		}
	} else if this.InlierIrlsWeight != nil {
		return false
	} else if that1.InlierIrlsWeight != nil {
		return false
	}
	if this.BiasStdev != nil && that1.BiasStdev != nil {
		if *this.BiasStdev != *that1.BiasStdev {
			return false
		}
	} else if this.BiasStdev != nil {
		return false
	} else if that1.BiasStdev != nil {
		return false
	}
	if this.UseSpatialBias != nil && that1.UseSpatialBias != nil {
		if *this.UseSpatialBias != *that1.UseSpatialBias {
			return false
		}
	} else if this.UseSpatialBias != nil {
		return false
	} else if that1.UseSpatialBias != nil {
		return false
	}
	if this.GridSize != nil && that1.GridSize != nil {
		if *this.GridSize != *that1.GridSize {
			return false
		}
	} else if this.GridSize != nil {
		return false
	} else if that1.GridSize != nil {
		return false
	}
	if this.SpatialSigma != nil && that1.SpatialSigma != nil {
		if *this.SpatialSigma != *that1.SpatialSigma {
			return false
		}
	} else if this.SpatialSigma != nil {
		return false
	} else if that1.SpatialSigma != nil {
		return false
	}
	if this.ColorSigma != nil && that1.ColorSigma != nil {
		if *this.ColorSigma != *that1.ColorSigma {
			return false
		}
	} else if this.ColorSigma != nil {
		return false
	} else if that1.ColorSigma != nil {
		return false
	}
	if this.LongTrackThreshold != nil && that1.LongTrackThreshold != nil {
		if *this.LongTrackThreshold != *that1.LongTrackThreshold {
			return false
		}
	} else if this.LongTrackThreshold != nil {
		return false
	} else if that1.LongTrackThreshold != nil {
		return false
	}
	if this.LongTrackConfidenceFraction != nil && that1.LongTrackConfidenceFraction != nil {
		if *this.LongTrackConfidenceFraction != *that1.LongTrackConfidenceFraction {
			return false
		}
	} else if this.LongTrackConfidenceFraction != nil {
		return false
	} else if that1.LongTrackConfidenceFraction != nil {
		return false
	}
	if this.SeedPriorsFromBias != nil && that1.SeedPriorsFromBias != nil {
		if *this.SeedPriorsFromBias != *that1.SeedPriorsFromBias {
			return false
		}
	} else if this.SeedPriorsFromBias != nil {
		return false
	} else if that1.SeedPriorsFromBias != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_TranslationBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_TranslationBounds)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_TranslationBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinFeatures != nil && that1.MinFeatures != nil {
		if *this.MinFeatures != *that1.MinFeatures {
			return false
		}
	} else if this.MinFeatures != nil {
		return false
	} else if that1.MinFeatures != nil {
		return false
	}
	if this.FracMaxMotionMagnitude != nil && that1.FracMaxMotionMagnitude != nil {
		if *this.FracMaxMotionMagnitude != *that1.FracMaxMotionMagnitude {
			return false
		}
	} else if this.FracMaxMotionMagnitude != nil {
		return false
	} else if that1.FracMaxMotionMagnitude != nil {
		return false
	}
	if this.MaxMotionStdevThreshold != nil && that1.MaxMotionStdevThreshold != nil {
		if *this.MaxMotionStdevThreshold != *that1.MaxMotionStdevThreshold {
			return false
		}
	} else if this.MaxMotionStdevThreshold != nil {
		return false
	} else if that1.MaxMotionStdevThreshold != nil {
		return false
	}
	if this.MaxMotionStdev != nil && that1.MaxMotionStdev != nil {
		if *this.MaxMotionStdev != *that1.MaxMotionStdev {
			return false
		}
	} else if this.MaxMotionStdev != nil {
		return false
	} else if that1.MaxMotionStdev != nil {
		return false
	}
	if this.MaxAcceleration != nil && that1.MaxAcceleration != nil {
		if *this.MaxAcceleration != *that1.MaxAcceleration {
			return false
		}
	} else if this.MaxAcceleration != nil {
		return false
	} else if that1.MaxAcceleration != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_SimilarityBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_SimilarityBounds)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_SimilarityBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OnlyStableInput != nil && that1.OnlyStableInput != nil {
		if *this.OnlyStableInput != *that1.OnlyStableInput {
			return false
		}
	} else if this.OnlyStableInput != nil {
		return false
	} else if that1.OnlyStableInput != nil {
		return false
	}
	if this.MinInlierFraction != nil && that1.MinInlierFraction != nil {
		if *this.MinInlierFraction != *that1.MinInlierFraction {
			return false
		}
	} else if this.MinInlierFraction != nil {
		return false
	} else if that1.MinInlierFraction != nil {
		return false
	}
	if this.MinInliers != nil && that1.MinInliers != nil {
		if *this.MinInliers != *that1.MinInliers {
			return false
		}
	} else if this.MinInliers != nil {
		return false
	} else if that1.MinInliers != nil {
		return false
	}
	if this.LowerScale != nil && that1.LowerScale != nil {
		if *this.LowerScale != *that1.LowerScale {
			return false
		}
	} else if this.LowerScale != nil {
		return false
	} else if that1.LowerScale != nil {
		return false
	}
	if this.UpperScale != nil && that1.UpperScale != nil {
		if *this.UpperScale != *that1.UpperScale {
			return false
		}
	} else if this.UpperScale != nil {
		return false
	} else if that1.UpperScale != nil {
		return false
	}
	if this.LimitRotation != nil && that1.LimitRotation != nil {
		if *this.LimitRotation != *that1.LimitRotation {
			return false
		}
	} else if this.LimitRotation != nil {
		return false
	} else if that1.LimitRotation != nil {
		return false
	}
	if this.InlierThreshold != nil && that1.InlierThreshold != nil {
		if *this.InlierThreshold != *that1.InlierThreshold {
			return false
		}
	} else if this.InlierThreshold != nil {
		return false
	} else if that1.InlierThreshold != nil {
		return false
	}
	if this.FracInlierThreshold != nil && that1.FracInlierThreshold != nil {
		if *this.FracInlierThreshold != *that1.FracInlierThreshold {
			return false
		}
	} else if this.FracInlierThreshold != nil {
		return false
	} else if that1.FracInlierThreshold != nil {
		return false
	}
	if this.StrictInlierThreshold != nil && that1.StrictInlierThreshold != nil {
		if *this.StrictInlierThreshold != *that1.StrictInlierThreshold {
			return false
		}
	} else if this.StrictInlierThreshold != nil {
		return false
	} else if that1.StrictInlierThreshold != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_HomographyBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_HomographyBounds)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_HomographyBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LowerScale != nil && that1.LowerScale != nil {
		if *this.LowerScale != *that1.LowerScale {
			return false
		}
	} else if this.LowerScale != nil {
		return false
	} else if that1.LowerScale != nil {
		return false
	}
	if this.UpperScale != nil && that1.UpperScale != nil {
		if *this.UpperScale != *that1.UpperScale {
			return false
		}
	} else if this.UpperScale != nil {
		return false
	} else if that1.UpperScale != nil {
		return false
	}
	if this.LimitRotation != nil && that1.LimitRotation != nil {
		if *this.LimitRotation != *that1.LimitRotation {
			return false
		}
	} else if this.LimitRotation != nil {
		return false
	} else if that1.LimitRotation != nil {
		return false
	}
	if this.LimitPerspective != nil && that1.LimitPerspective != nil {
		if *this.LimitPerspective != *that1.LimitPerspective {
			return false
		}
	} else if this.LimitPerspective != nil {
		return false
	} else if that1.LimitPerspective != nil {
		return false
	}
	if this.RegistrationThreshold != nil && that1.RegistrationThreshold != nil {
		if *this.RegistrationThreshold != *that1.RegistrationThreshold {
			return false
		}
	} else if this.RegistrationThreshold != nil {
		return false
	} else if that1.RegistrationThreshold != nil {
		return false
	}
	if this.FracRegistrationThreshold != nil && that1.FracRegistrationThreshold != nil {
		if *this.FracRegistrationThreshold != *that1.FracRegistrationThreshold {
			return false
		}
	} else if this.FracRegistrationThreshold != nil {
		return false
	} else if that1.FracRegistrationThreshold != nil {
		return false
	}
	if this.MinInlierCoverage != nil && that1.MinInlierCoverage != nil {
		if *this.MinInlierCoverage != *that1.MinInlierCoverage {
			return false
		}
	} else if this.MinInlierCoverage != nil {
		return false
	} else if that1.MinInlierCoverage != nil {
		return false
	}
	if this.FracInlierThreshold != nil && that1.FracInlierThreshold != nil {
		if *this.FracInlierThreshold != *that1.FracInlierThreshold {
			return false
		}
	} else if this.FracInlierThreshold != nil {
		return false
	} else if that1.FracInlierThreshold != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_MixtureHomographyBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_MixtureHomographyBounds)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_MixtureHomographyBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinInlierCoverage != nil && that1.MinInlierCoverage != nil {
		if *this.MinInlierCoverage != *that1.MinInlierCoverage {
			return false
		}
	} else if this.MinInlierCoverage != nil {
		return false
	} else if that1.MinInlierCoverage != nil {
		return false
	}
	if this.MaxAdjacentOutlierBlocks != nil && that1.MaxAdjacentOutlierBlocks != nil {
		if *this.MaxAdjacentOutlierBlocks != *that1.MaxAdjacentOutlierBlocks {
			return false
		}
	} else if this.MaxAdjacentOutlierBlocks != nil {
		return false
	} else if that1.MaxAdjacentOutlierBlocks != nil {
		return false
	}
	if this.MaxAdjacentEmptyBlocks != nil && that1.MaxAdjacentEmptyBlocks != nil {
		if *this.MaxAdjacentEmptyBlocks != *that1.MaxAdjacentEmptyBlocks {
			return false
		}
	} else if this.MaxAdjacentEmptyBlocks != nil {
		return false
	} else if that1.MaxAdjacentEmptyBlocks != nil {
		return false
	}
	if this.FracInlierThreshold != nil && that1.FracInlierThreshold != nil {
		if *this.FracInlierThreshold != *that1.FracInlierThreshold {
			return false
		}
	} else if this.FracInlierThreshold != nil {
		return false
	} else if that1.FracInlierThreshold != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_OverlayDetectionOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_OverlayDetectionOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_OverlayDetectionOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AnalysisMaskSize != nil && that1.AnalysisMaskSize != nil {
		if *this.AnalysisMaskSize != *that1.AnalysisMaskSize {
			return false
		}
	} else if this.AnalysisMaskSize != nil {
		return false
	} else if that1.AnalysisMaskSize != nil {
		return false
	}
	if this.StrictNearZeroMotion != nil && that1.StrictNearZeroMotion != nil {
		if *this.StrictNearZeroMotion != *that1.StrictNearZeroMotion {
			return false
		}
	} else if this.StrictNearZeroMotion != nil {
		return false
	} else if that1.StrictNearZeroMotion != nil {
		return false
	}
	if this.StrictMaxTranslationRatio != nil && that1.StrictMaxTranslationRatio != nil {
		if *this.StrictMaxTranslationRatio != *that1.StrictMaxTranslationRatio {
			return false
		}
	} else if this.StrictMaxTranslationRatio != nil {
		return false
	} else if that1.StrictMaxTranslationRatio != nil {
		return false
	}
	if this.StrictMinTexturedness != nil && that1.StrictMinTexturedness != nil {
		if *this.StrictMinTexturedness != *that1.StrictMinTexturedness {
			return false
		}
	} else if this.StrictMinTexturedness != nil {
		return false
	} else if that1.StrictMinTexturedness != nil {
		return false
	}
	if this.LooseNearZeroMotion != nil && that1.LooseNearZeroMotion != nil {
		if *this.LooseNearZeroMotion != *that1.LooseNearZeroMotion {
			return false
		}
	} else if this.LooseNearZeroMotion != nil {
		return false
	} else if that1.LooseNearZeroMotion != nil {
		return false
	}
	if this.OverlayMinRatio != nil && that1.OverlayMinRatio != nil {
		if *this.OverlayMinRatio != *that1.OverlayMinRatio {
			return false
		}
	} else if this.OverlayMinRatio != nil {
		return false
	} else if that1.OverlayMinRatio != nil {
		return false
	}
	if this.OverlayMinFeatures != nil && that1.OverlayMinFeatures != nil {
		if *this.OverlayMinFeatures != *that1.OverlayMinFeatures {
			return false
		}
	} else if this.OverlayMinFeatures != nil {
		return false
	} else if that1.OverlayMinFeatures != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions_ShotBoundaryOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionEstimationOptions_ShotBoundaryOptions)
	if !ok {
		that2, ok := that.(MotionEstimationOptions_ShotBoundaryOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MotionConsistencyThreshold != nil && that1.MotionConsistencyThreshold != nil {
		if *this.MotionConsistencyThreshold != *that1.MotionConsistencyThreshold {
			return false
		}
	} else if this.MotionConsistencyThreshold != nil {
		return false
	} else if that1.MotionConsistencyThreshold != nil {
		return false
	}
	if this.AppearanceConsistencyThreshold != nil && that1.AppearanceConsistencyThreshold != nil {
		if *this.AppearanceConsistencyThreshold != *that1.AppearanceConsistencyThreshold {
			return false
		}
	} else if this.AppearanceConsistencyThreshold != nil {
		return false
	} else if that1.AppearanceConsistencyThreshold != nil {
		return false
	}
	return true
}
func (this *MotionEstimationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 63)
	s = append(s, "&tracking.MotionEstimationOptions{")
	if this.EstimateTranslationIrls != nil {
		s = append(s, "EstimateTranslationIrls: "+valueToGoStringMotionEstimation(this.EstimateTranslationIrls, "bool")+",\n")
	}
	if this.LinearSimilarityEstimation != nil {
		s = append(s, "LinearSimilarityEstimation: "+valueToGoStringMotionEstimation(this.LinearSimilarityEstimation, "MotionEstimationOptions_LinearSimilarityEstimation")+",\n")
	}
	if this.AffineEstimation != nil {
		s = append(s, "AffineEstimation: "+valueToGoStringMotionEstimation(this.AffineEstimation, "MotionEstimationOptions_AffineEstimation")+",\n")
	}
	if this.HomographyEstimation != nil {
		s = append(s, "HomographyEstimation: "+valueToGoStringMotionEstimation(this.HomographyEstimation, "MotionEstimationOptions_HomographyEstimation")+",\n")
	}
	if this.HomographyExactDenominatorScaling != nil {
		s = append(s, "HomographyExactDenominatorScaling: "+valueToGoStringMotionEstimation(this.HomographyExactDenominatorScaling, "bool")+",\n")
	}
	if this.UseExactHomographyEstimation != nil {
		s = append(s, "UseExactHomographyEstimation: "+valueToGoStringMotionEstimation(this.UseExactHomographyEstimation, "bool")+",\n")
	}
	if this.UseHighestAccuracyForNormalEquations != nil {
		s = append(s, "UseHighestAccuracyForNormalEquations: "+valueToGoStringMotionEstimation(this.UseHighestAccuracyForNormalEquations, "bool")+",\n")
	}
	if this.HomographyPerspectiveRegularizer != nil {
		s = append(s, "HomographyPerspectiveRegularizer: "+valueToGoStringMotionEstimation(this.HomographyPerspectiveRegularizer, "float32")+",\n")
	}
	if this.MixHomographyEstimation != nil {
		s = append(s, "MixHomographyEstimation: "+valueToGoStringMotionEstimation(this.MixHomographyEstimation, "MotionEstimationOptions_MixtureHomographyEstimation")+",\n")
	}
	if this.NumMixtures != nil {
		s = append(s, "NumMixtures: "+valueToGoStringMotionEstimation(this.NumMixtures, "int32")+",\n")
	}
	if this.MixtureRowSigma != nil {
		s = append(s, "MixtureRowSigma: "+valueToGoStringMotionEstimation(this.MixtureRowSigma, "float32")+",\n")
	}
	if this.MixtureRegularizer != nil {
		s = append(s, "MixtureRegularizer: "+valueToGoStringMotionEstimation(this.MixtureRegularizer, "float32")+",\n")
	}
	if this.MixtureRegularizerLevels != nil {
		s = append(s, "MixtureRegularizerLevels: "+valueToGoStringMotionEstimation(this.MixtureRegularizerLevels, "float32")+",\n")
	}
	if this.MixtureRegularizerBase != nil {
		s = append(s, "MixtureRegularizerBase: "+valueToGoStringMotionEstimation(this.MixtureRegularizerBase, "float32")+",\n")
	}
	if this.MixtureRsAnalysisLevel != nil {
		s = append(s, "MixtureRsAnalysisLevel: "+valueToGoStringMotionEstimation(this.MixtureRsAnalysisLevel, "int32")+",\n")
	}
	if this.IrlsRounds != nil {
		s = append(s, "IrlsRounds: "+valueToGoStringMotionEstimation(this.IrlsRounds, "int32")+",\n")
	}
	if this.IrlsPriorScale != nil {
		s = append(s, "IrlsPriorScale: "+valueToGoStringMotionEstimation(this.IrlsPriorScale, "float32")+",\n")
	}
	if this.IrlsMotionMagnitudeFraction != nil {
		s = append(s, "IrlsMotionMagnitudeFraction: "+valueToGoStringMotionEstimation(this.IrlsMotionMagnitudeFraction, "float32")+",\n")
	}
	if this.IrlsMixtureFractionScale != nil {
		s = append(s, "IrlsMixtureFractionScale: "+valueToGoStringMotionEstimation(this.IrlsMixtureFractionScale, "float32")+",\n")
	}
	if this.IrlsWeightsPreinitialized != nil {
		s = append(s, "IrlsWeightsPreinitialized: "+valueToGoStringMotionEstimation(this.IrlsWeightsPreinitialized, "bool")+",\n")
	}
	if this.FilterInitializedIrlsWeights != nil {
		s = append(s, "FilterInitializedIrlsWeights: "+valueToGoStringMotionEstimation(this.FilterInitializedIrlsWeights, "bool")+",\n")
	}
	if this.IrlsInitialization != nil {
		s = append(s, "IrlsInitialization: "+fmt.Sprintf("%#v", this.IrlsInitialization)+",\n")
	}
	if this.FeatureDensityNormalization != nil {
		s = append(s, "FeatureDensityNormalization: "+valueToGoStringMotionEstimation(this.FeatureDensityNormalization, "bool")+",\n")
	}
	if this.FeatureMaskSize != nil {
		s = append(s, "FeatureMaskSize: "+valueToGoStringMotionEstimation(this.FeatureMaskSize, "int32")+",\n")
	}
	if this.LongFeatureInitialization != nil {
		s = append(s, "LongFeatureInitialization: "+fmt.Sprintf("%#v", this.LongFeatureInitialization)+",\n")
	}
	if this.IrlsMaskOptions != nil {
		s = append(s, "IrlsMaskOptions: "+fmt.Sprintf("%#v", this.IrlsMaskOptions)+",\n")
	}
	if this.JointTrackEstimation != nil {
		s = append(s, "JointTrackEstimation: "+fmt.Sprintf("%#v", this.JointTrackEstimation)+",\n")
	}
	if this.LongFeatureBiasOptions != nil {
		s = append(s, "LongFeatureBiasOptions: "+fmt.Sprintf("%#v", this.LongFeatureBiasOptions)+",\n")
	}
	if this.EstimationPolicy != nil {
		s = append(s, "EstimationPolicy: "+valueToGoStringMotionEstimation(this.EstimationPolicy, "MotionEstimationOptions_EstimationPolicy")+",\n")
	}
	if this.CoverageGridSize != nil {
		s = append(s, "CoverageGridSize: "+valueToGoStringMotionEstimation(this.CoverageGridSize, "int32")+",\n")
	}
	if this.MixtureModelMode != nil {
		s = append(s, "MixtureModelMode: "+valueToGoStringMotionEstimation(this.MixtureModelMode, "MotionEstimationOptions_MixtureModelMode")+",\n")
	}
	if this.UseOnlyLinSimInliersForHomography != nil {
		s = append(s, "UseOnlyLinSimInliersForHomography: "+valueToGoStringMotionEstimation(this.UseOnlyLinSimInliersForHomography, "bool")+",\n")
	}
	if this.LinSimInlierThreshold != nil {
		s = append(s, "LinSimInlierThreshold: "+valueToGoStringMotionEstimation(this.LinSimInlierThreshold, "float32")+",\n")
	}
	if this.StableTranslationBounds != nil {
		s = append(s, "StableTranslationBounds: "+fmt.Sprintf("%#v", this.StableTranslationBounds)+",\n")
	}
	if this.StableSimilarityBounds != nil {
		s = append(s, "StableSimilarityBounds: "+fmt.Sprintf("%#v", this.StableSimilarityBounds)+",\n")
	}
	if this.StableHomographyBounds != nil {
		s = append(s, "StableHomographyBounds: "+fmt.Sprintf("%#v", this.StableHomographyBounds)+",\n")
	}
	if this.StableMixtureHomographyBounds != nil {
		s = append(s, "StableMixtureHomographyBounds: "+fmt.Sprintf("%#v", this.StableMixtureHomographyBounds)+",\n")
	}
	if this.StrictCoverageScale != nil {
		s = append(s, "StrictCoverageScale: "+valueToGoStringMotionEstimation(this.StrictCoverageScale, "float32")+",\n")
	}
	if this.LabelEmptyFramesAsValid != nil {
		s = append(s, "LabelEmptyFramesAsValid: "+valueToGoStringMotionEstimation(this.LabelEmptyFramesAsValid, "bool")+",\n")
	}
	if this.FeatureGridSize != nil {
		s = append(s, "FeatureGridSize: "+valueToGoStringMotionEstimation(this.FeatureGridSize, "float32")+",\n")
	}
	if this.SpatialSigma != nil {
		s = append(s, "SpatialSigma: "+valueToGoStringMotionEstimation(this.SpatialSigma, "float32")+",\n")
	}
	if this.TemporalIrlsDiameter != nil {
		s = append(s, "TemporalIrlsDiameter: "+valueToGoStringMotionEstimation(this.TemporalIrlsDiameter, "int32")+",\n")
	}
	if this.TemporalSigma != nil {
		s = append(s, "TemporalSigma: "+valueToGoStringMotionEstimation(this.TemporalSigma, "float32")+",\n")
	}
	if this.FeatureSigma != nil {
		s = append(s, "FeatureSigma: "+valueToGoStringMotionEstimation(this.FeatureSigma, "float32")+",\n")
	}
	if this.Filter_5Taps != nil {
		s = append(s, "Filter_5Taps: "+valueToGoStringMotionEstimation(this.Filter_5Taps, "bool")+",\n")
	}
	if this.FrameConfidenceWeighting != nil {
		s = append(s, "FrameConfidenceWeighting: "+valueToGoStringMotionEstimation(this.FrameConfidenceWeighting, "bool")+",\n")
	}
	if this.ResetConfidenceThreshold != nil {
		s = append(s, "ResetConfidenceThreshold: "+valueToGoStringMotionEstimation(this.ResetConfidenceThreshold, "float32")+",\n")
	}
	if this.IrlsWeightFilter != nil {
		s = append(s, "IrlsWeightFilter: "+valueToGoStringMotionEstimation(this.IrlsWeightFilter, "MotionEstimationOptions_IRLSWeightFilter")+",\n")
	}
	if this.OverlayDetection != nil {
		s = append(s, "OverlayDetection: "+valueToGoStringMotionEstimation(this.OverlayDetection, "bool")+",\n")
	}
	if this.OverlayAnalysisChunkSize != nil {
		s = append(s, "OverlayAnalysisChunkSize: "+valueToGoStringMotionEstimation(this.OverlayAnalysisChunkSize, "int32")+",\n")
	}
	if this.OverlayDetectionOptions != nil {
		s = append(s, "OverlayDetectionOptions: "+fmt.Sprintf("%#v", this.OverlayDetectionOptions)+",\n")
	}
	if this.ShotBoundaryOptions != nil {
		s = append(s, "ShotBoundaryOptions: "+fmt.Sprintf("%#v", this.ShotBoundaryOptions)+",\n")
	}
	if this.OutputRefinedIrlsWeights != nil {
		s = append(s, "OutputRefinedIrlsWeights: "+valueToGoStringMotionEstimation(this.OutputRefinedIrlsWeights, "bool")+",\n")
	}
	if this.HomographyIrlsWeightInitialization != nil {
		s = append(s, "HomographyIrlsWeightInitialization: "+valueToGoStringMotionEstimation(this.HomographyIrlsWeightInitialization, "MotionEstimationOptions_HomographyIrlsWeightInitialization")+",\n")
	}
	if this.IrlsUseL0Norm != nil {
		s = append(s, "IrlsUseL0Norm: "+valueToGoStringMotionEstimation(this.IrlsUseL0Norm, "bool")+",\n")
	}
	if this.DomainLimitedIrlsScaling != nil {
		s = append(s, "DomainLimitedIrlsScaling: "+valueToGoStringMotionEstimation(this.DomainLimitedIrlsScaling, "bool")+",\n")
	}
	if this.DeactivateStableMotionEstimation != nil {
		s = append(s, "DeactivateStableMotionEstimation: "+valueToGoStringMotionEstimation(this.DeactivateStableMotionEstimation, "bool")+",\n")
	}
	if this.ProjectValidMotionsDown != nil {
		s = append(s, "ProjectValidMotionsDown: "+valueToGoStringMotionEstimation(this.ProjectValidMotionsDown, "bool")+",\n")
	}
	s = append(s, "EstimateSimilarity: "+fmt.Sprintf("%#v", this.EstimateSimilarity)+",\n")
	s = append(s, "XXX_InternalExtensions: "+extensionToGoStringMotionEstimation(this)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_IrlsOutlierInitialization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.MotionEstimationOptions_IrlsOutlierInitialization{")
	if this.Activated != nil {
		s = append(s, "Activated: "+valueToGoStringMotionEstimation(this.Activated, "bool")+",\n")
	}
	if this.Rounds != nil {
		s = append(s, "Rounds: "+valueToGoStringMotionEstimation(this.Rounds, "int32")+",\n")
	}
	if this.Cutoff != nil {
		s = append(s, "Cutoff: "+valueToGoStringMotionEstimation(this.Cutoff, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_LongFeatureInitialization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.MotionEstimationOptions_LongFeatureInitialization{")
	if this.Activated != nil {
		s = append(s, "Activated: "+valueToGoStringMotionEstimation(this.Activated, "bool")+",\n")
	}
	if this.MinLengthPercentile != nil {
		s = append(s, "MinLengthPercentile: "+valueToGoStringMotionEstimation(this.MinLengthPercentile, "float32")+",\n")
	}
	if this.UpweightMultiplier != nil {
		s = append(s, "UpweightMultiplier: "+valueToGoStringMotionEstimation(this.UpweightMultiplier, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_IrlsMaskOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.MotionEstimationOptions_IrlsMaskOptions{")
	if this.Decay != nil {
		s = append(s, "Decay: "+valueToGoStringMotionEstimation(this.Decay, "float32")+",\n")
	}
	if this.InlierScore != nil {
		s = append(s, "InlierScore: "+valueToGoStringMotionEstimation(this.InlierScore, "float32")+",\n")
	}
	if this.BaseScore != nil {
		s = append(s, "BaseScore: "+valueToGoStringMotionEstimation(this.BaseScore, "float32")+",\n")
	}
	if this.MinTranslationNorm != nil {
		s = append(s, "MinTranslationNorm: "+valueToGoStringMotionEstimation(this.MinTranslationNorm, "float32")+",\n")
	}
	if this.TranslationBlendAlpha != nil {
		s = append(s, "TranslationBlendAlpha: "+valueToGoStringMotionEstimation(this.TranslationBlendAlpha, "float32")+",\n")
	}
	if this.TranslationPriorIncrease != nil {
		s = append(s, "TranslationPriorIncrease: "+valueToGoStringMotionEstimation(this.TranslationPriorIncrease, "float32")+",\n")
	}
	s = append(s, "XXX_InternalExtensions: "+extensionToGoStringMotionEstimation(this)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_JointTrackEstimationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.MotionEstimationOptions_JointTrackEstimationOptions{")
	if this.NumMotionModels != nil {
		s = append(s, "NumMotionModels: "+valueToGoStringMotionEstimation(this.NumMotionModels, "int32")+",\n")
	}
	if this.MotionStride != nil {
		s = append(s, "MotionStride: "+valueToGoStringMotionEstimation(this.MotionStride, "int32")+",\n")
	}
	if this.TemporalSmoothing != nil {
		s = append(s, "TemporalSmoothing: "+valueToGoStringMotionEstimation(this.TemporalSmoothing, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_LongFeatureBiasOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&tracking.MotionEstimationOptions_LongFeatureBiasOptions{")
	if this.TotalRounds != nil {
		s = append(s, "TotalRounds: "+valueToGoStringMotionEstimation(this.TotalRounds, "int32")+",\n")
	}
	if this.InlierBias != nil {
		s = append(s, "InlierBias: "+valueToGoStringMotionEstimation(this.InlierBias, "float32")+",\n")
	}
	if this.OutlierBias != nil {
		s = append(s, "OutlierBias: "+valueToGoStringMotionEstimation(this.OutlierBias, "float32")+",\n")
	}
	if this.NumIrlsObservations != nil {
		s = append(s, "NumIrlsObservations: "+valueToGoStringMotionEstimation(this.NumIrlsObservations, "int32")+",\n")
	}
	if this.MaxIrlsChangeRatio != nil {
		s = append(s, "MaxIrlsChangeRatio: "+valueToGoStringMotionEstimation(this.MaxIrlsChangeRatio, "float32")+",\n")
	}
	if this.InlierIrlsWeight != nil {
		s = append(s, "InlierIrlsWeight: "+valueToGoStringMotionEstimation(this.InlierIrlsWeight, "float32")+",\n")
	}
	if this.BiasStdev != nil {
		s = append(s, "BiasStdev: "+valueToGoStringMotionEstimation(this.BiasStdev, "float32")+",\n")
	}
	if this.UseSpatialBias != nil {
		s = append(s, "UseSpatialBias: "+valueToGoStringMotionEstimation(this.UseSpatialBias, "bool")+",\n")
	}
	if this.GridSize != nil {
		s = append(s, "GridSize: "+valueToGoStringMotionEstimation(this.GridSize, "float32")+",\n")
	}
	if this.SpatialSigma != nil {
		s = append(s, "SpatialSigma: "+valueToGoStringMotionEstimation(this.SpatialSigma, "float32")+",\n")
	}
	if this.ColorSigma != nil {
		s = append(s, "ColorSigma: "+valueToGoStringMotionEstimation(this.ColorSigma, "float32")+",\n")
	}
	if this.LongTrackThreshold != nil {
		s = append(s, "LongTrackThreshold: "+valueToGoStringMotionEstimation(this.LongTrackThreshold, "int32")+",\n")
	}
	if this.LongTrackConfidenceFraction != nil {
		s = append(s, "LongTrackConfidenceFraction: "+valueToGoStringMotionEstimation(this.LongTrackConfidenceFraction, "float32")+",\n")
	}
	if this.SeedPriorsFromBias != nil {
		s = append(s, "SeedPriorsFromBias: "+valueToGoStringMotionEstimation(this.SeedPriorsFromBias, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_TranslationBounds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tracking.MotionEstimationOptions_TranslationBounds{")
	if this.MinFeatures != nil {
		s = append(s, "MinFeatures: "+valueToGoStringMotionEstimation(this.MinFeatures, "int32")+",\n")
	}
	if this.FracMaxMotionMagnitude != nil {
		s = append(s, "FracMaxMotionMagnitude: "+valueToGoStringMotionEstimation(this.FracMaxMotionMagnitude, "float32")+",\n")
	}
	if this.MaxMotionStdevThreshold != nil {
		s = append(s, "MaxMotionStdevThreshold: "+valueToGoStringMotionEstimation(this.MaxMotionStdevThreshold, "float32")+",\n")
	}
	if this.MaxMotionStdev != nil {
		s = append(s, "MaxMotionStdev: "+valueToGoStringMotionEstimation(this.MaxMotionStdev, "float32")+",\n")
	}
	if this.MaxAcceleration != nil {
		s = append(s, "MaxAcceleration: "+valueToGoStringMotionEstimation(this.MaxAcceleration, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_SimilarityBounds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&tracking.MotionEstimationOptions_SimilarityBounds{")
	if this.OnlyStableInput != nil {
		s = append(s, "OnlyStableInput: "+valueToGoStringMotionEstimation(this.OnlyStableInput, "bool")+",\n")
	}
	if this.MinInlierFraction != nil {
		s = append(s, "MinInlierFraction: "+valueToGoStringMotionEstimation(this.MinInlierFraction, "float32")+",\n")
	}
	if this.MinInliers != nil {
		s = append(s, "MinInliers: "+valueToGoStringMotionEstimation(this.MinInliers, "float32")+",\n")
	}
	if this.LowerScale != nil {
		s = append(s, "LowerScale: "+valueToGoStringMotionEstimation(this.LowerScale, "float32")+",\n")
	}
	if this.UpperScale != nil {
		s = append(s, "UpperScale: "+valueToGoStringMotionEstimation(this.UpperScale, "float32")+",\n")
	}
	if this.LimitRotation != nil {
		s = append(s, "LimitRotation: "+valueToGoStringMotionEstimation(this.LimitRotation, "float32")+",\n")
	}
	if this.InlierThreshold != nil {
		s = append(s, "InlierThreshold: "+valueToGoStringMotionEstimation(this.InlierThreshold, "float32")+",\n")
	}
	if this.FracInlierThreshold != nil {
		s = append(s, "FracInlierThreshold: "+valueToGoStringMotionEstimation(this.FracInlierThreshold, "float32")+",\n")
	}
	if this.StrictInlierThreshold != nil {
		s = append(s, "StrictInlierThreshold: "+valueToGoStringMotionEstimation(this.StrictInlierThreshold, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_HomographyBounds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tracking.MotionEstimationOptions_HomographyBounds{")
	if this.LowerScale != nil {
		s = append(s, "LowerScale: "+valueToGoStringMotionEstimation(this.LowerScale, "float32")+",\n")
	}
	if this.UpperScale != nil {
		s = append(s, "UpperScale: "+valueToGoStringMotionEstimation(this.UpperScale, "float32")+",\n")
	}
	if this.LimitRotation != nil {
		s = append(s, "LimitRotation: "+valueToGoStringMotionEstimation(this.LimitRotation, "float32")+",\n")
	}
	if this.LimitPerspective != nil {
		s = append(s, "LimitPerspective: "+valueToGoStringMotionEstimation(this.LimitPerspective, "float32")+",\n")
	}
	if this.RegistrationThreshold != nil {
		s = append(s, "RegistrationThreshold: "+valueToGoStringMotionEstimation(this.RegistrationThreshold, "float32")+",\n")
	}
	if this.FracRegistrationThreshold != nil {
		s = append(s, "FracRegistrationThreshold: "+valueToGoStringMotionEstimation(this.FracRegistrationThreshold, "float32")+",\n")
	}
	if this.MinInlierCoverage != nil {
		s = append(s, "MinInlierCoverage: "+valueToGoStringMotionEstimation(this.MinInlierCoverage, "float32")+",\n")
	}
	if this.FracInlierThreshold != nil {
		s = append(s, "FracInlierThreshold: "+valueToGoStringMotionEstimation(this.FracInlierThreshold, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_MixtureHomographyBounds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.MotionEstimationOptions_MixtureHomographyBounds{")
	if this.MinInlierCoverage != nil {
		s = append(s, "MinInlierCoverage: "+valueToGoStringMotionEstimation(this.MinInlierCoverage, "float32")+",\n")
	}
	if this.MaxAdjacentOutlierBlocks != nil {
		s = append(s, "MaxAdjacentOutlierBlocks: "+valueToGoStringMotionEstimation(this.MaxAdjacentOutlierBlocks, "int32")+",\n")
	}
	if this.MaxAdjacentEmptyBlocks != nil {
		s = append(s, "MaxAdjacentEmptyBlocks: "+valueToGoStringMotionEstimation(this.MaxAdjacentEmptyBlocks, "int32")+",\n")
	}
	if this.FracInlierThreshold != nil {
		s = append(s, "FracInlierThreshold: "+valueToGoStringMotionEstimation(this.FracInlierThreshold, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_OverlayDetectionOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&tracking.MotionEstimationOptions_OverlayDetectionOptions{")
	if this.AnalysisMaskSize != nil {
		s = append(s, "AnalysisMaskSize: "+valueToGoStringMotionEstimation(this.AnalysisMaskSize, "int32")+",\n")
	}
	if this.StrictNearZeroMotion != nil {
		s = append(s, "StrictNearZeroMotion: "+valueToGoStringMotionEstimation(this.StrictNearZeroMotion, "float32")+",\n")
	}
	if this.StrictMaxTranslationRatio != nil {
		s = append(s, "StrictMaxTranslationRatio: "+valueToGoStringMotionEstimation(this.StrictMaxTranslationRatio, "float32")+",\n")
	}
	if this.StrictMinTexturedness != nil {
		s = append(s, "StrictMinTexturedness: "+valueToGoStringMotionEstimation(this.StrictMinTexturedness, "float32")+",\n")
	}
	if this.LooseNearZeroMotion != nil {
		s = append(s, "LooseNearZeroMotion: "+valueToGoStringMotionEstimation(this.LooseNearZeroMotion, "float32")+",\n")
	}
	if this.OverlayMinRatio != nil {
		s = append(s, "OverlayMinRatio: "+valueToGoStringMotionEstimation(this.OverlayMinRatio, "float32")+",\n")
	}
	if this.OverlayMinFeatures != nil {
		s = append(s, "OverlayMinFeatures: "+valueToGoStringMotionEstimation(this.OverlayMinFeatures, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionEstimationOptions_ShotBoundaryOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.MotionEstimationOptions_ShotBoundaryOptions{")
	if this.MotionConsistencyThreshold != nil {
		s = append(s, "MotionConsistencyThreshold: "+valueToGoStringMotionEstimation(this.MotionConsistencyThreshold, "float32")+",\n")
	}
	if this.AppearanceConsistencyThreshold != nil {
		s = append(s, "AppearanceConsistencyThreshold: "+valueToGoStringMotionEstimation(this.AppearanceConsistencyThreshold, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMotionEstimation(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringMotionEstimation(m github_com_gogo_protobuf_proto.Message) string {
	e := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *MotionEstimationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.IrlsMixtureFractionScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.IrlsMixtureFractionScale))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa5
	}
	if m.FilterInitializedIrlsWeights != nil {
		i--
		if *m.FilterInitializedIrlsWeights {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.LongFeatureInitialization != nil {
		{
			size, err := m.LongFeatureInitialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x92
	}
	if m.DomainLimitedIrlsScaling != nil {
		i--
		if *m.DomainLimitedIrlsScaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.LongFeatureBiasOptions != nil {
		{
			size, err := m.LongFeatureBiasOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x82
	}
	if m.FeatureMaskSize != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.FeatureMaskSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.FeatureDensityNormalization != nil {
		i--
		if *m.FeatureDensityNormalization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.HomographyPerspectiveRegularizer != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.HomographyPerspectiveRegularizer))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.ShotBoundaryOptions != nil {
		{
			size, err := m.ShotBoundaryOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.JointTrackEstimation != nil {
		{
			size, err := m.JointTrackEstimation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	if m.EstimationPolicy != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.EstimationPolicy))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.IrlsMaskOptions != nil {
		{
			size, err := m.IrlsMaskOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.IrlsInitialization != nil {
		{
			size, err := m.IrlsInitialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc2
	}
	if m.UseHighestAccuracyForNormalEquations != nil {
		i--
		if *m.UseHighestAccuracyForNormalEquations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.UseExactHomographyEstimation != nil {
		i--
		if *m.UseExactHomographyEstimation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.HomographyExactDenominatorScaling != nil {
		i--
		if *m.HomographyExactDenominatorScaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.ProjectValidMotionsDown != nil {
		i--
		if *m.ProjectValidMotionsDown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.CoverageGridSize != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.CoverageGridSize))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.IrlsPriorScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.IrlsPriorScale))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x95
	}
	if m.ResetConfidenceThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ResetConfidenceThreshold))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8d
	}
	if m.FrameConfidenceWeighting != nil {
		i--
		if *m.FrameConfidenceWeighting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.DeactivateStableMotionEstimation != nil {
		i--
		if *m.DeactivateStableMotionEstimation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.IrlsUseL0Norm != nil {
		i--
		if *m.IrlsUseL0Norm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.HomographyIrlsWeightInitialization != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.HomographyIrlsWeightInitialization))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.MixtureRsAnalysisLevel != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MixtureRsAnalysisLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.MixtureRegularizerBase != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MixtureRegularizerBase))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xdd
	}
	if m.MixtureRegularizerLevels != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MixtureRegularizerLevels))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd5
	}
	if m.StrictCoverageScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StrictCoverageScale))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xcd
	}
	if m.OutputRefinedIrlsWeights != nil {
		i--
		if *m.OutputRefinedIrlsWeights {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.IrlsWeightsPreinitialized != nil {
		i--
		if *m.IrlsWeightsPreinitialized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.OverlayDetectionOptions != nil {
		{
			size, err := m.OverlayDetectionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.OverlayAnalysisChunkSize != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.OverlayAnalysisChunkSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.OverlayDetection != nil {
		i--
		if *m.OverlayDetection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.IrlsWeightFilter != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.IrlsWeightFilter))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.StableMixtureHomographyBounds != nil {
		{
			size, err := m.StableMixtureHomographyBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.StableSimilarityBounds != nil {
		{
			size, err := m.StableSimilarityBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.StableTranslationBounds != nil {
		{
			size, err := m.StableTranslationBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.IrlsMotionMagnitudeFraction != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.IrlsMotionMagnitudeFraction))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.AffineEstimation != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.AffineEstimation))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Filter_5Taps != nil {
		i--
		if *m.Filter_5Taps {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.FeatureSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FeatureSigma))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.TemporalSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.TemporalSigma))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.TemporalIrlsDiameter != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.TemporalIrlsDiameter))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SpatialSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.SpatialSigma))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.FeatureGridSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FeatureGridSize))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if m.MixtureModelMode != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MixtureModelMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.LabelEmptyFramesAsValid != nil {
		i--
		if *m.LabelEmptyFramesAsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.LinSimInlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LinSimInlierThreshold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.IrlsRounds != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.IrlsRounds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MixtureRegularizer != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MixtureRegularizer))))
		i--
		dAtA[i] = 0x7d
	}
	if m.MixtureRowSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MixtureRowSigma))))
		i--
		dAtA[i] = 0x75
	}
	if m.NumMixtures != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.NumMixtures))
		i--
		dAtA[i] = 0x68
	}
	if m.MixHomographyEstimation != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MixHomographyEstimation))
		i--
		dAtA[i] = 0x60
	}
	if m.StableHomographyBounds != nil {
		{
			size, err := m.StableHomographyBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMotionEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.UseOnlyLinSimInliersForHomography != nil {
		i--
		if *m.UseOnlyLinSimInliersForHomography {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HomographyEstimation != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.HomographyEstimation))
		i--
		dAtA[i] = 0x28
	}
	if m.LinearSimilarityEstimation != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.LinearSimilarityEstimation))
		i--
		dAtA[i] = 0x18
	}
	i--
	if m.EstimateSimilarity {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	if m.EstimateTranslationIrls != nil {
		i--
		if *m.EstimateTranslationIrls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cutoff != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Cutoff))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Rounds != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.Rounds))
		i--
		dAtA[i] = 0x10
	}
	if m.Activated != nil {
		i--
		if *m.Activated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_LongFeatureInitialization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_LongFeatureInitialization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_LongFeatureInitialization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpweightMultiplier != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.UpweightMultiplier))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MinLengthPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinLengthPercentile))))
		i--
		dAtA[i] = 0x15
	}
	if m.Activated != nil {
		i--
		if *m.Activated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_IrlsMaskOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_IrlsMaskOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_IrlsMaskOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.TranslationPriorIncrease != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.TranslationPriorIncrease))))
		i--
		dAtA[i] = 0x3d
	}
	if m.TranslationBlendAlpha != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.TranslationBlendAlpha))))
		i--
		dAtA[i] = 0x35
	}
	if m.MinTranslationNorm != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinTranslationNorm))))
		i--
		dAtA[i] = 0x2d
	}
	if m.BaseScore != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BaseScore))))
		i--
		dAtA[i] = 0x25
	}
	if m.InlierScore != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierScore))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Decay != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Decay))))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemporalSmoothing != nil {
		i--
		if *m.TemporalSmoothing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MotionStride != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MotionStride))
		i--
		dAtA[i] = 0x10
	}
	if m.NumMotionModels != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.NumMotionModels))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeedPriorsFromBias != nil {
		i--
		if *m.SeedPriorsFromBias {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.TotalRounds != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.TotalRounds))
		i--
		dAtA[i] = 0x68
	}
	if m.BiasStdev != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BiasStdev))))
		i--
		dAtA[i] = 0x65
	}
	if m.LongTrackConfidenceFraction != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LongTrackConfidenceFraction))))
		i--
		dAtA[i] = 0x5d
	}
	if m.LongTrackThreshold != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.LongTrackThreshold))
		i--
		dAtA[i] = 0x50
	}
	if m.ColorSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ColorSigma))))
		i--
		dAtA[i] = 0x4d
	}
	if m.SpatialSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.SpatialSigma))))
		i--
		dAtA[i] = 0x45
	}
	if m.GridSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.GridSize))))
		i--
		dAtA[i] = 0x3d
	}
	if m.UseSpatialBias != nil {
		i--
		if *m.UseSpatialBias {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.InlierIrlsWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierIrlsWeight))))
		i--
		dAtA[i] = 0x2d
	}
	if m.MaxIrlsChangeRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxIrlsChangeRatio))))
		i--
		dAtA[i] = 0x25
	}
	if m.NumIrlsObservations != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.NumIrlsObservations))
		i--
		dAtA[i] = 0x18
	}
	if m.OutlierBias != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OutlierBias))))
		i--
		dAtA[i] = 0x15
	}
	if m.InlierBias != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierBias))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_TranslationBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_TranslationBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_TranslationBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxAcceleration != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxAcceleration))))
		i--
		dAtA[i] = 0x2d
	}
	if m.MaxMotionStdevThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxMotionStdevThreshold))))
		i--
		dAtA[i] = 0x25
	}
	if m.MaxMotionStdev != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxMotionStdev))))
		i--
		dAtA[i] = 0x1d
	}
	if m.FracMaxMotionMagnitude != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracMaxMotionMagnitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.MinFeatures != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MinFeatures))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_SimilarityBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_SimilarityBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_SimilarityBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StrictInlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StrictInlierThreshold))))
		i--
		dAtA[i] = 0x4d
	}
	if m.FracInlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracInlierThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.InlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierThreshold))))
		i--
		dAtA[i] = 0x3d
	}
	if m.LimitRotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LimitRotation))))
		i--
		dAtA[i] = 0x35
	}
	if m.UpperScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.UpperScale))))
		i--
		dAtA[i] = 0x2d
	}
	if m.LowerScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LowerScale))))
		i--
		dAtA[i] = 0x25
	}
	if m.MinInliers != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInliers))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MinInlierFraction != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierFraction))))
		i--
		dAtA[i] = 0x15
	}
	if m.OnlyStableInput != nil {
		i--
		if *m.OnlyStableInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_HomographyBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_HomographyBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_HomographyBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FracRegistrationThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracRegistrationThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.FracInlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracInlierThreshold))))
		i--
		dAtA[i] = 0x3d
	}
	if m.MinInlierCoverage != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierCoverage))))
		i--
		dAtA[i] = 0x35
	}
	if m.RegistrationThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RegistrationThreshold))))
		i--
		dAtA[i] = 0x2d
	}
	if m.LimitPerspective != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LimitPerspective))))
		i--
		dAtA[i] = 0x25
	}
	if m.LimitRotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LimitRotation))))
		i--
		dAtA[i] = 0x1d
	}
	if m.UpperScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.UpperScale))))
		i--
		dAtA[i] = 0x15
	}
	if m.LowerScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LowerScale))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FracInlierThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracInlierThreshold))))
		i--
		dAtA[i] = 0x3d
	}
	if m.MaxAdjacentEmptyBlocks != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MaxAdjacentEmptyBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxAdjacentOutlierBlocks != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.MaxAdjacentOutlierBlocks))
		i--
		dAtA[i] = 0x10
	}
	if m.MinInlierCoverage != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierCoverage))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlayMinFeatures != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OverlayMinFeatures))))
		i--
		dAtA[i] = 0x3d
	}
	if m.OverlayMinRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OverlayMinRatio))))
		i--
		dAtA[i] = 0x35
	}
	if m.StrictMinTexturedness != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StrictMinTexturedness))))
		i--
		dAtA[i] = 0x2d
	}
	if m.LooseNearZeroMotion != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LooseNearZeroMotion))))
		i--
		dAtA[i] = 0x25
	}
	if m.StrictMaxTranslationRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StrictMaxTranslationRatio))))
		i--
		dAtA[i] = 0x1d
	}
	if m.StrictNearZeroMotion != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StrictNearZeroMotion))))
		i--
		dAtA[i] = 0x15
	}
	if m.AnalysisMaskSize != nil {
		i = encodeVarintMotionEstimation(dAtA, i, uint64(*m.AnalysisMaskSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppearanceConsistencyThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AppearanceConsistencyThreshold))))
		i--
		dAtA[i] = 0x15
	}
	if m.MotionConsistencyThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MotionConsistencyThreshold))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func encodeVarintMotionEstimation(dAtA []byte, offset int, v uint64) int {
	offset -= sovMotionEstimation(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MotionEstimationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EstimateTranslationIrls != nil {
		n += 2
	}
	n += 2
	if m.LinearSimilarityEstimation != nil {
		n += 1 + sovMotionEstimation(uint64(*m.LinearSimilarityEstimation))
	}
	if m.HomographyEstimation != nil {
		n += 1 + sovMotionEstimation(uint64(*m.HomographyEstimation))
	}
	if m.UseOnlyLinSimInliersForHomography != nil {
		n += 2
	}
	if m.StableHomographyBounds != nil {
		l = m.StableHomographyBounds.Size()
		n += 1 + l + sovMotionEstimation(uint64(l))
	}
	if m.MixHomographyEstimation != nil {
		n += 1 + sovMotionEstimation(uint64(*m.MixHomographyEstimation))
	}
	if m.NumMixtures != nil {
		n += 1 + sovMotionEstimation(uint64(*m.NumMixtures))
	}
	if m.MixtureRowSigma != nil {
		n += 5
	}
	if m.MixtureRegularizer != nil {
		n += 5
	}
	if m.IrlsRounds != nil {
		n += 2 + sovMotionEstimation(uint64(*m.IrlsRounds))
	}
	if m.LinSimInlierThreshold != nil {
		n += 6
	}
	if m.LabelEmptyFramesAsValid != nil {
		n += 3
	}
	if m.MixtureModelMode != nil {
		n += 2 + sovMotionEstimation(uint64(*m.MixtureModelMode))
	}
	if m.FeatureGridSize != nil {
		n += 6
	}
	if m.SpatialSigma != nil {
		n += 6
	}
	if m.TemporalIrlsDiameter != nil {
		n += 2 + sovMotionEstimation(uint64(*m.TemporalIrlsDiameter))
	}
	if m.TemporalSigma != nil {
		n += 6
	}
	if m.FeatureSigma != nil {
		n += 6
	}
	if m.Filter_5Taps != nil {
		n += 3
	}
	if m.AffineEstimation != nil {
		n += 2 + sovMotionEstimation(uint64(*m.AffineEstimation))
	}
	if m.IrlsMotionMagnitudeFraction != nil {
		n += 6
	}
	if m.StableTranslationBounds != nil {
		l = m.StableTranslationBounds.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.StableSimilarityBounds != nil {
		l = m.StableSimilarityBounds.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.StableMixtureHomographyBounds != nil {
		l = m.StableMixtureHomographyBounds.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.IrlsWeightFilter != nil {
		n += 2 + sovMotionEstimation(uint64(*m.IrlsWeightFilter))
	}
	if m.OverlayDetection != nil {
		n += 3
	}
	if m.OverlayAnalysisChunkSize != nil {
		n += 2 + sovMotionEstimation(uint64(*m.OverlayAnalysisChunkSize))
	}
	if m.OverlayDetectionOptions != nil {
		l = m.OverlayDetectionOptions.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.IrlsWeightsPreinitialized != nil {
		n += 3
	}
	if m.OutputRefinedIrlsWeights != nil {
		n += 3
	}
	if m.StrictCoverageScale != nil {
		n += 6
	}
	if m.MixtureRegularizerLevels != nil {
		n += 6
	}
	if m.MixtureRegularizerBase != nil {
		n += 6
	}
	if m.MixtureRsAnalysisLevel != nil {
		n += 2 + sovMotionEstimation(uint64(*m.MixtureRsAnalysisLevel))
	}
	if m.HomographyIrlsWeightInitialization != nil {
		n += 2 + sovMotionEstimation(uint64(*m.HomographyIrlsWeightInitialization))
	}
	if m.IrlsUseL0Norm != nil {
		n += 3
	}
	if m.DeactivateStableMotionEstimation != nil {
		n += 3
	}
	if m.FrameConfidenceWeighting != nil {
		n += 3
	}
	if m.ResetConfidenceThreshold != nil {
		n += 6
	}
	if m.IrlsPriorScale != nil {
		n += 6
	}
	if m.CoverageGridSize != nil {
		n += 2 + sovMotionEstimation(uint64(*m.CoverageGridSize))
	}
	if m.ProjectValidMotionsDown != nil {
		n += 3
	}
	if m.HomographyExactDenominatorScaling != nil {
		n += 3
	}
	if m.UseExactHomographyEstimation != nil {
		n += 3
	}
	if m.UseHighestAccuracyForNormalEquations != nil {
		n += 3
	}
	if m.IrlsInitialization != nil {
		l = m.IrlsInitialization.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.IrlsMaskOptions != nil {
		l = m.IrlsMaskOptions.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.EstimationPolicy != nil {
		n += 2 + sovMotionEstimation(uint64(*m.EstimationPolicy))
	}
	if m.JointTrackEstimation != nil {
		l = m.JointTrackEstimation.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.ShotBoundaryOptions != nil {
		l = m.ShotBoundaryOptions.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.HomographyPerspectiveRegularizer != nil {
		n += 6
	}
	if m.FeatureDensityNormalization != nil {
		n += 3
	}
	if m.FeatureMaskSize != nil {
		n += 2 + sovMotionEstimation(uint64(*m.FeatureMaskSize))
	}
	if m.LongFeatureBiasOptions != nil {
		l = m.LongFeatureBiasOptions.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.DomainLimitedIrlsScaling != nil {
		n += 3
	}
	if m.LongFeatureInitialization != nil {
		l = m.LongFeatureInitialization.Size()
		n += 2 + l + sovMotionEstimation(uint64(l))
	}
	if m.FilterInitializedIrlsWeights != nil {
		n += 3
	}
	if m.IrlsMixtureFractionScale != nil {
		n += 6
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *MotionEstimationOptions_IrlsOutlierInitialization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Activated != nil {
		n += 2
	}
	if m.Rounds != nil {
		n += 1 + sovMotionEstimation(uint64(*m.Rounds))
	}
	if m.Cutoff != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_LongFeatureInitialization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Activated != nil {
		n += 2
	}
	if m.MinLengthPercentile != nil {
		n += 5
	}
	if m.UpweightMultiplier != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_IrlsMaskOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decay != nil {
		n += 5
	}
	if m.InlierScore != nil {
		n += 5
	}
	if m.BaseScore != nil {
		n += 5
	}
	if m.MinTranslationNorm != nil {
		n += 5
	}
	if m.TranslationBlendAlpha != nil {
		n += 5
	}
	if m.TranslationPriorIncrease != nil {
		n += 5
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *MotionEstimationOptions_JointTrackEstimationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumMotionModels != nil {
		n += 1 + sovMotionEstimation(uint64(*m.NumMotionModels))
	}
	if m.MotionStride != nil {
		n += 1 + sovMotionEstimation(uint64(*m.MotionStride))
	}
	if m.TemporalSmoothing != nil {
		n += 2
	}
	return n
}

func (m *MotionEstimationOptions_LongFeatureBiasOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InlierBias != nil {
		n += 5
	}
	if m.OutlierBias != nil {
		n += 5
	}
	if m.NumIrlsObservations != nil {
		n += 1 + sovMotionEstimation(uint64(*m.NumIrlsObservations))
	}
	if m.MaxIrlsChangeRatio != nil {
		n += 5
	}
	if m.InlierIrlsWeight != nil {
		n += 5
	}
	if m.UseSpatialBias != nil {
		n += 2
	}
	if m.GridSize != nil {
		n += 5
	}
	if m.SpatialSigma != nil {
		n += 5
	}
	if m.ColorSigma != nil {
		n += 5
	}
	if m.LongTrackThreshold != nil {
		n += 1 + sovMotionEstimation(uint64(*m.LongTrackThreshold))
	}
	if m.LongTrackConfidenceFraction != nil {
		n += 5
	}
	if m.BiasStdev != nil {
		n += 5
	}
	if m.TotalRounds != nil {
		n += 1 + sovMotionEstimation(uint64(*m.TotalRounds))
	}
	if m.SeedPriorsFromBias != nil {
		n += 2
	}
	return n
}

func (m *MotionEstimationOptions_TranslationBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinFeatures != nil {
		n += 1 + sovMotionEstimation(uint64(*m.MinFeatures))
	}
	if m.FracMaxMotionMagnitude != nil {
		n += 5
	}
	if m.MaxMotionStdev != nil {
		n += 5
	}
	if m.MaxMotionStdevThreshold != nil {
		n += 5
	}
	if m.MaxAcceleration != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_SimilarityBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnlyStableInput != nil {
		n += 2
	}
	if m.MinInlierFraction != nil {
		n += 5
	}
	if m.MinInliers != nil {
		n += 5
	}
	if m.LowerScale != nil {
		n += 5
	}
	if m.UpperScale != nil {
		n += 5
	}
	if m.LimitRotation != nil {
		n += 5
	}
	if m.InlierThreshold != nil {
		n += 5
	}
	if m.FracInlierThreshold != nil {
		n += 5
	}
	if m.StrictInlierThreshold != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_HomographyBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowerScale != nil {
		n += 5
	}
	if m.UpperScale != nil {
		n += 5
	}
	if m.LimitRotation != nil {
		n += 5
	}
	if m.LimitPerspective != nil {
		n += 5
	}
	if m.RegistrationThreshold != nil {
		n += 5
	}
	if m.MinInlierCoverage != nil {
		n += 5
	}
	if m.FracInlierThreshold != nil {
		n += 5
	}
	if m.FracRegistrationThreshold != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_MixtureHomographyBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinInlierCoverage != nil {
		n += 5
	}
	if m.MaxAdjacentOutlierBlocks != nil {
		n += 1 + sovMotionEstimation(uint64(*m.MaxAdjacentOutlierBlocks))
	}
	if m.MaxAdjacentEmptyBlocks != nil {
		n += 1 + sovMotionEstimation(uint64(*m.MaxAdjacentEmptyBlocks))
	}
	if m.FracInlierThreshold != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_OverlayDetectionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnalysisMaskSize != nil {
		n += 1 + sovMotionEstimation(uint64(*m.AnalysisMaskSize))
	}
	if m.StrictNearZeroMotion != nil {
		n += 5
	}
	if m.StrictMaxTranslationRatio != nil {
		n += 5
	}
	if m.LooseNearZeroMotion != nil {
		n += 5
	}
	if m.StrictMinTexturedness != nil {
		n += 5
	}
	if m.OverlayMinRatio != nil {
		n += 5
	}
	if m.OverlayMinFeatures != nil {
		n += 5
	}
	return n
}

func (m *MotionEstimationOptions_ShotBoundaryOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MotionConsistencyThreshold != nil {
		n += 5
	}
	if m.AppearanceConsistencyThreshold != nil {
		n += 5
	}
	return n
}

func sovMotionEstimation(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMotionEstimation(x uint64) (n int) {
	return sovMotionEstimation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MotionEstimationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions{`,
		`EstimateTranslationIrls:` + valueToStringMotionEstimation(this.EstimateTranslationIrls) + `,`,
		`EstimateSimilarity:` + fmt.Sprintf("%v", this.EstimateSimilarity) + `,`,
		`LinearSimilarityEstimation:` + valueToStringMotionEstimation(this.LinearSimilarityEstimation) + `,`,
		`HomographyEstimation:` + valueToStringMotionEstimation(this.HomographyEstimation) + `,`,
		`UseOnlyLinSimInliersForHomography:` + valueToStringMotionEstimation(this.UseOnlyLinSimInliersForHomography) + `,`,
		`StableHomographyBounds:` + strings.Replace(fmt.Sprintf("%v", this.StableHomographyBounds), "MotionEstimationOptions_HomographyBounds", "MotionEstimationOptions_HomographyBounds", 1) + `,`,
		`MixHomographyEstimation:` + valueToStringMotionEstimation(this.MixHomographyEstimation) + `,`,
		`NumMixtures:` + valueToStringMotionEstimation(this.NumMixtures) + `,`,
		`MixtureRowSigma:` + valueToStringMotionEstimation(this.MixtureRowSigma) + `,`,
		`MixtureRegularizer:` + valueToStringMotionEstimation(this.MixtureRegularizer) + `,`,
		`IrlsRounds:` + valueToStringMotionEstimation(this.IrlsRounds) + `,`,
		`LinSimInlierThreshold:` + valueToStringMotionEstimation(this.LinSimInlierThreshold) + `,`,
		`LabelEmptyFramesAsValid:` + valueToStringMotionEstimation(this.LabelEmptyFramesAsValid) + `,`,
		`MixtureModelMode:` + valueToStringMotionEstimation(this.MixtureModelMode) + `,`,
		`FeatureGridSize:` + valueToStringMotionEstimation(this.FeatureGridSize) + `,`,
		`SpatialSigma:` + valueToStringMotionEstimation(this.SpatialSigma) + `,`,
		`TemporalIrlsDiameter:` + valueToStringMotionEstimation(this.TemporalIrlsDiameter) + `,`,
		`TemporalSigma:` + valueToStringMotionEstimation(this.TemporalSigma) + `,`,
		`FeatureSigma:` + valueToStringMotionEstimation(this.FeatureSigma) + `,`,
		`Filter_5Taps:` + valueToStringMotionEstimation(this.Filter_5Taps) + `,`,
		`AffineEstimation:` + valueToStringMotionEstimation(this.AffineEstimation) + `,`,
		`IrlsMotionMagnitudeFraction:` + valueToStringMotionEstimation(this.IrlsMotionMagnitudeFraction) + `,`,
		`StableTranslationBounds:` + strings.Replace(fmt.Sprintf("%v", this.StableTranslationBounds), "MotionEstimationOptions_TranslationBounds", "MotionEstimationOptions_TranslationBounds", 1) + `,`,
		`StableSimilarityBounds:` + strings.Replace(fmt.Sprintf("%v", this.StableSimilarityBounds), "MotionEstimationOptions_SimilarityBounds", "MotionEstimationOptions_SimilarityBounds", 1) + `,`,
		`StableMixtureHomographyBounds:` + strings.Replace(fmt.Sprintf("%v", this.StableMixtureHomographyBounds), "MotionEstimationOptions_MixtureHomographyBounds", "MotionEstimationOptions_MixtureHomographyBounds", 1) + `,`,
		`IrlsWeightFilter:` + valueToStringMotionEstimation(this.IrlsWeightFilter) + `,`,
		`OverlayDetection:` + valueToStringMotionEstimation(this.OverlayDetection) + `,`,
		`OverlayAnalysisChunkSize:` + valueToStringMotionEstimation(this.OverlayAnalysisChunkSize) + `,`,
		`OverlayDetectionOptions:` + strings.Replace(fmt.Sprintf("%v", this.OverlayDetectionOptions), "MotionEstimationOptions_OverlayDetectionOptions", "MotionEstimationOptions_OverlayDetectionOptions", 1) + `,`,
		`IrlsWeightsPreinitialized:` + valueToStringMotionEstimation(this.IrlsWeightsPreinitialized) + `,`,
		`OutputRefinedIrlsWeights:` + valueToStringMotionEstimation(this.OutputRefinedIrlsWeights) + `,`,
		`StrictCoverageScale:` + valueToStringMotionEstimation(this.StrictCoverageScale) + `,`,
		`MixtureRegularizerLevels:` + valueToStringMotionEstimation(this.MixtureRegularizerLevels) + `,`,
		`MixtureRegularizerBase:` + valueToStringMotionEstimation(this.MixtureRegularizerBase) + `,`,
		`MixtureRsAnalysisLevel:` + valueToStringMotionEstimation(this.MixtureRsAnalysisLevel) + `,`,
		`HomographyIrlsWeightInitialization:` + valueToStringMotionEstimation(this.HomographyIrlsWeightInitialization) + `,`,
		`IrlsUseL0Norm:` + valueToStringMotionEstimation(this.IrlsUseL0Norm) + `,`,
		`DeactivateStableMotionEstimation:` + valueToStringMotionEstimation(this.DeactivateStableMotionEstimation) + `,`,
		`FrameConfidenceWeighting:` + valueToStringMotionEstimation(this.FrameConfidenceWeighting) + `,`,
		`ResetConfidenceThreshold:` + valueToStringMotionEstimation(this.ResetConfidenceThreshold) + `,`,
		`IrlsPriorScale:` + valueToStringMotionEstimation(this.IrlsPriorScale) + `,`,
		`CoverageGridSize:` + valueToStringMotionEstimation(this.CoverageGridSize) + `,`,
		`ProjectValidMotionsDown:` + valueToStringMotionEstimation(this.ProjectValidMotionsDown) + `,`,
		`HomographyExactDenominatorScaling:` + valueToStringMotionEstimation(this.HomographyExactDenominatorScaling) + `,`,
		`UseExactHomographyEstimation:` + valueToStringMotionEstimation(this.UseExactHomographyEstimation) + `,`,
		`UseHighestAccuracyForNormalEquations:` + valueToStringMotionEstimation(this.UseHighestAccuracyForNormalEquations) + `,`,
		`IrlsInitialization:` + strings.Replace(fmt.Sprintf("%v", this.IrlsInitialization), "MotionEstimationOptions_IrlsOutlierInitialization", "MotionEstimationOptions_IrlsOutlierInitialization", 1) + `,`,
		`IrlsMaskOptions:` + strings.Replace(fmt.Sprintf("%v", this.IrlsMaskOptions), "MotionEstimationOptions_IrlsMaskOptions", "MotionEstimationOptions_IrlsMaskOptions", 1) + `,`,
		`EstimationPolicy:` + valueToStringMotionEstimation(this.EstimationPolicy) + `,`,
		`JointTrackEstimation:` + strings.Replace(fmt.Sprintf("%v", this.JointTrackEstimation), "MotionEstimationOptions_JointTrackEstimationOptions", "MotionEstimationOptions_JointTrackEstimationOptions", 1) + `,`,
		`ShotBoundaryOptions:` + strings.Replace(fmt.Sprintf("%v", this.ShotBoundaryOptions), "MotionEstimationOptions_ShotBoundaryOptions", "MotionEstimationOptions_ShotBoundaryOptions", 1) + `,`,
		`HomographyPerspectiveRegularizer:` + valueToStringMotionEstimation(this.HomographyPerspectiveRegularizer) + `,`,
		`FeatureDensityNormalization:` + valueToStringMotionEstimation(this.FeatureDensityNormalization) + `,`,
		`FeatureMaskSize:` + valueToStringMotionEstimation(this.FeatureMaskSize) + `,`,
		`LongFeatureBiasOptions:` + strings.Replace(fmt.Sprintf("%v", this.LongFeatureBiasOptions), "MotionEstimationOptions_LongFeatureBiasOptions", "MotionEstimationOptions_LongFeatureBiasOptions", 1) + `,`,
		`DomainLimitedIrlsScaling:` + valueToStringMotionEstimation(this.DomainLimitedIrlsScaling) + `,`,
		`LongFeatureInitialization:` + strings.Replace(fmt.Sprintf("%v", this.LongFeatureInitialization), "MotionEstimationOptions_LongFeatureInitialization", "MotionEstimationOptions_LongFeatureInitialization", 1) + `,`,
		`FilterInitializedIrlsWeights:` + valueToStringMotionEstimation(this.FilterInitializedIrlsWeights) + `,`,
		`IrlsMixtureFractionScale:` + valueToStringMotionEstimation(this.IrlsMixtureFractionScale) + `,`,
		`XXX_InternalExtensions:` + github_com_gogo_protobuf_proto.StringFromInternalExtension(this) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_IrlsOutlierInitialization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_IrlsOutlierInitialization{`,
		`Activated:` + valueToStringMotionEstimation(this.Activated) + `,`,
		`Rounds:` + valueToStringMotionEstimation(this.Rounds) + `,`,
		`Cutoff:` + valueToStringMotionEstimation(this.Cutoff) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_LongFeatureInitialization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_LongFeatureInitialization{`,
		`Activated:` + valueToStringMotionEstimation(this.Activated) + `,`,
		`MinLengthPercentile:` + valueToStringMotionEstimation(this.MinLengthPercentile) + `,`,
		`UpweightMultiplier:` + valueToStringMotionEstimation(this.UpweightMultiplier) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_IrlsMaskOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_IrlsMaskOptions{`,
		`Decay:` + valueToStringMotionEstimation(this.Decay) + `,`,
		`InlierScore:` + valueToStringMotionEstimation(this.InlierScore) + `,`,
		`BaseScore:` + valueToStringMotionEstimation(this.BaseScore) + `,`,
		`MinTranslationNorm:` + valueToStringMotionEstimation(this.MinTranslationNorm) + `,`,
		`TranslationBlendAlpha:` + valueToStringMotionEstimation(this.TranslationBlendAlpha) + `,`,
		`TranslationPriorIncrease:` + valueToStringMotionEstimation(this.TranslationPriorIncrease) + `,`,
		`XXX_InternalExtensions:` + github_com_gogo_protobuf_proto.StringFromInternalExtension(this) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_JointTrackEstimationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_JointTrackEstimationOptions{`,
		`NumMotionModels:` + valueToStringMotionEstimation(this.NumMotionModels) + `,`,
		`MotionStride:` + valueToStringMotionEstimation(this.MotionStride) + `,`,
		`TemporalSmoothing:` + valueToStringMotionEstimation(this.TemporalSmoothing) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_LongFeatureBiasOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_LongFeatureBiasOptions{`,
		`InlierBias:` + valueToStringMotionEstimation(this.InlierBias) + `,`,
		`OutlierBias:` + valueToStringMotionEstimation(this.OutlierBias) + `,`,
		`NumIrlsObservations:` + valueToStringMotionEstimation(this.NumIrlsObservations) + `,`,
		`MaxIrlsChangeRatio:` + valueToStringMotionEstimation(this.MaxIrlsChangeRatio) + `,`,
		`InlierIrlsWeight:` + valueToStringMotionEstimation(this.InlierIrlsWeight) + `,`,
		`UseSpatialBias:` + valueToStringMotionEstimation(this.UseSpatialBias) + `,`,
		`GridSize:` + valueToStringMotionEstimation(this.GridSize) + `,`,
		`SpatialSigma:` + valueToStringMotionEstimation(this.SpatialSigma) + `,`,
		`ColorSigma:` + valueToStringMotionEstimation(this.ColorSigma) + `,`,
		`LongTrackThreshold:` + valueToStringMotionEstimation(this.LongTrackThreshold) + `,`,
		`LongTrackConfidenceFraction:` + valueToStringMotionEstimation(this.LongTrackConfidenceFraction) + `,`,
		`BiasStdev:` + valueToStringMotionEstimation(this.BiasStdev) + `,`,
		`TotalRounds:` + valueToStringMotionEstimation(this.TotalRounds) + `,`,
		`SeedPriorsFromBias:` + valueToStringMotionEstimation(this.SeedPriorsFromBias) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_TranslationBounds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_TranslationBounds{`,
		`MinFeatures:` + valueToStringMotionEstimation(this.MinFeatures) + `,`,
		`FracMaxMotionMagnitude:` + valueToStringMotionEstimation(this.FracMaxMotionMagnitude) + `,`,
		`MaxMotionStdev:` + valueToStringMotionEstimation(this.MaxMotionStdev) + `,`,
		`MaxMotionStdevThreshold:` + valueToStringMotionEstimation(this.MaxMotionStdevThreshold) + `,`,
		`MaxAcceleration:` + valueToStringMotionEstimation(this.MaxAcceleration) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_SimilarityBounds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_SimilarityBounds{`,
		`OnlyStableInput:` + valueToStringMotionEstimation(this.OnlyStableInput) + `,`,
		`MinInlierFraction:` + valueToStringMotionEstimation(this.MinInlierFraction) + `,`,
		`MinInliers:` + valueToStringMotionEstimation(this.MinInliers) + `,`,
		`LowerScale:` + valueToStringMotionEstimation(this.LowerScale) + `,`,
		`UpperScale:` + valueToStringMotionEstimation(this.UpperScale) + `,`,
		`LimitRotation:` + valueToStringMotionEstimation(this.LimitRotation) + `,`,
		`InlierThreshold:` + valueToStringMotionEstimation(this.InlierThreshold) + `,`,
		`FracInlierThreshold:` + valueToStringMotionEstimation(this.FracInlierThreshold) + `,`,
		`StrictInlierThreshold:` + valueToStringMotionEstimation(this.StrictInlierThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_HomographyBounds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_HomographyBounds{`,
		`LowerScale:` + valueToStringMotionEstimation(this.LowerScale) + `,`,
		`UpperScale:` + valueToStringMotionEstimation(this.UpperScale) + `,`,
		`LimitRotation:` + valueToStringMotionEstimation(this.LimitRotation) + `,`,
		`LimitPerspective:` + valueToStringMotionEstimation(this.LimitPerspective) + `,`,
		`RegistrationThreshold:` + valueToStringMotionEstimation(this.RegistrationThreshold) + `,`,
		`MinInlierCoverage:` + valueToStringMotionEstimation(this.MinInlierCoverage) + `,`,
		`FracInlierThreshold:` + valueToStringMotionEstimation(this.FracInlierThreshold) + `,`,
		`FracRegistrationThreshold:` + valueToStringMotionEstimation(this.FracRegistrationThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_MixtureHomographyBounds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_MixtureHomographyBounds{`,
		`MinInlierCoverage:` + valueToStringMotionEstimation(this.MinInlierCoverage) + `,`,
		`MaxAdjacentOutlierBlocks:` + valueToStringMotionEstimation(this.MaxAdjacentOutlierBlocks) + `,`,
		`MaxAdjacentEmptyBlocks:` + valueToStringMotionEstimation(this.MaxAdjacentEmptyBlocks) + `,`,
		`FracInlierThreshold:` + valueToStringMotionEstimation(this.FracInlierThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_OverlayDetectionOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_OverlayDetectionOptions{`,
		`AnalysisMaskSize:` + valueToStringMotionEstimation(this.AnalysisMaskSize) + `,`,
		`StrictNearZeroMotion:` + valueToStringMotionEstimation(this.StrictNearZeroMotion) + `,`,
		`StrictMaxTranslationRatio:` + valueToStringMotionEstimation(this.StrictMaxTranslationRatio) + `,`,
		`LooseNearZeroMotion:` + valueToStringMotionEstimation(this.LooseNearZeroMotion) + `,`,
		`StrictMinTexturedness:` + valueToStringMotionEstimation(this.StrictMinTexturedness) + `,`,
		`OverlayMinRatio:` + valueToStringMotionEstimation(this.OverlayMinRatio) + `,`,
		`OverlayMinFeatures:` + valueToStringMotionEstimation(this.OverlayMinFeatures) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionEstimationOptions_ShotBoundaryOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionEstimationOptions_ShotBoundaryOptions{`,
		`MotionConsistencyThreshold:` + valueToStringMotionEstimation(this.MotionConsistencyThreshold) + `,`,
		`AppearanceConsistencyThreshold:` + valueToStringMotionEstimation(this.AppearanceConsistencyThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMotionEstimation(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MotionEstimationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MotionEstimationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MotionEstimationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimateTranslationIrls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EstimateTranslationIrls = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimateSimilarity", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EstimateSimilarity = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinearSimilarityEstimation", wireType)
			}
			var v MotionEstimationOptions_LinearSimilarityEstimation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_LinearSimilarityEstimation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LinearSimilarityEstimation = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomographyEstimation", wireType)
			}
			var v MotionEstimationOptions_HomographyEstimation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_HomographyEstimation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HomographyEstimation = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOnlyLinSimInliersForHomography", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseOnlyLinSimInliersForHomography = &b
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableHomographyBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StableHomographyBounds == nil {
				m.StableHomographyBounds = &MotionEstimationOptions_HomographyBounds{}
			}
			if err := m.StableHomographyBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixHomographyEstimation", wireType)
			}
			var v MotionEstimationOptions_MixtureHomographyEstimation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_MixtureHomographyEstimation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MixHomographyEstimation = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMixtures", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumMixtures = &v
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureRowSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MixtureRowSigma = &v2
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureRegularizer", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MixtureRegularizer = &v2
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsRounds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrlsRounds = &v
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinSimInlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LinSimInlierThreshold = &v2
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelEmptyFramesAsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LabelEmptyFramesAsValid = &b
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureModelMode", wireType)
			}
			var v MotionEstimationOptions_MixtureModelMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_MixtureModelMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MixtureModelMode = &v
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureGridSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FeatureGridSize = &v2
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.SpatialSigma = &v2
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporalIrlsDiameter", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TemporalIrlsDiameter = &v
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporalSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.TemporalSigma = &v2
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FeatureSigma = &v2
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter_5Taps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Filter_5Taps = &b
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffineEstimation", wireType)
			}
			var v MotionEstimationOptions_AffineEstimation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_AffineEstimation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AffineEstimation = &v
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsMotionMagnitudeFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.IrlsMotionMagnitudeFraction = &v2
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableTranslationBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StableTranslationBounds == nil {
				m.StableTranslationBounds = &MotionEstimationOptions_TranslationBounds{}
			}
			if err := m.StableTranslationBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableSimilarityBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StableSimilarityBounds == nil {
				m.StableSimilarityBounds = &MotionEstimationOptions_SimilarityBounds{}
			}
			if err := m.StableSimilarityBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableMixtureHomographyBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StableMixtureHomographyBounds == nil {
				m.StableMixtureHomographyBounds = &MotionEstimationOptions_MixtureHomographyBounds{}
			}
			if err := m.StableMixtureHomographyBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsWeightFilter", wireType)
			}
			var v MotionEstimationOptions_IRLSWeightFilter
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_IRLSWeightFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrlsWeightFilter = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayDetection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OverlayDetection = &b
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayAnalysisChunkSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlayAnalysisChunkSize = &v
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayDetectionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OverlayDetectionOptions == nil {
				m.OverlayDetectionOptions = &MotionEstimationOptions_OverlayDetectionOptions{}
			}
			if err := m.OverlayDetectionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsWeightsPreinitialized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IrlsWeightsPreinitialized = &b
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRefinedIrlsWeights", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OutputRefinedIrlsWeights = &b
		case 41:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictCoverageScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StrictCoverageScale = &v2
		case 42:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureRegularizerLevels", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MixtureRegularizerLevels = &v2
		case 43:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureRegularizerBase", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MixtureRegularizerBase = &v2
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureRsAnalysisLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MixtureRsAnalysisLevel = &v
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomographyIrlsWeightInitialization", wireType)
			}
			var v MotionEstimationOptions_HomographyIrlsWeightInitialization
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_HomographyIrlsWeightInitialization(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HomographyIrlsWeightInitialization = &v
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsUseL0Norm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IrlsUseL0Norm = &b
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeactivateStableMotionEstimation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DeactivateStableMotionEstimation = &b
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameConfidenceWeighting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FrameConfidenceWeighting = &b
		case 49:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetConfidenceThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ResetConfidenceThreshold = &v2
		case 50:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsPriorScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.IrlsPriorScale = &v2
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverageGridSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CoverageGridSize = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectValidMotionsDown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ProjectValidMotionsDown = &b
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomographyExactDenominatorScaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HomographyExactDenominatorScaling = &b
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseExactHomographyEstimation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseExactHomographyEstimation = &b
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHighestAccuracyForNormalEquations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseHighestAccuracyForNormalEquations = &b
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsInitialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IrlsInitialization == nil {
				m.IrlsInitialization = &MotionEstimationOptions_IrlsOutlierInitialization{}
			}
			if err := m.IrlsInitialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsMaskOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IrlsMaskOptions == nil {
				m.IrlsMaskOptions = &MotionEstimationOptions_IrlsMaskOptions{}
			}
			if err := m.IrlsMaskOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimationPolicy", wireType)
			}
			var v MotionEstimationOptions_EstimationPolicy
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionEstimationOptions_EstimationPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EstimationPolicy = &v
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JointTrackEstimation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JointTrackEstimation == nil {
				m.JointTrackEstimation = &MotionEstimationOptions_JointTrackEstimationOptions{}
			}
			if err := m.JointTrackEstimation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShotBoundaryOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShotBoundaryOptions == nil {
				m.ShotBoundaryOptions = &MotionEstimationOptions_ShotBoundaryOptions{}
			}
			if err := m.ShotBoundaryOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomographyPerspectiveRegularizer", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.HomographyPerspectiveRegularizer = &v2
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureDensityNormalization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FeatureDensityNormalization = &b
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureMaskSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeatureMaskSize = &v
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongFeatureBiasOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LongFeatureBiasOptions == nil {
				m.LongFeatureBiasOptions = &MotionEstimationOptions_LongFeatureBiasOptions{}
			}
			if err := m.LongFeatureBiasOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainLimitedIrlsScaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DomainLimitedIrlsScaling = &b
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongFeatureInitialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LongFeatureInitialization == nil {
				m.LongFeatureInitialization = &MotionEstimationOptions_LongFeatureInitialization{}
			}
			if err := m.LongFeatureInitialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterInitializedIrlsWeights", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FilterInitializedIrlsWeights = &b
		case 68:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsMixtureFractionScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.IrlsMixtureFractionScale = &v2
		default:
			if ((fieldNum >= 7) && (fieldNum < 8)) || ((fieldNum >= 8) && (fieldNum < 9)) || ((fieldNum >= 16) && (fieldNum < 17)) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipMotionEstimation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthMotionEstimation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipMotionEstimation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthMotionEstimation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_IrlsOutlierInitialization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IrlsOutlierInitialization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IrlsOutlierInitialization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Activated = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rounds = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cutoff", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Cutoff = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_LongFeatureInitialization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongFeatureInitialization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongFeatureInitialization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Activated = &b
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLengthPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinLengthPercentile = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpweightMultiplier", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.UpweightMultiplier = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_IrlsMaskOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IrlsMaskOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IrlsMaskOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decay", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Decay = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierScore = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BaseScore = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTranslationNorm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinTranslationNorm = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranslationBlendAlpha", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.TranslationBlendAlpha = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranslationPriorIncrease", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.TranslationPriorIncrease = &v2
		default:
			if (fieldNum >= 1) && (fieldNum < 2) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipMotionEstimation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthMotionEstimation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipMotionEstimation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthMotionEstimation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_JointTrackEstimationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JointTrackEstimationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JointTrackEstimationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMotionModels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumMotionModels = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionStride", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MotionStride = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporalSmoothing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TemporalSmoothing = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_LongFeatureBiasOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongFeatureBiasOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongFeatureBiasOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierBias", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierBias = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierBias", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OutlierBias = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIrlsObservations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumIrlsObservations = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIrlsChangeRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxIrlsChangeRatio = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierIrlsWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierIrlsWeight = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSpatialBias", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseSpatialBias = &b
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GridSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.GridSize = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.SpatialSigma = &v2
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ColorSigma = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTrackThreshold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LongTrackThreshold = &v
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTrackConfidenceFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LongTrackConfidenceFraction = &v2
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiasStdev", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BiasStdev = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRounds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalRounds = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeedPriorsFromBias", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SeedPriorsFromBias = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_TranslationBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TranslationBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TranslationBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatures", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinFeatures = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracMaxMotionMagnitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracMaxMotionMagnitude = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMotionStdev", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxMotionStdev = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMotionStdevThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxMotionStdevThreshold = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAcceleration", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxAcceleration = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_SimilarityBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimilarityBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimilarityBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyStableInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OnlyStableInput = &b
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierFraction = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInliers", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInliers = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LowerScale = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.UpperScale = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitRotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LimitRotation = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierThreshold = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracInlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracInlierThreshold = &v2
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictInlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StrictInlierThreshold = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_HomographyBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomographyBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomographyBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LowerScale = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.UpperScale = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitRotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LimitRotation = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPerspective", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LimitPerspective = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RegistrationThreshold = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierCoverage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierCoverage = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracInlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracInlierThreshold = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracRegistrationThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracRegistrationThreshold = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_MixtureHomographyBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixtureHomographyBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixtureHomographyBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierCoverage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierCoverage = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAdjacentOutlierBlocks", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxAdjacentOutlierBlocks = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAdjacentEmptyBlocks", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxAdjacentEmptyBlocks = &v
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracInlierThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracInlierThreshold = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_OverlayDetectionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverlayDetectionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverlayDetectionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisMaskSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnalysisMaskSize = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictNearZeroMotion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StrictNearZeroMotion = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictMaxTranslationRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StrictMaxTranslationRatio = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LooseNearZeroMotion", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LooseNearZeroMotion = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictMinTexturedness", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StrictMinTexturedness = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayMinRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OverlayMinRatio = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlayMinFeatures", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OverlayMinFeatures = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionEstimationOptions_ShotBoundaryOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShotBoundaryOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShotBoundaryOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionConsistencyThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MotionConsistencyThreshold = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppearanceConsistencyThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AppearanceConsistencyThreshold = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMotionEstimation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMotionEstimation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMotionEstimation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMotionEstimation
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMotionEstimation
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMotionEstimation
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMotionEstimation        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMotionEstimation          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMotionEstimation = fmt.Errorf("proto: unexpected end of group")
)
