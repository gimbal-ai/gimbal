// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/motion_models.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MixtureHomography_VariableDOF int32

const (
	ALL_DOF           MixtureHomography_VariableDOF = 0
	TRANSLATION_DOF   MixtureHomography_VariableDOF = 1
	SKEW_ROTATION_DOF MixtureHomography_VariableDOF = 2
	CONST_DOF         MixtureHomography_VariableDOF = 3
)

var MixtureHomography_VariableDOF_name = map[int32]string{
	0: "ALL_DOF",
	1: "TRANSLATION_DOF",
	2: "SKEW_ROTATION_DOF",
	3: "CONST_DOF",
}

var MixtureHomography_VariableDOF_value = map[string]int32{
	"ALL_DOF":           0,
	"TRANSLATION_DOF":   1,
	"SKEW_ROTATION_DOF": 2,
	"CONST_DOF":         3,
}

func (x MixtureHomography_VariableDOF) Enum() *MixtureHomography_VariableDOF {
	p := new(MixtureHomography_VariableDOF)
	*p = x
	return p
}

func (x MixtureHomography_VariableDOF) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MixtureHomography_VariableDOF_name, int32(x))
}

func (x *MixtureHomography_VariableDOF) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MixtureHomography_VariableDOF_value, data, "MixtureHomography_VariableDOF")
	if err != nil {
		return err
	}
	*x = MixtureHomography_VariableDOF(value)
	return nil
}

func (MixtureHomography_VariableDOF) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{7, 0}
}

type TranslationModel struct {
	Dx *float32 `protobuf:"fixed32,1,opt,name=dx,def=0" json:"dx,omitempty"`
	Dy *float32 `protobuf:"fixed32,2,opt,name=dy,def=0" json:"dy,omitempty"`
}

func (m *TranslationModel) Reset()      { *m = TranslationModel{} }
func (*TranslationModel) ProtoMessage() {}
func (*TranslationModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{0}
}
func (m *TranslationModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TranslationModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TranslationModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TranslationModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TranslationModel.Merge(m, src)
}
func (m *TranslationModel) XXX_Size() int {
	return m.Size()
}
func (m *TranslationModel) XXX_DiscardUnknown() {
	xxx_messageInfo_TranslationModel.DiscardUnknown(m)
}

var xxx_messageInfo_TranslationModel proto.InternalMessageInfo

const Default_TranslationModel_Dx float32 = 0
const Default_TranslationModel_Dy float32 = 0

func (m *TranslationModel) GetDx() float32 {
	if m != nil && m.Dx != nil {
		return *m.Dx
	}
	return Default_TranslationModel_Dx
}

func (m *TranslationModel) GetDy() float32 {
	if m != nil && m.Dy != nil {
		return *m.Dy
	}
	return Default_TranslationModel_Dy
}

type SimilarityModel struct {
	Dx       *float32 `protobuf:"fixed32,1,opt,name=dx,def=0" json:"dx,omitempty"`
	Dy       *float32 `protobuf:"fixed32,2,opt,name=dy,def=0" json:"dy,omitempty"`
	Scale    *float32 `protobuf:"fixed32,3,opt,name=scale,def=1" json:"scale,omitempty"`
	Rotation *float32 `protobuf:"fixed32,4,opt,name=rotation,def=0" json:"rotation,omitempty"`
}

func (m *SimilarityModel) Reset()      { *m = SimilarityModel{} }
func (*SimilarityModel) ProtoMessage() {}
func (*SimilarityModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{1}
}
func (m *SimilarityModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimilarityModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimilarityModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimilarityModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimilarityModel.Merge(m, src)
}
func (m *SimilarityModel) XXX_Size() int {
	return m.Size()
}
func (m *SimilarityModel) XXX_DiscardUnknown() {
	xxx_messageInfo_SimilarityModel.DiscardUnknown(m)
}

var xxx_messageInfo_SimilarityModel proto.InternalMessageInfo

const Default_SimilarityModel_Dx float32 = 0
const Default_SimilarityModel_Dy float32 = 0
const Default_SimilarityModel_Scale float32 = 1
const Default_SimilarityModel_Rotation float32 = 0

func (m *SimilarityModel) GetDx() float32 {
	if m != nil && m.Dx != nil {
		return *m.Dx
	}
	return Default_SimilarityModel_Dx
}

func (m *SimilarityModel) GetDy() float32 {
	if m != nil && m.Dy != nil {
		return *m.Dy
	}
	return Default_SimilarityModel_Dy
}

func (m *SimilarityModel) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_SimilarityModel_Scale
}

func (m *SimilarityModel) GetRotation() float32 {
	if m != nil && m.Rotation != nil {
		return *m.Rotation
	}
	return Default_SimilarityModel_Rotation
}

type LinearSimilarityModel struct {
	Dx *float32 `protobuf:"fixed32,1,opt,name=dx,def=0" json:"dx,omitempty"`
	Dy *float32 `protobuf:"fixed32,2,opt,name=dy,def=0" json:"dy,omitempty"`
	A  *float32 `protobuf:"fixed32,3,opt,name=a,def=1" json:"a,omitempty"`
	B  *float32 `protobuf:"fixed32,4,opt,name=b,def=0" json:"b,omitempty"`
}

func (m *LinearSimilarityModel) Reset()      { *m = LinearSimilarityModel{} }
func (*LinearSimilarityModel) ProtoMessage() {}
func (*LinearSimilarityModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{2}
}
func (m *LinearSimilarityModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinearSimilarityModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinearSimilarityModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinearSimilarityModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinearSimilarityModel.Merge(m, src)
}
func (m *LinearSimilarityModel) XXX_Size() int {
	return m.Size()
}
func (m *LinearSimilarityModel) XXX_DiscardUnknown() {
	xxx_messageInfo_LinearSimilarityModel.DiscardUnknown(m)
}

var xxx_messageInfo_LinearSimilarityModel proto.InternalMessageInfo

const Default_LinearSimilarityModel_Dx float32 = 0
const Default_LinearSimilarityModel_Dy float32 = 0
const Default_LinearSimilarityModel_A float32 = 1
const Default_LinearSimilarityModel_B float32 = 0

func (m *LinearSimilarityModel) GetDx() float32 {
	if m != nil && m.Dx != nil {
		return *m.Dx
	}
	return Default_LinearSimilarityModel_Dx
}

func (m *LinearSimilarityModel) GetDy() float32 {
	if m != nil && m.Dy != nil {
		return *m.Dy
	}
	return Default_LinearSimilarityModel_Dy
}

func (m *LinearSimilarityModel) GetA() float32 {
	if m != nil && m.A != nil {
		return *m.A
	}
	return Default_LinearSimilarityModel_A
}

func (m *LinearSimilarityModel) GetB() float32 {
	if m != nil && m.B != nil {
		return *m.B
	}
	return Default_LinearSimilarityModel_B
}

type AffineModel struct {
	Dx *float32 `protobuf:"fixed32,1,opt,name=dx,def=0" json:"dx,omitempty"`
	Dy *float32 `protobuf:"fixed32,2,opt,name=dy,def=0" json:"dy,omitempty"`
	A  *float32 `protobuf:"fixed32,3,opt,name=a,def=1" json:"a,omitempty"`
	B  *float32 `protobuf:"fixed32,4,opt,name=b,def=0" json:"b,omitempty"`
	C  *float32 `protobuf:"fixed32,5,opt,name=c,def=0" json:"c,omitempty"`
	D  *float32 `protobuf:"fixed32,6,opt,name=d,def=1" json:"d,omitempty"`
}

func (m *AffineModel) Reset()      { *m = AffineModel{} }
func (*AffineModel) ProtoMessage() {}
func (*AffineModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{3}
}
func (m *AffineModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AffineModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AffineModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AffineModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AffineModel.Merge(m, src)
}
func (m *AffineModel) XXX_Size() int {
	return m.Size()
}
func (m *AffineModel) XXX_DiscardUnknown() {
	xxx_messageInfo_AffineModel.DiscardUnknown(m)
}

var xxx_messageInfo_AffineModel proto.InternalMessageInfo

const Default_AffineModel_Dx float32 = 0
const Default_AffineModel_Dy float32 = 0
const Default_AffineModel_A float32 = 1
const Default_AffineModel_B float32 = 0
const Default_AffineModel_C float32 = 0
const Default_AffineModel_D float32 = 1

func (m *AffineModel) GetDx() float32 {
	if m != nil && m.Dx != nil {
		return *m.Dx
	}
	return Default_AffineModel_Dx
}

func (m *AffineModel) GetDy() float32 {
	if m != nil && m.Dy != nil {
		return *m.Dy
	}
	return Default_AffineModel_Dy
}

func (m *AffineModel) GetA() float32 {
	if m != nil && m.A != nil {
		return *m.A
	}
	return Default_AffineModel_A
}

func (m *AffineModel) GetB() float32 {
	if m != nil && m.B != nil {
		return *m.B
	}
	return Default_AffineModel_B
}

func (m *AffineModel) GetC() float32 {
	if m != nil && m.C != nil {
		return *m.C
	}
	return Default_AffineModel_C
}

func (m *AffineModel) GetD() float32 {
	if m != nil && m.D != nil {
		return *m.D
	}
	return Default_AffineModel_D
}

type Homography struct {
	H_00 *float32 `protobuf:"fixed32,1,opt,name=h_00,json=h00,def=1" json:"h_00,omitempty"`
	H_01 *float32 `protobuf:"fixed32,2,opt,name=h_01,json=h01,def=0" json:"h_01,omitempty"`
	H_02 *float32 `protobuf:"fixed32,3,opt,name=h_02,json=h02,def=0" json:"h_02,omitempty"`
	H_10 *float32 `protobuf:"fixed32,4,opt,name=h_10,json=h10,def=0" json:"h_10,omitempty"`
	H_11 *float32 `protobuf:"fixed32,5,opt,name=h_11,json=h11,def=1" json:"h_11,omitempty"`
	H_12 *float32 `protobuf:"fixed32,6,opt,name=h_12,json=h12,def=0" json:"h_12,omitempty"`
	H_20 *float32 `protobuf:"fixed32,7,opt,name=h_20,json=h20,def=0" json:"h_20,omitempty"`
	H_21 *float32 `protobuf:"fixed32,8,opt,name=h_21,json=h21,def=0" json:"h_21,omitempty"`
}

func (m *Homography) Reset()      { *m = Homography{} }
func (*Homography) ProtoMessage() {}
func (*Homography) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{4}
}
func (m *Homography) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Homography) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Homography.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Homography) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Homography.Merge(m, src)
}
func (m *Homography) XXX_Size() int {
	return m.Size()
}
func (m *Homography) XXX_DiscardUnknown() {
	xxx_messageInfo_Homography.DiscardUnknown(m)
}

var xxx_messageInfo_Homography proto.InternalMessageInfo

const Default_Homography_H_00 float32 = 1
const Default_Homography_H_01 float32 = 0
const Default_Homography_H_02 float32 = 0
const Default_Homography_H_10 float32 = 0
const Default_Homography_H_11 float32 = 1
const Default_Homography_H_12 float32 = 0
const Default_Homography_H_20 float32 = 0
const Default_Homography_H_21 float32 = 0

func (m *Homography) GetH_00() float32 {
	if m != nil && m.H_00 != nil {
		return *m.H_00
	}
	return Default_Homography_H_00
}

func (m *Homography) GetH_01() float32 {
	if m != nil && m.H_01 != nil {
		return *m.H_01
	}
	return Default_Homography_H_01
}

func (m *Homography) GetH_02() float32 {
	if m != nil && m.H_02 != nil {
		return *m.H_02
	}
	return Default_Homography_H_02
}

func (m *Homography) GetH_10() float32 {
	if m != nil && m.H_10 != nil {
		return *m.H_10
	}
	return Default_Homography_H_10
}

func (m *Homography) GetH_11() float32 {
	if m != nil && m.H_11 != nil {
		return *m.H_11
	}
	return Default_Homography_H_11
}

func (m *Homography) GetH_12() float32 {
	if m != nil && m.H_12 != nil {
		return *m.H_12
	}
	return Default_Homography_H_12
}

func (m *Homography) GetH_20() float32 {
	if m != nil && m.H_20 != nil {
		return *m.H_20
	}
	return Default_Homography_H_20
}

func (m *Homography) GetH_21() float32 {
	if m != nil && m.H_21 != nil {
		return *m.H_21
	}
	return Default_Homography_H_21
}

type MixtureLinearSimilarity struct {
	Model []*LinearSimilarityModel `protobuf:"bytes,1,rep,name=model" json:"model,omitempty"`
}

func (m *MixtureLinearSimilarity) Reset()      { *m = MixtureLinearSimilarity{} }
func (*MixtureLinearSimilarity) ProtoMessage() {}
func (*MixtureLinearSimilarity) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{5}
}
func (m *MixtureLinearSimilarity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixtureLinearSimilarity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixtureLinearSimilarity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixtureLinearSimilarity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixtureLinearSimilarity.Merge(m, src)
}
func (m *MixtureLinearSimilarity) XXX_Size() int {
	return m.Size()
}
func (m *MixtureLinearSimilarity) XXX_DiscardUnknown() {
	xxx_messageInfo_MixtureLinearSimilarity.DiscardUnknown(m)
}

var xxx_messageInfo_MixtureLinearSimilarity proto.InternalMessageInfo

func (m *MixtureLinearSimilarity) GetModel() []*LinearSimilarityModel {
	if m != nil {
		return m.Model
	}
	return nil
}

type MixtureAffine struct {
	Model []*AffineModel `protobuf:"bytes,1,rep,name=model" json:"model,omitempty"`
}

func (m *MixtureAffine) Reset()      { *m = MixtureAffine{} }
func (*MixtureAffine) ProtoMessage() {}
func (*MixtureAffine) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{6}
}
func (m *MixtureAffine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixtureAffine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixtureAffine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixtureAffine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixtureAffine.Merge(m, src)
}
func (m *MixtureAffine) XXX_Size() int {
	return m.Size()
}
func (m *MixtureAffine) XXX_DiscardUnknown() {
	xxx_messageInfo_MixtureAffine.DiscardUnknown(m)
}

var xxx_messageInfo_MixtureAffine proto.InternalMessageInfo

func (m *MixtureAffine) GetModel() []*AffineModel {
	if m != nil {
		return m.Model
	}
	return nil
}

type MixtureHomography struct {
	Model []*Homography                  `protobuf:"bytes,1,rep,name=model" json:"model,omitempty"`
	Dof   *MixtureHomography_VariableDOF `protobuf:"varint,2,opt,name=dof,enum=mediapipe.MixtureHomography_VariableDOF,def=0" json:"dof,omitempty"`
}

func (m *MixtureHomography) Reset()      { *m = MixtureHomography{} }
func (*MixtureHomography) ProtoMessage() {}
func (*MixtureHomography) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7d13174359700da, []int{7}
}
func (m *MixtureHomography) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MixtureHomography) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MixtureHomography.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MixtureHomography) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MixtureHomography.Merge(m, src)
}
func (m *MixtureHomography) XXX_Size() int {
	return m.Size()
}
func (m *MixtureHomography) XXX_DiscardUnknown() {
	xxx_messageInfo_MixtureHomography.DiscardUnknown(m)
}

var xxx_messageInfo_MixtureHomography proto.InternalMessageInfo

const Default_MixtureHomography_Dof MixtureHomography_VariableDOF = ALL_DOF

func (m *MixtureHomography) GetModel() []*Homography {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *MixtureHomography) GetDof() MixtureHomography_VariableDOF {
	if m != nil && m.Dof != nil {
		return *m.Dof
	}
	return Default_MixtureHomography_Dof
}

func init() {
	proto.RegisterEnum("mediapipe.MixtureHomography_VariableDOF", MixtureHomography_VariableDOF_name, MixtureHomography_VariableDOF_value)
	proto.RegisterType((*TranslationModel)(nil), "mediapipe.TranslationModel")
	proto.RegisterType((*SimilarityModel)(nil), "mediapipe.SimilarityModel")
	proto.RegisterType((*LinearSimilarityModel)(nil), "mediapipe.LinearSimilarityModel")
	proto.RegisterType((*AffineModel)(nil), "mediapipe.AffineModel")
	proto.RegisterType((*Homography)(nil), "mediapipe.Homography")
	proto.RegisterType((*MixtureLinearSimilarity)(nil), "mediapipe.MixtureLinearSimilarity")
	proto.RegisterType((*MixtureAffine)(nil), "mediapipe.MixtureAffine")
	proto.RegisterType((*MixtureHomography)(nil), "mediapipe.MixtureHomography")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/motion_models.proto", fileDescriptor_d7d13174359700da)
}

var fileDescriptor_d7d13174359700da = []byte{
	// 548 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x4f, 0x8f, 0xd2, 0x40,
	0x18, 0x87, 0x3b, 0x74, 0x71, 0x77, 0x5f, 0xb2, 0xb2, 0x8c, 0xe2, 0xf6, 0xe2, 0x84, 0xf4, 0x44,
	0xb2, 0x06, 0x3a, 0x35, 0x31, 0x66, 0x13, 0x0f, 0xb8, 0xeb, 0x46, 0x23, 0x0b, 0xb1, 0xa0, 0x26,
	0x5e, 0xc8, 0x40, 0x0b, 0x9d, 0xd8, 0x32, 0xa4, 0x94, 0x08, 0x37, 0x3f, 0x82, 0x1f, 0xc3, 0x0f,
	0xe1, 0x07, 0xf0, 0xc8, 0x71, 0x0f, 0x1e, 0xa4, 0x5c, 0x3c, 0xee, 0x47, 0x30, 0x2d, 0x2d, 0xed,
	0xfa, 0xe7, 0xa0, 0xd9, 0x63, 0x9f, 0xfe, 0xde, 0xe7, 0x7d, 0x33, 0xef, 0x64, 0xe0, 0xd8, 0xb5,
	0x4c, 0xce, 0x26, 0x7c, 0x62, 0xd5, 0x67, 0x3e, 0x77, 0xea, 0xbe, 0xc7, 0x06, 0xef, 0xf9, 0x78,
	0x54, 0x77, 0x85, 0xcf, 0xc5, 0xb8, 0xe7, 0x0a, 0xd3, 0x72, 0xa6, 0xb5, 0x89, 0x27, 0x7c, 0x81,
	0xf7, 0xb7, 0x61, 0xf5, 0x31, 0x1c, 0x76, 0x3d, 0x36, 0x9e, 0x3a, 0x2c, 0x8c, 0x5d, 0x84, 0x29,
	0x5c, 0x82, 0x9c, 0x39, 0x57, 0x50, 0x05, 0x55, 0x73, 0x27, 0x48, 0x33, 0x72, 0xe6, 0x3c, 0x42,
	0x0b, 0x25, 0x97, 0xa2, 0x85, 0x2a, 0xa0, 0xd8, 0xe1, 0x2e, 0x77, 0x98, 0xc7, 0xfd, 0xc5, 0x3f,
	0x14, 0xe2, 0x23, 0xc8, 0x4f, 0x07, 0xcc, 0xb1, 0x14, 0x79, 0x43, 0xa9, 0xb1, 0xf9, 0xc6, 0xf7,
	0x61, 0xcf, 0x13, 0x7e, 0x34, 0x88, 0xb2, 0x93, 0x54, 0x6c, 0x91, 0xda, 0x83, 0x72, 0x93, 0x8f,
	0x2d, 0xe6, 0xfd, 0x5f, 0xdb, 0x22, 0x20, 0x96, 0xb6, 0x44, 0x2c, 0x04, 0xfd, 0xb4, 0x0f, 0xea,
	0xab, 0x1f, 0xa0, 0xd0, 0x18, 0x0e, 0xf9, 0xd8, 0xba, 0x51, 0x6d, 0x08, 0x06, 0x4a, 0x7e, 0x0b,
	0x06, 0x21, 0x30, 0x95, 0x5b, 0xdb, 0x12, 0x53, 0xfd, 0x82, 0x00, 0x9e, 0x0b, 0x57, 0x8c, 0x3c,
	0x36, 0xb1, 0x17, 0xf8, 0x2e, 0xec, 0xd8, 0x3d, 0x4d, 0x4b, 0x5a, 0x53, 0x43, 0xb6, 0x35, 0x2d,
	0xa6, 0x34, 0xed, 0x2e, 0xdb, 0x1a, 0x8d, 0xa9, 0x9e, 0x4c, 0x10, 0x51, 0x7d, 0x43, 0xa9, 0x96,
	0x8e, 0x21, 0xdb, 0x34, 0x36, 0x50, 0x9a, 0xcc, 0x12, 0x7a, 0x69, 0x6c, 0xa0, 0x7a, 0x32, 0x50,
	0x94, 0x8d, 0x0d, 0xba, 0xa6, 0xec, 0xa6, 0x54, 0x8f, 0x0d, 0x3a, 0x55, 0xf6, 0x32, 0x94, 0xaa,
	0xaf, 0xe0, 0xe8, 0x82, 0xcf, 0xfd, 0x99, 0x67, 0xfd, 0xba, 0x1f, 0xfc, 0x08, 0xf2, 0xd1, 0xcd,
	0x53, 0x50, 0x45, 0xae, 0x16, 0xf4, 0x4a, 0x6d, 0x7b, 0xf3, 0x6a, 0x7f, 0xdc, 0xa5, 0xb1, 0x89,
	0xab, 0x4f, 0xe0, 0x20, 0x56, 0x6e, 0x36, 0x82, 0x1f, 0x5c, 0x17, 0xdd, 0xcb, 0x88, 0x32, 0x3b,
	0x4b, 0xca, 0xbf, 0x21, 0x28, 0xc5, 0xf5, 0x99, 0x73, 0x3d, 0xbe, 0xee, 0x28, 0x67, 0x1c, 0x69,
	0x2a, 0x56, 0xe0, 0x53, 0x90, 0x4d, 0x31, 0x8c, 0x4e, 0xfb, 0xb6, 0x5e, 0xcd, 0x44, 0x7f, 0xf3,
	0xd6, 0xde, 0x30, 0x8f, 0xb3, 0xbe, 0x63, 0x9d, 0xb5, 0xcf, 0x4f, 0x76, 0x1b, 0xcd, 0x66, 0xef,
	0xac, 0x7d, 0x6e, 0x84, 0xd5, 0xea, 0x6b, 0x28, 0x64, 0x7e, 0xe2, 0x02, 0x24, 0xbf, 0x0f, 0x25,
	0x7c, 0x07, 0x8a, 0x5d, 0xa3, 0xd1, 0xea, 0x34, 0x1b, 0xdd, 0x17, 0xed, 0x56, 0x04, 0x11, 0x2e,
	0x43, 0xa9, 0xf3, 0xf2, 0xd9, 0xdb, 0x9e, 0xd1, 0xee, 0xa6, 0x38, 0x87, 0x0f, 0x60, 0xff, 0xb4,
	0xdd, 0xea, 0x74, 0xa3, 0x4f, 0xf9, 0x29, 0x5f, 0xae, 0x88, 0x74, 0xb9, 0x22, 0xd2, 0xd5, 0x8a,
	0xa0, 0x8f, 0x01, 0x41, 0x9f, 0x03, 0x82, 0xbe, 0x06, 0x04, 0x2d, 0x03, 0x82, 0xbe, 0x07, 0x04,
	0xfd, 0x08, 0x88, 0x74, 0x15, 0x10, 0xf4, 0x69, 0x4d, 0xa4, 0xe5, 0x9a, 0x48, 0x97, 0x6b, 0x22,
	0xbd, 0x7b, 0x38, 0xe2, 0xbe, 0x3d, 0xeb, 0xd7, 0x06, 0xc2, 0xad, 0x8f, 0x84, 0x18, 0x39, 0x56,
	0x3d, 0x7d, 0x34, 0xfe, 0xf2, 0x7c, 0xfc, 0x0c, 0x00, 0x00, 0xff, 0xff, 0xf1, 0xff, 0xc4, 0xa8,
	0x58, 0x04, 0x00, 0x00,
}

func (x MixtureHomography_VariableDOF) String() string {
	s, ok := MixtureHomography_VariableDOF_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TranslationModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TranslationModel)
	if !ok {
		that2, ok := that.(TranslationModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dx != nil && that1.Dx != nil {
		if *this.Dx != *that1.Dx {
			return false
		}
	} else if this.Dx != nil {
		return false
	} else if that1.Dx != nil {
		return false
	}
	if this.Dy != nil && that1.Dy != nil {
		if *this.Dy != *that1.Dy {
			return false
		}
	} else if this.Dy != nil {
		return false
	} else if that1.Dy != nil {
		return false
	}
	return true
}
func (this *SimilarityModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimilarityModel)
	if !ok {
		that2, ok := that.(SimilarityModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dx != nil && that1.Dx != nil {
		if *this.Dx != *that1.Dx {
			return false
		}
	} else if this.Dx != nil {
		return false
	} else if that1.Dx != nil {
		return false
	}
	if this.Dy != nil && that1.Dy != nil {
		if *this.Dy != *that1.Dy {
			return false
		}
	} else if this.Dy != nil {
		return false
	} else if that1.Dy != nil {
		return false
	}
	if this.Scale != nil && that1.Scale != nil {
		if *this.Scale != *that1.Scale {
			return false
		}
	} else if this.Scale != nil {
		return false
	} else if that1.Scale != nil {
		return false
	}
	if this.Rotation != nil && that1.Rotation != nil {
		if *this.Rotation != *that1.Rotation {
			return false
		}
	} else if this.Rotation != nil {
		return false
	} else if that1.Rotation != nil {
		return false
	}
	return true
}
func (this *LinearSimilarityModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinearSimilarityModel)
	if !ok {
		that2, ok := that.(LinearSimilarityModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dx != nil && that1.Dx != nil {
		if *this.Dx != *that1.Dx {
			return false
		}
	} else if this.Dx != nil {
		return false
	} else if that1.Dx != nil {
		return false
	}
	if this.Dy != nil && that1.Dy != nil {
		if *this.Dy != *that1.Dy {
			return false
		}
	} else if this.Dy != nil {
		return false
	} else if that1.Dy != nil {
		return false
	}
	if this.A != nil && that1.A != nil {
		if *this.A != *that1.A {
			return false
		}
	} else if this.A != nil {
		return false
	} else if that1.A != nil {
		return false
	}
	if this.B != nil && that1.B != nil {
		if *this.B != *that1.B {
			return false
		}
	} else if this.B != nil {
		return false
	} else if that1.B != nil {
		return false
	}
	return true
}
func (this *AffineModel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AffineModel)
	if !ok {
		that2, ok := that.(AffineModel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dx != nil && that1.Dx != nil {
		if *this.Dx != *that1.Dx {
			return false
		}
	} else if this.Dx != nil {
		return false
	} else if that1.Dx != nil {
		return false
	}
	if this.Dy != nil && that1.Dy != nil {
		if *this.Dy != *that1.Dy {
			return false
		}
	} else if this.Dy != nil {
		return false
	} else if that1.Dy != nil {
		return false
	}
	if this.A != nil && that1.A != nil {
		if *this.A != *that1.A {
			return false
		}
	} else if this.A != nil {
		return false
	} else if that1.A != nil {
		return false
	}
	if this.B != nil && that1.B != nil {
		if *this.B != *that1.B {
			return false
		}
	} else if this.B != nil {
		return false
	} else if that1.B != nil {
		return false
	}
	if this.C != nil && that1.C != nil {
		if *this.C != *that1.C {
			return false
		}
	} else if this.C != nil {
		return false
	} else if that1.C != nil {
		return false
	}
	if this.D != nil && that1.D != nil {
		if *this.D != *that1.D {
			return false
		}
	} else if this.D != nil {
		return false
	} else if that1.D != nil {
		return false
	}
	return true
}
func (this *Homography) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Homography)
	if !ok {
		that2, ok := that.(Homography)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.H_00 != nil && that1.H_00 != nil {
		if *this.H_00 != *that1.H_00 {
			return false
		}
	} else if this.H_00 != nil {
		return false
	} else if that1.H_00 != nil {
		return false
	}
	if this.H_01 != nil && that1.H_01 != nil {
		if *this.H_01 != *that1.H_01 {
			return false
		}
	} else if this.H_01 != nil {
		return false
	} else if that1.H_01 != nil {
		return false
	}
	if this.H_02 != nil && that1.H_02 != nil {
		if *this.H_02 != *that1.H_02 {
			return false
		}
	} else if this.H_02 != nil {
		return false
	} else if that1.H_02 != nil {
		return false
	}
	if this.H_10 != nil && that1.H_10 != nil {
		if *this.H_10 != *that1.H_10 {
			return false
		}
	} else if this.H_10 != nil {
		return false
	} else if that1.H_10 != nil {
		return false
	}
	if this.H_11 != nil && that1.H_11 != nil {
		if *this.H_11 != *that1.H_11 {
			return false
		}
	} else if this.H_11 != nil {
		return false
	} else if that1.H_11 != nil {
		return false
	}
	if this.H_12 != nil && that1.H_12 != nil {
		if *this.H_12 != *that1.H_12 {
			return false
		}
	} else if this.H_12 != nil {
		return false
	} else if that1.H_12 != nil {
		return false
	}
	if this.H_20 != nil && that1.H_20 != nil {
		if *this.H_20 != *that1.H_20 {
			return false
		}
	} else if this.H_20 != nil {
		return false
	} else if that1.H_20 != nil {
		return false
	}
	if this.H_21 != nil && that1.H_21 != nil {
		if *this.H_21 != *that1.H_21 {
			return false
		}
	} else if this.H_21 != nil {
		return false
	} else if that1.H_21 != nil {
		return false
	}
	return true
}
func (this *MixtureLinearSimilarity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MixtureLinearSimilarity)
	if !ok {
		that2, ok := that.(MixtureLinearSimilarity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Model) != len(that1.Model) {
		return false
	}
	for i := range this.Model {
		if !this.Model[i].Equal(that1.Model[i]) {
			return false
		}
	}
	return true
}
func (this *MixtureAffine) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MixtureAffine)
	if !ok {
		that2, ok := that.(MixtureAffine)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Model) != len(that1.Model) {
		return false
	}
	for i := range this.Model {
		if !this.Model[i].Equal(that1.Model[i]) {
			return false
		}
	}
	return true
}
func (this *MixtureHomography) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MixtureHomography)
	if !ok {
		that2, ok := that.(MixtureHomography)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Model) != len(that1.Model) {
		return false
	}
	for i := range this.Model {
		if !this.Model[i].Equal(that1.Model[i]) {
			return false
		}
	}
	if this.Dof != nil && that1.Dof != nil {
		if *this.Dof != *that1.Dof {
			return false
		}
	} else if this.Dof != nil {
		return false
	} else if that1.Dof != nil {
		return false
	}
	return true
}
func (this *TranslationModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.TranslationModel{")
	if this.Dx != nil {
		s = append(s, "Dx: "+valueToGoStringMotionModels(this.Dx, "float32")+",\n")
	}
	if this.Dy != nil {
		s = append(s, "Dy: "+valueToGoStringMotionModels(this.Dy, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimilarityModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.SimilarityModel{")
	if this.Dx != nil {
		s = append(s, "Dx: "+valueToGoStringMotionModels(this.Dx, "float32")+",\n")
	}
	if this.Dy != nil {
		s = append(s, "Dy: "+valueToGoStringMotionModels(this.Dy, "float32")+",\n")
	}
	if this.Scale != nil {
		s = append(s, "Scale: "+valueToGoStringMotionModels(this.Scale, "float32")+",\n")
	}
	if this.Rotation != nil {
		s = append(s, "Rotation: "+valueToGoStringMotionModels(this.Rotation, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinearSimilarityModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.LinearSimilarityModel{")
	if this.Dx != nil {
		s = append(s, "Dx: "+valueToGoStringMotionModels(this.Dx, "float32")+",\n")
	}
	if this.Dy != nil {
		s = append(s, "Dy: "+valueToGoStringMotionModels(this.Dy, "float32")+",\n")
	}
	if this.A != nil {
		s = append(s, "A: "+valueToGoStringMotionModels(this.A, "float32")+",\n")
	}
	if this.B != nil {
		s = append(s, "B: "+valueToGoStringMotionModels(this.B, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AffineModel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.AffineModel{")
	if this.Dx != nil {
		s = append(s, "Dx: "+valueToGoStringMotionModels(this.Dx, "float32")+",\n")
	}
	if this.Dy != nil {
		s = append(s, "Dy: "+valueToGoStringMotionModels(this.Dy, "float32")+",\n")
	}
	if this.A != nil {
		s = append(s, "A: "+valueToGoStringMotionModels(this.A, "float32")+",\n")
	}
	if this.B != nil {
		s = append(s, "B: "+valueToGoStringMotionModels(this.B, "float32")+",\n")
	}
	if this.C != nil {
		s = append(s, "C: "+valueToGoStringMotionModels(this.C, "float32")+",\n")
	}
	if this.D != nil {
		s = append(s, "D: "+valueToGoStringMotionModels(this.D, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Homography) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tracking.Homography{")
	if this.H_00 != nil {
		s = append(s, "H_00: "+valueToGoStringMotionModels(this.H_00, "float32")+",\n")
	}
	if this.H_01 != nil {
		s = append(s, "H_01: "+valueToGoStringMotionModels(this.H_01, "float32")+",\n")
	}
	if this.H_02 != nil {
		s = append(s, "H_02: "+valueToGoStringMotionModels(this.H_02, "float32")+",\n")
	}
	if this.H_10 != nil {
		s = append(s, "H_10: "+valueToGoStringMotionModels(this.H_10, "float32")+",\n")
	}
	if this.H_11 != nil {
		s = append(s, "H_11: "+valueToGoStringMotionModels(this.H_11, "float32")+",\n")
	}
	if this.H_12 != nil {
		s = append(s, "H_12: "+valueToGoStringMotionModels(this.H_12, "float32")+",\n")
	}
	if this.H_20 != nil {
		s = append(s, "H_20: "+valueToGoStringMotionModels(this.H_20, "float32")+",\n")
	}
	if this.H_21 != nil {
		s = append(s, "H_21: "+valueToGoStringMotionModels(this.H_21, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MixtureLinearSimilarity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.MixtureLinearSimilarity{")
	if this.Model != nil {
		s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MixtureAffine) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.MixtureAffine{")
	if this.Model != nil {
		s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MixtureHomography) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.MixtureHomography{")
	if this.Model != nil {
		s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	}
	if this.Dof != nil {
		s = append(s, "Dof: "+valueToGoStringMotionModels(this.Dof, "MixtureHomography_VariableDOF")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMotionModels(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TranslationModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TranslationModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TranslationModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dy))))
		i--
		dAtA[i] = 0x15
	}
	if m.Dx != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dx))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *SimilarityModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimilarityModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimilarityModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Rotation))))
		i--
		dAtA[i] = 0x25
	}
	if m.Scale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Dy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dy))))
		i--
		dAtA[i] = 0x15
	}
	if m.Dx != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dx))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *LinearSimilarityModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinearSimilarityModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinearSimilarityModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.B != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.B))))
		i--
		dAtA[i] = 0x25
	}
	if m.A != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.A))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Dy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dy))))
		i--
		dAtA[i] = 0x15
	}
	if m.Dx != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dx))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *AffineModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AffineModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AffineModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.D != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.D))))
		i--
		dAtA[i] = 0x35
	}
	if m.C != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.C))))
		i--
		dAtA[i] = 0x2d
	}
	if m.B != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.B))))
		i--
		dAtA[i] = 0x25
	}
	if m.A != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.A))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Dy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dy))))
		i--
		dAtA[i] = 0x15
	}
	if m.Dx != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Dx))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Homography) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Homography) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Homography) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.H_21 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_21))))
		i--
		dAtA[i] = 0x45
	}
	if m.H_20 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_20))))
		i--
		dAtA[i] = 0x3d
	}
	if m.H_12 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_12))))
		i--
		dAtA[i] = 0x35
	}
	if m.H_11 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_11))))
		i--
		dAtA[i] = 0x2d
	}
	if m.H_10 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_10))))
		i--
		dAtA[i] = 0x25
	}
	if m.H_02 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_02))))
		i--
		dAtA[i] = 0x1d
	}
	if m.H_01 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_01))))
		i--
		dAtA[i] = 0x15
	}
	if m.H_00 != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.H_00))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *MixtureLinearSimilarity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixtureLinearSimilarity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MixtureLinearSimilarity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		for iNdEx := len(m.Model) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Model[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMotionModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MixtureAffine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixtureAffine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MixtureAffine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		for iNdEx := len(m.Model) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Model[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMotionModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MixtureHomography) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MixtureHomography) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MixtureHomography) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dof != nil {
		i = encodeVarintMotionModels(dAtA, i, uint64(*m.Dof))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Model) > 0 {
		for iNdEx := len(m.Model) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Model[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMotionModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMotionModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovMotionModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TranslationModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dx != nil {
		n += 5
	}
	if m.Dy != nil {
		n += 5
	}
	return n
}

func (m *SimilarityModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dx != nil {
		n += 5
	}
	if m.Dy != nil {
		n += 5
	}
	if m.Scale != nil {
		n += 5
	}
	if m.Rotation != nil {
		n += 5
	}
	return n
}

func (m *LinearSimilarityModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dx != nil {
		n += 5
	}
	if m.Dy != nil {
		n += 5
	}
	if m.A != nil {
		n += 5
	}
	if m.B != nil {
		n += 5
	}
	return n
}

func (m *AffineModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dx != nil {
		n += 5
	}
	if m.Dy != nil {
		n += 5
	}
	if m.A != nil {
		n += 5
	}
	if m.B != nil {
		n += 5
	}
	if m.C != nil {
		n += 5
	}
	if m.D != nil {
		n += 5
	}
	return n
}

func (m *Homography) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.H_00 != nil {
		n += 5
	}
	if m.H_01 != nil {
		n += 5
	}
	if m.H_02 != nil {
		n += 5
	}
	if m.H_10 != nil {
		n += 5
	}
	if m.H_11 != nil {
		n += 5
	}
	if m.H_12 != nil {
		n += 5
	}
	if m.H_20 != nil {
		n += 5
	}
	if m.H_21 != nil {
		n += 5
	}
	return n
}

func (m *MixtureLinearSimilarity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Model) > 0 {
		for _, e := range m.Model {
			l = e.Size()
			n += 1 + l + sovMotionModels(uint64(l))
		}
	}
	return n
}

func (m *MixtureAffine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Model) > 0 {
		for _, e := range m.Model {
			l = e.Size()
			n += 1 + l + sovMotionModels(uint64(l))
		}
	}
	return n
}

func (m *MixtureHomography) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Model) > 0 {
		for _, e := range m.Model {
			l = e.Size()
			n += 1 + l + sovMotionModels(uint64(l))
		}
	}
	if m.Dof != nil {
		n += 1 + sovMotionModels(uint64(*m.Dof))
	}
	return n
}

func sovMotionModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMotionModels(x uint64) (n int) {
	return sovMotionModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TranslationModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TranslationModel{`,
		`Dx:` + valueToStringMotionModels(this.Dx) + `,`,
		`Dy:` + valueToStringMotionModels(this.Dy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimilarityModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimilarityModel{`,
		`Dx:` + valueToStringMotionModels(this.Dx) + `,`,
		`Dy:` + valueToStringMotionModels(this.Dy) + `,`,
		`Scale:` + valueToStringMotionModels(this.Scale) + `,`,
		`Rotation:` + valueToStringMotionModels(this.Rotation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinearSimilarityModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinearSimilarityModel{`,
		`Dx:` + valueToStringMotionModels(this.Dx) + `,`,
		`Dy:` + valueToStringMotionModels(this.Dy) + `,`,
		`A:` + valueToStringMotionModels(this.A) + `,`,
		`B:` + valueToStringMotionModels(this.B) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AffineModel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AffineModel{`,
		`Dx:` + valueToStringMotionModels(this.Dx) + `,`,
		`Dy:` + valueToStringMotionModels(this.Dy) + `,`,
		`A:` + valueToStringMotionModels(this.A) + `,`,
		`B:` + valueToStringMotionModels(this.B) + `,`,
		`C:` + valueToStringMotionModels(this.C) + `,`,
		`D:` + valueToStringMotionModels(this.D) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Homography) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Homography{`,
		`H_00:` + valueToStringMotionModels(this.H_00) + `,`,
		`H_01:` + valueToStringMotionModels(this.H_01) + `,`,
		`H_02:` + valueToStringMotionModels(this.H_02) + `,`,
		`H_10:` + valueToStringMotionModels(this.H_10) + `,`,
		`H_11:` + valueToStringMotionModels(this.H_11) + `,`,
		`H_12:` + valueToStringMotionModels(this.H_12) + `,`,
		`H_20:` + valueToStringMotionModels(this.H_20) + `,`,
		`H_21:` + valueToStringMotionModels(this.H_21) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MixtureLinearSimilarity) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModel := "[]*LinearSimilarityModel{"
	for _, f := range this.Model {
		repeatedStringForModel += strings.Replace(f.String(), "LinearSimilarityModel", "LinearSimilarityModel", 1) + ","
	}
	repeatedStringForModel += "}"
	s := strings.Join([]string{`&MixtureLinearSimilarity{`,
		`Model:` + repeatedStringForModel + `,`,
		`}`,
	}, "")
	return s
}
func (this *MixtureAffine) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModel := "[]*AffineModel{"
	for _, f := range this.Model {
		repeatedStringForModel += strings.Replace(f.String(), "AffineModel", "AffineModel", 1) + ","
	}
	repeatedStringForModel += "}"
	s := strings.Join([]string{`&MixtureAffine{`,
		`Model:` + repeatedStringForModel + `,`,
		`}`,
	}, "")
	return s
}
func (this *MixtureHomography) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForModel := "[]*Homography{"
	for _, f := range this.Model {
		repeatedStringForModel += strings.Replace(f.String(), "Homography", "Homography", 1) + ","
	}
	repeatedStringForModel += "}"
	s := strings.Join([]string{`&MixtureHomography{`,
		`Model:` + repeatedStringForModel + `,`,
		`Dof:` + valueToStringMotionModels(this.Dof) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMotionModels(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TranslationModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TranslationModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TranslationModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dx = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dy = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimilarityModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimilarityModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimilarityModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dx = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dy = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Rotation = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinearSimilarityModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinearSimilarityModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinearSimilarityModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dx = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dy = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.A = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.B = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AffineModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AffineModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AffineModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dx = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Dy = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.A = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.B = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.C = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.D = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Homography) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Homography: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Homography: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_00", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_00 = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_01", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_01 = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_02", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_02 = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_10", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_10 = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_11", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_11 = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_12", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_12 = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_20", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_20 = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field H_21", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.H_21 = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixtureLinearSimilarity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixtureLinearSimilarity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixtureLinearSimilarity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = append(m.Model, &LinearSimilarityModel{})
			if err := m.Model[len(m.Model)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixtureAffine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixtureAffine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixtureAffine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = append(m.Model, &AffineModel{})
			if err := m.Model[len(m.Model)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MixtureHomography) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MixtureHomography: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MixtureHomography: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMotionModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMotionModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = append(m.Model, &Homography{})
			if err := m.Model[len(m.Model)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dof", wireType)
			}
			var v MixtureHomography_VariableDOF
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MixtureHomography_VariableDOF(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dof = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMotionModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMotionModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMotionModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMotionModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMotionModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMotionModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMotionModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMotionModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMotionModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMotionModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMotionModels = fmt.Errorf("proto: unexpected end of group")
)
