// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/region_flow_computation.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	sort "sort"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TrackingOptions_FlowDirection int32

const (
	FLOW_DIRECTION_UNKNOWN       TrackingOptions_FlowDirection = 0
	FLOW_DIRECTION_FORWARD       TrackingOptions_FlowDirection = 1
	FLOW_DIRECTION_BACKWARD      TrackingOptions_FlowDirection = 2
	FLOW_DIRECTION_CONSECUTIVELY TrackingOptions_FlowDirection = 3
)

var TrackingOptions_FlowDirection_name = map[int32]string{
	0: "FLOW_DIRECTION_UNKNOWN",
	1: "FLOW_DIRECTION_FORWARD",
	2: "FLOW_DIRECTION_BACKWARD",
	3: "FLOW_DIRECTION_CONSECUTIVELY",
}

var TrackingOptions_FlowDirection_value = map[string]int32{
	"FLOW_DIRECTION_UNKNOWN":       0,
	"FLOW_DIRECTION_FORWARD":       1,
	"FLOW_DIRECTION_BACKWARD":      2,
	"FLOW_DIRECTION_CONSECUTIVELY": 3,
}

func (x TrackingOptions_FlowDirection) Enum() *TrackingOptions_FlowDirection {
	p := new(TrackingOptions_FlowDirection)
	*p = x
	return p
}

func (x TrackingOptions_FlowDirection) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackingOptions_FlowDirection_name, int32(x))
}

func (x *TrackingOptions_FlowDirection) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackingOptions_FlowDirection_value, data, "TrackingOptions_FlowDirection")
	if err != nil {
		return err
	}
	*x = TrackingOptions_FlowDirection(value)
	return nil
}

func (TrackingOptions_FlowDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 0}
}

type TrackingOptions_TrackingPolicy int32

const (
	POLICY_UNKNOWN      TrackingOptions_TrackingPolicy = 0
	POLICY_SINGLE_FRAME TrackingOptions_TrackingPolicy = 1
	POLICY_MULTI_FRAME  TrackingOptions_TrackingPolicy = 2
	POLICY_LONG_TRACKS  TrackingOptions_TrackingPolicy = 3
)

var TrackingOptions_TrackingPolicy_name = map[int32]string{
	0: "POLICY_UNKNOWN",
	1: "POLICY_SINGLE_FRAME",
	2: "POLICY_MULTI_FRAME",
	3: "POLICY_LONG_TRACKS",
}

var TrackingOptions_TrackingPolicy_value = map[string]int32{
	"POLICY_UNKNOWN":      0,
	"POLICY_SINGLE_FRAME": 1,
	"POLICY_MULTI_FRAME":  2,
	"POLICY_LONG_TRACKS":  3,
}

func (x TrackingOptions_TrackingPolicy) Enum() *TrackingOptions_TrackingPolicy {
	p := new(TrackingOptions_TrackingPolicy)
	*p = x
	return p
}

func (x TrackingOptions_TrackingPolicy) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackingOptions_TrackingPolicy_name, int32(x))
}

func (x *TrackingOptions_TrackingPolicy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackingOptions_TrackingPolicy_value, data, "TrackingOptions_TrackingPolicy")
	if err != nil {
		return err
	}
	*x = TrackingOptions_TrackingPolicy(value)
	return nil
}

func (TrackingOptions_TrackingPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 1}
}

type TrackingOptions_CornerExtractionMethod int32

const (
	EXTRACTION_UNKNOWN     TrackingOptions_CornerExtractionMethod = 0
	EXTRACTION_HARRIS      TrackingOptions_CornerExtractionMethod = 1
	EXTRACTION_MIN_EIG_VAL TrackingOptions_CornerExtractionMethod = 2
	EXTRACTION_FAST        TrackingOptions_CornerExtractionMethod = 3
)

var TrackingOptions_CornerExtractionMethod_name = map[int32]string{
	0: "EXTRACTION_UNKNOWN",
	1: "EXTRACTION_HARRIS",
	2: "EXTRACTION_MIN_EIG_VAL",
	3: "EXTRACTION_FAST",
}

var TrackingOptions_CornerExtractionMethod_value = map[string]int32{
	"EXTRACTION_UNKNOWN":     0,
	"EXTRACTION_HARRIS":      1,
	"EXTRACTION_MIN_EIG_VAL": 2,
	"EXTRACTION_FAST":        3,
}

func (x TrackingOptions_CornerExtractionMethod) Enum() *TrackingOptions_CornerExtractionMethod {
	p := new(TrackingOptions_CornerExtractionMethod)
	*p = x
	return p
}

func (x TrackingOptions_CornerExtractionMethod) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackingOptions_CornerExtractionMethod_name, int32(x))
}

func (x *TrackingOptions_CornerExtractionMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackingOptions_CornerExtractionMethod_value, data, "TrackingOptions_CornerExtractionMethod")
	if err != nil {
		return err
	}
	*x = TrackingOptions_CornerExtractionMethod(value)
	return nil
}

func (TrackingOptions_CornerExtractionMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 2}
}

type TrackingOptions_KltTrackerImplementation int32

const (
	UNSPECIFIED TrackingOptions_KltTrackerImplementation = 0
	KLT_OPENCV  TrackingOptions_KltTrackerImplementation = 1
)

var TrackingOptions_KltTrackerImplementation_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "KLT_OPENCV",
}

var TrackingOptions_KltTrackerImplementation_value = map[string]int32{
	"UNSPECIFIED": 0,
	"KLT_OPENCV":  1,
}

func (x TrackingOptions_KltTrackerImplementation) Enum() *TrackingOptions_KltTrackerImplementation {
	p := new(TrackingOptions_KltTrackerImplementation)
	*p = x
	return p
}

func (x TrackingOptions_KltTrackerImplementation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackingOptions_KltTrackerImplementation_name, int32(x))
}

func (x *TrackingOptions_KltTrackerImplementation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackingOptions_KltTrackerImplementation_value, data, "TrackingOptions_KltTrackerImplementation")
	if err != nil {
		return err
	}
	*x = TrackingOptions_KltTrackerImplementation(value)
	return nil
}

func (TrackingOptions_KltTrackerImplementation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 3}
}

type RegionFlowComputationOptions_IrlsInitialization int32

const (
	INIT_UNKNOWN     RegionFlowComputationOptions_IrlsInitialization = 0
	INIT_UNIFORM     RegionFlowComputationOptions_IrlsInitialization = 1
	INIT_CONSISTENCY RegionFlowComputationOptions_IrlsInitialization = 2
)

var RegionFlowComputationOptions_IrlsInitialization_name = map[int32]string{
	0: "INIT_UNKNOWN",
	1: "INIT_UNIFORM",
	2: "INIT_CONSISTENCY",
}

var RegionFlowComputationOptions_IrlsInitialization_value = map[string]int32{
	"INIT_UNKNOWN":     0,
	"INIT_UNIFORM":     1,
	"INIT_CONSISTENCY": 2,
}

func (x RegionFlowComputationOptions_IrlsInitialization) Enum() *RegionFlowComputationOptions_IrlsInitialization {
	p := new(RegionFlowComputationOptions_IrlsInitialization)
	*p = x
	return p
}

func (x RegionFlowComputationOptions_IrlsInitialization) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RegionFlowComputationOptions_IrlsInitialization_name, int32(x))
}

func (x *RegionFlowComputationOptions_IrlsInitialization) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegionFlowComputationOptions_IrlsInitialization_value, data, "RegionFlowComputationOptions_IrlsInitialization")
	if err != nil {
		return err
	}
	*x = RegionFlowComputationOptions_IrlsInitialization(value)
	return nil
}

func (RegionFlowComputationOptions_IrlsInitialization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 0}
}

type RegionFlowComputationOptions_DownsampleMode int32

const (
	REGION_FLOW_DOWNSAMPLE_UNKNOWN       RegionFlowComputationOptions_DownsampleMode = 0
	REGION_FLOW_DOWNSAMPLE_NONE          RegionFlowComputationOptions_DownsampleMode = 1
	REGION_FLOW_DOWNSAMPLE_TO_MAX_SIZE   RegionFlowComputationOptions_DownsampleMode = 2
	REGION_FLOW_DOWNSAMPLE_BY_FACTOR     RegionFlowComputationOptions_DownsampleMode = 3
	REGION_FLOW_DOWNSAMPLE_BY_SCHEDULE   RegionFlowComputationOptions_DownsampleMode = 4
	REGION_FLOW_DOWNSAMPLE_TO_MIN_SIZE   RegionFlowComputationOptions_DownsampleMode = 5
	REGION_FLOW_DOWNSAMPLE_TO_INPUT_SIZE RegionFlowComputationOptions_DownsampleMode = 6
)

var RegionFlowComputationOptions_DownsampleMode_name = map[int32]string{
	0: "REGION_FLOW_DOWNSAMPLE_UNKNOWN",
	1: "REGION_FLOW_DOWNSAMPLE_NONE",
	2: "REGION_FLOW_DOWNSAMPLE_TO_MAX_SIZE",
	3: "REGION_FLOW_DOWNSAMPLE_BY_FACTOR",
	4: "REGION_FLOW_DOWNSAMPLE_BY_SCHEDULE",
	5: "REGION_FLOW_DOWNSAMPLE_TO_MIN_SIZE",
	6: "REGION_FLOW_DOWNSAMPLE_TO_INPUT_SIZE",
}

var RegionFlowComputationOptions_DownsampleMode_value = map[string]int32{
	"REGION_FLOW_DOWNSAMPLE_UNKNOWN":       0,
	"REGION_FLOW_DOWNSAMPLE_NONE":          1,
	"REGION_FLOW_DOWNSAMPLE_TO_MAX_SIZE":   2,
	"REGION_FLOW_DOWNSAMPLE_BY_FACTOR":     3,
	"REGION_FLOW_DOWNSAMPLE_BY_SCHEDULE":   4,
	"REGION_FLOW_DOWNSAMPLE_TO_MIN_SIZE":   5,
	"REGION_FLOW_DOWNSAMPLE_TO_INPUT_SIZE": 6,
}

func (x RegionFlowComputationOptions_DownsampleMode) Enum() *RegionFlowComputationOptions_DownsampleMode {
	p := new(RegionFlowComputationOptions_DownsampleMode)
	*p = x
	return p
}

func (x RegionFlowComputationOptions_DownsampleMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RegionFlowComputationOptions_DownsampleMode_name, int32(x))
}

func (x *RegionFlowComputationOptions_DownsampleMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegionFlowComputationOptions_DownsampleMode_value, data, "RegionFlowComputationOptions_DownsampleMode")
	if err != nil {
		return err
	}
	*x = RegionFlowComputationOptions_DownsampleMode(value)
	return nil
}

func (RegionFlowComputationOptions_DownsampleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 1}
}

type RegionFlowComputationOptions_GainCorrectMode int32

const (
	GAIN_CORRECT_DEFAULT_USER RegionFlowComputationOptions_GainCorrectMode = 1
	GAIN_CORRECT_VIDEO        RegionFlowComputationOptions_GainCorrectMode = 2
	GAIN_CORRECT_HDR          RegionFlowComputationOptions_GainCorrectMode = 3
	GAIN_CORRECT_PHOTO_BURST  RegionFlowComputationOptions_GainCorrectMode = 4
)

var RegionFlowComputationOptions_GainCorrectMode_name = map[int32]string{
	1: "GAIN_CORRECT_DEFAULT_USER",
	2: "GAIN_CORRECT_VIDEO",
	3: "GAIN_CORRECT_HDR",
	4: "GAIN_CORRECT_PHOTO_BURST",
}

var RegionFlowComputationOptions_GainCorrectMode_value = map[string]int32{
	"GAIN_CORRECT_DEFAULT_USER": 1,
	"GAIN_CORRECT_VIDEO":        2,
	"GAIN_CORRECT_HDR":          3,
	"GAIN_CORRECT_PHOTO_BURST":  4,
}

func (x RegionFlowComputationOptions_GainCorrectMode) Enum() *RegionFlowComputationOptions_GainCorrectMode {
	p := new(RegionFlowComputationOptions_GainCorrectMode)
	*p = x
	return p
}

func (x RegionFlowComputationOptions_GainCorrectMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RegionFlowComputationOptions_GainCorrectMode_name, int32(x))
}

func (x *RegionFlowComputationOptions_GainCorrectMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegionFlowComputationOptions_GainCorrectMode_value, data, "RegionFlowComputationOptions_GainCorrectMode")
	if err != nil {
		return err
	}
	*x = RegionFlowComputationOptions_GainCorrectMode(value)
	return nil
}

func (RegionFlowComputationOptions_GainCorrectMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 2}
}

type RegionFlowComputationOptions_ImageFormat int32

const (
	FORMAT_UNKNOWN   RegionFlowComputationOptions_ImageFormat = 0
	FORMAT_GRAYSCALE RegionFlowComputationOptions_ImageFormat = 1
	FORMAT_RGB       RegionFlowComputationOptions_ImageFormat = 2
	FORMAT_RGBA      RegionFlowComputationOptions_ImageFormat = 3
	FORMAT_BGR       RegionFlowComputationOptions_ImageFormat = 4
	FORMAT_BGRA      RegionFlowComputationOptions_ImageFormat = 5
)

var RegionFlowComputationOptions_ImageFormat_name = map[int32]string{
	0: "FORMAT_UNKNOWN",
	1: "FORMAT_GRAYSCALE",
	2: "FORMAT_RGB",
	3: "FORMAT_RGBA",
	4: "FORMAT_BGR",
	5: "FORMAT_BGRA",
}

var RegionFlowComputationOptions_ImageFormat_value = map[string]int32{
	"FORMAT_UNKNOWN":   0,
	"FORMAT_GRAYSCALE": 1,
	"FORMAT_RGB":       2,
	"FORMAT_RGBA":      3,
	"FORMAT_BGR":       4,
	"FORMAT_BGRA":      5,
}

func (x RegionFlowComputationOptions_ImageFormat) Enum() *RegionFlowComputationOptions_ImageFormat {
	p := new(RegionFlowComputationOptions_ImageFormat)
	*p = x
	return p
}

func (x RegionFlowComputationOptions_ImageFormat) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RegionFlowComputationOptions_ImageFormat_name, int32(x))
}

func (x *RegionFlowComputationOptions_ImageFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegionFlowComputationOptions_ImageFormat_value, data, "RegionFlowComputationOptions_ImageFormat")
	if err != nil {
		return err
	}
	*x = RegionFlowComputationOptions_ImageFormat(value)
	return nil
}

func (RegionFlowComputationOptions_ImageFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 3}
}

type RegionFlowComputationOptions_DescriptorExtractorType int32

const (
	ORB RegionFlowComputationOptions_DescriptorExtractorType = 0
)

var RegionFlowComputationOptions_DescriptorExtractorType_name = map[int32]string{
	0: "ORB",
}

var RegionFlowComputationOptions_DescriptorExtractorType_value = map[string]int32{
	"ORB": 0,
}

func (x RegionFlowComputationOptions_DescriptorExtractorType) Enum() *RegionFlowComputationOptions_DescriptorExtractorType {
	p := new(RegionFlowComputationOptions_DescriptorExtractorType)
	*p = x
	return p
}

func (x RegionFlowComputationOptions_DescriptorExtractorType) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RegionFlowComputationOptions_DescriptorExtractorType_name, int32(x))
}

func (x *RegionFlowComputationOptions_DescriptorExtractorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegionFlowComputationOptions_DescriptorExtractorType_value, data, "RegionFlowComputationOptions_DescriptorExtractorType")
	if err != nil {
		return err
	}
	*x = RegionFlowComputationOptions_DescriptorExtractorType(value)
	return nil
}

func (RegionFlowComputationOptions_DescriptorExtractorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 4}
}

type TrackingOptions struct {
	InternalTrackingDirection          *TrackingOptions_FlowDirection               `protobuf:"varint,19,opt,name=internal_tracking_direction,json=internalTrackingDirection,enum=mediapipe.TrackingOptions_FlowDirection,def=2" json:"internal_tracking_direction,omitempty"`
	OutputFlowDirection                *TrackingOptions_FlowDirection               `protobuf:"varint,20,opt,name=output_flow_direction,json=outputFlowDirection,enum=mediapipe.TrackingOptions_FlowDirection,def=2" json:"output_flow_direction,omitempty"`
	TrackingPolicy                     *TrackingOptions_TrackingPolicy              `protobuf:"varint,25,opt,name=tracking_policy,json=trackingPolicy,enum=mediapipe.TrackingOptions_TrackingPolicy,def=1" json:"tracking_policy,omitempty"`
	MultiFramesToTrack                 *int32                                       `protobuf:"varint,1,opt,name=multi_frames_to_track,json=multiFramesToTrack,def=1" json:"multi_frames_to_track,omitempty"`
	LongTracksMaxFrames                *int32                                       `protobuf:"varint,26,opt,name=long_tracks_max_frames,json=longTracksMaxFrames,def=300" json:"long_tracks_max_frames,omitempty"`
	MaxFeatures                        *int32                                       `protobuf:"varint,2,opt,name=max_features,json=maxFeatures,def=2000" json:"max_features,omitempty"`
	CornerExtractionMethod             *TrackingOptions_CornerExtractionMethod      `protobuf:"varint,27,opt,name=corner_extraction_method,json=cornerExtractionMethod,enum=mediapipe.TrackingOptions_CornerExtractionMethod,def=2" json:"corner_extraction_method,omitempty"`
	MinEigValSettings                  *TrackingOptions_MinEigValExtractionSettings `protobuf:"bytes,28,opt,name=min_eig_val_settings,json=minEigValSettings" json:"min_eig_val_settings,omitempty"`
	HarrisSettings                     *TrackingOptions_HarrisExtractionSettings    `protobuf:"bytes,29,opt,name=harris_settings,json=harrisSettings" json:"harris_settings,omitempty"`
	FastSettings                       *TrackingOptions_FastExtractionSettings      `protobuf:"bytes,31,opt,name=fast_settings,json=fastSettings" json:"fast_settings,omitempty"`
	TrackingWindowSize                 *int32                                       `protobuf:"varint,4,opt,name=tracking_window_size,json=trackingWindowSize,def=10" json:"tracking_window_size,omitempty"`
	TrackingIterations                 *int32                                       `protobuf:"varint,5,opt,name=tracking_iterations,json=trackingIterations,def=10" json:"tracking_iterations,omitempty"`
	FractionalTrackingDistance         *float32                                     `protobuf:"fixed32,6,opt,name=fractional_tracking_distance,json=fractionalTrackingDistance,def=0.15" json:"fractional_tracking_distance,omitempty"`
	AdaptiveTrackingDistance           *bool                                        `protobuf:"varint,24,opt,name=adaptive_tracking_distance,json=adaptiveTrackingDistance,def=0" json:"adaptive_tracking_distance,omitempty"`
	MinFeatureDistance                 *float32                                     `protobuf:"fixed32,7,opt,name=min_feature_distance,json=minFeatureDistance,def=7" json:"min_feature_distance,omitempty"`
	DistanceDownscaleSqrt              *bool                                        `protobuf:"varint,21,opt,name=distance_downscale_sqrt,json=distanceDownscaleSqrt,def=1" json:"distance_downscale_sqrt,omitempty"`
	AdaptiveGoodFeaturesToTrack        *bool                                        `protobuf:"varint,8,opt,name=adaptive_good_features_to_track,json=adaptiveGoodFeaturesToTrack,def=1" json:"adaptive_good_features_to_track,omitempty"`
	AdaptiveFeaturesBlockSize          *float32                                     `protobuf:"fixed32,9,opt,name=adaptive_features_block_size,json=adaptiveFeaturesBlockSize,def=0.26" json:"adaptive_features_block_size,omitempty"`
	AdaptiveFeaturesLevels             *int32                                       `protobuf:"varint,10,opt,name=adaptive_features_levels,json=adaptiveFeaturesLevels,def=1" json:"adaptive_features_levels,omitempty"`
	AdaptiveExtractionLevels           *int32                                       `protobuf:"varint,22,opt,name=adaptive_extraction_levels,json=adaptiveExtractionLevels,def=1" json:"adaptive_extraction_levels,omitempty"`
	AdaptiveExtractionLevelsLowestSize *int32                                       `protobuf:"varint,23,opt,name=adaptive_extraction_levels_lowest_size,json=adaptiveExtractionLevelsLowestSize,def=0" json:"adaptive_extraction_levels_lowest_size,omitempty"`
	SyntheticZeroMotionGridStep        *float32                                     `protobuf:"fixed32,13,opt,name=synthetic_zero_motion_grid_step,json=syntheticZeroMotionGridStep,def=0.04" json:"synthetic_zero_motion_grid_step,omitempty"`
	WideBaselineMatching               *bool                                        `protobuf:"varint,14,opt,name=wide_baseline_matching,json=wideBaselineMatching,def=0" json:"wide_baseline_matching,omitempty"`
	RatioTestThreshold                 *float32                                     `protobuf:"fixed32,15,opt,name=ratio_test_threshold,json=ratioTestThreshold,def=0.8" json:"ratio_test_threshold,omitempty"`
	RefineWideBaselineMatches          *bool                                        `protobuf:"varint,16,opt,name=refine_wide_baseline_matches,json=refineWideBaselineMatches,def=0" json:"refine_wide_baseline_matches,omitempty"`
	ReuseFeaturesMaxFrameDistance      *int32                                       `protobuf:"varint,17,opt,name=reuse_features_max_frame_distance,json=reuseFeaturesMaxFrameDistance,def=0" json:"reuse_features_max_frame_distance,omitempty"`
	ReuseFeaturesMinSurvivedFrac       *float32                                     `protobuf:"fixed32,18,opt,name=reuse_features_min_survived_frac,json=reuseFeaturesMinSurvivedFrac,def=0.7" json:"reuse_features_min_survived_frac,omitempty"`
	KltTrackerImplementation           *TrackingOptions_KltTrackerImplementation    `protobuf:"varint,32,opt,name=klt_tracker_implementation,json=kltTrackerImplementation,enum=mediapipe.TrackingOptions_KltTrackerImplementation,def=1" json:"klt_tracker_implementation,omitempty"`
	proto.XXX_InternalExtensions       `json:"-"`
}

func (m *TrackingOptions) Reset()      { *m = TrackingOptions{} }
func (*TrackingOptions) ProtoMessage() {}
func (*TrackingOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0}
}

var extRange_TrackingOptions = []proto.ExtensionRange{
	{Start: 3, End: 3},
	{Start: 11, End: 11},
	{Start: 12, End: 12},
	{Start: 30, End: 30},
}

func (*TrackingOptions) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TrackingOptions
}

func (m *TrackingOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingOptions.Merge(m, src)
}
func (m *TrackingOptions) XXX_Size() int {
	return m.Size()
}
func (m *TrackingOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingOptions proto.InternalMessageInfo

const Default_TrackingOptions_InternalTrackingDirection TrackingOptions_FlowDirection = FLOW_DIRECTION_BACKWARD
const Default_TrackingOptions_OutputFlowDirection TrackingOptions_FlowDirection = FLOW_DIRECTION_BACKWARD
const Default_TrackingOptions_TrackingPolicy TrackingOptions_TrackingPolicy = POLICY_SINGLE_FRAME
const Default_TrackingOptions_MultiFramesToTrack int32 = 1
const Default_TrackingOptions_LongTracksMaxFrames int32 = 300
const Default_TrackingOptions_MaxFeatures int32 = 2000
const Default_TrackingOptions_CornerExtractionMethod TrackingOptions_CornerExtractionMethod = EXTRACTION_MIN_EIG_VAL
const Default_TrackingOptions_TrackingWindowSize int32 = 10
const Default_TrackingOptions_TrackingIterations int32 = 10
const Default_TrackingOptions_FractionalTrackingDistance float32 = 0.15
const Default_TrackingOptions_AdaptiveTrackingDistance bool = false
const Default_TrackingOptions_MinFeatureDistance float32 = 7
const Default_TrackingOptions_DistanceDownscaleSqrt bool = true
const Default_TrackingOptions_AdaptiveGoodFeaturesToTrack bool = true
const Default_TrackingOptions_AdaptiveFeaturesBlockSize float32 = 0.26
const Default_TrackingOptions_AdaptiveFeaturesLevels int32 = 1
const Default_TrackingOptions_AdaptiveExtractionLevels int32 = 1
const Default_TrackingOptions_AdaptiveExtractionLevelsLowestSize int32 = 0
const Default_TrackingOptions_SyntheticZeroMotionGridStep float32 = 0.04
const Default_TrackingOptions_WideBaselineMatching bool = false
const Default_TrackingOptions_RatioTestThreshold float32 = 0.8
const Default_TrackingOptions_RefineWideBaselineMatches bool = false
const Default_TrackingOptions_ReuseFeaturesMaxFrameDistance int32 = 0
const Default_TrackingOptions_ReuseFeaturesMinSurvivedFrac float32 = 0.7
const Default_TrackingOptions_KltTrackerImplementation TrackingOptions_KltTrackerImplementation = KLT_OPENCV

func (m *TrackingOptions) GetInternalTrackingDirection() TrackingOptions_FlowDirection {
	if m != nil && m.InternalTrackingDirection != nil {
		return *m.InternalTrackingDirection
	}
	return Default_TrackingOptions_InternalTrackingDirection
}

func (m *TrackingOptions) GetOutputFlowDirection() TrackingOptions_FlowDirection {
	if m != nil && m.OutputFlowDirection != nil {
		return *m.OutputFlowDirection
	}
	return Default_TrackingOptions_OutputFlowDirection
}

func (m *TrackingOptions) GetTrackingPolicy() TrackingOptions_TrackingPolicy {
	if m != nil && m.TrackingPolicy != nil {
		return *m.TrackingPolicy
	}
	return Default_TrackingOptions_TrackingPolicy
}

func (m *TrackingOptions) GetMultiFramesToTrack() int32 {
	if m != nil && m.MultiFramesToTrack != nil {
		return *m.MultiFramesToTrack
	}
	return Default_TrackingOptions_MultiFramesToTrack
}

func (m *TrackingOptions) GetLongTracksMaxFrames() int32 {
	if m != nil && m.LongTracksMaxFrames != nil {
		return *m.LongTracksMaxFrames
	}
	return Default_TrackingOptions_LongTracksMaxFrames
}

func (m *TrackingOptions) GetMaxFeatures() int32 {
	if m != nil && m.MaxFeatures != nil {
		return *m.MaxFeatures
	}
	return Default_TrackingOptions_MaxFeatures
}

func (m *TrackingOptions) GetCornerExtractionMethod() TrackingOptions_CornerExtractionMethod {
	if m != nil && m.CornerExtractionMethod != nil {
		return *m.CornerExtractionMethod
	}
	return Default_TrackingOptions_CornerExtractionMethod
}

func (m *TrackingOptions) GetMinEigValSettings() *TrackingOptions_MinEigValExtractionSettings {
	if m != nil {
		return m.MinEigValSettings
	}
	return nil
}

func (m *TrackingOptions) GetHarrisSettings() *TrackingOptions_HarrisExtractionSettings {
	if m != nil {
		return m.HarrisSettings
	}
	return nil
}

func (m *TrackingOptions) GetFastSettings() *TrackingOptions_FastExtractionSettings {
	if m != nil {
		return m.FastSettings
	}
	return nil
}

func (m *TrackingOptions) GetTrackingWindowSize() int32 {
	if m != nil && m.TrackingWindowSize != nil {
		return *m.TrackingWindowSize
	}
	return Default_TrackingOptions_TrackingWindowSize
}

func (m *TrackingOptions) GetTrackingIterations() int32 {
	if m != nil && m.TrackingIterations != nil {
		return *m.TrackingIterations
	}
	return Default_TrackingOptions_TrackingIterations
}

func (m *TrackingOptions) GetFractionalTrackingDistance() float32 {
	if m != nil && m.FractionalTrackingDistance != nil {
		return *m.FractionalTrackingDistance
	}
	return Default_TrackingOptions_FractionalTrackingDistance
}

func (m *TrackingOptions) GetAdaptiveTrackingDistance() bool {
	if m != nil && m.AdaptiveTrackingDistance != nil {
		return *m.AdaptiveTrackingDistance
	}
	return Default_TrackingOptions_AdaptiveTrackingDistance
}

func (m *TrackingOptions) GetMinFeatureDistance() float32 {
	if m != nil && m.MinFeatureDistance != nil {
		return *m.MinFeatureDistance
	}
	return Default_TrackingOptions_MinFeatureDistance
}

func (m *TrackingOptions) GetDistanceDownscaleSqrt() bool {
	if m != nil && m.DistanceDownscaleSqrt != nil {
		return *m.DistanceDownscaleSqrt
	}
	return Default_TrackingOptions_DistanceDownscaleSqrt
}

func (m *TrackingOptions) GetAdaptiveGoodFeaturesToTrack() bool {
	if m != nil && m.AdaptiveGoodFeaturesToTrack != nil {
		return *m.AdaptiveGoodFeaturesToTrack
	}
	return Default_TrackingOptions_AdaptiveGoodFeaturesToTrack
}

func (m *TrackingOptions) GetAdaptiveFeaturesBlockSize() float32 {
	if m != nil && m.AdaptiveFeaturesBlockSize != nil {
		return *m.AdaptiveFeaturesBlockSize
	}
	return Default_TrackingOptions_AdaptiveFeaturesBlockSize
}

func (m *TrackingOptions) GetAdaptiveFeaturesLevels() int32 {
	if m != nil && m.AdaptiveFeaturesLevels != nil {
		return *m.AdaptiveFeaturesLevels
	}
	return Default_TrackingOptions_AdaptiveFeaturesLevels
}

func (m *TrackingOptions) GetAdaptiveExtractionLevels() int32 {
	if m != nil && m.AdaptiveExtractionLevels != nil {
		return *m.AdaptiveExtractionLevels
	}
	return Default_TrackingOptions_AdaptiveExtractionLevels
}

func (m *TrackingOptions) GetAdaptiveExtractionLevelsLowestSize() int32 {
	if m != nil && m.AdaptiveExtractionLevelsLowestSize != nil {
		return *m.AdaptiveExtractionLevelsLowestSize
	}
	return Default_TrackingOptions_AdaptiveExtractionLevelsLowestSize
}

func (m *TrackingOptions) GetSyntheticZeroMotionGridStep() float32 {
	if m != nil && m.SyntheticZeroMotionGridStep != nil {
		return *m.SyntheticZeroMotionGridStep
	}
	return Default_TrackingOptions_SyntheticZeroMotionGridStep
}

func (m *TrackingOptions) GetWideBaselineMatching() bool {
	if m != nil && m.WideBaselineMatching != nil {
		return *m.WideBaselineMatching
	}
	return Default_TrackingOptions_WideBaselineMatching
}

func (m *TrackingOptions) GetRatioTestThreshold() float32 {
	if m != nil && m.RatioTestThreshold != nil {
		return *m.RatioTestThreshold
	}
	return Default_TrackingOptions_RatioTestThreshold
}

func (m *TrackingOptions) GetRefineWideBaselineMatches() bool {
	if m != nil && m.RefineWideBaselineMatches != nil {
		return *m.RefineWideBaselineMatches
	}
	return Default_TrackingOptions_RefineWideBaselineMatches
}

func (m *TrackingOptions) GetReuseFeaturesMaxFrameDistance() int32 {
	if m != nil && m.ReuseFeaturesMaxFrameDistance != nil {
		return *m.ReuseFeaturesMaxFrameDistance
	}
	return Default_TrackingOptions_ReuseFeaturesMaxFrameDistance
}

func (m *TrackingOptions) GetReuseFeaturesMinSurvivedFrac() float32 {
	if m != nil && m.ReuseFeaturesMinSurvivedFrac != nil {
		return *m.ReuseFeaturesMinSurvivedFrac
	}
	return Default_TrackingOptions_ReuseFeaturesMinSurvivedFrac
}

func (m *TrackingOptions) GetKltTrackerImplementation() TrackingOptions_KltTrackerImplementation {
	if m != nil && m.KltTrackerImplementation != nil {
		return *m.KltTrackerImplementation
	}
	return Default_TrackingOptions_KltTrackerImplementation
}

type TrackingOptions_MinEigValExtractionSettings struct {
	FeatureQualityLevel        *float32 `protobuf:"fixed32,1,opt,name=feature_quality_level,json=featureQualityLevel,def=0.01" json:"feature_quality_level,omitempty"`
	AdaptiveLowestQualityLevel *float32 `protobuf:"fixed32,2,opt,name=adaptive_lowest_quality_level,json=adaptiveLowestQualityLevel,def=8e-05" json:"adaptive_lowest_quality_level,omitempty"`
}

func (m *TrackingOptions_MinEigValExtractionSettings) Reset() {
	*m = TrackingOptions_MinEigValExtractionSettings{}
}
func (*TrackingOptions_MinEigValExtractionSettings) ProtoMessage() {}
func (*TrackingOptions_MinEigValExtractionSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 0}
}
func (m *TrackingOptions_MinEigValExtractionSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingOptions_MinEigValExtractionSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingOptions_MinEigValExtractionSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingOptions_MinEigValExtractionSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingOptions_MinEigValExtractionSettings.Merge(m, src)
}
func (m *TrackingOptions_MinEigValExtractionSettings) XXX_Size() int {
	return m.Size()
}
func (m *TrackingOptions_MinEigValExtractionSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingOptions_MinEigValExtractionSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingOptions_MinEigValExtractionSettings proto.InternalMessageInfo

const Default_TrackingOptions_MinEigValExtractionSettings_FeatureQualityLevel float32 = 0.01
const Default_TrackingOptions_MinEigValExtractionSettings_AdaptiveLowestQualityLevel float32 = 8e-05

func (m *TrackingOptions_MinEigValExtractionSettings) GetFeatureQualityLevel() float32 {
	if m != nil && m.FeatureQualityLevel != nil {
		return *m.FeatureQualityLevel
	}
	return Default_TrackingOptions_MinEigValExtractionSettings_FeatureQualityLevel
}

func (m *TrackingOptions_MinEigValExtractionSettings) GetAdaptiveLowestQualityLevel() float32 {
	if m != nil && m.AdaptiveLowestQualityLevel != nil {
		return *m.AdaptiveLowestQualityLevel
	}
	return Default_TrackingOptions_MinEigValExtractionSettings_AdaptiveLowestQualityLevel
}

type TrackingOptions_HarrisExtractionSettings struct {
	FeatureQualityLevel *float32 `protobuf:"fixed32,1,opt,name=feature_quality_level,json=featureQualityLevel,def=0.00025" json:"feature_quality_level,omitempty"`
}

func (m *TrackingOptions_HarrisExtractionSettings) Reset() {
	*m = TrackingOptions_HarrisExtractionSettings{}
}
func (*TrackingOptions_HarrisExtractionSettings) ProtoMessage() {}
func (*TrackingOptions_HarrisExtractionSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 1}
}
func (m *TrackingOptions_HarrisExtractionSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingOptions_HarrisExtractionSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingOptions_HarrisExtractionSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingOptions_HarrisExtractionSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingOptions_HarrisExtractionSettings.Merge(m, src)
}
func (m *TrackingOptions_HarrisExtractionSettings) XXX_Size() int {
	return m.Size()
}
func (m *TrackingOptions_HarrisExtractionSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingOptions_HarrisExtractionSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingOptions_HarrisExtractionSettings proto.InternalMessageInfo

const Default_TrackingOptions_HarrisExtractionSettings_FeatureQualityLevel float32 = 0.00025

func (m *TrackingOptions_HarrisExtractionSettings) GetFeatureQualityLevel() float32 {
	if m != nil && m.FeatureQualityLevel != nil {
		return *m.FeatureQualityLevel
	}
	return Default_TrackingOptions_HarrisExtractionSettings_FeatureQualityLevel
}

type TrackingOptions_FastExtractionSettings struct {
	Threshold *int32 `protobuf:"varint,1,opt,name=threshold,def=10" json:"threshold,omitempty"`
}

func (m *TrackingOptions_FastExtractionSettings) Reset() {
	*m = TrackingOptions_FastExtractionSettings{}
}
func (*TrackingOptions_FastExtractionSettings) ProtoMessage() {}
func (*TrackingOptions_FastExtractionSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{0, 2}
}
func (m *TrackingOptions_FastExtractionSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackingOptions_FastExtractionSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackingOptions_FastExtractionSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackingOptions_FastExtractionSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingOptions_FastExtractionSettings.Merge(m, src)
}
func (m *TrackingOptions_FastExtractionSettings) XXX_Size() int {
	return m.Size()
}
func (m *TrackingOptions_FastExtractionSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingOptions_FastExtractionSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingOptions_FastExtractionSettings proto.InternalMessageInfo

const Default_TrackingOptions_FastExtractionSettings_Threshold int32 = 10

func (m *TrackingOptions_FastExtractionSettings) GetThreshold() int32 {
	if m != nil && m.Threshold != nil {
		return *m.Threshold
	}
	return Default_TrackingOptions_FastExtractionSettings_Threshold
}

type RegionFlowComputationOptions struct {
	TrackingOptions                        *TrackingOptions                                       `protobuf:"bytes,1,opt,name=tracking_options,json=trackingOptions" json:"tracking_options,omitempty"`
	MinFeatureInliers                      *int32                                                 `protobuf:"varint,2,opt,name=min_feature_inliers,json=minFeatureInliers,def=3" json:"min_feature_inliers,omitempty"`
	RelativeMinFeatureInliers              *float32                                               `protobuf:"fixed32,46,opt,name=relative_min_feature_inliers,json=relativeMinFeatureInliers,def=0.2" json:"relative_min_feature_inliers,omitempty"`
	PreBlurSigma                           *float32                                               `protobuf:"fixed32,33,opt,name=pre_blur_sigma,json=preBlurSigma,def=0.8" json:"pre_blur_sigma,omitempty"`
	RansacRoundsPerRegion                  *int32                                                 `protobuf:"varint,3,opt,name=ransac_rounds_per_region,json=ransacRoundsPerRegion,def=15" json:"ransac_rounds_per_region,omitempty"`
	AbsoluteInlierErrorThreshold           *float32                                               `protobuf:"fixed32,4,opt,name=absolute_inlier_error_threshold,json=absoluteInlierErrorThreshold,def=2" json:"absolute_inlier_error_threshold,omitempty"`
	FracInlierErrorThreshold               *float32                                               `protobuf:"fixed32,52,opt,name=frac_inlier_error_threshold,json=fracInlierErrorThreshold,def=0" json:"frac_inlier_error_threshold,omitempty"`
	RelativeInlierErrorThreshold           *float32                                               `protobuf:"fixed32,44,opt,name=relative_inlier_error_threshold,json=relativeInlierErrorThreshold,def=0.1" json:"relative_inlier_error_threshold,omitempty"`
	TopInlierSets                          *int32                                                 `protobuf:"varint,45,opt,name=top_inlier_sets,json=topInlierSets,def=2" json:"top_inlier_sets,omitempty"`
	NoEstimationMode                       *bool                                                  `protobuf:"varint,40,opt,name=no_estimation_mode,json=noEstimationMode,def=0" json:"no_estimation_mode,omitempty"`
	FastEstimationBlockSize                *float32                                               `protobuf:"fixed32,6,opt,name=fast_estimation_block_size,json=fastEstimationBlockSize,def=0.25" json:"fast_estimation_block_size,omitempty"`
	FastEstimationMinBlockSize             *int32                                                 `protobuf:"varint,25,opt,name=fast_estimation_min_block_size,json=fastEstimationMinBlockSize,def=100" json:"fast_estimation_min_block_size,omitempty"`
	FastEstimationOverlapGrids             *int32                                                 `protobuf:"varint,22,opt,name=fast_estimation_overlap_grids,json=fastEstimationOverlapGrids,def=3" json:"fast_estimation_overlap_grids,omitempty"`
	MaxMagnitudeThresholdRatio             *float32                                               `protobuf:"fixed32,23,opt,name=max_magnitude_threshold_ratio,json=maxMagnitudeThresholdRatio,def=0.2" json:"max_magnitude_threshold_ratio,omitempty"`
	MedianMagnitudeBounds                  *float32                                               `protobuf:"fixed32,51,opt,name=median_magnitude_bounds,json=medianMagnitudeBounds,def=0" json:"median_magnitude_bounds,omitempty"`
	IrlsInitialization                     *RegionFlowComputationOptions_IrlsInitialization       `protobuf:"varint,49,opt,name=irls_initialization,json=irlsInitialization,enum=mediapipe.RegionFlowComputationOptions_IrlsInitialization,def=2" json:"irls_initialization,omitempty"`
	DownsampleMode                         *RegionFlowComputationOptions_DownsampleMode           `protobuf:"varint,11,opt,name=downsample_mode,json=downsampleMode,enum=mediapipe.RegionFlowComputationOptions_DownsampleMode,def=1" json:"downsample_mode,omitempty"`
	DownsamplingSize                       *int32                                                 `protobuf:"varint,12,opt,name=downsampling_size,json=downsamplingSize,def=256" json:"downsampling_size,omitempty"`
	DownsampleFactor                       *float32                                               `protobuf:"fixed32,18,opt,name=downsample_factor,json=downsampleFactor,def=2" json:"downsample_factor,omitempty"`
	RoundDownsampleFactor                  *bool                                                  `protobuf:"varint,62,opt,name=round_downsample_factor,json=roundDownsampleFactor,def=0" json:"round_downsample_factor,omitempty"`
	DownsampleSchedule                     *RegionFlowComputationOptions_DownSampleSchedule       `protobuf:"bytes,19,opt,name=downsample_schedule,json=downsampleSchedule" json:"downsample_schedule,omitempty"`
	MinFeatureRequirement                  *int32                                                 `protobuf:"varint,13,opt,name=min_feature_requirement,json=minFeatureRequirement,def=20" json:"min_feature_requirement,omitempty"`
	MinFeatureCover                        *float32                                               `protobuf:"fixed32,14,opt,name=min_feature_cover,json=minFeatureCover,def=0.15" json:"min_feature_cover,omitempty"`
	MinFeatureCoverGrid                    *int32                                                 `protobuf:"varint,20,opt,name=min_feature_cover_grid,json=minFeatureCoverGrid,def=8" json:"min_feature_cover_grid,omitempty"`
	ComputeBlurScore                       *bool                                                  `protobuf:"varint,17,opt,name=compute_blur_score,json=computeBlurScore,def=0" json:"compute_blur_score,omitempty"`
	BlurScoreOptions                       *RegionFlowComputationOptions_BlurScoreOptions         `protobuf:"bytes,31,opt,name=blur_score_options,json=blurScoreOptions" json:"blur_score_options,omitempty"`
	VisualConsistencyOptions               *RegionFlowComputationOptions_VisualConsistencyOptions `protobuf:"bytes,55,opt,name=visual_consistency_options,json=visualConsistencyOptions" json:"visual_consistency_options,omitempty"`
	PatchDescriptorRadius                  *int32                                                 `protobuf:"varint,21,opt,name=patch_descriptor_radius,json=patchDescriptorRadius,def=3" json:"patch_descriptor_radius,omitempty"`
	DistanceFromBorder                     *int32                                                 `protobuf:"varint,50,opt,name=distance_from_border,json=distanceFromBorder,def=3" json:"distance_from_border,omitempty"`
	CornerResponseScale                    *float32                                               `protobuf:"fixed32,26,opt,name=corner_response_scale,json=cornerResponseScale,def=1500" json:"corner_response_scale,omitempty"`
	VerifyFeatures                         *bool                                                  `protobuf:"varint,27,opt,name=verify_features,json=verifyFeatures,def=0" json:"verify_features,omitempty"`
	VerificationDistance                   *float32                                               `protobuf:"fixed32,28,opt,name=verification_distance,json=verificationDistance,def=0.5" json:"verification_distance,omitempty"`
	VerifyLongFeatures                     *bool                                                  `protobuf:"varint,53,opt,name=verify_long_features,json=verifyLongFeatures,def=1" json:"verify_long_features,omitempty"`
	LongFeatureVerificationThreshold       *float32                                               `protobuf:"fixed32,54,opt,name=long_feature_verification_threshold,json=longFeatureVerificationThreshold,def=0.04" json:"long_feature_verification_threshold,omitempty"`
	MaxLongFeatureAcceleration             *float32                                               `protobuf:"fixed32,56,opt,name=max_long_feature_acceleration,json=maxLongFeatureAcceleration,def=5" json:"max_long_feature_acceleration,omitempty"`
	VerifyLongFeatureAcceleration          *bool                                                  `protobuf:"varint,63,opt,name=verify_long_feature_acceleration,json=verifyLongFeatureAcceleration,def=0" json:"verify_long_feature_acceleration,omitempty"`
	VerifyLongFeatureTriggerRatio          *float32                                               `protobuf:"fixed32,64,opt,name=verify_long_feature_trigger_ratio,json=verifyLongFeatureTriggerRatio,def=0" json:"verify_long_feature_trigger_ratio,omitempty"`
	HistogramEqualization                  *bool                                                  `protobuf:"varint,57,opt,name=histogram_equalization,json=histogramEqualization,def=0" json:"histogram_equalization,omitempty"`
	UseSyntheticZeroMotionTracksAllFrames  *bool                                                  `protobuf:"varint,34,opt,name=use_synthetic_zero_motion_tracks_all_frames,json=useSyntheticZeroMotionTracksAllFrames,def=0" json:"use_synthetic_zero_motion_tracks_all_frames,omitempty"`
	UseSyntheticZeroMotionTracksFirstFrame *bool                                                  `protobuf:"varint,35,opt,name=use_synthetic_zero_motion_tracks_first_frame,json=useSyntheticZeroMotionTracksFirstFrame,def=0" json:"use_synthetic_zero_motion_tracks_first_frame,omitempty"`
	GainCorrection                         *bool                                                  `protobuf:"varint,36,opt,name=gain_correction,json=gainCorrection,def=0" json:"gain_correction,omitempty"`
	FastGainCorrection                     *bool                                                  `protobuf:"varint,61,opt,name=fast_gain_correction,json=fastGainCorrection,def=0" json:"fast_gain_correction,omitempty"`
	GainCorrectionMultipleHypotheses       *bool                                                  `protobuf:"varint,47,opt,name=gain_correction_multiple_hypotheses,json=gainCorrectionMultipleHypotheses,def=1" json:"gain_correction_multiple_hypotheses,omitempty"`
	GainCorrectionInlierImprovementFrac    *float32                                               `protobuf:"fixed32,48,opt,name=gain_correction_inlier_improvement_frac,json=gainCorrectionInlierImprovementFrac,def=0.1" json:"gain_correction_inlier_improvement_frac,omitempty"`
	GainCorrectionBrightReference          *bool                                                  `protobuf:"varint,59,opt,name=gain_correction_bright_reference,json=gainCorrectionBrightReference,def=0" json:"gain_correction_bright_reference,omitempty"`
	GainCorrectionTriggeringRatio          *float32                                               `protobuf:"fixed32,60,opt,name=gain_correction_triggering_ratio,json=gainCorrectionTriggeringRatio,def=0" json:"gain_correction_triggering_ratio,omitempty"`
	FracGainFeatureSize                    *float32                                               `protobuf:"fixed32,37,opt,name=frac_gain_feature_size,json=fracGainFeatureSize,def=0.3" json:"frac_gain_feature_size,omitempty"`
	FracGainStep                           *float32                                               `protobuf:"fixed32,38,opt,name=frac_gain_step,json=fracGainStep,def=0.1" json:"frac_gain_step,omitempty"`
	GainCorrectMode                        *RegionFlowComputationOptions_GainCorrectMode          `protobuf:"varint,41,opt,name=gain_correct_mode,json=gainCorrectMode,enum=mediapipe.RegionFlowComputationOptions_GainCorrectMode,def=1" json:"gain_correct_mode,omitempty"`
	GainBiasBounds                         *ToneEstimationOptions_GainBiasBounds                  `protobuf:"bytes,39,opt,name=gain_bias_bounds,json=gainBiasBounds" json:"gain_bias_bounds,omitempty"`
	ImageFormat                            *RegionFlowComputationOptions_ImageFormat              `protobuf:"varint,58,opt,name=image_format,json=imageFormat,enum=mediapipe.RegionFlowComputationOptions_ImageFormat,def=2" json:"image_format,omitempty"`
	DescriptorExtractorType                *RegionFlowComputationOptions_DescriptorExtractorType  `protobuf:"varint,65,opt,name=descriptor_extractor_type,json=descriptorExtractorType,enum=mediapipe.RegionFlowComputationOptions_DescriptorExtractorType,def=0" json:"descriptor_extractor_type,omitempty"`
	ComputeDerivativeInPyramid             *bool                                                  `protobuf:"varint,66,opt,name=compute_derivative_in_pyramid,json=computeDerivativeInPyramid,def=1" json:"compute_derivative_in_pyramid,omitempty"`
	proto.XXX_InternalExtensions           `json:"-"`
}

func (m *RegionFlowComputationOptions) Reset()      { *m = RegionFlowComputationOptions{} }
func (*RegionFlowComputationOptions) ProtoMessage() {}
func (*RegionFlowComputationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1}
}

var extRange_RegionFlowComputationOptions = []proto.ExtensionRange{
	{Start: 5, End: 5},
	{Start: 7, End: 7},
	{Start: 8, End: 8},
	{Start: 9, End: 9},
	{Start: 10, End: 10},
	{Start: 15, End: 15},
	{Start: 16, End: 16},
	{Start: 24, End: 24},
	{Start: 29, End: 29},
	{Start: 30, End: 30},
	{Start: 32, End: 32},
	{Start: 42, End: 42},
	{Start: 43, End: 43},
}

func (*RegionFlowComputationOptions) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_RegionFlowComputationOptions
}

func (m *RegionFlowComputationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionFlowComputationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionFlowComputationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionFlowComputationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionFlowComputationOptions.Merge(m, src)
}
func (m *RegionFlowComputationOptions) XXX_Size() int {
	return m.Size()
}
func (m *RegionFlowComputationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionFlowComputationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RegionFlowComputationOptions proto.InternalMessageInfo

const Default_RegionFlowComputationOptions_MinFeatureInliers int32 = 3
const Default_RegionFlowComputationOptions_RelativeMinFeatureInliers float32 = 0.2
const Default_RegionFlowComputationOptions_PreBlurSigma float32 = 0.8
const Default_RegionFlowComputationOptions_RansacRoundsPerRegion int32 = 15
const Default_RegionFlowComputationOptions_AbsoluteInlierErrorThreshold float32 = 2
const Default_RegionFlowComputationOptions_FracInlierErrorThreshold float32 = 0
const Default_RegionFlowComputationOptions_RelativeInlierErrorThreshold float32 = 0.1
const Default_RegionFlowComputationOptions_TopInlierSets int32 = 2
const Default_RegionFlowComputationOptions_NoEstimationMode bool = false
const Default_RegionFlowComputationOptions_FastEstimationBlockSize float32 = 0.25
const Default_RegionFlowComputationOptions_FastEstimationMinBlockSize int32 = 100
const Default_RegionFlowComputationOptions_FastEstimationOverlapGrids int32 = 3
const Default_RegionFlowComputationOptions_MaxMagnitudeThresholdRatio float32 = 0.2
const Default_RegionFlowComputationOptions_MedianMagnitudeBounds float32 = 0
const Default_RegionFlowComputationOptions_IrlsInitialization RegionFlowComputationOptions_IrlsInitialization = INIT_CONSISTENCY
const Default_RegionFlowComputationOptions_DownsampleMode RegionFlowComputationOptions_DownsampleMode = REGION_FLOW_DOWNSAMPLE_NONE
const Default_RegionFlowComputationOptions_DownsamplingSize int32 = 256
const Default_RegionFlowComputationOptions_DownsampleFactor float32 = 2
const Default_RegionFlowComputationOptions_RoundDownsampleFactor bool = false
const Default_RegionFlowComputationOptions_MinFeatureRequirement int32 = 20
const Default_RegionFlowComputationOptions_MinFeatureCover float32 = 0.15
const Default_RegionFlowComputationOptions_MinFeatureCoverGrid int32 = 8
const Default_RegionFlowComputationOptions_ComputeBlurScore bool = false
const Default_RegionFlowComputationOptions_PatchDescriptorRadius int32 = 3
const Default_RegionFlowComputationOptions_DistanceFromBorder int32 = 3
const Default_RegionFlowComputationOptions_CornerResponseScale float32 = 1500
const Default_RegionFlowComputationOptions_VerifyFeatures bool = false
const Default_RegionFlowComputationOptions_VerificationDistance float32 = 0.5
const Default_RegionFlowComputationOptions_VerifyLongFeatures bool = true
const Default_RegionFlowComputationOptions_LongFeatureVerificationThreshold float32 = 0.04
const Default_RegionFlowComputationOptions_MaxLongFeatureAcceleration float32 = 5
const Default_RegionFlowComputationOptions_VerifyLongFeatureAcceleration bool = false
const Default_RegionFlowComputationOptions_VerifyLongFeatureTriggerRatio float32 = 0
const Default_RegionFlowComputationOptions_HistogramEqualization bool = false
const Default_RegionFlowComputationOptions_UseSyntheticZeroMotionTracksAllFrames bool = false
const Default_RegionFlowComputationOptions_UseSyntheticZeroMotionTracksFirstFrame bool = false
const Default_RegionFlowComputationOptions_GainCorrection bool = false
const Default_RegionFlowComputationOptions_FastGainCorrection bool = false
const Default_RegionFlowComputationOptions_GainCorrectionMultipleHypotheses bool = true
const Default_RegionFlowComputationOptions_GainCorrectionInlierImprovementFrac float32 = 0.1
const Default_RegionFlowComputationOptions_GainCorrectionBrightReference bool = false
const Default_RegionFlowComputationOptions_GainCorrectionTriggeringRatio float32 = 0
const Default_RegionFlowComputationOptions_FracGainFeatureSize float32 = 0.3
const Default_RegionFlowComputationOptions_FracGainStep float32 = 0.1
const Default_RegionFlowComputationOptions_GainCorrectMode RegionFlowComputationOptions_GainCorrectMode = GAIN_CORRECT_DEFAULT_USER
const Default_RegionFlowComputationOptions_ImageFormat RegionFlowComputationOptions_ImageFormat = FORMAT_RGB
const Default_RegionFlowComputationOptions_DescriptorExtractorType RegionFlowComputationOptions_DescriptorExtractorType = ORB
const Default_RegionFlowComputationOptions_ComputeDerivativeInPyramid bool = true

func (m *RegionFlowComputationOptions) GetTrackingOptions() *TrackingOptions {
	if m != nil {
		return m.TrackingOptions
	}
	return nil
}

func (m *RegionFlowComputationOptions) GetMinFeatureInliers() int32 {
	if m != nil && m.MinFeatureInliers != nil {
		return *m.MinFeatureInliers
	}
	return Default_RegionFlowComputationOptions_MinFeatureInliers
}

func (m *RegionFlowComputationOptions) GetRelativeMinFeatureInliers() float32 {
	if m != nil && m.RelativeMinFeatureInliers != nil {
		return *m.RelativeMinFeatureInliers
	}
	return Default_RegionFlowComputationOptions_RelativeMinFeatureInliers
}

func (m *RegionFlowComputationOptions) GetPreBlurSigma() float32 {
	if m != nil && m.PreBlurSigma != nil {
		return *m.PreBlurSigma
	}
	return Default_RegionFlowComputationOptions_PreBlurSigma
}

func (m *RegionFlowComputationOptions) GetRansacRoundsPerRegion() int32 {
	if m != nil && m.RansacRoundsPerRegion != nil {
		return *m.RansacRoundsPerRegion
	}
	return Default_RegionFlowComputationOptions_RansacRoundsPerRegion
}

func (m *RegionFlowComputationOptions) GetAbsoluteInlierErrorThreshold() float32 {
	if m != nil && m.AbsoluteInlierErrorThreshold != nil {
		return *m.AbsoluteInlierErrorThreshold
	}
	return Default_RegionFlowComputationOptions_AbsoluteInlierErrorThreshold
}

func (m *RegionFlowComputationOptions) GetFracInlierErrorThreshold() float32 {
	if m != nil && m.FracInlierErrorThreshold != nil {
		return *m.FracInlierErrorThreshold
	}
	return Default_RegionFlowComputationOptions_FracInlierErrorThreshold
}

func (m *RegionFlowComputationOptions) GetRelativeInlierErrorThreshold() float32 {
	if m != nil && m.RelativeInlierErrorThreshold != nil {
		return *m.RelativeInlierErrorThreshold
	}
	return Default_RegionFlowComputationOptions_RelativeInlierErrorThreshold
}

func (m *RegionFlowComputationOptions) GetTopInlierSets() int32 {
	if m != nil && m.TopInlierSets != nil {
		return *m.TopInlierSets
	}
	return Default_RegionFlowComputationOptions_TopInlierSets
}

func (m *RegionFlowComputationOptions) GetNoEstimationMode() bool {
	if m != nil && m.NoEstimationMode != nil {
		return *m.NoEstimationMode
	}
	return Default_RegionFlowComputationOptions_NoEstimationMode
}

func (m *RegionFlowComputationOptions) GetFastEstimationBlockSize() float32 {
	if m != nil && m.FastEstimationBlockSize != nil {
		return *m.FastEstimationBlockSize
	}
	return Default_RegionFlowComputationOptions_FastEstimationBlockSize
}

func (m *RegionFlowComputationOptions) GetFastEstimationMinBlockSize() int32 {
	if m != nil && m.FastEstimationMinBlockSize != nil {
		return *m.FastEstimationMinBlockSize
	}
	return Default_RegionFlowComputationOptions_FastEstimationMinBlockSize
}

func (m *RegionFlowComputationOptions) GetFastEstimationOverlapGrids() int32 {
	if m != nil && m.FastEstimationOverlapGrids != nil {
		return *m.FastEstimationOverlapGrids
	}
	return Default_RegionFlowComputationOptions_FastEstimationOverlapGrids
}

func (m *RegionFlowComputationOptions) GetMaxMagnitudeThresholdRatio() float32 {
	if m != nil && m.MaxMagnitudeThresholdRatio != nil {
		return *m.MaxMagnitudeThresholdRatio
	}
	return Default_RegionFlowComputationOptions_MaxMagnitudeThresholdRatio
}

func (m *RegionFlowComputationOptions) GetMedianMagnitudeBounds() float32 {
	if m != nil && m.MedianMagnitudeBounds != nil {
		return *m.MedianMagnitudeBounds
	}
	return Default_RegionFlowComputationOptions_MedianMagnitudeBounds
}

func (m *RegionFlowComputationOptions) GetIrlsInitialization() RegionFlowComputationOptions_IrlsInitialization {
	if m != nil && m.IrlsInitialization != nil {
		return *m.IrlsInitialization
	}
	return Default_RegionFlowComputationOptions_IrlsInitialization
}

func (m *RegionFlowComputationOptions) GetDownsampleMode() RegionFlowComputationOptions_DownsampleMode {
	if m != nil && m.DownsampleMode != nil {
		return *m.DownsampleMode
	}
	return Default_RegionFlowComputationOptions_DownsampleMode
}

func (m *RegionFlowComputationOptions) GetDownsamplingSize() int32 {
	if m != nil && m.DownsamplingSize != nil {
		return *m.DownsamplingSize
	}
	return Default_RegionFlowComputationOptions_DownsamplingSize
}

func (m *RegionFlowComputationOptions) GetDownsampleFactor() float32 {
	if m != nil && m.DownsampleFactor != nil {
		return *m.DownsampleFactor
	}
	return Default_RegionFlowComputationOptions_DownsampleFactor
}

func (m *RegionFlowComputationOptions) GetRoundDownsampleFactor() bool {
	if m != nil && m.RoundDownsampleFactor != nil {
		return *m.RoundDownsampleFactor
	}
	return Default_RegionFlowComputationOptions_RoundDownsampleFactor
}

func (m *RegionFlowComputationOptions) GetDownsampleSchedule() *RegionFlowComputationOptions_DownSampleSchedule {
	if m != nil {
		return m.DownsampleSchedule
	}
	return nil
}

func (m *RegionFlowComputationOptions) GetMinFeatureRequirement() int32 {
	if m != nil && m.MinFeatureRequirement != nil {
		return *m.MinFeatureRequirement
	}
	return Default_RegionFlowComputationOptions_MinFeatureRequirement
}

func (m *RegionFlowComputationOptions) GetMinFeatureCover() float32 {
	if m != nil && m.MinFeatureCover != nil {
		return *m.MinFeatureCover
	}
	return Default_RegionFlowComputationOptions_MinFeatureCover
}

func (m *RegionFlowComputationOptions) GetMinFeatureCoverGrid() int32 {
	if m != nil && m.MinFeatureCoverGrid != nil {
		return *m.MinFeatureCoverGrid
	}
	return Default_RegionFlowComputationOptions_MinFeatureCoverGrid
}

func (m *RegionFlowComputationOptions) GetComputeBlurScore() bool {
	if m != nil && m.ComputeBlurScore != nil {
		return *m.ComputeBlurScore
	}
	return Default_RegionFlowComputationOptions_ComputeBlurScore
}

func (m *RegionFlowComputationOptions) GetBlurScoreOptions() *RegionFlowComputationOptions_BlurScoreOptions {
	if m != nil {
		return m.BlurScoreOptions
	}
	return nil
}

func (m *RegionFlowComputationOptions) GetVisualConsistencyOptions() *RegionFlowComputationOptions_VisualConsistencyOptions {
	if m != nil {
		return m.VisualConsistencyOptions
	}
	return nil
}

func (m *RegionFlowComputationOptions) GetPatchDescriptorRadius() int32 {
	if m != nil && m.PatchDescriptorRadius != nil {
		return *m.PatchDescriptorRadius
	}
	return Default_RegionFlowComputationOptions_PatchDescriptorRadius
}

func (m *RegionFlowComputationOptions) GetDistanceFromBorder() int32 {
	if m != nil && m.DistanceFromBorder != nil {
		return *m.DistanceFromBorder
	}
	return Default_RegionFlowComputationOptions_DistanceFromBorder
}

func (m *RegionFlowComputationOptions) GetCornerResponseScale() float32 {
	if m != nil && m.CornerResponseScale != nil {
		return *m.CornerResponseScale
	}
	return Default_RegionFlowComputationOptions_CornerResponseScale
}

func (m *RegionFlowComputationOptions) GetVerifyFeatures() bool {
	if m != nil && m.VerifyFeatures != nil {
		return *m.VerifyFeatures
	}
	return Default_RegionFlowComputationOptions_VerifyFeatures
}

func (m *RegionFlowComputationOptions) GetVerificationDistance() float32 {
	if m != nil && m.VerificationDistance != nil {
		return *m.VerificationDistance
	}
	return Default_RegionFlowComputationOptions_VerificationDistance
}

func (m *RegionFlowComputationOptions) GetVerifyLongFeatures() bool {
	if m != nil && m.VerifyLongFeatures != nil {
		return *m.VerifyLongFeatures
	}
	return Default_RegionFlowComputationOptions_VerifyLongFeatures
}

func (m *RegionFlowComputationOptions) GetLongFeatureVerificationThreshold() float32 {
	if m != nil && m.LongFeatureVerificationThreshold != nil {
		return *m.LongFeatureVerificationThreshold
	}
	return Default_RegionFlowComputationOptions_LongFeatureVerificationThreshold
}

func (m *RegionFlowComputationOptions) GetMaxLongFeatureAcceleration() float32 {
	if m != nil && m.MaxLongFeatureAcceleration != nil {
		return *m.MaxLongFeatureAcceleration
	}
	return Default_RegionFlowComputationOptions_MaxLongFeatureAcceleration
}

func (m *RegionFlowComputationOptions) GetVerifyLongFeatureAcceleration() bool {
	if m != nil && m.VerifyLongFeatureAcceleration != nil {
		return *m.VerifyLongFeatureAcceleration
	}
	return Default_RegionFlowComputationOptions_VerifyLongFeatureAcceleration
}

func (m *RegionFlowComputationOptions) GetVerifyLongFeatureTriggerRatio() float32 {
	if m != nil && m.VerifyLongFeatureTriggerRatio != nil {
		return *m.VerifyLongFeatureTriggerRatio
	}
	return Default_RegionFlowComputationOptions_VerifyLongFeatureTriggerRatio
}

func (m *RegionFlowComputationOptions) GetHistogramEqualization() bool {
	if m != nil && m.HistogramEqualization != nil {
		return *m.HistogramEqualization
	}
	return Default_RegionFlowComputationOptions_HistogramEqualization
}

func (m *RegionFlowComputationOptions) GetUseSyntheticZeroMotionTracksAllFrames() bool {
	if m != nil && m.UseSyntheticZeroMotionTracksAllFrames != nil {
		return *m.UseSyntheticZeroMotionTracksAllFrames
	}
	return Default_RegionFlowComputationOptions_UseSyntheticZeroMotionTracksAllFrames
}

func (m *RegionFlowComputationOptions) GetUseSyntheticZeroMotionTracksFirstFrame() bool {
	if m != nil && m.UseSyntheticZeroMotionTracksFirstFrame != nil {
		return *m.UseSyntheticZeroMotionTracksFirstFrame
	}
	return Default_RegionFlowComputationOptions_UseSyntheticZeroMotionTracksFirstFrame
}

func (m *RegionFlowComputationOptions) GetGainCorrection() bool {
	if m != nil && m.GainCorrection != nil {
		return *m.GainCorrection
	}
	return Default_RegionFlowComputationOptions_GainCorrection
}

func (m *RegionFlowComputationOptions) GetFastGainCorrection() bool {
	if m != nil && m.FastGainCorrection != nil {
		return *m.FastGainCorrection
	}
	return Default_RegionFlowComputationOptions_FastGainCorrection
}

func (m *RegionFlowComputationOptions) GetGainCorrectionMultipleHypotheses() bool {
	if m != nil && m.GainCorrectionMultipleHypotheses != nil {
		return *m.GainCorrectionMultipleHypotheses
	}
	return Default_RegionFlowComputationOptions_GainCorrectionMultipleHypotheses
}

func (m *RegionFlowComputationOptions) GetGainCorrectionInlierImprovementFrac() float32 {
	if m != nil && m.GainCorrectionInlierImprovementFrac != nil {
		return *m.GainCorrectionInlierImprovementFrac
	}
	return Default_RegionFlowComputationOptions_GainCorrectionInlierImprovementFrac
}

func (m *RegionFlowComputationOptions) GetGainCorrectionBrightReference() bool {
	if m != nil && m.GainCorrectionBrightReference != nil {
		return *m.GainCorrectionBrightReference
	}
	return Default_RegionFlowComputationOptions_GainCorrectionBrightReference
}

func (m *RegionFlowComputationOptions) GetGainCorrectionTriggeringRatio() float32 {
	if m != nil && m.GainCorrectionTriggeringRatio != nil {
		return *m.GainCorrectionTriggeringRatio
	}
	return Default_RegionFlowComputationOptions_GainCorrectionTriggeringRatio
}

func (m *RegionFlowComputationOptions) GetFracGainFeatureSize() float32 {
	if m != nil && m.FracGainFeatureSize != nil {
		return *m.FracGainFeatureSize
	}
	return Default_RegionFlowComputationOptions_FracGainFeatureSize
}

func (m *RegionFlowComputationOptions) GetFracGainStep() float32 {
	if m != nil && m.FracGainStep != nil {
		return *m.FracGainStep
	}
	return Default_RegionFlowComputationOptions_FracGainStep
}

func (m *RegionFlowComputationOptions) GetGainCorrectMode() RegionFlowComputationOptions_GainCorrectMode {
	if m != nil && m.GainCorrectMode != nil {
		return *m.GainCorrectMode
	}
	return Default_RegionFlowComputationOptions_GainCorrectMode
}

func (m *RegionFlowComputationOptions) GetGainBiasBounds() *ToneEstimationOptions_GainBiasBounds {
	if m != nil {
		return m.GainBiasBounds
	}
	return nil
}

func (m *RegionFlowComputationOptions) GetImageFormat() RegionFlowComputationOptions_ImageFormat {
	if m != nil && m.ImageFormat != nil {
		return *m.ImageFormat
	}
	return Default_RegionFlowComputationOptions_ImageFormat
}

func (m *RegionFlowComputationOptions) GetDescriptorExtractorType() RegionFlowComputationOptions_DescriptorExtractorType {
	if m != nil && m.DescriptorExtractorType != nil {
		return *m.DescriptorExtractorType
	}
	return Default_RegionFlowComputationOptions_DescriptorExtractorType
}

func (m *RegionFlowComputationOptions) GetComputeDerivativeInPyramid() bool {
	if m != nil && m.ComputeDerivativeInPyramid != nil {
		return *m.ComputeDerivativeInPyramid
	}
	return Default_RegionFlowComputationOptions_ComputeDerivativeInPyramid
}

type RegionFlowComputationOptions_DownSampleSchedule struct {
	DownsampleFactor_360P  *float32 `protobuf:"fixed32,1,opt,name=downsample_factor_360p,json=downsampleFactor360p,def=1" json:"downsample_factor_360p,omitempty"`
	DownsampleFactor_480P  *float32 `protobuf:"fixed32,2,opt,name=downsample_factor_480p,json=downsampleFactor480p,def=1" json:"downsample_factor_480p,omitempty"`
	DownsampleFactor_720P  *float32 `protobuf:"fixed32,3,opt,name=downsample_factor_720p,json=downsampleFactor720p,def=2" json:"downsample_factor_720p,omitempty"`
	DownsampleFactor_1080P *float32 `protobuf:"fixed32,4,opt,name=downsample_factor_1080p,json=downsampleFactor1080p,def=2" json:"downsample_factor_1080p,omitempty"`
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) Reset() {
	*m = RegionFlowComputationOptions_DownSampleSchedule{}
}
func (*RegionFlowComputationOptions_DownSampleSchedule) ProtoMessage() {}
func (*RegionFlowComputationOptions_DownSampleSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 0}
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionFlowComputationOptions_DownSampleSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionFlowComputationOptions_DownSampleSchedule.Merge(m, src)
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) XXX_Size() int {
	return m.Size()
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionFlowComputationOptions_DownSampleSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_RegionFlowComputationOptions_DownSampleSchedule proto.InternalMessageInfo

const Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_360P float32 = 1
const Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_480P float32 = 1
const Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_720P float32 = 2
const Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_1080P float32 = 2

func (m *RegionFlowComputationOptions_DownSampleSchedule) GetDownsampleFactor_360P() float32 {
	if m != nil && m.DownsampleFactor_360P != nil {
		return *m.DownsampleFactor_360P
	}
	return Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_360P
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) GetDownsampleFactor_480P() float32 {
	if m != nil && m.DownsampleFactor_480P != nil {
		return *m.DownsampleFactor_480P
	}
	return Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_480P
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) GetDownsampleFactor_720P() float32 {
	if m != nil && m.DownsampleFactor_720P != nil {
		return *m.DownsampleFactor_720P
	}
	return Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_720P
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) GetDownsampleFactor_1080P() float32 {
	if m != nil && m.DownsampleFactor_1080P != nil {
		return *m.DownsampleFactor_1080P
	}
	return Default_RegionFlowComputationOptions_DownSampleSchedule_DownsampleFactor_1080P
}

type RegionFlowComputationOptions_BlurScoreOptions struct {
	BoxFilterDiam               *int32   `protobuf:"varint,1,opt,name=box_filter_diam,json=boxFilterDiam,def=3" json:"box_filter_diam,omitempty"`
	RelativeCornernessThreshold *float32 `protobuf:"fixed32,2,opt,name=relative_cornerness_threshold,json=relativeCornernessThreshold,def=0.03" json:"relative_cornerness_threshold,omitempty"`
	AbsoluteCornernessThreshold *float32 `protobuf:"fixed32,3,opt,name=absolute_cornerness_threshold,json=absoluteCornernessThreshold,def=0.0001" json:"absolute_cornerness_threshold,omitempty"`
	MedianPercentile            *float32 `protobuf:"fixed32,5,opt,name=median_percentile,json=medianPercentile,def=0.85" json:"median_percentile,omitempty"`
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) Reset() {
	*m = RegionFlowComputationOptions_BlurScoreOptions{}
}
func (*RegionFlowComputationOptions_BlurScoreOptions) ProtoMessage() {}
func (*RegionFlowComputationOptions_BlurScoreOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 1}
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionFlowComputationOptions_BlurScoreOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionFlowComputationOptions_BlurScoreOptions.Merge(m, src)
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) XXX_Size() int {
	return m.Size()
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionFlowComputationOptions_BlurScoreOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RegionFlowComputationOptions_BlurScoreOptions proto.InternalMessageInfo

const Default_RegionFlowComputationOptions_BlurScoreOptions_BoxFilterDiam int32 = 3
const Default_RegionFlowComputationOptions_BlurScoreOptions_RelativeCornernessThreshold float32 = 0.03
const Default_RegionFlowComputationOptions_BlurScoreOptions_AbsoluteCornernessThreshold float32 = 0.0001
const Default_RegionFlowComputationOptions_BlurScoreOptions_MedianPercentile float32 = 0.85

func (m *RegionFlowComputationOptions_BlurScoreOptions) GetBoxFilterDiam() int32 {
	if m != nil && m.BoxFilterDiam != nil {
		return *m.BoxFilterDiam
	}
	return Default_RegionFlowComputationOptions_BlurScoreOptions_BoxFilterDiam
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) GetRelativeCornernessThreshold() float32 {
	if m != nil && m.RelativeCornernessThreshold != nil {
		return *m.RelativeCornernessThreshold
	}
	return Default_RegionFlowComputationOptions_BlurScoreOptions_RelativeCornernessThreshold
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) GetAbsoluteCornernessThreshold() float32 {
	if m != nil && m.AbsoluteCornernessThreshold != nil {
		return *m.AbsoluteCornernessThreshold
	}
	return Default_RegionFlowComputationOptions_BlurScoreOptions_AbsoluteCornernessThreshold
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) GetMedianPercentile() float32 {
	if m != nil && m.MedianPercentile != nil {
		return *m.MedianPercentile
	}
	return Default_RegionFlowComputationOptions_BlurScoreOptions_MedianPercentile
}

type RegionFlowComputationOptions_VisualConsistencyOptions struct {
	ComputeConsistency *bool  `protobuf:"varint,1,opt,name=compute_consistency,json=computeConsistency,def=1" json:"compute_consistency,omitempty"`
	TinyImageDimension *int32 `protobuf:"varint,2,opt,name=tiny_image_dimension,json=tinyImageDimension,def=20" json:"tiny_image_dimension,omitempty"`
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) Reset() {
	*m = RegionFlowComputationOptions_VisualConsistencyOptions{}
}
func (*RegionFlowComputationOptions_VisualConsistencyOptions) ProtoMessage() {}
func (*RegionFlowComputationOptions_VisualConsistencyOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9059f4218cd68dd5, []int{1, 2}
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionFlowComputationOptions_VisualConsistencyOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionFlowComputationOptions_VisualConsistencyOptions.Merge(m, src)
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) XXX_Size() int {
	return m.Size()
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionFlowComputationOptions_VisualConsistencyOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RegionFlowComputationOptions_VisualConsistencyOptions proto.InternalMessageInfo

const Default_RegionFlowComputationOptions_VisualConsistencyOptions_ComputeConsistency bool = true
const Default_RegionFlowComputationOptions_VisualConsistencyOptions_TinyImageDimension int32 = 20

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) GetComputeConsistency() bool {
	if m != nil && m.ComputeConsistency != nil {
		return *m.ComputeConsistency
	}
	return Default_RegionFlowComputationOptions_VisualConsistencyOptions_ComputeConsistency
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) GetTinyImageDimension() int32 {
	if m != nil && m.TinyImageDimension != nil {
		return *m.TinyImageDimension
	}
	return Default_RegionFlowComputationOptions_VisualConsistencyOptions_TinyImageDimension
}

func init() {
	proto.RegisterEnum("mediapipe.TrackingOptions_FlowDirection", TrackingOptions_FlowDirection_name, TrackingOptions_FlowDirection_value)
	proto.RegisterEnum("mediapipe.TrackingOptions_TrackingPolicy", TrackingOptions_TrackingPolicy_name, TrackingOptions_TrackingPolicy_value)
	proto.RegisterEnum("mediapipe.TrackingOptions_CornerExtractionMethod", TrackingOptions_CornerExtractionMethod_name, TrackingOptions_CornerExtractionMethod_value)
	proto.RegisterEnum("mediapipe.TrackingOptions_KltTrackerImplementation", TrackingOptions_KltTrackerImplementation_name, TrackingOptions_KltTrackerImplementation_value)
	proto.RegisterEnum("mediapipe.RegionFlowComputationOptions_IrlsInitialization", RegionFlowComputationOptions_IrlsInitialization_name, RegionFlowComputationOptions_IrlsInitialization_value)
	proto.RegisterEnum("mediapipe.RegionFlowComputationOptions_DownsampleMode", RegionFlowComputationOptions_DownsampleMode_name, RegionFlowComputationOptions_DownsampleMode_value)
	proto.RegisterEnum("mediapipe.RegionFlowComputationOptions_GainCorrectMode", RegionFlowComputationOptions_GainCorrectMode_name, RegionFlowComputationOptions_GainCorrectMode_value)
	proto.RegisterEnum("mediapipe.RegionFlowComputationOptions_ImageFormat", RegionFlowComputationOptions_ImageFormat_name, RegionFlowComputationOptions_ImageFormat_value)
	proto.RegisterEnum("mediapipe.RegionFlowComputationOptions_DescriptorExtractorType", RegionFlowComputationOptions_DescriptorExtractorType_name, RegionFlowComputationOptions_DescriptorExtractorType_value)
	proto.RegisterType((*TrackingOptions)(nil), "mediapipe.TrackingOptions")
	proto.RegisterType((*TrackingOptions_MinEigValExtractionSettings)(nil), "mediapipe.TrackingOptions.MinEigValExtractionSettings")
	proto.RegisterType((*TrackingOptions_HarrisExtractionSettings)(nil), "mediapipe.TrackingOptions.HarrisExtractionSettings")
	proto.RegisterType((*TrackingOptions_FastExtractionSettings)(nil), "mediapipe.TrackingOptions.FastExtractionSettings")
	proto.RegisterType((*RegionFlowComputationOptions)(nil), "mediapipe.RegionFlowComputationOptions")
	proto.RegisterType((*RegionFlowComputationOptions_DownSampleSchedule)(nil), "mediapipe.RegionFlowComputationOptions.DownSampleSchedule")
	proto.RegisterType((*RegionFlowComputationOptions_BlurScoreOptions)(nil), "mediapipe.RegionFlowComputationOptions.BlurScoreOptions")
	proto.RegisterType((*RegionFlowComputationOptions_VisualConsistencyOptions)(nil), "mediapipe.RegionFlowComputationOptions.VisualConsistencyOptions")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/region_flow_computation.proto", fileDescriptor_9059f4218cd68dd5)
}

var fileDescriptor_9059f4218cd68dd5 = []byte{
	// 3328 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0xcd, 0x53, 0x1b, 0x49,
	0x96, 0xa7, 0x84, 0xe8, 0x96, 0x13, 0x0c, 0xe5, 0xe4, 0xab, 0x10, 0x20, 0xd3, 0x72, 0x8f, 0x1b,
	0xab, 0xbb, 0xb1, 0x00, 0x83, 0x19, 0xb9, 0x67, 0xbb, 0xf5, 0x09, 0x32, 0x48, 0x62, 0x53, 0x02,
	0x0f, 0x1d, 0x1b, 0x91, 0x51, 0x48, 0x89, 0xc8, 0x70, 0xa9, 0x4a, 0xce, 0x2a, 0x61, 0x70, 0xcc,
	0x4c, 0xcc, 0xc6, 0x46, 0xcc, 0x5e, 0xf7, 0x1f, 0xd8, 0xc3, 0x9e, 0x76, 0xff, 0x87, 0xfd, 0x07,
	0xf6, 0xd8, 0xc7, 0x39, 0x6e, 0xbb, 0x2f, 0x7b, 0x9c, 0xf3, 0x9e, 0x36, 0x32, 0xb3, 0xbe, 0xf4,
	0x45, 0xfb, 0xb0, 0x47, 0xea, 0xfd, 0xde, 0xef, 0x55, 0x65, 0xbe, 0x7c, 0xef, 0xf7, 0x52, 0x80,
	0xbd, 0x0e, 0x69, 0x51, 0xbd, 0x4b, 0xbb, 0xe4, 0x79, 0xcf, 0xa1, 0xc6, 0x73, 0x87, 0xe9, 0xcd,
	0xb7, 0xd4, 0x6c, 0x3f, 0x67, 0xa4, 0x4d, 0x2d, 0x13, 0x5f, 0x19, 0xd6, 0x7b, 0xdc, 0xb4, 0x3a,
	0xdd, 0x9e, 0xa3, 0x3b, 0xd4, 0x32, 0xb7, 0xba, 0xcc, 0x72, 0x2c, 0xf8, 0xc0, 0x77, 0x8b, 0x7f,
	0x3b, 0x8e, 0xc1, 0xb1, 0x4c, 0x82, 0x89, 0xed, 0xd0, 0x4e, 0xc8, 0x33, 0xf9, 0xef, 0xcb, 0x60,
	0xae, 0xe1, 0x42, 0x6a, 0x5d, 0x6e, 0xb0, 0xe1, 0x3f, 0x2a, 0x60, 0x95, 0x9a, 0x0e, 0x61, 0xa6,
	0x6e, 0x60, 0xcf, 0x1f, 0xb7, 0x28, 0x23, 0x4d, 0x0e, 0xd0, 0xe6, 0x37, 0x94, 0xcd, 0xd9, 0x9d,
	0xcd, 0x2d, 0x3f, 0xd2, 0xd6, 0x00, 0xc3, 0x56, 0xc9, 0xb0, 0xde, 0x17, 0x3c, 0x7c, 0x66, 0xb9,
	0x74, 0x52, 0x7b, 0x83, 0x0b, 0x65, 0x54, 0xcc, 0x37, 0xca, 0xb5, 0x2a, 0xce, 0x65, 0xf3, 0xc7,
	0x6f, 0xb2, 0xa8, 0x80, 0x56, 0xbc, 0x28, 0x9e, 0xbf, 0xef, 0x03, 0x7b, 0x60, 0xd1, 0xea, 0x39,
	0xdd, 0x9e, 0x23, 0x3f, 0x39, 0x08, 0xbe, 0xf0, 0xff, 0x15, 0x7c, 0x5e, 0xf2, 0xf7, 0xa1, 0x61,
	0x1b, 0xcc, 0xf9, 0x1f, 0xdc, 0xb5, 0x0c, 0xda, 0xbc, 0xd3, 0x56, 0x44, 0xc0, 0x67, 0xf7, 0x04,
	0xf4, 0xfe, 0x3e, 0x15, 0x0e, 0x99, 0xf9, 0xd3, 0xda, 0x49, 0x39, 0x7f, 0x81, 0xeb, 0xe5, 0xea,
	0xe1, 0x49, 0x11, 0x97, 0x50, 0xb6, 0x52, 0x44, 0xb3, 0x4e, 0x1f, 0x08, 0xbe, 0x00, 0x8b, 0x9d,
	0x9e, 0xe1, 0x50, 0x7c, 0xc5, 0xf4, 0x0e, 0xb1, 0xb1, 0x63, 0xc9, 0x95, 0xd6, 0x94, 0x0d, 0x65,
	0x73, 0x2a, 0xa3, 0x6c, 0x23, 0x28, 0xec, 0x25, 0x61, 0x6e, 0x58, 0x22, 0x06, 0x3c, 0x00, 0x4b,
	0x86, 0x65, 0xb6, 0x25, 0xd4, 0xc6, 0x1d, 0xfd, 0xd6, 0xf5, 0xd7, 0xe2, 0xc2, 0x6d, 0x72, 0x37,
	0x9d, 0x46, 0xf3, 0x1c, 0x22, 0xf0, 0x76, 0x45, 0xbf, 0x95, 0x04, 0xf0, 0x2b, 0x30, 0x23, 0xd0,
	0x44, 0x77, 0x7a, 0x8c, 0xd8, 0x5a, 0x44, 0xe0, 0xa3, 0x3b, 0xe9, 0x74, 0x1a, 0x4d, 0x77, 0xf4,
	0xdb, 0x92, 0x6b, 0x80, 0xff, 0xa4, 0x00, 0xad, 0x69, 0x31, 0x93, 0x30, 0x4c, 0x6e, 0x79, 0x1c,
	0xfe, 0x8d, 0xb8, 0x43, 0x9c, 0x6b, 0xab, 0xa5, 0xad, 0x8a, 0xb5, 0xd8, 0xbe, 0x67, 0x2d, 0xf2,
	0xc2, 0xb5, 0xe8, 0x7b, 0x56, 0x84, 0x63, 0x66, 0xa9, 0xf8, 0xfb, 0x06, 0xca, 0xca, 0x1d, 0xa8,
	0x94, 0xab, 0xb8, 0x58, 0x3e, 0xc4, 0xe7, 0xd9, 0x13, 0xb4, 0xd4, 0x1c, 0x89, 0x87, 0x6d, 0xb0,
	0xd0, 0xa1, 0x26, 0x26, 0xb4, 0x8d, 0x6f, 0x74, 0x03, 0xdb, 0xc4, 0x71, 0xa8, 0xd9, 0xb6, 0xb5,
	0xb5, 0x0d, 0x65, 0x73, 0x7a, 0x67, 0xff, 0x9e, 0x17, 0xa8, 0x50, 0xb3, 0x48, 0xdb, 0xe7, 0xba,
	0x11, 0x70, 0xd6, 0x5d, 0x6f, 0xf4, 0xa8, 0xe3, 0x19, 0xbd, 0x47, 0xf0, 0x1f, 0xc0, 0xdc, 0xb5,
	0xce, 0x18, 0xb5, 0x83, 0x18, 0xeb, 0x22, 0xc6, 0xee, 0x3d, 0x31, 0x8e, 0x84, 0xc7, 0x88, 0x00,
	0xb3, 0x92, 0xcb, 0x67, 0x3f, 0x07, 0x0f, 0xaf, 0x74, 0xdb, 0x09, 0xb8, 0x1f, 0x0b, 0xee, 0xfb,
	0x16, 0xb0, 0xa4, 0xdb, 0xce, 0x08, 0xe6, 0x19, 0xce, 0xe3, 0xf3, 0xbe, 0x00, 0x0b, 0x7e, 0x9a,
	0xbe, 0xa7, 0x66, 0xcb, 0x7a, 0x8f, 0x6d, 0xfa, 0x81, 0x68, 0x51, 0xb1, 0xab, 0x91, 0xed, 0x34,
	0x82, 0x9e, 0xfd, 0x8d, 0x30, 0xd7, 0xe9, 0x07, 0x02, 0x77, 0xc1, 0xbc, 0xef, 0x45, 0x1d, 0xc2,
	0x44, 0x1d, 0xb0, 0xb5, 0xa9, 0x61, 0xa7, 0xb2, 0x6f, 0x85, 0x25, 0xb0, 0x76, 0xe5, 0xbe, 0x4c,
	0x7f, 0x35, 0xb0, 0x1d, 0xdd, 0x6c, 0x12, 0xed, 0xb3, 0x0d, 0x65, 0x33, 0x92, 0x89, 0xa6, 0xb7,
	0xb6, 0xf7, 0x50, 0x3c, 0x40, 0x06, 0x27, 0x5a, 0xe2, 0x60, 0x1e, 0xc4, 0xf5, 0x96, 0xde, 0x75,
	0xe8, 0x0d, 0x19, 0xc1, 0xa2, 0x6d, 0x28, 0x9b, 0xb1, 0xcc, 0xd4, 0x95, 0x6e, 0xd8, 0x04, 0x69,
	0x1e, 0x70, 0x88, 0x64, 0x57, 0xa6, 0x85, 0x9b, 0xc5, 0x81, 0xfb, 0xe7, 0xe2, 0x25, 0x94, 0x97,
	0x08, 0x76, 0xa8, 0xe9, 0xa6, 0xb2, 0xef, 0xf4, 0x1d, 0x58, 0xf6, 0x80, 0xb8, 0x65, 0xbd, 0x37,
	0xed, 0xa6, 0x6e, 0x10, 0x6c, 0xbf, 0x63, 0x8e, 0xb6, 0x28, 0xc2, 0x46, 0x1d, 0xd6, 0x23, 0x68,
	0xd1, 0x03, 0x15, 0x3c, 0x4c, 0xfd, 0x1d, 0x73, 0xe0, 0x6b, 0xf0, 0xd8, 0x7f, 0xef, 0xb6, 0x65,
	0xb5, 0xfc, 0x23, 0x14, 0x1c, 0xd9, 0x58, 0x88, 0x65, 0xd5, 0x03, 0x1f, 0x5a, 0x56, 0xcb, 0x3b,
	0x54, 0xde, 0xf1, 0x2d, 0x82, 0x35, 0x9f, 0xcb, 0xa7, 0xb9, 0x34, 0xac, 0xe6, 0x5b, 0xb9, 0x7d,
	0x0f, 0xbc, 0xb5, 0xdc, 0xd9, 0x47, 0x2b, 0x1e, 0xd2, 0x23, 0xc9, 0x71, 0x9c, 0xd8, 0xc7, 0x57,
	0x40, 0x1b, 0xa6, 0x31, 0xc8, 0x0d, 0x31, 0x6c, 0x0d, 0x78, 0xe5, 0x63, 0x69, 0xd0, 0xff, 0x44,
	0x00, 0xe0, 0xf7, 0xa1, 0x7d, 0x08, 0x1d, 0x70, 0xd7, 0x7d, 0xc9, 0x73, 0xf7, 0x23, 0x04, 0xb9,
	0xe8, 0x12, 0x9c, 0x81, 0xa7, 0xe3, 0x09, 0xb0, 0x61, 0xbd, 0x27, 0x3c, 0xe1, 0xf9, 0xe7, 0x2c,
	0x4b, 0xb2, 0x34, 0x4a, 0x8e, 0x23, 0x3b, 0x11, 0x68, 0xf1, 0x51, 0xaf, 0xc1, 0x63, 0xfb, 0xce,
	0x74, 0xae, 0x89, 0x43, 0x9b, 0xf8, 0x03, 0x61, 0x16, 0xee, 0x58, 0x82, 0xb8, 0xcd, 0x68, 0x0b,
	0xdb, 0x0e, 0xe9, 0x6a, 0x0f, 0xbd, 0xe5, 0x49, 0xbf, 0x40, 0xab, 0x3e, 0xf8, 0x47, 0xc2, 0xac,
	0x8a, 0x80, 0x1e, 0x32, 0xda, 0xaa, 0x3b, 0xa4, 0x0b, 0x5f, 0x81, 0xa5, 0xf7, 0xb4, 0x45, 0xf0,
	0xa5, 0x6e, 0x13, 0x83, 0x9a, 0x04, 0x77, 0x74, 0xa7, 0x79, 0x4d, 0xcd, 0xb6, 0x36, 0x1b, 0xce,
	0xb3, 0x05, 0x0e, 0xca, 0xb9, 0x98, 0x8a, 0x0b, 0x81, 0x7b, 0x60, 0x41, 0xe4, 0x3e, 0x76, 0xf8,
	0x87, 0x38, 0xd7, 0x8c, 0xd8, 0xd7, 0x96, 0xd1, 0xd2, 0xe6, 0x44, 0xf4, 0xc9, 0xf4, 0xd6, 0x01,
	0x82, 0x02, 0xd0, 0x20, 0xb6, 0xd3, 0xf0, 0xcc, 0xfc, 0x9c, 0x30, 0x72, 0xc5, 0x83, 0x8d, 0x08,
	0x4d, 0x6c, 0x4d, 0x0d, 0x47, 0x5e, 0x91, 0xd0, 0x37, 0x83, 0xf1, 0x89, 0x0d, 0x8f, 0xc1, 0x17,
	0x8c, 0xf4, 0xec, 0xd0, 0xce, 0xfa, 0x55, 0x3e, 0xc8, 0xf7, 0x47, 0xde, 0xca, 0xae, 0x0b, 0xac,
	0xb7, 0xc5, 0x5e, 0xb9, 0xf7, 0x53, 0xff, 0x18, 0x6c, 0x0c, 0x92, 0x51, 0x13, 0xdb, 0x3d, 0x76,
	0x43, 0x6f, 0x48, 0x8b, 0xb3, 0x36, 0x35, 0xe8, 0x7d, 0xd7, 0x4b, 0xb4, 0xd6, 0xcf, 0x46, 0xcd,
	0xba, 0x8b, 0x2c, 0x31, 0xbd, 0x09, 0xff, 0x08, 0xe2, 0x6f, 0x0d, 0x47, 0xe6, 0x3c, 0x61, 0x98,
	0x76, 0xba, 0x06, 0xe9, 0x10, 0x53, 0x0a, 0x11, 0x6d, 0x43, 0xb4, 0x86, 0xfb, 0xaa, 0xe6, 0xb1,
	0xe1, 0x34, 0xa4, 0x6f, 0xb9, 0xcf, 0x35, 0x03, 0x8e, 0x4f, 0x1a, 0xb8, 0x76, 0x5a, 0xac, 0xe6,
	0xcf, 0x91, 0xf6, 0x76, 0x0c, 0x2a, 0xfe, 0x6f, 0x0a, 0x58, 0xbd, 0xa7, 0xb8, 0xc3, 0x03, 0xb0,
	0xe8, 0xd5, 0x85, 0x77, 0x3d, 0xdd, 0xa0, 0xce, 0x9d, 0xcc, 0x49, 0xd1, 0x51, 0x65, 0xda, 0x6c,
	0xa3, 0x79, 0x17, 0xf2, 0xf7, 0x12, 0x21, 0xb2, 0x10, 0x1e, 0x81, 0x75, 0x3f, 0xa3, 0xdd, 0xfc,
	0xed, 0x67, 0x88, 0x08, 0x86, 0xa9, 0x03, 0xf2, 0x6d, 0x7a, 0x0f, 0xf9, 0xc7, 0x47, 0x26, 0x6f,
	0x98, 0x29, 0xfe, 0x06, 0x68, 0xe3, 0x7a, 0x03, 0x7c, 0x75, 0xff, 0xfb, 0x7d, 0x9e, 0xde, 0x4a,
	0xa7, 0xd3, 0x3b, 0x7b, 0x23, 0x5f, 0x31, 0x9e, 0x01, 0x4b, 0xa3, 0x1b, 0x03, 0xdc, 0x00, 0x0f,
	0x82, 0x1c, 0x55, 0xfc, 0x52, 0x1e, 0x3c, 0x4c, 0xfe, 0x45, 0x01, 0x0f, 0xfb, 0x55, 0x4e, 0x1c,
	0x2c, 0x0d, 0xa8, 0xa2, 0xb3, 0xea, 0x71, 0xb5, 0xf6, 0xa6, 0xaa, 0x4e, 0x8c, 0xb0, 0x95, 0x6a,
	0x88, 0x0b, 0x26, 0x55, 0x81, 0xab, 0x60, 0x9c, 0x9a, 0x52, 0x23, 0x70, 0x03, 0xac, 0x0d, 0x18,
	0xf3, 0xb5, 0x6a, 0xbd, 0x98, 0x3f, 0x6b, 0x94, 0xcf, 0x8b, 0x27, 0x17, 0xea, 0x64, 0xb2, 0x03,
	0x66, 0xfb, 0xa5, 0x12, 0x84, 0x60, 0xd6, 0x15, 0x4b, 0xc1, 0x0b, 0x2c, 0x83, 0x51, 0x02, 0x4a,
	0x55, 0xe0, 0x12, 0x80, 0xae, 0xa1, 0x72, 0x76, 0xd2, 0x28, 0xbb, 0xcf, 0x23, 0xa1, 0xe7, 0x27,
	0xb5, 0xea, 0x21, 0xe6, 0x3a, 0xe3, 0xb8, 0xae, 0x4e, 0x26, 0x6f, 0xc1, 0xd2, 0x68, 0x35, 0xc2,
	0x3d, 0x42, 0x7a, 0x24, 0x08, 0xbd, 0x08, 0x1e, 0x85, 0x9e, 0x1f, 0x65, 0x11, 0x2a, 0xd7, 0x55,
	0x85, 0x2f, 0xc9, 0x68, 0xf9, 0xa2, 0x46, 0xe0, 0x3c, 0x98, 0x0b, 0xd9, 0x4a, 0xd9, 0x7a, 0x43,
	0x9d, 0x4c, 0xbe, 0x02, 0xda, 0xb8, 0x64, 0x87, 0x73, 0x60, 0xfa, 0xac, 0x5a, 0x3f, 0x2d, 0xe6,
	0xcb, 0xa5, 0x72, 0xb1, 0xa0, 0x4e, 0xc0, 0x59, 0x10, 0xca, 0x7f, 0x55, 0x49, 0x45, 0x63, 0x93,
	0x6a, 0x34, 0x15, 0x8d, 0x4d, 0xab, 0x33, 0xa9, 0x68, 0x6c, 0x46, 0x7d, 0x98, 0x8a, 0xc6, 0x12,
	0xea, 0xe3, 0xe4, 0x7f, 0x3e, 0x03, 0x6b, 0x48, 0x4c, 0x01, 0x7c, 0x33, 0xf3, 0xc1, 0x0c, 0xe0,
	0xc9, 0xf6, 0x22, 0x50, 0xfd, 0xc6, 0x6a, 0xc9, 0x67, 0x22, 0x21, 0xa6, 0x77, 0xe2, 0xe3, 0x4f,
	0x25, 0xf2, 0xf5, 0xae, 0x47, 0xb3, 0x0d, 0xe6, 0xc3, 0x3d, 0x96, 0x9a, 0x06, 0x25, 0xcc, 0x13,
	0x8c, 0xca, 0xae, 0x10, 0x51, 0x6e, 0x89, 0x28, 0x4b, 0x1b, 0x2c, 0xf0, 0xda, 0x67, 0xe8, 0xe2,
	0x00, 0x8d, 0xf2, 0xdd, 0xf2, 0x4a, 0xcc, 0x0e, 0xaf, 0x7c, 0x12, 0x58, 0x19, 0x62, 0x79, 0x06,
	0x66, 0xbb, 0x8c, 0xe0, 0x4b, 0xa3, 0xc7, 0xb0, 0x4d, 0xdb, 0x1d, 0x5d, 0xfb, 0x22, 0x28, 0xb9,
	0x33, 0x5d, 0x46, 0x72, 0x46, 0x8f, 0xd5, 0xb9, 0x81, 0x77, 0x40, 0xa6, 0x9b, 0xb6, 0xde, 0xc4,
	0xcc, 0xea, 0x99, 0x2d, 0x1b, 0x77, 0x09, 0xc3, 0x72, 0x44, 0xd2, 0x26, 0xdd, 0x33, 0xb0, 0x87,
	0x16, 0x25, 0x06, 0x09, 0xc8, 0x29, 0x61, 0x72, 0xf5, 0xe0, 0x11, 0x78, 0xac, 0x5f, 0xda, 0x96,
	0xd1, 0x73, 0xbc, 0x37, 0xc4, 0x84, 0x31, 0x8b, 0x85, 0x6a, 0x7d, 0x54, 0xea, 0x89, 0x1d, 0xb4,
	0xe6, 0x21, 0xe5, 0x4b, 0x16, 0x39, 0x2e, 0xa8, 0xf9, 0x3f, 0x80, 0x55, 0x5e, 0x42, 0xc7, 0xb1,
	0xbc, 0x90, 0x2c, 0x69, 0xa4, 0x71, 0xd4, 0x48, 0x86, 0xd7, 0xe0, 0xb1, 0xbf, 0x72, 0x63, 0x58,
	0xbe, 0xf1, 0x16, 0x61, 0x1b, 0xf9, 0xab, 0x3c, 0x92, 0xeb, 0x19, 0x98, 0x73, 0xac, 0xae, 0x47,
	0x63, 0x13, 0xc7, 0xd6, 0xbe, 0x95, 0x9b, 0xb6, 0x83, 0x1e, 0x3a, 0x56, 0x57, 0x3a, 0xd5, 0x89,
	0x63, 0xc3, 0x5d, 0x00, 0x4d, 0x2b, 0x34, 0x0c, 0xe2, 0x8e, 0xd5, 0x22, 0xda, 0x66, 0xb8, 0x45,
	0xa9, 0xa6, 0x55, 0xf4, 0xed, 0x15, 0xab, 0x45, 0x60, 0x16, 0xc4, 0x85, 0x98, 0x0d, 0xb9, 0x85,
	0xb4, 0x8b, 0xaf, 0x03, 0x77, 0xf6, 0xd0, 0x32, 0xc7, 0x05, 0xde, 0x81, 0x72, 0x39, 0x04, 0x89,
	0x41, 0x0a, 0x9e, 0x2f, 0x21, 0x9a, 0x15, 0x39, 0xc7, 0x6c, 0xa7, 0xd3, 0x28, 0xde, 0xcf, 0x52,
	0xa1, 0x21, 0xa2, 0x02, 0x58, 0x1f, 0x24, 0xb2, 0x6e, 0x08, 0x33, 0xf4, 0xae, 0xd0, 0x0b, 0xbe,
	0x90, 0xd9, 0x1d, 0x64, 0xa9, 0x49, 0x14, 0x97, 0x0a, 0x5c, 0xdb, 0xae, 0xf3, 0xe6, 0xda, 0xd1,
	0xdb, 0x26, 0x75, 0x7a, 0x2d, 0x12, 0xac, 0x3a, 0x16, 0x1d, 0x5e, 0x28, 0x18, 0x37, 0x71, 0xe3,
	0x1d, 0xfd, 0xb6, 0xe2, 0x01, 0xfd, 0x45, 0x47, 0x1c, 0x06, 0x7f, 0x0b, 0x96, 0xc5, 0x01, 0x33,
	0x43, 0x54, 0x97, 0x22, 0xeb, 0xb4, 0x5d, 0x2f, 0x07, 0x16, 0x25, 0xc2, 0xa7, 0xc8, 0x09, 0x3b,
	0xfc, 0x23, 0x98, 0xa7, 0xcc, 0xb0, 0x31, 0x35, 0xa9, 0x43, 0x75, 0x83, 0x7e, 0x90, 0xdd, 0x74,
	0x5b, 0x74, 0xd3, 0x4c, 0xe8, 0xdc, 0xde, 0x77, 0xf4, 0xb7, 0xca, 0xcc, 0xb0, 0xcb, 0x7d, 0x0c,
	0x19, 0xb5, 0x5c, 0x2d, 0x37, 0x44, 0x09, 0x2e, 0xd7, 0x1b, 0xc5, 0x6a, 0xfe, 0x02, 0x41, 0x3a,
	0x84, 0x82, 0x7f, 0x00, 0x73, 0x42, 0x12, 0xeb, 0xbc, 0x48, 0xc9, 0x2c, 0x98, 0x16, 0xa1, 0xf7,
	0x3f, 0x35, 0x74, 0xc1, 0x77, 0xe7, 0x49, 0x92, 0x59, 0x45, 0xc5, 0x43, 0x51, 0x09, 0x45, 0x2b,
	0xa8, 0xbd, 0xa9, 0xd6, 0xb3, 0x95, 0xd3, 0x93, 0x22, 0xae, 0xd6, 0xaa, 0x45, 0x34, 0xdb, 0xea,
	0x03, 0xc3, 0x34, 0x78, 0xe4, 0x3f, 0xe1, 0x55, 0x4b, 0x64, 0xc0, 0x8c, 0xcc, 0x80, 0x9d, 0xbd,
	0x7d, 0xa4, 0x86, 0xad, 0x62, 0xdf, 0xb7, 0x42, 0x1e, 0x04, 0x5f, 0xe9, 0x4d, 0xc7, 0x62, 0xae,
	0x82, 0x51, 0x76, 0x42, 0x78, 0x52, 0x12, 0x26, 0xf8, 0x3b, 0xb0, 0x2c, 0x2a, 0x04, 0x1e, 0xf6,
	0xfa, 0xbb, 0x70, 0xb6, 0x2f, 0x0a, 0x54, 0x61, 0xd0, 0xfd, 0x2d, 0x98, 0x0f, 0x39, 0xda, 0xcd,
	0x6b, 0xd2, 0xea, 0x19, 0x44, 0x5c, 0x80, 0x4c, 0x7f, 0xfa, 0xee, 0x70, 0xda, 0xba, 0xa0, 0xa8,
	0xbb, 0x0c, 0x08, 0x06, 0xb4, 0xde, 0x33, 0x98, 0x01, 0xcb, 0xe1, 0xe2, 0xc9, 0xc8, 0xbb, 0x1e,
	0x65, 0xa2, 0x73, 0x08, 0xe5, 0x3b, 0x95, 0x89, 0xec, 0xf0, 0x34, 0xf2, 0xeb, 0x26, 0x0a, 0x00,
	0x7c, 0x25, 0xc3, 0xbe, 0x4d, 0x7e, 0x18, 0x84, 0xd8, 0xf5, 0x46, 0xb3, 0xb9, 0xc0, 0x2f, 0xcf,
	0x8d, 0x70, 0x1f, 0x2c, 0x0d, 0x79, 0x88, 0xb3, 0x23, 0x6e, 0x58, 0xa6, 0x32, 0xca, 0x01, 0x9a,
	0x1f, 0xf0, 0xe1, 0x87, 0x86, 0x97, 0x0e, 0x79, 0xff, 0xe4, 0x55, 0xea, 0xa6, 0xc5, 0xa4, 0x20,
	0x0d, 0x4a, 0x87, 0x0b, 0x10, 0xf5, 0x9a, 0x9b, 0xe1, 0x15, 0x80, 0x01, 0xd8, 0x6f, 0x4e, 0x72,
	0x18, 0x3e, 0xf8, 0xd4, 0x65, 0xf4, 0xe9, 0xbc, 0xd6, 0xa5, 0x5e, 0x0e, 0x3c, 0x81, 0x7f, 0x02,
	0xf1, 0x1b, 0x6a, 0xf7, 0x74, 0x03, 0x37, 0x2d, 0xd3, 0xa6, 0xb6, 0x43, 0xcc, 0xe6, 0x9d, 0x1f,
	0xef, 0xa5, 0x88, 0xf7, 0xc3, 0xa7, 0xc6, 0x3b, 0x17, 0x4c, 0xf9, 0x80, 0xc8, 0x8b, 0xab, 0xdd,
	0x8c, 0xb1, 0xf0, 0x42, 0xd0, 0xe5, 0x3a, 0x1e, 0xb7, 0x88, 0xdd, 0x64, 0xb4, 0xeb, 0x58, 0x0c,
	0x33, 0xbd, 0x45, 0x7b, 0xb6, 0x18, 0x35, 0x45, 0x41, 0x5a, 0x14, 0x88, 0x82, 0x0f, 0x40, 0xc2,
	0xce, 0x47, 0x5b, 0x7f, 0x4a, 0xbd, 0x62, 0x56, 0x07, 0x5f, 0x5a, 0xac, 0x45, 0x98, 0xb6, 0xe3,
	0xf9, 0x41, 0xcf, 0x5c, 0x62, 0x56, 0x27, 0x27, 0x8c, 0x5c, 0xf3, 0xba, 0x77, 0x35, 0x8c, 0xd8,
	0x5d, 0xcb, 0xb4, 0x79, 0x92, 0xea, 0x06, 0x11, 0xd7, 0x41, 0x91, 0x4c, 0x74, 0x7b, 0x2f, 0x9d,
	0x46, 0xf3, 0x12, 0x82, 0x5c, 0x44, 0x9d, 0x03, 0xe0, 0x16, 0x98, 0xbb, 0x21, 0x8c, 0x5e, 0xdd,
	0x05, 0x57, 0x42, 0xab, 0xe1, 0x3d, 0x9c, 0x95, 0x56, 0xff, 0x5a, 0xe8, 0x00, 0x2c, 0x8a, 0x27,
	0xb4, 0x29, 0xab, 0xad, 0x3f, 0x8a, 0xac, 0x79, 0x25, 0x72, 0x0f, 0x2d, 0x84, 0x11, 0xfe, 0x0c,
	0xb2, 0x0f, 0x16, 0xdc, 0x48, 0xe2, 0xea, 0xca, 0x0f, 0xb7, 0x17, 0x9a, 0x9a, 0xa1, 0x44, 0x9c,
	0x58, 0x66, 0xdb, 0x8f, 0x58, 0x07, 0x4f, 0xc2, 0x0e, 0xb8, 0x2f, 0x7c, 0xd0, 0x1e, 0xf7, 0x43,
	0x43, 0xe1, 0x86, 0x11, 0x10, 0x9c, 0x87, 0xe0, 0x41, 0x8f, 0x2c, 0xc8, 0x8a, 0xdf, 0x47, 0xac,
	0x37, 0x9b, 0xc4, 0x70, 0xef, 0x3b, 0xb4, 0x03, 0x59, 0x4b, 0xf6, 0x44, 0xbd, 0x0f, 0xbd, 0x4f,
	0x36, 0x04, 0x82, 0x55, 0xb0, 0x31, 0xe2, 0x93, 0xfa, 0x89, 0xbe, 0x0f, 0xaf, 0xe6, 0xfa, 0xd0,
	0xf7, 0xf5, 0xf1, 0x1d, 0x83, 0x2f, 0x46, 0xf1, 0x39, 0x8c, 0xb6, 0xdb, 0x7c, 0x6f, 0x45, 0x2f,
	0xfa, 0xc1, 0xeb, 0x24, 0xc3, 0x64, 0x0d, 0x09, 0x94, 0xcd, 0xe8, 0x3b, 0xb0, 0x74, 0x4d, 0x6d,
	0xc7, 0x6a, 0x33, 0xbd, 0x83, 0x89, 0x18, 0x35, 0xdc, 0xa6, 0xf2, 0xdb, 0xbe, 0x8a, 0xe7, 0x83,
	0x8a, 0x21, 0x0c, 0xd4, 0xc1, 0xd7, 0x7c, 0x5e, 0x1c, 0x3d, 0x8a, 0xbb, 0xd7, 0x8e, 0xba, 0x61,
	0x78, 0xd7, 0x8e, 0xc9, 0x30, 0xe5, 0x6f, 0x7a, 0x36, 0xa9, 0x0f, 0x8f, 0xe5, 0xf2, 0x2a, 0x32,
	0x6b, 0x18, 0xee, 0x55, 0x64, 0x13, 0x7c, 0xf3, 0xab, 0x21, 0xae, 0x28, 0xb3, 0x1d, 0x19, 0x44,
	0x7b, 0x12, 0x8e, 0xf1, 0xf4, 0xbe, 0x18, 0x25, 0xee, 0x25, 0xa2, 0xf0, 0xfc, 0x6e, 0xeb, 0xd4,
	0xc4, 0x4d, 0x8b, 0x79, 0x37, 0xc7, 0x5f, 0xf6, 0xe5, 0x37, 0xb7, 0xe6, 0x7d, 0x23, 0x7c, 0x09,
	0x16, 0x84, 0xa0, 0x18, 0x74, 0xfa, 0x5d, 0xd8, 0x09, 0x72, 0xc8, 0x61, 0xbf, 0x63, 0x1d, 0x3c,
	0x19, 0xf0, 0xc1, 0xe2, 0xe2, 0x96, 0x37, 0x8c, 0xeb, 0xbb, 0xae, 0xe5, 0x5c, 0x13, 0x9b, 0xd8,
	0xda, 0xf3, 0x50, 0xb6, 0x6f, 0xf4, 0xc7, 0xae, 0xb8, 0xf0, 0x23, 0x1f, 0x0d, 0x2f, 0xc0, 0x57,
	0x83, 0xa4, 0xae, 0xac, 0xa3, 0x9d, 0x2e, 0xb3, 0x6e, 0x44, 0xd1, 0x97, 0xe3, 0x7b, 0x3a, 0x90,
	0x87, 0x4f, 0xfa, 0x79, 0xa5, 0xde, 0x2b, 0x07, 0x0e, 0x62, 0x8a, 0xaf, 0x82, 0x8d, 0x41, 0xea,
	0x4b, 0x46, 0xdb, 0xd7, 0x0e, 0x66, 0xe4, 0x8a, 0x30, 0xc2, 0xcf, 0xf4, 0xab, 0xbe, 0xdc, 0xed,
	0x67, 0xcd, 0x09, 0x30, 0xf2, 0xb0, 0xf0, 0xf5, 0x30, 0x9f, 0x9b, 0xb7, 0xbc, 0xa3, 0xcb, 0xd4,
	0xfd, 0xce, 0x4f, 0xdd, 0x7e, 0xae, 0x86, 0x0f, 0x94, 0xa9, 0x7b, 0x00, 0x96, 0x84, 0x9e, 0x16,
	0x84, 0xde, 0x29, 0x10, 0xa2, 0xe0, 0x37, 0xde, 0x57, 0xee, 0xa2, 0x79, 0x0e, 0xe1, 0x9b, 0xe0,
	0x26, 0xbf, 0xd0, 0x05, 0xcf, 0xc0, 0x6c, 0xe0, 0x29, 0x2e, 0x8b, 0x9e, 0x06, 0xeb, 0x32, 0xe3,
	0x79, 0x88, 0xcb, 0xa1, 0x3f, 0x81, 0x47, 0xe1, 0x17, 0x96, 0xa2, 0xe7, 0x99, 0x10, 0x3d, 0x2f,
	0x3f, 0xb5, 0x35, 0x84, 0x72, 0x40, 0xa8, 0x9e, 0x95, 0xc3, 0x6c, 0x99, 0xcf, 0xbb, 0x88, 0x8f,
	0xbe, 0xb8, 0x50, 0x2c, 0x65, 0xcf, 0x4e, 0x1a, 0xf8, 0xac, 0x5e, 0x44, 0x68, 0xae, 0xdd, 0x8f,
	0x85, 0x17, 0x40, 0x15, 0xf1, 0x2f, 0xa9, 0x6e, 0x7b, 0x2a, 0xf1, 0x2b, 0xd1, 0x99, 0x9e, 0x87,
	0xc7, 0x34, 0xcb, 0x24, 0x21, 0xd5, 0x1a, 0x8a, 0x9b, 0xa3, 0xba, 0x2d, 0xc5, 0xa3, 0x4c, 0xe2,
	0xe0, 0x6f, 0x78, 0x09, 0x66, 0x68, 0x47, 0x6f, 0x13, 0x7c, 0x65, 0xb1, 0x8e, 0xee, 0x68, 0x99,
	0xa1, 0x3b, 0x99, 0xfb, 0x55, 0x24, 0xf7, 0x2d, 0x09, 0xd7, 0x0c, 0x28, 0xd5, 0x50, 0x25, 0xdb,
	0xc0, 0xe8, 0x30, 0x87, 0xa6, 0x69, 0x60, 0x80, 0x7f, 0x56, 0xc0, 0x4a, 0xa8, 0xbb, 0xb9, 0x37,
	0x80, 0x7c, 0x62, 0xb9, 0xeb, 0x12, 0x2d, 0x2b, 0x22, 0x7e, 0xff, 0xc9, 0xca, 0xc8, 0x27, 0x2a,
	0x7a, 0x3c, 0x8d, 0xbb, 0x2e, 0xc9, 0x4c, 0xd6, 0x50, 0x0e, 0x2d, 0xb7, 0x46, 0x5b, 0xe1, 0x21,
	0x58, 0xf7, 0x24, 0x48, 0x8b, 0x30, 0x7a, 0xe3, 0x8d, 0x4f, 0xb8, 0x7b, 0xc7, 0xf4, 0x0e, 0x6d,
	0x69, 0xb9, 0xd0, 0x61, 0x8b, 0xbb, 0xd0, 0x82, 0x8f, 0x2c, 0x9b, 0xa7, 0x12, 0x17, 0xff, 0x5f,
	0x05, 0xc0, 0x61, 0x71, 0x06, 0x5f, 0x82, 0xa5, 0x21, 0xb9, 0x88, 0x77, 0xf7, 0xd3, 0x5d, 0xf7,
	0xaa, 0x46, 0xd9, 0x46, 0x0b, 0x83, 0x4a, 0x93, 0x9b, 0x47, 0x3b, 0xbe, 0x38, 0x48, 0x77, 0xdd,
	0x1b, 0xa4, 0x51, 0x8e, 0xdc, 0x3c, 0xda, 0xf1, 0xe5, 0x4e, 0xba, 0x2b, 0xa6, 0x59, 0xa1, 0x6d,
	0x87, 0x1c, 0xb9, 0x99, 0x0b, 0x8e, 0x61, 0xc7, 0xed, 0x34, 0x0f, 0xe9, 0xcf, 0xb0, 0x8b, 0x83,
	0x9e, 0xc2, 0x1e, 0xff, 0x4b, 0x04, 0xa8, 0x83, 0x92, 0x8a, 0xcf, 0x90, 0x97, 0xd6, 0x2d, 0xbe,
	0xa2, 0x86, 0x43, 0x18, 0x6e, 0x51, 0xbd, 0xe3, 0xfd, 0x20, 0xb5, 0x8b, 0x1e, 0x5e, 0x5a, 0xb7,
	0x25, 0x61, 0x28, 0x50, 0xbd, 0x03, 0x8f, 0xc0, 0xba, 0x3f, 0xba, 0x4a, 0x85, 0x61, 0x12, 0xdb,
	0x0e, 0x75, 0xe6, 0x88, 0xdf, 0x99, 0x77, 0xd1, 0xaa, 0x07, 0xcd, 0xfb, 0xc8, 0xf0, 0x10, 0xbc,
	0xee, 0x0f, 0xe4, 0x23, 0x99, 0xe4, 0x22, 0x7c, 0x26, 0x6e, 0xc8, 0xb6, 0xd1, 0xaa, 0x07, 0x1e,
	0xc5, 0xb5, 0x0d, 0x1e, 0xb9, 0xa3, 0x58, 0x97, 0xb0, 0x26, 0x31, 0x1d, 0x6a, 0x10, 0xf1, 0x0b,
	0x87, 0x78, 0x93, 0x83, 0x3d, 0xa4, 0x4a, 0xf3, 0xa9, 0x6f, 0x8d, 0xff, 0xb3, 0x02, 0xb4, 0x71,
	0x5a, 0x0f, 0xee, 0x81, 0x79, 0x2f, 0xd7, 0x42, 0x92, 0x52, 0x2c, 0x8a, 0x2f, 0x5e, 0x5c, 0x40,
	0xc8, 0x5b, 0xfc, 0x40, 0x43, 0xcd, 0x3b, 0x2c, 0x8f, 0x63, 0x8b, 0x76, 0x88, 0x69, 0xf3, 0x76,
	0x12, 0xf1, 0x85, 0x3c, 0xe4, 0x76, 0x71, 0xe2, 0x0a, 0x9e, 0x35, 0x59, 0x05, 0x70, 0x78, 0x92,
	0x83, 0x2a, 0x98, 0x11, 0xb3, 0x5c, 0x70, 0x4f, 0x15, 0x3c, 0x29, 0xf3, 0x63, 0xaa, 0x2a, 0x70,
	0x01, 0x0c, 0xcd, 0x7b, 0x6a, 0x24, 0xf9, 0xaf, 0x11, 0x30, 0xdb, 0x3f, 0x9f, 0xc1, 0x24, 0x48,
	0x8c, 0x99, 0xd0, 0x02, 0xfa, 0xc7, 0xe0, 0xbe, 0x29, 0x4e, 0x55, 0xe0, 0x53, 0x90, 0x1c, 0x03,
	0x68, 0xd4, 0x70, 0x25, 0xfb, 0x7b, 0x5c, 0x2f, 0xff, 0x58, 0x54, 0x23, 0xf0, 0x4b, 0xb0, 0x31,
	0x06, 0x97, 0xbb, 0xc0, 0xa5, 0x6c, 0xbe, 0x51, 0x43, 0xea, 0xe4, 0x3d, 0x6c, 0xb9, 0x0b, 0x5c,
	0xcf, 0x1f, 0x15, 0x0b, 0x67, 0x27, 0x45, 0x35, 0xfa, 0x2b, 0x51, 0xcb, 0x55, 0x19, 0x75, 0x0a,
	0x6e, 0x82, 0x2f, 0xc7, 0xe3, 0xca, 0xd5, 0xd3, 0xb3, 0x86, 0x44, 0x7e, 0x96, 0xfc, 0x03, 0x98,
	0x1b, 0xa8, 0xe4, 0x70, 0x1d, 0x8c, 0xaf, 0xe5, 0xf2, 0x0e, 0xb2, 0xcf, 0x7c, 0x5e, 0x2e, 0x14,
	0x6b, 0x6a, 0x84, 0xaf, 0x7f, 0xdf, 0xf3, 0xa3, 0x02, 0xff, 0xb2, 0x35, 0xa0, 0xf5, 0x3d, 0x3d,
	0x3d, 0xaa, 0x35, 0x6a, 0x38, 0x77, 0x86, 0xea, 0x0d, 0x35, 0x9a, 0xbc, 0x03, 0xd3, 0xa1, 0x8a,
	0x0b, 0x21, 0x98, 0x75, 0x6b, 0x6e, 0xb0, 0x13, 0x0b, 0x40, 0x75, 0x9f, 0x1d, 0xa2, 0xec, 0x45,
	0x3d, 0x9f, 0x3d, 0xe1, 0xcb, 0x3f, 0x0b, 0x42, 0xd5, 0x59, 0x8d, 0xc0, 0x39, 0x30, 0x1d, 0xfc,
	0x9d, 0x55, 0x27, 0x43, 0x80, 0xdc, 0x21, 0x52, 0xa3, 0x21, 0x40, 0xee, 0x10, 0x65, 0xd5, 0xa9,
	0x64, 0x12, 0x2c, 0x8f, 0x29, 0xbd, 0xf0, 0x73, 0xc0, 0x8b, 0xaf, 0x3a, 0x91, 0x8a, 0xc6, 0xa6,
	0xd4, 0xcf, 0x52, 0xd1, 0xd8, 0xe7, 0x6a, 0x2c, 0x15, 0x8d, 0xc5, 0xd4, 0x07, 0xa9, 0x68, 0xec,
	0x81, 0x0a, 0x52, 0xd1, 0x18, 0x50, 0xa7, 0x53, 0xd1, 0xd8, 0x9c, 0xaa, 0xa6, 0xa2, 0x31, 0x55,
	0x7d, 0x94, 0x8a, 0xc6, 0x34, 0x75, 0x25, 0x15, 0x8d, 0xad, 0xab, 0x09, 0x79, 0x57, 0x99, 0x8a,
	0xc6, 0x36, 0xd4, 0x2f, 0x52, 0xd1, 0x58, 0x4a, 0xfd, 0x3a, 0x15, 0x8d, 0x7d, 0xad, 0x7e, 0x93,
	0xa3, 0x3f, 0xfd, 0x9c, 0x98, 0xf8, 0xeb, 0xcf, 0x89, 0x89, 0xbf, 0xfd, 0x9c, 0x50, 0xfe, 0xfc,
	0x31, 0xa1, 0xfc, 0xc7, 0xc7, 0x84, 0xf2, 0x5f, 0x1f, 0x13, 0xca, 0x4f, 0x1f, 0x13, 0xca, 0x7f,
	0x7f, 0x4c, 0x28, 0xff, 0xf3, 0x31, 0x31, 0xf1, 0xb7, 0x8f, 0x09, 0xe5, 0x5f, 0x7e, 0x49, 0x4c,
	0xfc, 0xf4, 0x4b, 0x62, 0xe2, 0xaf, 0xbf, 0x24, 0x26, 0x7e, 0xdc, 0x6d, 0x53, 0xe7, 0xba, 0x77,
	0xb9, 0xd5, 0xb4, 0x3a, 0xcf, 0xdb, 0x96, 0xd5, 0x36, 0xc8, 0xf3, 0xe0, 0xdf, 0x1b, 0xc6, 0xfc,
	0xa3, 0xc3, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x48, 0x16, 0xeb, 0x1e, 0x44, 0x21, 0x00, 0x00,
}

func (x TrackingOptions_FlowDirection) String() string {
	s, ok := TrackingOptions_FlowDirection_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrackingOptions_TrackingPolicy) String() string {
	s, ok := TrackingOptions_TrackingPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrackingOptions_CornerExtractionMethod) String() string {
	s, ok := TrackingOptions_CornerExtractionMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrackingOptions_KltTrackerImplementation) String() string {
	s, ok := TrackingOptions_KltTrackerImplementation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RegionFlowComputationOptions_IrlsInitialization) String() string {
	s, ok := RegionFlowComputationOptions_IrlsInitialization_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RegionFlowComputationOptions_DownsampleMode) String() string {
	s, ok := RegionFlowComputationOptions_DownsampleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RegionFlowComputationOptions_GainCorrectMode) String() string {
	s, ok := RegionFlowComputationOptions_GainCorrectMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RegionFlowComputationOptions_ImageFormat) String() string {
	s, ok := RegionFlowComputationOptions_ImageFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RegionFlowComputationOptions_DescriptorExtractorType) String() string {
	s, ok := RegionFlowComputationOptions_DescriptorExtractorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TrackingOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingOptions)
	if !ok {
		that2, ok := that.(TrackingOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.InternalTrackingDirection != nil && that1.InternalTrackingDirection != nil {
		if *this.InternalTrackingDirection != *that1.InternalTrackingDirection {
			return false
		}
	} else if this.InternalTrackingDirection != nil {
		return false
	} else if that1.InternalTrackingDirection != nil {
		return false
	}
	if this.OutputFlowDirection != nil && that1.OutputFlowDirection != nil {
		if *this.OutputFlowDirection != *that1.OutputFlowDirection {
			return false
		}
	} else if this.OutputFlowDirection != nil {
		return false
	} else if that1.OutputFlowDirection != nil {
		return false
	}
	if this.TrackingPolicy != nil && that1.TrackingPolicy != nil {
		if *this.TrackingPolicy != *that1.TrackingPolicy {
			return false
		}
	} else if this.TrackingPolicy != nil {
		return false
	} else if that1.TrackingPolicy != nil {
		return false
	}
	if this.MultiFramesToTrack != nil && that1.MultiFramesToTrack != nil {
		if *this.MultiFramesToTrack != *that1.MultiFramesToTrack {
			return false
		}
	} else if this.MultiFramesToTrack != nil {
		return false
	} else if that1.MultiFramesToTrack != nil {
		return false
	}
	if this.LongTracksMaxFrames != nil && that1.LongTracksMaxFrames != nil {
		if *this.LongTracksMaxFrames != *that1.LongTracksMaxFrames {
			return false
		}
	} else if this.LongTracksMaxFrames != nil {
		return false
	} else if that1.LongTracksMaxFrames != nil {
		return false
	}
	if this.MaxFeatures != nil && that1.MaxFeatures != nil {
		if *this.MaxFeatures != *that1.MaxFeatures {
			return false
		}
	} else if this.MaxFeatures != nil {
		return false
	} else if that1.MaxFeatures != nil {
		return false
	}
	if this.CornerExtractionMethod != nil && that1.CornerExtractionMethod != nil {
		if *this.CornerExtractionMethod != *that1.CornerExtractionMethod {
			return false
		}
	} else if this.CornerExtractionMethod != nil {
		return false
	} else if that1.CornerExtractionMethod != nil {
		return false
	}
	if !this.MinEigValSettings.Equal(that1.MinEigValSettings) {
		return false
	}
	if !this.HarrisSettings.Equal(that1.HarrisSettings) {
		return false
	}
	if !this.FastSettings.Equal(that1.FastSettings) {
		return false
	}
	if this.TrackingWindowSize != nil && that1.TrackingWindowSize != nil {
		if *this.TrackingWindowSize != *that1.TrackingWindowSize {
			return false
		}
	} else if this.TrackingWindowSize != nil {
		return false
	} else if that1.TrackingWindowSize != nil {
		return false
	}
	if this.TrackingIterations != nil && that1.TrackingIterations != nil {
		if *this.TrackingIterations != *that1.TrackingIterations {
			return false
		}
	} else if this.TrackingIterations != nil {
		return false
	} else if that1.TrackingIterations != nil {
		return false
	}
	if this.FractionalTrackingDistance != nil && that1.FractionalTrackingDistance != nil {
		if *this.FractionalTrackingDistance != *that1.FractionalTrackingDistance {
			return false
		}
	} else if this.FractionalTrackingDistance != nil {
		return false
	} else if that1.FractionalTrackingDistance != nil {
		return false
	}
	if this.AdaptiveTrackingDistance != nil && that1.AdaptiveTrackingDistance != nil {
		if *this.AdaptiveTrackingDistance != *that1.AdaptiveTrackingDistance {
			return false
		}
	} else if this.AdaptiveTrackingDistance != nil {
		return false
	} else if that1.AdaptiveTrackingDistance != nil {
		return false
	}
	if this.MinFeatureDistance != nil && that1.MinFeatureDistance != nil {
		if *this.MinFeatureDistance != *that1.MinFeatureDistance {
			return false
		}
	} else if this.MinFeatureDistance != nil {
		return false
	} else if that1.MinFeatureDistance != nil {
		return false
	}
	if this.DistanceDownscaleSqrt != nil && that1.DistanceDownscaleSqrt != nil {
		if *this.DistanceDownscaleSqrt != *that1.DistanceDownscaleSqrt {
			return false
		}
	} else if this.DistanceDownscaleSqrt != nil {
		return false
	} else if that1.DistanceDownscaleSqrt != nil {
		return false
	}
	if this.AdaptiveGoodFeaturesToTrack != nil && that1.AdaptiveGoodFeaturesToTrack != nil {
		if *this.AdaptiveGoodFeaturesToTrack != *that1.AdaptiveGoodFeaturesToTrack {
			return false
		}
	} else if this.AdaptiveGoodFeaturesToTrack != nil {
		return false
	} else if that1.AdaptiveGoodFeaturesToTrack != nil {
		return false
	}
	if this.AdaptiveFeaturesBlockSize != nil && that1.AdaptiveFeaturesBlockSize != nil {
		if *this.AdaptiveFeaturesBlockSize != *that1.AdaptiveFeaturesBlockSize {
			return false
		}
	} else if this.AdaptiveFeaturesBlockSize != nil {
		return false
	} else if that1.AdaptiveFeaturesBlockSize != nil {
		return false
	}
	if this.AdaptiveFeaturesLevels != nil && that1.AdaptiveFeaturesLevels != nil {
		if *this.AdaptiveFeaturesLevels != *that1.AdaptiveFeaturesLevels {
			return false
		}
	} else if this.AdaptiveFeaturesLevels != nil {
		return false
	} else if that1.AdaptiveFeaturesLevels != nil {
		return false
	}
	if this.AdaptiveExtractionLevels != nil && that1.AdaptiveExtractionLevels != nil {
		if *this.AdaptiveExtractionLevels != *that1.AdaptiveExtractionLevels {
			return false
		}
	} else if this.AdaptiveExtractionLevels != nil {
		return false
	} else if that1.AdaptiveExtractionLevels != nil {
		return false
	}
	if this.AdaptiveExtractionLevelsLowestSize != nil && that1.AdaptiveExtractionLevelsLowestSize != nil {
		if *this.AdaptiveExtractionLevelsLowestSize != *that1.AdaptiveExtractionLevelsLowestSize {
			return false
		}
	} else if this.AdaptiveExtractionLevelsLowestSize != nil {
		return false
	} else if that1.AdaptiveExtractionLevelsLowestSize != nil {
		return false
	}
	if this.SyntheticZeroMotionGridStep != nil && that1.SyntheticZeroMotionGridStep != nil {
		if *this.SyntheticZeroMotionGridStep != *that1.SyntheticZeroMotionGridStep {
			return false
		}
	} else if this.SyntheticZeroMotionGridStep != nil {
		return false
	} else if that1.SyntheticZeroMotionGridStep != nil {
		return false
	}
	if this.WideBaselineMatching != nil && that1.WideBaselineMatching != nil {
		if *this.WideBaselineMatching != *that1.WideBaselineMatching {
			return false
		}
	} else if this.WideBaselineMatching != nil {
		return false
	} else if that1.WideBaselineMatching != nil {
		return false
	}
	if this.RatioTestThreshold != nil && that1.RatioTestThreshold != nil {
		if *this.RatioTestThreshold != *that1.RatioTestThreshold {
			return false
		}
	} else if this.RatioTestThreshold != nil {
		return false
	} else if that1.RatioTestThreshold != nil {
		return false
	}
	if this.RefineWideBaselineMatches != nil && that1.RefineWideBaselineMatches != nil {
		if *this.RefineWideBaselineMatches != *that1.RefineWideBaselineMatches {
			return false
		}
	} else if this.RefineWideBaselineMatches != nil {
		return false
	} else if that1.RefineWideBaselineMatches != nil {
		return false
	}
	if this.ReuseFeaturesMaxFrameDistance != nil && that1.ReuseFeaturesMaxFrameDistance != nil {
		if *this.ReuseFeaturesMaxFrameDistance != *that1.ReuseFeaturesMaxFrameDistance {
			return false
		}
	} else if this.ReuseFeaturesMaxFrameDistance != nil {
		return false
	} else if that1.ReuseFeaturesMaxFrameDistance != nil {
		return false
	}
	if this.ReuseFeaturesMinSurvivedFrac != nil && that1.ReuseFeaturesMinSurvivedFrac != nil {
		if *this.ReuseFeaturesMinSurvivedFrac != *that1.ReuseFeaturesMinSurvivedFrac {
			return false
		}
	} else if this.ReuseFeaturesMinSurvivedFrac != nil {
		return false
	} else if that1.ReuseFeaturesMinSurvivedFrac != nil {
		return false
	}
	if this.KltTrackerImplementation != nil && that1.KltTrackerImplementation != nil {
		if *this.KltTrackerImplementation != *that1.KltTrackerImplementation {
			return false
		}
	} else if this.KltTrackerImplementation != nil {
		return false
	} else if that1.KltTrackerImplementation != nil {
		return false
	}
	thismap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(this)
	thatmap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(that1)
	for k, v := range thismap {
		if v2, ok := thatmap[k]; ok {
			if !v.Equal(&v2) {
				return false
			}
		} else {
			return false
		}
	}
	for k, _ := range thatmap {
		if _, ok := thismap[k]; !ok {
			return false
		}
	}
	return true
}
func (this *TrackingOptions_MinEigValExtractionSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingOptions_MinEigValExtractionSettings)
	if !ok {
		that2, ok := that.(TrackingOptions_MinEigValExtractionSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FeatureQualityLevel != nil && that1.FeatureQualityLevel != nil {
		if *this.FeatureQualityLevel != *that1.FeatureQualityLevel {
			return false
		}
	} else if this.FeatureQualityLevel != nil {
		return false
	} else if that1.FeatureQualityLevel != nil {
		return false
	}
	if this.AdaptiveLowestQualityLevel != nil && that1.AdaptiveLowestQualityLevel != nil {
		if *this.AdaptiveLowestQualityLevel != *that1.AdaptiveLowestQualityLevel {
			return false
		}
	} else if this.AdaptiveLowestQualityLevel != nil {
		return false
	} else if that1.AdaptiveLowestQualityLevel != nil {
		return false
	}
	return true
}
func (this *TrackingOptions_HarrisExtractionSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingOptions_HarrisExtractionSettings)
	if !ok {
		that2, ok := that.(TrackingOptions_HarrisExtractionSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FeatureQualityLevel != nil && that1.FeatureQualityLevel != nil {
		if *this.FeatureQualityLevel != *that1.FeatureQualityLevel {
			return false
		}
	} else if this.FeatureQualityLevel != nil {
		return false
	} else if that1.FeatureQualityLevel != nil {
		return false
	}
	return true
}
func (this *TrackingOptions_FastExtractionSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackingOptions_FastExtractionSettings)
	if !ok {
		that2, ok := that.(TrackingOptions_FastExtractionSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Threshold != nil && that1.Threshold != nil {
		if *this.Threshold != *that1.Threshold {
			return false
		}
	} else if this.Threshold != nil {
		return false
	} else if that1.Threshold != nil {
		return false
	}
	return true
}
func (this *RegionFlowComputationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegionFlowComputationOptions)
	if !ok {
		that2, ok := that.(RegionFlowComputationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrackingOptions.Equal(that1.TrackingOptions) {
		return false
	}
	if this.MinFeatureInliers != nil && that1.MinFeatureInliers != nil {
		if *this.MinFeatureInliers != *that1.MinFeatureInliers {
			return false
		}
	} else if this.MinFeatureInliers != nil {
		return false
	} else if that1.MinFeatureInliers != nil {
		return false
	}
	if this.RelativeMinFeatureInliers != nil && that1.RelativeMinFeatureInliers != nil {
		if *this.RelativeMinFeatureInliers != *that1.RelativeMinFeatureInliers {
			return false
		}
	} else if this.RelativeMinFeatureInliers != nil {
		return false
	} else if that1.RelativeMinFeatureInliers != nil {
		return false
	}
	if this.PreBlurSigma != nil && that1.PreBlurSigma != nil {
		if *this.PreBlurSigma != *that1.PreBlurSigma {
			return false
		}
	} else if this.PreBlurSigma != nil {
		return false
	} else if that1.PreBlurSigma != nil {
		return false
	}
	if this.RansacRoundsPerRegion != nil && that1.RansacRoundsPerRegion != nil {
		if *this.RansacRoundsPerRegion != *that1.RansacRoundsPerRegion {
			return false
		}
	} else if this.RansacRoundsPerRegion != nil {
		return false
	} else if that1.RansacRoundsPerRegion != nil {
		return false
	}
	if this.AbsoluteInlierErrorThreshold != nil && that1.AbsoluteInlierErrorThreshold != nil {
		if *this.AbsoluteInlierErrorThreshold != *that1.AbsoluteInlierErrorThreshold {
			return false
		}
	} else if this.AbsoluteInlierErrorThreshold != nil {
		return false
	} else if that1.AbsoluteInlierErrorThreshold != nil {
		return false
	}
	if this.FracInlierErrorThreshold != nil && that1.FracInlierErrorThreshold != nil {
		if *this.FracInlierErrorThreshold != *that1.FracInlierErrorThreshold {
			return false
		}
	} else if this.FracInlierErrorThreshold != nil {
		return false
	} else if that1.FracInlierErrorThreshold != nil {
		return false
	}
	if this.RelativeInlierErrorThreshold != nil && that1.RelativeInlierErrorThreshold != nil {
		if *this.RelativeInlierErrorThreshold != *that1.RelativeInlierErrorThreshold {
			return false
		}
	} else if this.RelativeInlierErrorThreshold != nil {
		return false
	} else if that1.RelativeInlierErrorThreshold != nil {
		return false
	}
	if this.TopInlierSets != nil && that1.TopInlierSets != nil {
		if *this.TopInlierSets != *that1.TopInlierSets {
			return false
		}
	} else if this.TopInlierSets != nil {
		return false
	} else if that1.TopInlierSets != nil {
		return false
	}
	if this.NoEstimationMode != nil && that1.NoEstimationMode != nil {
		if *this.NoEstimationMode != *that1.NoEstimationMode {
			return false
		}
	} else if this.NoEstimationMode != nil {
		return false
	} else if that1.NoEstimationMode != nil {
		return false
	}
	if this.FastEstimationBlockSize != nil && that1.FastEstimationBlockSize != nil {
		if *this.FastEstimationBlockSize != *that1.FastEstimationBlockSize {
			return false
		}
	} else if this.FastEstimationBlockSize != nil {
		return false
	} else if that1.FastEstimationBlockSize != nil {
		return false
	}
	if this.FastEstimationMinBlockSize != nil && that1.FastEstimationMinBlockSize != nil {
		if *this.FastEstimationMinBlockSize != *that1.FastEstimationMinBlockSize {
			return false
		}
	} else if this.FastEstimationMinBlockSize != nil {
		return false
	} else if that1.FastEstimationMinBlockSize != nil {
		return false
	}
	if this.FastEstimationOverlapGrids != nil && that1.FastEstimationOverlapGrids != nil {
		if *this.FastEstimationOverlapGrids != *that1.FastEstimationOverlapGrids {
			return false
		}
	} else if this.FastEstimationOverlapGrids != nil {
		return false
	} else if that1.FastEstimationOverlapGrids != nil {
		return false
	}
	if this.MaxMagnitudeThresholdRatio != nil && that1.MaxMagnitudeThresholdRatio != nil {
		if *this.MaxMagnitudeThresholdRatio != *that1.MaxMagnitudeThresholdRatio {
			return false
		}
	} else if this.MaxMagnitudeThresholdRatio != nil {
		return false
	} else if that1.MaxMagnitudeThresholdRatio != nil {
		return false
	}
	if this.MedianMagnitudeBounds != nil && that1.MedianMagnitudeBounds != nil {
		if *this.MedianMagnitudeBounds != *that1.MedianMagnitudeBounds {
			return false
		}
	} else if this.MedianMagnitudeBounds != nil {
		return false
	} else if that1.MedianMagnitudeBounds != nil {
		return false
	}
	if this.IrlsInitialization != nil && that1.IrlsInitialization != nil {
		if *this.IrlsInitialization != *that1.IrlsInitialization {
			return false
		}
	} else if this.IrlsInitialization != nil {
		return false
	} else if that1.IrlsInitialization != nil {
		return false
	}
	if this.DownsampleMode != nil && that1.DownsampleMode != nil {
		if *this.DownsampleMode != *that1.DownsampleMode {
			return false
		}
	} else if this.DownsampleMode != nil {
		return false
	} else if that1.DownsampleMode != nil {
		return false
	}
	if this.DownsamplingSize != nil && that1.DownsamplingSize != nil {
		if *this.DownsamplingSize != *that1.DownsamplingSize {
			return false
		}
	} else if this.DownsamplingSize != nil {
		return false
	} else if that1.DownsamplingSize != nil {
		return false
	}
	if this.DownsampleFactor != nil && that1.DownsampleFactor != nil {
		if *this.DownsampleFactor != *that1.DownsampleFactor {
			return false
		}
	} else if this.DownsampleFactor != nil {
		return false
	} else if that1.DownsampleFactor != nil {
		return false
	}
	if this.RoundDownsampleFactor != nil && that1.RoundDownsampleFactor != nil {
		if *this.RoundDownsampleFactor != *that1.RoundDownsampleFactor {
			return false
		}
	} else if this.RoundDownsampleFactor != nil {
		return false
	} else if that1.RoundDownsampleFactor != nil {
		return false
	}
	if !this.DownsampleSchedule.Equal(that1.DownsampleSchedule) {
		return false
	}
	if this.MinFeatureRequirement != nil && that1.MinFeatureRequirement != nil {
		if *this.MinFeatureRequirement != *that1.MinFeatureRequirement {
			return false
		}
	} else if this.MinFeatureRequirement != nil {
		return false
	} else if that1.MinFeatureRequirement != nil {
		return false
	}
	if this.MinFeatureCover != nil && that1.MinFeatureCover != nil {
		if *this.MinFeatureCover != *that1.MinFeatureCover {
			return false
		}
	} else if this.MinFeatureCover != nil {
		return false
	} else if that1.MinFeatureCover != nil {
		return false
	}
	if this.MinFeatureCoverGrid != nil && that1.MinFeatureCoverGrid != nil {
		if *this.MinFeatureCoverGrid != *that1.MinFeatureCoverGrid {
			return false
		}
	} else if this.MinFeatureCoverGrid != nil {
		return false
	} else if that1.MinFeatureCoverGrid != nil {
		return false
	}
	if this.ComputeBlurScore != nil && that1.ComputeBlurScore != nil {
		if *this.ComputeBlurScore != *that1.ComputeBlurScore {
			return false
		}
	} else if this.ComputeBlurScore != nil {
		return false
	} else if that1.ComputeBlurScore != nil {
		return false
	}
	if !this.BlurScoreOptions.Equal(that1.BlurScoreOptions) {
		return false
	}
	if !this.VisualConsistencyOptions.Equal(that1.VisualConsistencyOptions) {
		return false
	}
	if this.PatchDescriptorRadius != nil && that1.PatchDescriptorRadius != nil {
		if *this.PatchDescriptorRadius != *that1.PatchDescriptorRadius {
			return false
		}
	} else if this.PatchDescriptorRadius != nil {
		return false
	} else if that1.PatchDescriptorRadius != nil {
		return false
	}
	if this.DistanceFromBorder != nil && that1.DistanceFromBorder != nil {
		if *this.DistanceFromBorder != *that1.DistanceFromBorder {
			return false
		}
	} else if this.DistanceFromBorder != nil {
		return false
	} else if that1.DistanceFromBorder != nil {
		return false
	}
	if this.CornerResponseScale != nil && that1.CornerResponseScale != nil {
		if *this.CornerResponseScale != *that1.CornerResponseScale {
			return false
		}
	} else if this.CornerResponseScale != nil {
		return false
	} else if that1.CornerResponseScale != nil {
		return false
	}
	if this.VerifyFeatures != nil && that1.VerifyFeatures != nil {
		if *this.VerifyFeatures != *that1.VerifyFeatures {
			return false
		}
	} else if this.VerifyFeatures != nil {
		return false
	} else if that1.VerifyFeatures != nil {
		return false
	}
	if this.VerificationDistance != nil && that1.VerificationDistance != nil {
		if *this.VerificationDistance != *that1.VerificationDistance {
			return false
		}
	} else if this.VerificationDistance != nil {
		return false
	} else if that1.VerificationDistance != nil {
		return false
	}
	if this.VerifyLongFeatures != nil && that1.VerifyLongFeatures != nil {
		if *this.VerifyLongFeatures != *that1.VerifyLongFeatures {
			return false
		}
	} else if this.VerifyLongFeatures != nil {
		return false
	} else if that1.VerifyLongFeatures != nil {
		return false
	}
	if this.LongFeatureVerificationThreshold != nil && that1.LongFeatureVerificationThreshold != nil {
		if *this.LongFeatureVerificationThreshold != *that1.LongFeatureVerificationThreshold {
			return false
		}
	} else if this.LongFeatureVerificationThreshold != nil {
		return false
	} else if that1.LongFeatureVerificationThreshold != nil {
		return false
	}
	if this.MaxLongFeatureAcceleration != nil && that1.MaxLongFeatureAcceleration != nil {
		if *this.MaxLongFeatureAcceleration != *that1.MaxLongFeatureAcceleration {
			return false
		}
	} else if this.MaxLongFeatureAcceleration != nil {
		return false
	} else if that1.MaxLongFeatureAcceleration != nil {
		return false
	}
	if this.VerifyLongFeatureAcceleration != nil && that1.VerifyLongFeatureAcceleration != nil {
		if *this.VerifyLongFeatureAcceleration != *that1.VerifyLongFeatureAcceleration {
			return false
		}
	} else if this.VerifyLongFeatureAcceleration != nil {
		return false
	} else if that1.VerifyLongFeatureAcceleration != nil {
		return false
	}
	if this.VerifyLongFeatureTriggerRatio != nil && that1.VerifyLongFeatureTriggerRatio != nil {
		if *this.VerifyLongFeatureTriggerRatio != *that1.VerifyLongFeatureTriggerRatio {
			return false
		}
	} else if this.VerifyLongFeatureTriggerRatio != nil {
		return false
	} else if that1.VerifyLongFeatureTriggerRatio != nil {
		return false
	}
	if this.HistogramEqualization != nil && that1.HistogramEqualization != nil {
		if *this.HistogramEqualization != *that1.HistogramEqualization {
			return false
		}
	} else if this.HistogramEqualization != nil {
		return false
	} else if that1.HistogramEqualization != nil {
		return false
	}
	if this.UseSyntheticZeroMotionTracksAllFrames != nil && that1.UseSyntheticZeroMotionTracksAllFrames != nil {
		if *this.UseSyntheticZeroMotionTracksAllFrames != *that1.UseSyntheticZeroMotionTracksAllFrames {
			return false
		}
	} else if this.UseSyntheticZeroMotionTracksAllFrames != nil {
		return false
	} else if that1.UseSyntheticZeroMotionTracksAllFrames != nil {
		return false
	}
	if this.UseSyntheticZeroMotionTracksFirstFrame != nil && that1.UseSyntheticZeroMotionTracksFirstFrame != nil {
		if *this.UseSyntheticZeroMotionTracksFirstFrame != *that1.UseSyntheticZeroMotionTracksFirstFrame {
			return false
		}
	} else if this.UseSyntheticZeroMotionTracksFirstFrame != nil {
		return false
	} else if that1.UseSyntheticZeroMotionTracksFirstFrame != nil {
		return false
	}
	if this.GainCorrection != nil && that1.GainCorrection != nil {
		if *this.GainCorrection != *that1.GainCorrection {
			return false
		}
	} else if this.GainCorrection != nil {
		return false
	} else if that1.GainCorrection != nil {
		return false
	}
	if this.FastGainCorrection != nil && that1.FastGainCorrection != nil {
		if *this.FastGainCorrection != *that1.FastGainCorrection {
			return false
		}
	} else if this.FastGainCorrection != nil {
		return false
	} else if that1.FastGainCorrection != nil {
		return false
	}
	if this.GainCorrectionMultipleHypotheses != nil && that1.GainCorrectionMultipleHypotheses != nil {
		if *this.GainCorrectionMultipleHypotheses != *that1.GainCorrectionMultipleHypotheses {
			return false
		}
	} else if this.GainCorrectionMultipleHypotheses != nil {
		return false
	} else if that1.GainCorrectionMultipleHypotheses != nil {
		return false
	}
	if this.GainCorrectionInlierImprovementFrac != nil && that1.GainCorrectionInlierImprovementFrac != nil {
		if *this.GainCorrectionInlierImprovementFrac != *that1.GainCorrectionInlierImprovementFrac {
			return false
		}
	} else if this.GainCorrectionInlierImprovementFrac != nil {
		return false
	} else if that1.GainCorrectionInlierImprovementFrac != nil {
		return false
	}
	if this.GainCorrectionBrightReference != nil && that1.GainCorrectionBrightReference != nil {
		if *this.GainCorrectionBrightReference != *that1.GainCorrectionBrightReference {
			return false
		}
	} else if this.GainCorrectionBrightReference != nil {
		return false
	} else if that1.GainCorrectionBrightReference != nil {
		return false
	}
	if this.GainCorrectionTriggeringRatio != nil && that1.GainCorrectionTriggeringRatio != nil {
		if *this.GainCorrectionTriggeringRatio != *that1.GainCorrectionTriggeringRatio {
			return false
		}
	} else if this.GainCorrectionTriggeringRatio != nil {
		return false
	} else if that1.GainCorrectionTriggeringRatio != nil {
		return false
	}
	if this.FracGainFeatureSize != nil && that1.FracGainFeatureSize != nil {
		if *this.FracGainFeatureSize != *that1.FracGainFeatureSize {
			return false
		}
	} else if this.FracGainFeatureSize != nil {
		return false
	} else if that1.FracGainFeatureSize != nil {
		return false
	}
	if this.FracGainStep != nil && that1.FracGainStep != nil {
		if *this.FracGainStep != *that1.FracGainStep {
			return false
		}
	} else if this.FracGainStep != nil {
		return false
	} else if that1.FracGainStep != nil {
		return false
	}
	if this.GainCorrectMode != nil && that1.GainCorrectMode != nil {
		if *this.GainCorrectMode != *that1.GainCorrectMode {
			return false
		}
	} else if this.GainCorrectMode != nil {
		return false
	} else if that1.GainCorrectMode != nil {
		return false
	}
	if !this.GainBiasBounds.Equal(that1.GainBiasBounds) {
		return false
	}
	if this.ImageFormat != nil && that1.ImageFormat != nil {
		if *this.ImageFormat != *that1.ImageFormat {
			return false
		}
	} else if this.ImageFormat != nil {
		return false
	} else if that1.ImageFormat != nil {
		return false
	}
	if this.DescriptorExtractorType != nil && that1.DescriptorExtractorType != nil {
		if *this.DescriptorExtractorType != *that1.DescriptorExtractorType {
			return false
		}
	} else if this.DescriptorExtractorType != nil {
		return false
	} else if that1.DescriptorExtractorType != nil {
		return false
	}
	if this.ComputeDerivativeInPyramid != nil && that1.ComputeDerivativeInPyramid != nil {
		if *this.ComputeDerivativeInPyramid != *that1.ComputeDerivativeInPyramid {
			return false
		}
	} else if this.ComputeDerivativeInPyramid != nil {
		return false
	} else if that1.ComputeDerivativeInPyramid != nil {
		return false
	}
	thismap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(this)
	thatmap := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(that1)
	for k, v := range thismap {
		if v2, ok := thatmap[k]; ok {
			if !v.Equal(&v2) {
				return false
			}
		} else {
			return false
		}
	}
	for k, _ := range thatmap {
		if _, ok := thismap[k]; !ok {
			return false
		}
	}
	return true
}
func (this *RegionFlowComputationOptions_DownSampleSchedule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegionFlowComputationOptions_DownSampleSchedule)
	if !ok {
		that2, ok := that.(RegionFlowComputationOptions_DownSampleSchedule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DownsampleFactor_360P != nil && that1.DownsampleFactor_360P != nil {
		if *this.DownsampleFactor_360P != *that1.DownsampleFactor_360P {
			return false
		}
	} else if this.DownsampleFactor_360P != nil {
		return false
	} else if that1.DownsampleFactor_360P != nil {
		return false
	}
	if this.DownsampleFactor_480P != nil && that1.DownsampleFactor_480P != nil {
		if *this.DownsampleFactor_480P != *that1.DownsampleFactor_480P {
			return false
		}
	} else if this.DownsampleFactor_480P != nil {
		return false
	} else if that1.DownsampleFactor_480P != nil {
		return false
	}
	if this.DownsampleFactor_720P != nil && that1.DownsampleFactor_720P != nil {
		if *this.DownsampleFactor_720P != *that1.DownsampleFactor_720P {
			return false
		}
	} else if this.DownsampleFactor_720P != nil {
		return false
	} else if that1.DownsampleFactor_720P != nil {
		return false
	}
	if this.DownsampleFactor_1080P != nil && that1.DownsampleFactor_1080P != nil {
		if *this.DownsampleFactor_1080P != *that1.DownsampleFactor_1080P {
			return false
		}
	} else if this.DownsampleFactor_1080P != nil {
		return false
	} else if that1.DownsampleFactor_1080P != nil {
		return false
	}
	return true
}
func (this *RegionFlowComputationOptions_BlurScoreOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegionFlowComputationOptions_BlurScoreOptions)
	if !ok {
		that2, ok := that.(RegionFlowComputationOptions_BlurScoreOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BoxFilterDiam != nil && that1.BoxFilterDiam != nil {
		if *this.BoxFilterDiam != *that1.BoxFilterDiam {
			return false
		}
	} else if this.BoxFilterDiam != nil {
		return false
	} else if that1.BoxFilterDiam != nil {
		return false
	}
	if this.RelativeCornernessThreshold != nil && that1.RelativeCornernessThreshold != nil {
		if *this.RelativeCornernessThreshold != *that1.RelativeCornernessThreshold {
			return false
		}
	} else if this.RelativeCornernessThreshold != nil {
		return false
	} else if that1.RelativeCornernessThreshold != nil {
		return false
	}
	if this.AbsoluteCornernessThreshold != nil && that1.AbsoluteCornernessThreshold != nil {
		if *this.AbsoluteCornernessThreshold != *that1.AbsoluteCornernessThreshold {
			return false
		}
	} else if this.AbsoluteCornernessThreshold != nil {
		return false
	} else if that1.AbsoluteCornernessThreshold != nil {
		return false
	}
	if this.MedianPercentile != nil && that1.MedianPercentile != nil {
		if *this.MedianPercentile != *that1.MedianPercentile {
			return false
		}
	} else if this.MedianPercentile != nil {
		return false
	} else if that1.MedianPercentile != nil {
		return false
	}
	return true
}
func (this *RegionFlowComputationOptions_VisualConsistencyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegionFlowComputationOptions_VisualConsistencyOptions)
	if !ok {
		that2, ok := that.(RegionFlowComputationOptions_VisualConsistencyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ComputeConsistency != nil && that1.ComputeConsistency != nil {
		if *this.ComputeConsistency != *that1.ComputeConsistency {
			return false
		}
	} else if this.ComputeConsistency != nil {
		return false
	} else if that1.ComputeConsistency != nil {
		return false
	}
	if this.TinyImageDimension != nil && that1.TinyImageDimension != nil {
		if *this.TinyImageDimension != *that1.TinyImageDimension {
			return false
		}
	} else if this.TinyImageDimension != nil {
		return false
	} else if that1.TinyImageDimension != nil {
		return false
	}
	return true
}
func (this *TrackingOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 32)
	s = append(s, "&tracking.TrackingOptions{")
	if this.InternalTrackingDirection != nil {
		s = append(s, "InternalTrackingDirection: "+valueToGoStringRegionFlowComputation(this.InternalTrackingDirection, "TrackingOptions_FlowDirection")+",\n")
	}
	if this.OutputFlowDirection != nil {
		s = append(s, "OutputFlowDirection: "+valueToGoStringRegionFlowComputation(this.OutputFlowDirection, "TrackingOptions_FlowDirection")+",\n")
	}
	if this.TrackingPolicy != nil {
		s = append(s, "TrackingPolicy: "+valueToGoStringRegionFlowComputation(this.TrackingPolicy, "TrackingOptions_TrackingPolicy")+",\n")
	}
	if this.MultiFramesToTrack != nil {
		s = append(s, "MultiFramesToTrack: "+valueToGoStringRegionFlowComputation(this.MultiFramesToTrack, "int32")+",\n")
	}
	if this.LongTracksMaxFrames != nil {
		s = append(s, "LongTracksMaxFrames: "+valueToGoStringRegionFlowComputation(this.LongTracksMaxFrames, "int32")+",\n")
	}
	if this.MaxFeatures != nil {
		s = append(s, "MaxFeatures: "+valueToGoStringRegionFlowComputation(this.MaxFeatures, "int32")+",\n")
	}
	if this.CornerExtractionMethod != nil {
		s = append(s, "CornerExtractionMethod: "+valueToGoStringRegionFlowComputation(this.CornerExtractionMethod, "TrackingOptions_CornerExtractionMethod")+",\n")
	}
	if this.MinEigValSettings != nil {
		s = append(s, "MinEigValSettings: "+fmt.Sprintf("%#v", this.MinEigValSettings)+",\n")
	}
	if this.HarrisSettings != nil {
		s = append(s, "HarrisSettings: "+fmt.Sprintf("%#v", this.HarrisSettings)+",\n")
	}
	if this.FastSettings != nil {
		s = append(s, "FastSettings: "+fmt.Sprintf("%#v", this.FastSettings)+",\n")
	}
	if this.TrackingWindowSize != nil {
		s = append(s, "TrackingWindowSize: "+valueToGoStringRegionFlowComputation(this.TrackingWindowSize, "int32")+",\n")
	}
	if this.TrackingIterations != nil {
		s = append(s, "TrackingIterations: "+valueToGoStringRegionFlowComputation(this.TrackingIterations, "int32")+",\n")
	}
	if this.FractionalTrackingDistance != nil {
		s = append(s, "FractionalTrackingDistance: "+valueToGoStringRegionFlowComputation(this.FractionalTrackingDistance, "float32")+",\n")
	}
	if this.AdaptiveTrackingDistance != nil {
		s = append(s, "AdaptiveTrackingDistance: "+valueToGoStringRegionFlowComputation(this.AdaptiveTrackingDistance, "bool")+",\n")
	}
	if this.MinFeatureDistance != nil {
		s = append(s, "MinFeatureDistance: "+valueToGoStringRegionFlowComputation(this.MinFeatureDistance, "float32")+",\n")
	}
	if this.DistanceDownscaleSqrt != nil {
		s = append(s, "DistanceDownscaleSqrt: "+valueToGoStringRegionFlowComputation(this.DistanceDownscaleSqrt, "bool")+",\n")
	}
	if this.AdaptiveGoodFeaturesToTrack != nil {
		s = append(s, "AdaptiveGoodFeaturesToTrack: "+valueToGoStringRegionFlowComputation(this.AdaptiveGoodFeaturesToTrack, "bool")+",\n")
	}
	if this.AdaptiveFeaturesBlockSize != nil {
		s = append(s, "AdaptiveFeaturesBlockSize: "+valueToGoStringRegionFlowComputation(this.AdaptiveFeaturesBlockSize, "float32")+",\n")
	}
	if this.AdaptiveFeaturesLevels != nil {
		s = append(s, "AdaptiveFeaturesLevels: "+valueToGoStringRegionFlowComputation(this.AdaptiveFeaturesLevels, "int32")+",\n")
	}
	if this.AdaptiveExtractionLevels != nil {
		s = append(s, "AdaptiveExtractionLevels: "+valueToGoStringRegionFlowComputation(this.AdaptiveExtractionLevels, "int32")+",\n")
	}
	if this.AdaptiveExtractionLevelsLowestSize != nil {
		s = append(s, "AdaptiveExtractionLevelsLowestSize: "+valueToGoStringRegionFlowComputation(this.AdaptiveExtractionLevelsLowestSize, "int32")+",\n")
	}
	if this.SyntheticZeroMotionGridStep != nil {
		s = append(s, "SyntheticZeroMotionGridStep: "+valueToGoStringRegionFlowComputation(this.SyntheticZeroMotionGridStep, "float32")+",\n")
	}
	if this.WideBaselineMatching != nil {
		s = append(s, "WideBaselineMatching: "+valueToGoStringRegionFlowComputation(this.WideBaselineMatching, "bool")+",\n")
	}
	if this.RatioTestThreshold != nil {
		s = append(s, "RatioTestThreshold: "+valueToGoStringRegionFlowComputation(this.RatioTestThreshold, "float32")+",\n")
	}
	if this.RefineWideBaselineMatches != nil {
		s = append(s, "RefineWideBaselineMatches: "+valueToGoStringRegionFlowComputation(this.RefineWideBaselineMatches, "bool")+",\n")
	}
	if this.ReuseFeaturesMaxFrameDistance != nil {
		s = append(s, "ReuseFeaturesMaxFrameDistance: "+valueToGoStringRegionFlowComputation(this.ReuseFeaturesMaxFrameDistance, "int32")+",\n")
	}
	if this.ReuseFeaturesMinSurvivedFrac != nil {
		s = append(s, "ReuseFeaturesMinSurvivedFrac: "+valueToGoStringRegionFlowComputation(this.ReuseFeaturesMinSurvivedFrac, "float32")+",\n")
	}
	if this.KltTrackerImplementation != nil {
		s = append(s, "KltTrackerImplementation: "+valueToGoStringRegionFlowComputation(this.KltTrackerImplementation, "TrackingOptions_KltTrackerImplementation")+",\n")
	}
	s = append(s, "XXX_InternalExtensions: "+extensionToGoStringRegionFlowComputation(this)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingOptions_MinEigValExtractionSettings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.TrackingOptions_MinEigValExtractionSettings{")
	if this.FeatureQualityLevel != nil {
		s = append(s, "FeatureQualityLevel: "+valueToGoStringRegionFlowComputation(this.FeatureQualityLevel, "float32")+",\n")
	}
	if this.AdaptiveLowestQualityLevel != nil {
		s = append(s, "AdaptiveLowestQualityLevel: "+valueToGoStringRegionFlowComputation(this.AdaptiveLowestQualityLevel, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingOptions_HarrisExtractionSettings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.TrackingOptions_HarrisExtractionSettings{")
	if this.FeatureQualityLevel != nil {
		s = append(s, "FeatureQualityLevel: "+valueToGoStringRegionFlowComputation(this.FeatureQualityLevel, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackingOptions_FastExtractionSettings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.TrackingOptions_FastExtractionSettings{")
	if this.Threshold != nil {
		s = append(s, "Threshold: "+valueToGoStringRegionFlowComputation(this.Threshold, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegionFlowComputationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 57)
	s = append(s, "&tracking.RegionFlowComputationOptions{")
	if this.TrackingOptions != nil {
		s = append(s, "TrackingOptions: "+fmt.Sprintf("%#v", this.TrackingOptions)+",\n")
	}
	if this.MinFeatureInliers != nil {
		s = append(s, "MinFeatureInliers: "+valueToGoStringRegionFlowComputation(this.MinFeatureInliers, "int32")+",\n")
	}
	if this.RelativeMinFeatureInliers != nil {
		s = append(s, "RelativeMinFeatureInliers: "+valueToGoStringRegionFlowComputation(this.RelativeMinFeatureInliers, "float32")+",\n")
	}
	if this.PreBlurSigma != nil {
		s = append(s, "PreBlurSigma: "+valueToGoStringRegionFlowComputation(this.PreBlurSigma, "float32")+",\n")
	}
	if this.RansacRoundsPerRegion != nil {
		s = append(s, "RansacRoundsPerRegion: "+valueToGoStringRegionFlowComputation(this.RansacRoundsPerRegion, "int32")+",\n")
	}
	if this.AbsoluteInlierErrorThreshold != nil {
		s = append(s, "AbsoluteInlierErrorThreshold: "+valueToGoStringRegionFlowComputation(this.AbsoluteInlierErrorThreshold, "float32")+",\n")
	}
	if this.FracInlierErrorThreshold != nil {
		s = append(s, "FracInlierErrorThreshold: "+valueToGoStringRegionFlowComputation(this.FracInlierErrorThreshold, "float32")+",\n")
	}
	if this.RelativeInlierErrorThreshold != nil {
		s = append(s, "RelativeInlierErrorThreshold: "+valueToGoStringRegionFlowComputation(this.RelativeInlierErrorThreshold, "float32")+",\n")
	}
	if this.TopInlierSets != nil {
		s = append(s, "TopInlierSets: "+valueToGoStringRegionFlowComputation(this.TopInlierSets, "int32")+",\n")
	}
	if this.NoEstimationMode != nil {
		s = append(s, "NoEstimationMode: "+valueToGoStringRegionFlowComputation(this.NoEstimationMode, "bool")+",\n")
	}
	if this.FastEstimationBlockSize != nil {
		s = append(s, "FastEstimationBlockSize: "+valueToGoStringRegionFlowComputation(this.FastEstimationBlockSize, "float32")+",\n")
	}
	if this.FastEstimationMinBlockSize != nil {
		s = append(s, "FastEstimationMinBlockSize: "+valueToGoStringRegionFlowComputation(this.FastEstimationMinBlockSize, "int32")+",\n")
	}
	if this.FastEstimationOverlapGrids != nil {
		s = append(s, "FastEstimationOverlapGrids: "+valueToGoStringRegionFlowComputation(this.FastEstimationOverlapGrids, "int32")+",\n")
	}
	if this.MaxMagnitudeThresholdRatio != nil {
		s = append(s, "MaxMagnitudeThresholdRatio: "+valueToGoStringRegionFlowComputation(this.MaxMagnitudeThresholdRatio, "float32")+",\n")
	}
	if this.MedianMagnitudeBounds != nil {
		s = append(s, "MedianMagnitudeBounds: "+valueToGoStringRegionFlowComputation(this.MedianMagnitudeBounds, "float32")+",\n")
	}
	if this.IrlsInitialization != nil {
		s = append(s, "IrlsInitialization: "+valueToGoStringRegionFlowComputation(this.IrlsInitialization, "RegionFlowComputationOptions_IrlsInitialization")+",\n")
	}
	if this.DownsampleMode != nil {
		s = append(s, "DownsampleMode: "+valueToGoStringRegionFlowComputation(this.DownsampleMode, "RegionFlowComputationOptions_DownsampleMode")+",\n")
	}
	if this.DownsamplingSize != nil {
		s = append(s, "DownsamplingSize: "+valueToGoStringRegionFlowComputation(this.DownsamplingSize, "int32")+",\n")
	}
	if this.DownsampleFactor != nil {
		s = append(s, "DownsampleFactor: "+valueToGoStringRegionFlowComputation(this.DownsampleFactor, "float32")+",\n")
	}
	if this.RoundDownsampleFactor != nil {
		s = append(s, "RoundDownsampleFactor: "+valueToGoStringRegionFlowComputation(this.RoundDownsampleFactor, "bool")+",\n")
	}
	if this.DownsampleSchedule != nil {
		s = append(s, "DownsampleSchedule: "+fmt.Sprintf("%#v", this.DownsampleSchedule)+",\n")
	}
	if this.MinFeatureRequirement != nil {
		s = append(s, "MinFeatureRequirement: "+valueToGoStringRegionFlowComputation(this.MinFeatureRequirement, "int32")+",\n")
	}
	if this.MinFeatureCover != nil {
		s = append(s, "MinFeatureCover: "+valueToGoStringRegionFlowComputation(this.MinFeatureCover, "float32")+",\n")
	}
	if this.MinFeatureCoverGrid != nil {
		s = append(s, "MinFeatureCoverGrid: "+valueToGoStringRegionFlowComputation(this.MinFeatureCoverGrid, "int32")+",\n")
	}
	if this.ComputeBlurScore != nil {
		s = append(s, "ComputeBlurScore: "+valueToGoStringRegionFlowComputation(this.ComputeBlurScore, "bool")+",\n")
	}
	if this.BlurScoreOptions != nil {
		s = append(s, "BlurScoreOptions: "+fmt.Sprintf("%#v", this.BlurScoreOptions)+",\n")
	}
	if this.VisualConsistencyOptions != nil {
		s = append(s, "VisualConsistencyOptions: "+fmt.Sprintf("%#v", this.VisualConsistencyOptions)+",\n")
	}
	if this.PatchDescriptorRadius != nil {
		s = append(s, "PatchDescriptorRadius: "+valueToGoStringRegionFlowComputation(this.PatchDescriptorRadius, "int32")+",\n")
	}
	if this.DistanceFromBorder != nil {
		s = append(s, "DistanceFromBorder: "+valueToGoStringRegionFlowComputation(this.DistanceFromBorder, "int32")+",\n")
	}
	if this.CornerResponseScale != nil {
		s = append(s, "CornerResponseScale: "+valueToGoStringRegionFlowComputation(this.CornerResponseScale, "float32")+",\n")
	}
	if this.VerifyFeatures != nil {
		s = append(s, "VerifyFeatures: "+valueToGoStringRegionFlowComputation(this.VerifyFeatures, "bool")+",\n")
	}
	if this.VerificationDistance != nil {
		s = append(s, "VerificationDistance: "+valueToGoStringRegionFlowComputation(this.VerificationDistance, "float32")+",\n")
	}
	if this.VerifyLongFeatures != nil {
		s = append(s, "VerifyLongFeatures: "+valueToGoStringRegionFlowComputation(this.VerifyLongFeatures, "bool")+",\n")
	}
	if this.LongFeatureVerificationThreshold != nil {
		s = append(s, "LongFeatureVerificationThreshold: "+valueToGoStringRegionFlowComputation(this.LongFeatureVerificationThreshold, "float32")+",\n")
	}
	if this.MaxLongFeatureAcceleration != nil {
		s = append(s, "MaxLongFeatureAcceleration: "+valueToGoStringRegionFlowComputation(this.MaxLongFeatureAcceleration, "float32")+",\n")
	}
	if this.VerifyLongFeatureAcceleration != nil {
		s = append(s, "VerifyLongFeatureAcceleration: "+valueToGoStringRegionFlowComputation(this.VerifyLongFeatureAcceleration, "bool")+",\n")
	}
	if this.VerifyLongFeatureTriggerRatio != nil {
		s = append(s, "VerifyLongFeatureTriggerRatio: "+valueToGoStringRegionFlowComputation(this.VerifyLongFeatureTriggerRatio, "float32")+",\n")
	}
	if this.HistogramEqualization != nil {
		s = append(s, "HistogramEqualization: "+valueToGoStringRegionFlowComputation(this.HistogramEqualization, "bool")+",\n")
	}
	if this.UseSyntheticZeroMotionTracksAllFrames != nil {
		s = append(s, "UseSyntheticZeroMotionTracksAllFrames: "+valueToGoStringRegionFlowComputation(this.UseSyntheticZeroMotionTracksAllFrames, "bool")+",\n")
	}
	if this.UseSyntheticZeroMotionTracksFirstFrame != nil {
		s = append(s, "UseSyntheticZeroMotionTracksFirstFrame: "+valueToGoStringRegionFlowComputation(this.UseSyntheticZeroMotionTracksFirstFrame, "bool")+",\n")
	}
	if this.GainCorrection != nil {
		s = append(s, "GainCorrection: "+valueToGoStringRegionFlowComputation(this.GainCorrection, "bool")+",\n")
	}
	if this.FastGainCorrection != nil {
		s = append(s, "FastGainCorrection: "+valueToGoStringRegionFlowComputation(this.FastGainCorrection, "bool")+",\n")
	}
	if this.GainCorrectionMultipleHypotheses != nil {
		s = append(s, "GainCorrectionMultipleHypotheses: "+valueToGoStringRegionFlowComputation(this.GainCorrectionMultipleHypotheses, "bool")+",\n")
	}
	if this.GainCorrectionInlierImprovementFrac != nil {
		s = append(s, "GainCorrectionInlierImprovementFrac: "+valueToGoStringRegionFlowComputation(this.GainCorrectionInlierImprovementFrac, "float32")+",\n")
	}
	if this.GainCorrectionBrightReference != nil {
		s = append(s, "GainCorrectionBrightReference: "+valueToGoStringRegionFlowComputation(this.GainCorrectionBrightReference, "bool")+",\n")
	}
	if this.GainCorrectionTriggeringRatio != nil {
		s = append(s, "GainCorrectionTriggeringRatio: "+valueToGoStringRegionFlowComputation(this.GainCorrectionTriggeringRatio, "float32")+",\n")
	}
	if this.FracGainFeatureSize != nil {
		s = append(s, "FracGainFeatureSize: "+valueToGoStringRegionFlowComputation(this.FracGainFeatureSize, "float32")+",\n")
	}
	if this.FracGainStep != nil {
		s = append(s, "FracGainStep: "+valueToGoStringRegionFlowComputation(this.FracGainStep, "float32")+",\n")
	}
	if this.GainCorrectMode != nil {
		s = append(s, "GainCorrectMode: "+valueToGoStringRegionFlowComputation(this.GainCorrectMode, "RegionFlowComputationOptions_GainCorrectMode")+",\n")
	}
	if this.GainBiasBounds != nil {
		s = append(s, "GainBiasBounds: "+fmt.Sprintf("%#v", this.GainBiasBounds)+",\n")
	}
	if this.ImageFormat != nil {
		s = append(s, "ImageFormat: "+valueToGoStringRegionFlowComputation(this.ImageFormat, "RegionFlowComputationOptions_ImageFormat")+",\n")
	}
	if this.DescriptorExtractorType != nil {
		s = append(s, "DescriptorExtractorType: "+valueToGoStringRegionFlowComputation(this.DescriptorExtractorType, "RegionFlowComputationOptions_DescriptorExtractorType")+",\n")
	}
	if this.ComputeDerivativeInPyramid != nil {
		s = append(s, "ComputeDerivativeInPyramid: "+valueToGoStringRegionFlowComputation(this.ComputeDerivativeInPyramid, "bool")+",\n")
	}
	s = append(s, "XXX_InternalExtensions: "+extensionToGoStringRegionFlowComputation(this)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegionFlowComputationOptions_DownSampleSchedule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.RegionFlowComputationOptions_DownSampleSchedule{")
	if this.DownsampleFactor_360P != nil {
		s = append(s, "DownsampleFactor_360P: "+valueToGoStringRegionFlowComputation(this.DownsampleFactor_360P, "float32")+",\n")
	}
	if this.DownsampleFactor_480P != nil {
		s = append(s, "DownsampleFactor_480P: "+valueToGoStringRegionFlowComputation(this.DownsampleFactor_480P, "float32")+",\n")
	}
	if this.DownsampleFactor_720P != nil {
		s = append(s, "DownsampleFactor_720P: "+valueToGoStringRegionFlowComputation(this.DownsampleFactor_720P, "float32")+",\n")
	}
	if this.DownsampleFactor_1080P != nil {
		s = append(s, "DownsampleFactor_1080P: "+valueToGoStringRegionFlowComputation(this.DownsampleFactor_1080P, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegionFlowComputationOptions_BlurScoreOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.RegionFlowComputationOptions_BlurScoreOptions{")
	if this.BoxFilterDiam != nil {
		s = append(s, "BoxFilterDiam: "+valueToGoStringRegionFlowComputation(this.BoxFilterDiam, "int32")+",\n")
	}
	if this.RelativeCornernessThreshold != nil {
		s = append(s, "RelativeCornernessThreshold: "+valueToGoStringRegionFlowComputation(this.RelativeCornernessThreshold, "float32")+",\n")
	}
	if this.AbsoluteCornernessThreshold != nil {
		s = append(s, "AbsoluteCornernessThreshold: "+valueToGoStringRegionFlowComputation(this.AbsoluteCornernessThreshold, "float32")+",\n")
	}
	if this.MedianPercentile != nil {
		s = append(s, "MedianPercentile: "+valueToGoStringRegionFlowComputation(this.MedianPercentile, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegionFlowComputationOptions_VisualConsistencyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.RegionFlowComputationOptions_VisualConsistencyOptions{")
	if this.ComputeConsistency != nil {
		s = append(s, "ComputeConsistency: "+valueToGoStringRegionFlowComputation(this.ComputeConsistency, "bool")+",\n")
	}
	if this.TinyImageDimension != nil {
		s = append(s, "TinyImageDimension: "+valueToGoStringRegionFlowComputation(this.TinyImageDimension, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRegionFlowComputation(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringRegionFlowComputation(m github_com_gogo_protobuf_proto.Message) string {
	e := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *TrackingOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.KltTrackerImplementation != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.KltTrackerImplementation))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.FastSettings != nil {
		{
			size, err := m.FastSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.HarrisSettings != nil {
		{
			size, err := m.HarrisSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.MinEigValSettings != nil {
		{
			size, err := m.MinEigValSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.CornerExtractionMethod != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.CornerExtractionMethod))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.LongTracksMaxFrames != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.LongTracksMaxFrames))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.TrackingPolicy != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.TrackingPolicy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.AdaptiveTrackingDistance != nil {
		i--
		if *m.AdaptiveTrackingDistance {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.AdaptiveExtractionLevelsLowestSize != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.AdaptiveExtractionLevelsLowestSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.AdaptiveExtractionLevels != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.AdaptiveExtractionLevels))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.DistanceDownscaleSqrt != nil {
		i--
		if *m.DistanceDownscaleSqrt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.OutputFlowDirection != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.OutputFlowDirection))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.InternalTrackingDirection != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.InternalTrackingDirection))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ReuseFeaturesMinSurvivedFrac != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ReuseFeaturesMinSurvivedFrac))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.ReuseFeaturesMaxFrameDistance != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.ReuseFeaturesMaxFrameDistance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.RefineWideBaselineMatches != nil {
		i--
		if *m.RefineWideBaselineMatches {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RatioTestThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RatioTestThreshold))))
		i--
		dAtA[i] = 0x7d
	}
	if m.WideBaselineMatching != nil {
		i--
		if *m.WideBaselineMatching {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.SyntheticZeroMotionGridStep != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.SyntheticZeroMotionGridStep))))
		i--
		dAtA[i] = 0x6d
	}
	if m.AdaptiveFeaturesLevels != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.AdaptiveFeaturesLevels))
		i--
		dAtA[i] = 0x50
	}
	if m.AdaptiveFeaturesBlockSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AdaptiveFeaturesBlockSize))))
		i--
		dAtA[i] = 0x4d
	}
	if m.AdaptiveGoodFeaturesToTrack != nil {
		i--
		if *m.AdaptiveGoodFeaturesToTrack {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.MinFeatureDistance != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinFeatureDistance))))
		i--
		dAtA[i] = 0x3d
	}
	if m.FractionalTrackingDistance != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FractionalTrackingDistance))))
		i--
		dAtA[i] = 0x35
	}
	if m.TrackingIterations != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.TrackingIterations))
		i--
		dAtA[i] = 0x28
	}
	if m.TrackingWindowSize != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.TrackingWindowSize))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxFeatures != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.MaxFeatures))
		i--
		dAtA[i] = 0x10
	}
	if m.MultiFramesToTrack != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.MultiFramesToTrack))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrackingOptions_MinEigValExtractionSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingOptions_MinEigValExtractionSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingOptions_MinEigValExtractionSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdaptiveLowestQualityLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AdaptiveLowestQualityLevel))))
		i--
		dAtA[i] = 0x15
	}
	if m.FeatureQualityLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FeatureQualityLevel))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *TrackingOptions_HarrisExtractionSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingOptions_HarrisExtractionSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingOptions_HarrisExtractionSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeatureQualityLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FeatureQualityLevel))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *TrackingOptions_FastExtractionSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackingOptions_FastExtractionSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackingOptions_FastExtractionSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.Threshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionFlowComputationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionFlowComputationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionFlowComputationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.ComputeDerivativeInPyramid != nil {
		i--
		if *m.ComputeDerivativeInPyramid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.DescriptorExtractorType != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.DescriptorExtractorType))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.VerifyLongFeatureTriggerRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.VerifyLongFeatureTriggerRatio))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x85
	}
	if m.VerifyLongFeatureAcceleration != nil {
		i--
		if *m.VerifyLongFeatureAcceleration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.RoundDownsampleFactor != nil {
		i--
		if *m.RoundDownsampleFactor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.FastGainCorrection != nil {
		i--
		if *m.FastGainCorrection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.GainCorrectionTriggeringRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.GainCorrectionTriggeringRatio))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe5
	}
	if m.GainCorrectionBrightReference != nil {
		i--
		if *m.GainCorrectionBrightReference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.ImageFormat != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.ImageFormat))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.HistogramEqualization != nil {
		i--
		if *m.HistogramEqualization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxLongFeatureAcceleration != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxLongFeatureAcceleration))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc5
	}
	if m.VisualConsistencyOptions != nil {
		{
			size, err := m.VisualConsistencyOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xba
	}
	if m.LongFeatureVerificationThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LongFeatureVerificationThreshold))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb5
	}
	if m.VerifyLongFeatures != nil {
		i--
		if *m.VerifyLongFeatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.FracInlierErrorThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracInlierErrorThreshold))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.MedianMagnitudeBounds != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MedianMagnitudeBounds))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.DistanceFromBorder != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.DistanceFromBorder))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.IrlsInitialization != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.IrlsInitialization))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.GainCorrectionInlierImprovementFrac != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.GainCorrectionInlierImprovementFrac))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x85
	}
	if m.GainCorrectionMultipleHypotheses != nil {
		i--
		if *m.GainCorrectionMultipleHypotheses {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.RelativeMinFeatureInliers != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RelativeMinFeatureInliers))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf5
	}
	if m.TopInlierSets != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.TopInlierSets))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.RelativeInlierErrorThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RelativeInlierErrorThreshold))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe5
	}
	if m.GainCorrectMode != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.GainCorrectMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.NoEstimationMode != nil {
		i--
		if *m.NoEstimationMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.GainBiasBounds != nil {
		{
			size, err := m.GainBiasBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.FracGainStep != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracGainStep))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb5
	}
	if m.FracGainFeatureSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracGainFeatureSize))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.GainCorrection != nil {
		i--
		if *m.GainCorrection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.UseSyntheticZeroMotionTracksFirstFrame != nil {
		i--
		if *m.UseSyntheticZeroMotionTracksFirstFrame {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.UseSyntheticZeroMotionTracksAllFrames != nil {
		i--
		if *m.UseSyntheticZeroMotionTracksAllFrames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.PreBlurSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PreBlurSigma))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8d
	}
	if m.BlurScoreOptions != nil {
		{
			size, err := m.BlurScoreOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.VerificationDistance != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.VerificationDistance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.VerifyFeatures != nil {
		i--
		if *m.VerifyFeatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.CornerResponseScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.CornerResponseScale))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd5
	}
	if m.FastEstimationMinBlockSize != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.FastEstimationMinBlockSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxMagnitudeThresholdRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxMagnitudeThresholdRatio))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.FastEstimationOverlapGrids != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.FastEstimationOverlapGrids))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.PatchDescriptorRadius != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.PatchDescriptorRadius))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MinFeatureCoverGrid != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.MinFeatureCoverGrid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DownsampleSchedule != nil {
		{
			size, err := m.DownsampleSchedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.DownsampleFactor != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.ComputeBlurScore != nil {
		i--
		if *m.ComputeBlurScore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.MinFeatureCover != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinFeatureCover))))
		i--
		dAtA[i] = 0x75
	}
	if m.MinFeatureRequirement != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.MinFeatureRequirement))
		i--
		dAtA[i] = 0x68
	}
	if m.DownsamplingSize != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.DownsamplingSize))
		i--
		dAtA[i] = 0x60
	}
	if m.DownsampleMode != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.DownsampleMode))
		i--
		dAtA[i] = 0x58
	}
	if m.FastEstimationBlockSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FastEstimationBlockSize))))
		i--
		dAtA[i] = 0x35
	}
	if m.AbsoluteInlierErrorThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AbsoluteInlierErrorThreshold))))
		i--
		dAtA[i] = 0x25
	}
	if m.RansacRoundsPerRegion != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.RansacRoundsPerRegion))
		i--
		dAtA[i] = 0x18
	}
	if m.MinFeatureInliers != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.MinFeatureInliers))
		i--
		dAtA[i] = 0x10
	}
	if m.TrackingOptions != nil {
		{
			size, err := m.TrackingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegionFlowComputation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownsampleFactor_1080P != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor_1080P))))
		i--
		dAtA[i] = 0x25
	}
	if m.DownsampleFactor_720P != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor_720P))))
		i--
		dAtA[i] = 0x1d
	}
	if m.DownsampleFactor_480P != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor_480P))))
		i--
		dAtA[i] = 0x15
	}
	if m.DownsampleFactor_360P != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor_360P))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MedianPercentile))))
		i--
		dAtA[i] = 0x2d
	}
	if m.AbsoluteCornernessThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.AbsoluteCornernessThreshold))))
		i--
		dAtA[i] = 0x1d
	}
	if m.RelativeCornernessThreshold != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RelativeCornernessThreshold))))
		i--
		dAtA[i] = 0x15
	}
	if m.BoxFilterDiam != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.BoxFilterDiam))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TinyImageDimension != nil {
		i = encodeVarintRegionFlowComputation(dAtA, i, uint64(*m.TinyImageDimension))
		i--
		dAtA[i] = 0x10
	}
	if m.ComputeConsistency != nil {
		i--
		if *m.ComputeConsistency {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRegionFlowComputation(dAtA []byte, offset int, v uint64) int {
	offset -= sovRegionFlowComputation(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TrackingOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiFramesToTrack != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.MultiFramesToTrack))
	}
	if m.MaxFeatures != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.MaxFeatures))
	}
	if m.TrackingWindowSize != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.TrackingWindowSize))
	}
	if m.TrackingIterations != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.TrackingIterations))
	}
	if m.FractionalTrackingDistance != nil {
		n += 5
	}
	if m.MinFeatureDistance != nil {
		n += 5
	}
	if m.AdaptiveGoodFeaturesToTrack != nil {
		n += 2
	}
	if m.AdaptiveFeaturesBlockSize != nil {
		n += 5
	}
	if m.AdaptiveFeaturesLevels != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.AdaptiveFeaturesLevels))
	}
	if m.SyntheticZeroMotionGridStep != nil {
		n += 5
	}
	if m.WideBaselineMatching != nil {
		n += 2
	}
	if m.RatioTestThreshold != nil {
		n += 5
	}
	if m.RefineWideBaselineMatches != nil {
		n += 3
	}
	if m.ReuseFeaturesMaxFrameDistance != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.ReuseFeaturesMaxFrameDistance))
	}
	if m.ReuseFeaturesMinSurvivedFrac != nil {
		n += 6
	}
	if m.InternalTrackingDirection != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.InternalTrackingDirection))
	}
	if m.OutputFlowDirection != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.OutputFlowDirection))
	}
	if m.DistanceDownscaleSqrt != nil {
		n += 3
	}
	if m.AdaptiveExtractionLevels != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.AdaptiveExtractionLevels))
	}
	if m.AdaptiveExtractionLevelsLowestSize != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.AdaptiveExtractionLevelsLowestSize))
	}
	if m.AdaptiveTrackingDistance != nil {
		n += 3
	}
	if m.TrackingPolicy != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.TrackingPolicy))
	}
	if m.LongTracksMaxFrames != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.LongTracksMaxFrames))
	}
	if m.CornerExtractionMethod != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.CornerExtractionMethod))
	}
	if m.MinEigValSettings != nil {
		l = m.MinEigValSettings.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.HarrisSettings != nil {
		l = m.HarrisSettings.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.FastSettings != nil {
		l = m.FastSettings.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.KltTrackerImplementation != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.KltTrackerImplementation))
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *TrackingOptions_MinEigValExtractionSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeatureQualityLevel != nil {
		n += 5
	}
	if m.AdaptiveLowestQualityLevel != nil {
		n += 5
	}
	return n
}

func (m *TrackingOptions_HarrisExtractionSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeatureQualityLevel != nil {
		n += 5
	}
	return n
}

func (m *TrackingOptions_FastExtractionSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threshold != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.Threshold))
	}
	return n
}

func (m *RegionFlowComputationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackingOptions != nil {
		l = m.TrackingOptions.Size()
		n += 1 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.MinFeatureInliers != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.MinFeatureInliers))
	}
	if m.RansacRoundsPerRegion != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.RansacRoundsPerRegion))
	}
	if m.AbsoluteInlierErrorThreshold != nil {
		n += 5
	}
	if m.FastEstimationBlockSize != nil {
		n += 5
	}
	if m.DownsampleMode != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.DownsampleMode))
	}
	if m.DownsamplingSize != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.DownsamplingSize))
	}
	if m.MinFeatureRequirement != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.MinFeatureRequirement))
	}
	if m.MinFeatureCover != nil {
		n += 5
	}
	if m.ComputeBlurScore != nil {
		n += 3
	}
	if m.DownsampleFactor != nil {
		n += 6
	}
	if m.DownsampleSchedule != nil {
		l = m.DownsampleSchedule.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.MinFeatureCoverGrid != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.MinFeatureCoverGrid))
	}
	if m.PatchDescriptorRadius != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.PatchDescriptorRadius))
	}
	if m.FastEstimationOverlapGrids != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.FastEstimationOverlapGrids))
	}
	if m.MaxMagnitudeThresholdRatio != nil {
		n += 6
	}
	if m.FastEstimationMinBlockSize != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.FastEstimationMinBlockSize))
	}
	if m.CornerResponseScale != nil {
		n += 6
	}
	if m.VerifyFeatures != nil {
		n += 3
	}
	if m.VerificationDistance != nil {
		n += 6
	}
	if m.BlurScoreOptions != nil {
		l = m.BlurScoreOptions.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.PreBlurSigma != nil {
		n += 6
	}
	if m.UseSyntheticZeroMotionTracksAllFrames != nil {
		n += 3
	}
	if m.UseSyntheticZeroMotionTracksFirstFrame != nil {
		n += 3
	}
	if m.GainCorrection != nil {
		n += 3
	}
	if m.FracGainFeatureSize != nil {
		n += 6
	}
	if m.FracGainStep != nil {
		n += 6
	}
	if m.GainBiasBounds != nil {
		l = m.GainBiasBounds.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.NoEstimationMode != nil {
		n += 3
	}
	if m.GainCorrectMode != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.GainCorrectMode))
	}
	if m.RelativeInlierErrorThreshold != nil {
		n += 6
	}
	if m.TopInlierSets != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.TopInlierSets))
	}
	if m.RelativeMinFeatureInliers != nil {
		n += 6
	}
	if m.GainCorrectionMultipleHypotheses != nil {
		n += 3
	}
	if m.GainCorrectionInlierImprovementFrac != nil {
		n += 6
	}
	if m.IrlsInitialization != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.IrlsInitialization))
	}
	if m.DistanceFromBorder != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.DistanceFromBorder))
	}
	if m.MedianMagnitudeBounds != nil {
		n += 6
	}
	if m.FracInlierErrorThreshold != nil {
		n += 6
	}
	if m.VerifyLongFeatures != nil {
		n += 3
	}
	if m.LongFeatureVerificationThreshold != nil {
		n += 6
	}
	if m.VisualConsistencyOptions != nil {
		l = m.VisualConsistencyOptions.Size()
		n += 2 + l + sovRegionFlowComputation(uint64(l))
	}
	if m.MaxLongFeatureAcceleration != nil {
		n += 6
	}
	if m.HistogramEqualization != nil {
		n += 3
	}
	if m.ImageFormat != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.ImageFormat))
	}
	if m.GainCorrectionBrightReference != nil {
		n += 3
	}
	if m.GainCorrectionTriggeringRatio != nil {
		n += 6
	}
	if m.FastGainCorrection != nil {
		n += 3
	}
	if m.RoundDownsampleFactor != nil {
		n += 3
	}
	if m.VerifyLongFeatureAcceleration != nil {
		n += 3
	}
	if m.VerifyLongFeatureTriggerRatio != nil {
		n += 6
	}
	if m.DescriptorExtractorType != nil {
		n += 2 + sovRegionFlowComputation(uint64(*m.DescriptorExtractorType))
	}
	if m.ComputeDerivativeInPyramid != nil {
		n += 3
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *RegionFlowComputationOptions_DownSampleSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DownsampleFactor_360P != nil {
		n += 5
	}
	if m.DownsampleFactor_480P != nil {
		n += 5
	}
	if m.DownsampleFactor_720P != nil {
		n += 5
	}
	if m.DownsampleFactor_1080P != nil {
		n += 5
	}
	return n
}

func (m *RegionFlowComputationOptions_BlurScoreOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoxFilterDiam != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.BoxFilterDiam))
	}
	if m.RelativeCornernessThreshold != nil {
		n += 5
	}
	if m.AbsoluteCornernessThreshold != nil {
		n += 5
	}
	if m.MedianPercentile != nil {
		n += 5
	}
	return n
}

func (m *RegionFlowComputationOptions_VisualConsistencyOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComputeConsistency != nil {
		n += 2
	}
	if m.TinyImageDimension != nil {
		n += 1 + sovRegionFlowComputation(uint64(*m.TinyImageDimension))
	}
	return n
}

func sovRegionFlowComputation(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRegionFlowComputation(x uint64) (n int) {
	return sovRegionFlowComputation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TrackingOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingOptions{`,
		`MultiFramesToTrack:` + valueToStringRegionFlowComputation(this.MultiFramesToTrack) + `,`,
		`MaxFeatures:` + valueToStringRegionFlowComputation(this.MaxFeatures) + `,`,
		`TrackingWindowSize:` + valueToStringRegionFlowComputation(this.TrackingWindowSize) + `,`,
		`TrackingIterations:` + valueToStringRegionFlowComputation(this.TrackingIterations) + `,`,
		`FractionalTrackingDistance:` + valueToStringRegionFlowComputation(this.FractionalTrackingDistance) + `,`,
		`MinFeatureDistance:` + valueToStringRegionFlowComputation(this.MinFeatureDistance) + `,`,
		`AdaptiveGoodFeaturesToTrack:` + valueToStringRegionFlowComputation(this.AdaptiveGoodFeaturesToTrack) + `,`,
		`AdaptiveFeaturesBlockSize:` + valueToStringRegionFlowComputation(this.AdaptiveFeaturesBlockSize) + `,`,
		`AdaptiveFeaturesLevels:` + valueToStringRegionFlowComputation(this.AdaptiveFeaturesLevels) + `,`,
		`SyntheticZeroMotionGridStep:` + valueToStringRegionFlowComputation(this.SyntheticZeroMotionGridStep) + `,`,
		`WideBaselineMatching:` + valueToStringRegionFlowComputation(this.WideBaselineMatching) + `,`,
		`RatioTestThreshold:` + valueToStringRegionFlowComputation(this.RatioTestThreshold) + `,`,
		`RefineWideBaselineMatches:` + valueToStringRegionFlowComputation(this.RefineWideBaselineMatches) + `,`,
		`ReuseFeaturesMaxFrameDistance:` + valueToStringRegionFlowComputation(this.ReuseFeaturesMaxFrameDistance) + `,`,
		`ReuseFeaturesMinSurvivedFrac:` + valueToStringRegionFlowComputation(this.ReuseFeaturesMinSurvivedFrac) + `,`,
		`InternalTrackingDirection:` + valueToStringRegionFlowComputation(this.InternalTrackingDirection) + `,`,
		`OutputFlowDirection:` + valueToStringRegionFlowComputation(this.OutputFlowDirection) + `,`,
		`DistanceDownscaleSqrt:` + valueToStringRegionFlowComputation(this.DistanceDownscaleSqrt) + `,`,
		`AdaptiveExtractionLevels:` + valueToStringRegionFlowComputation(this.AdaptiveExtractionLevels) + `,`,
		`AdaptiveExtractionLevelsLowestSize:` + valueToStringRegionFlowComputation(this.AdaptiveExtractionLevelsLowestSize) + `,`,
		`AdaptiveTrackingDistance:` + valueToStringRegionFlowComputation(this.AdaptiveTrackingDistance) + `,`,
		`TrackingPolicy:` + valueToStringRegionFlowComputation(this.TrackingPolicy) + `,`,
		`LongTracksMaxFrames:` + valueToStringRegionFlowComputation(this.LongTracksMaxFrames) + `,`,
		`CornerExtractionMethod:` + valueToStringRegionFlowComputation(this.CornerExtractionMethod) + `,`,
		`MinEigValSettings:` + strings.Replace(fmt.Sprintf("%v", this.MinEigValSettings), "TrackingOptions_MinEigValExtractionSettings", "TrackingOptions_MinEigValExtractionSettings", 1) + `,`,
		`HarrisSettings:` + strings.Replace(fmt.Sprintf("%v", this.HarrisSettings), "TrackingOptions_HarrisExtractionSettings", "TrackingOptions_HarrisExtractionSettings", 1) + `,`,
		`FastSettings:` + strings.Replace(fmt.Sprintf("%v", this.FastSettings), "TrackingOptions_FastExtractionSettings", "TrackingOptions_FastExtractionSettings", 1) + `,`,
		`KltTrackerImplementation:` + valueToStringRegionFlowComputation(this.KltTrackerImplementation) + `,`,
		`XXX_InternalExtensions:` + github_com_gogo_protobuf_proto.StringFromInternalExtension(this) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingOptions_MinEigValExtractionSettings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingOptions_MinEigValExtractionSettings{`,
		`FeatureQualityLevel:` + valueToStringRegionFlowComputation(this.FeatureQualityLevel) + `,`,
		`AdaptiveLowestQualityLevel:` + valueToStringRegionFlowComputation(this.AdaptiveLowestQualityLevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingOptions_HarrisExtractionSettings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingOptions_HarrisExtractionSettings{`,
		`FeatureQualityLevel:` + valueToStringRegionFlowComputation(this.FeatureQualityLevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackingOptions_FastExtractionSettings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackingOptions_FastExtractionSettings{`,
		`Threshold:` + valueToStringRegionFlowComputation(this.Threshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegionFlowComputationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegionFlowComputationOptions{`,
		`TrackingOptions:` + strings.Replace(this.TrackingOptions.String(), "TrackingOptions", "TrackingOptions", 1) + `,`,
		`MinFeatureInliers:` + valueToStringRegionFlowComputation(this.MinFeatureInliers) + `,`,
		`RansacRoundsPerRegion:` + valueToStringRegionFlowComputation(this.RansacRoundsPerRegion) + `,`,
		`AbsoluteInlierErrorThreshold:` + valueToStringRegionFlowComputation(this.AbsoluteInlierErrorThreshold) + `,`,
		`FastEstimationBlockSize:` + valueToStringRegionFlowComputation(this.FastEstimationBlockSize) + `,`,
		`DownsampleMode:` + valueToStringRegionFlowComputation(this.DownsampleMode) + `,`,
		`DownsamplingSize:` + valueToStringRegionFlowComputation(this.DownsamplingSize) + `,`,
		`MinFeatureRequirement:` + valueToStringRegionFlowComputation(this.MinFeatureRequirement) + `,`,
		`MinFeatureCover:` + valueToStringRegionFlowComputation(this.MinFeatureCover) + `,`,
		`ComputeBlurScore:` + valueToStringRegionFlowComputation(this.ComputeBlurScore) + `,`,
		`DownsampleFactor:` + valueToStringRegionFlowComputation(this.DownsampleFactor) + `,`,
		`DownsampleSchedule:` + strings.Replace(fmt.Sprintf("%v", this.DownsampleSchedule), "RegionFlowComputationOptions_DownSampleSchedule", "RegionFlowComputationOptions_DownSampleSchedule", 1) + `,`,
		`MinFeatureCoverGrid:` + valueToStringRegionFlowComputation(this.MinFeatureCoverGrid) + `,`,
		`PatchDescriptorRadius:` + valueToStringRegionFlowComputation(this.PatchDescriptorRadius) + `,`,
		`FastEstimationOverlapGrids:` + valueToStringRegionFlowComputation(this.FastEstimationOverlapGrids) + `,`,
		`MaxMagnitudeThresholdRatio:` + valueToStringRegionFlowComputation(this.MaxMagnitudeThresholdRatio) + `,`,
		`FastEstimationMinBlockSize:` + valueToStringRegionFlowComputation(this.FastEstimationMinBlockSize) + `,`,
		`CornerResponseScale:` + valueToStringRegionFlowComputation(this.CornerResponseScale) + `,`,
		`VerifyFeatures:` + valueToStringRegionFlowComputation(this.VerifyFeatures) + `,`,
		`VerificationDistance:` + valueToStringRegionFlowComputation(this.VerificationDistance) + `,`,
		`BlurScoreOptions:` + strings.Replace(fmt.Sprintf("%v", this.BlurScoreOptions), "RegionFlowComputationOptions_BlurScoreOptions", "RegionFlowComputationOptions_BlurScoreOptions", 1) + `,`,
		`PreBlurSigma:` + valueToStringRegionFlowComputation(this.PreBlurSigma) + `,`,
		`UseSyntheticZeroMotionTracksAllFrames:` + valueToStringRegionFlowComputation(this.UseSyntheticZeroMotionTracksAllFrames) + `,`,
		`UseSyntheticZeroMotionTracksFirstFrame:` + valueToStringRegionFlowComputation(this.UseSyntheticZeroMotionTracksFirstFrame) + `,`,
		`GainCorrection:` + valueToStringRegionFlowComputation(this.GainCorrection) + `,`,
		`FracGainFeatureSize:` + valueToStringRegionFlowComputation(this.FracGainFeatureSize) + `,`,
		`FracGainStep:` + valueToStringRegionFlowComputation(this.FracGainStep) + `,`,
		`GainBiasBounds:` + strings.Replace(fmt.Sprintf("%v", this.GainBiasBounds), "ToneEstimationOptions_GainBiasBounds", "ToneEstimationOptions_GainBiasBounds", 1) + `,`,
		`NoEstimationMode:` + valueToStringRegionFlowComputation(this.NoEstimationMode) + `,`,
		`GainCorrectMode:` + valueToStringRegionFlowComputation(this.GainCorrectMode) + `,`,
		`RelativeInlierErrorThreshold:` + valueToStringRegionFlowComputation(this.RelativeInlierErrorThreshold) + `,`,
		`TopInlierSets:` + valueToStringRegionFlowComputation(this.TopInlierSets) + `,`,
		`RelativeMinFeatureInliers:` + valueToStringRegionFlowComputation(this.RelativeMinFeatureInliers) + `,`,
		`GainCorrectionMultipleHypotheses:` + valueToStringRegionFlowComputation(this.GainCorrectionMultipleHypotheses) + `,`,
		`GainCorrectionInlierImprovementFrac:` + valueToStringRegionFlowComputation(this.GainCorrectionInlierImprovementFrac) + `,`,
		`IrlsInitialization:` + valueToStringRegionFlowComputation(this.IrlsInitialization) + `,`,
		`DistanceFromBorder:` + valueToStringRegionFlowComputation(this.DistanceFromBorder) + `,`,
		`MedianMagnitudeBounds:` + valueToStringRegionFlowComputation(this.MedianMagnitudeBounds) + `,`,
		`FracInlierErrorThreshold:` + valueToStringRegionFlowComputation(this.FracInlierErrorThreshold) + `,`,
		`VerifyLongFeatures:` + valueToStringRegionFlowComputation(this.VerifyLongFeatures) + `,`,
		`LongFeatureVerificationThreshold:` + valueToStringRegionFlowComputation(this.LongFeatureVerificationThreshold) + `,`,
		`VisualConsistencyOptions:` + strings.Replace(fmt.Sprintf("%v", this.VisualConsistencyOptions), "RegionFlowComputationOptions_VisualConsistencyOptions", "RegionFlowComputationOptions_VisualConsistencyOptions", 1) + `,`,
		`MaxLongFeatureAcceleration:` + valueToStringRegionFlowComputation(this.MaxLongFeatureAcceleration) + `,`,
		`HistogramEqualization:` + valueToStringRegionFlowComputation(this.HistogramEqualization) + `,`,
		`ImageFormat:` + valueToStringRegionFlowComputation(this.ImageFormat) + `,`,
		`GainCorrectionBrightReference:` + valueToStringRegionFlowComputation(this.GainCorrectionBrightReference) + `,`,
		`GainCorrectionTriggeringRatio:` + valueToStringRegionFlowComputation(this.GainCorrectionTriggeringRatio) + `,`,
		`FastGainCorrection:` + valueToStringRegionFlowComputation(this.FastGainCorrection) + `,`,
		`RoundDownsampleFactor:` + valueToStringRegionFlowComputation(this.RoundDownsampleFactor) + `,`,
		`VerifyLongFeatureAcceleration:` + valueToStringRegionFlowComputation(this.VerifyLongFeatureAcceleration) + `,`,
		`VerifyLongFeatureTriggerRatio:` + valueToStringRegionFlowComputation(this.VerifyLongFeatureTriggerRatio) + `,`,
		`DescriptorExtractorType:` + valueToStringRegionFlowComputation(this.DescriptorExtractorType) + `,`,
		`ComputeDerivativeInPyramid:` + valueToStringRegionFlowComputation(this.ComputeDerivativeInPyramid) + `,`,
		`XXX_InternalExtensions:` + github_com_gogo_protobuf_proto.StringFromInternalExtension(this) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegionFlowComputationOptions_DownSampleSchedule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegionFlowComputationOptions_DownSampleSchedule{`,
		`DownsampleFactor_360P:` + valueToStringRegionFlowComputation(this.DownsampleFactor_360P) + `,`,
		`DownsampleFactor_480P:` + valueToStringRegionFlowComputation(this.DownsampleFactor_480P) + `,`,
		`DownsampleFactor_720P:` + valueToStringRegionFlowComputation(this.DownsampleFactor_720P) + `,`,
		`DownsampleFactor_1080P:` + valueToStringRegionFlowComputation(this.DownsampleFactor_1080P) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegionFlowComputationOptions_BlurScoreOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegionFlowComputationOptions_BlurScoreOptions{`,
		`BoxFilterDiam:` + valueToStringRegionFlowComputation(this.BoxFilterDiam) + `,`,
		`RelativeCornernessThreshold:` + valueToStringRegionFlowComputation(this.RelativeCornernessThreshold) + `,`,
		`AbsoluteCornernessThreshold:` + valueToStringRegionFlowComputation(this.AbsoluteCornernessThreshold) + `,`,
		`MedianPercentile:` + valueToStringRegionFlowComputation(this.MedianPercentile) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegionFlowComputationOptions_VisualConsistencyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegionFlowComputationOptions_VisualConsistencyOptions{`,
		`ComputeConsistency:` + valueToStringRegionFlowComputation(this.ComputeConsistency) + `,`,
		`TinyImageDimension:` + valueToStringRegionFlowComputation(this.TinyImageDimension) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringRegionFlowComputation(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TrackingOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackingOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackingOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiFramesToTrack", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiFramesToTrack = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFeatures", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxFeatures = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingWindowSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackingWindowSize = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingIterations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackingIterations = &v
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionalTrackingDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FractionalTrackingDistance = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatureDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinFeatureDistance = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveGoodFeaturesToTrack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AdaptiveGoodFeaturesToTrack = &b
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveFeaturesBlockSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AdaptiveFeaturesBlockSize = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveFeaturesLevels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdaptiveFeaturesLevels = &v
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyntheticZeroMotionGridStep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.SyntheticZeroMotionGridStep = &v2
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WideBaselineMatching", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WideBaselineMatching = &b
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatioTestThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RatioTestThreshold = &v2
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefineWideBaselineMatches", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RefineWideBaselineMatches = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReuseFeaturesMaxFrameDistance", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReuseFeaturesMaxFrameDistance = &v
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReuseFeaturesMinSurvivedFrac", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ReuseFeaturesMinSurvivedFrac = &v2
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTrackingDirection", wireType)
			}
			var v TrackingOptions_FlowDirection
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackingOptions_FlowDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalTrackingDirection = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFlowDirection", wireType)
			}
			var v TrackingOptions_FlowDirection
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackingOptions_FlowDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputFlowDirection = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistanceDownscaleSqrt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DistanceDownscaleSqrt = &b
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveExtractionLevels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdaptiveExtractionLevels = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveExtractionLevelsLowestSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdaptiveExtractionLevelsLowestSize = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveTrackingDistance", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AdaptiveTrackingDistance = &b
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingPolicy", wireType)
			}
			var v TrackingOptions_TrackingPolicy
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackingOptions_TrackingPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackingPolicy = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTracksMaxFrames", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LongTracksMaxFrames = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerExtractionMethod", wireType)
			}
			var v TrackingOptions_CornerExtractionMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackingOptions_CornerExtractionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CornerExtractionMethod = &v
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEigValSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinEigValSettings == nil {
				m.MinEigValSettings = &TrackingOptions_MinEigValExtractionSettings{}
			}
			if err := m.MinEigValSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HarrisSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HarrisSettings == nil {
				m.HarrisSettings = &TrackingOptions_HarrisExtractionSettings{}
			}
			if err := m.HarrisSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FastSettings == nil {
				m.FastSettings = &TrackingOptions_FastExtractionSettings{}
			}
			if err := m.FastSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KltTrackerImplementation", wireType)
			}
			var v TrackingOptions_KltTrackerImplementation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackingOptions_KltTrackerImplementation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KltTrackerImplementation = &v
		default:
			if ((fieldNum >= 3) && (fieldNum < 4)) || ((fieldNum >= 11) && (fieldNum < 12)) || ((fieldNum >= 12) && (fieldNum < 13)) || ((fieldNum >= 30) && (fieldNum < 31)) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthRegionFlowComputation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthRegionFlowComputation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingOptions_MinEigValExtractionSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinEigValExtractionSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinEigValExtractionSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureQualityLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FeatureQualityLevel = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdaptiveLowestQualityLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AdaptiveLowestQualityLevel = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingOptions_HarrisExtractionSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HarrisExtractionSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HarrisExtractionSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureQualityLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FeatureQualityLevel = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackingOptions_FastExtractionSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastExtractionSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastExtractionSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Threshold = &v
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionFlowComputationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionFlowComputationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionFlowComputationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrackingOptions == nil {
				m.TrackingOptions = &TrackingOptions{}
			}
			if err := m.TrackingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatureInliers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinFeatureInliers = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RansacRoundsPerRegion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RansacRoundsPerRegion = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsoluteInlierErrorThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AbsoluteInlierErrorThreshold = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastEstimationBlockSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FastEstimationBlockSize = &v2
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleMode", wireType)
			}
			var v RegionFlowComputationOptions_DownsampleMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RegionFlowComputationOptions_DownsampleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DownsampleMode = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsamplingSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DownsamplingSize = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatureRequirement", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinFeatureRequirement = &v
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatureCover", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinFeatureCover = &v2
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeBlurScore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ComputeBlurScore = &b
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor = &v2
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownsampleSchedule == nil {
				m.DownsampleSchedule = &RegionFlowComputationOptions_DownSampleSchedule{}
			}
			if err := m.DownsampleSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeatureCoverGrid", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinFeatureCoverGrid = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchDescriptorRadius", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PatchDescriptorRadius = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastEstimationOverlapGrids", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FastEstimationOverlapGrids = &v
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMagnitudeThresholdRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxMagnitudeThresholdRatio = &v2
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastEstimationMinBlockSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FastEstimationMinBlockSize = &v
		case 26:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerResponseScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.CornerResponseScale = &v2
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyFeatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VerifyFeatures = &b
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.VerificationDistance = &v2
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlurScoreOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlurScoreOptions == nil {
				m.BlurScoreOptions = &RegionFlowComputationOptions_BlurScoreOptions{}
			}
			if err := m.BlurScoreOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBlurSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PreBlurSigma = &v2
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSyntheticZeroMotionTracksAllFrames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseSyntheticZeroMotionTracksAllFrames = &b
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSyntheticZeroMotionTracksFirstFrame", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UseSyntheticZeroMotionTracksFirstFrame = &b
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GainCorrection = &b
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracGainFeatureSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracGainFeatureSize = &v2
		case 38:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracGainStep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracGainStep = &v2
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainBiasBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GainBiasBounds == nil {
				m.GainBiasBounds = &ToneEstimationOptions_GainBiasBounds{}
			}
			if err := m.GainBiasBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEstimationMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoEstimationMode = &b
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrectMode", wireType)
			}
			var v RegionFlowComputationOptions_GainCorrectMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RegionFlowComputationOptions_GainCorrectMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GainCorrectMode = &v
		case 44:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeInlierErrorThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RelativeInlierErrorThreshold = &v2
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopInlierSets", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopInlierSets = &v
		case 46:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeMinFeatureInliers", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RelativeMinFeatureInliers = &v2
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrectionMultipleHypotheses", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GainCorrectionMultipleHypotheses = &b
		case 48:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrectionInlierImprovementFrac", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.GainCorrectionInlierImprovementFrac = &v2
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsInitialization", wireType)
			}
			var v RegionFlowComputationOptions_IrlsInitialization
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RegionFlowComputationOptions_IrlsInitialization(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrlsInitialization = &v
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistanceFromBorder", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistanceFromBorder = &v
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianMagnitudeBounds", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MedianMagnitudeBounds = &v2
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracInlierErrorThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracInlierErrorThreshold = &v2
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLongFeatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VerifyLongFeatures = &b
		case 54:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongFeatureVerificationThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LongFeatureVerificationThreshold = &v2
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisualConsistencyOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VisualConsistencyOptions == nil {
				m.VisualConsistencyOptions = &RegionFlowComputationOptions_VisualConsistencyOptions{}
			}
			if err := m.VisualConsistencyOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLongFeatureAcceleration", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxLongFeatureAcceleration = &v2
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramEqualization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HistogramEqualization = &b
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageFormat", wireType)
			}
			var v RegionFlowComputationOptions_ImageFormat
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RegionFlowComputationOptions_ImageFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImageFormat = &v
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrectionBrightReference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GainCorrectionBrightReference = &b
		case 60:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainCorrectionTriggeringRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.GainCorrectionTriggeringRatio = &v2
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastGainCorrection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FastGainCorrection = &b
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundDownsampleFactor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RoundDownsampleFactor = &b
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLongFeatureAcceleration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.VerifyLongFeatureAcceleration = &b
		case 64:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyLongFeatureTriggerRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.VerifyLongFeatureTriggerRatio = &v2
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorExtractorType", wireType)
			}
			var v RegionFlowComputationOptions_DescriptorExtractorType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RegionFlowComputationOptions_DescriptorExtractorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DescriptorExtractorType = &v
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeDerivativeInPyramid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ComputeDerivativeInPyramid = &b
		default:
			if ((fieldNum >= 5) && (fieldNum < 6)) || ((fieldNum >= 7) && (fieldNum < 8)) || ((fieldNum >= 8) && (fieldNum < 9)) || ((fieldNum >= 9) && (fieldNum < 10)) || ((fieldNum >= 10) && (fieldNum < 11)) || ((fieldNum >= 15) && (fieldNum < 16)) || ((fieldNum >= 16) && (fieldNum < 17)) || ((fieldNum >= 24) && (fieldNum < 25)) || ((fieldNum >= 29) && (fieldNum < 30)) || ((fieldNum >= 30) && (fieldNum < 31)) || ((fieldNum >= 32) && (fieldNum < 33)) || ((fieldNum >= 42) && (fieldNum < 43)) || ((fieldNum >= 43) && (fieldNum < 44)) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthRegionFlowComputation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthRegionFlowComputation
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionFlowComputationOptions_DownSampleSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownSampleSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownSampleSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor_360P", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor_360P = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor_480P", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor_480P = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor_720P", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor_720P = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor_1080P", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor_1080P = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionFlowComputationOptions_BlurScoreOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlurScoreOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlurScoreOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxFilterDiam", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoxFilterDiam = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeCornernessThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RelativeCornernessThreshold = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsoluteCornernessThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.AbsoluteCornernessThreshold = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MedianPercentile = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionFlowComputationOptions_VisualConsistencyOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VisualConsistencyOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VisualConsistencyOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeConsistency", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ComputeConsistency = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TinyImageDimension", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TinyImageDimension = &v
		default:
			iNdEx = preIndex
			skippy, err := skipRegionFlowComputation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegionFlowComputation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegionFlowComputation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegionFlowComputation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegionFlowComputation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRegionFlowComputation
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRegionFlowComputation
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRegionFlowComputation
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRegionFlowComputation        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegionFlowComputation          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRegionFlowComputation = fmt.Errorf("proto: unexpected end of group")
)
