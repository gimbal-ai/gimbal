// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/tone_estimation.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ToneChange_Type int32

const (
	TONE_TYPE_VALID   ToneChange_Type = 0
	TONE_TYPE_INVALID ToneChange_Type = 10
)

var ToneChange_Type_name = map[int32]string{
	0:  "TONE_TYPE_VALID",
	10: "TONE_TYPE_INVALID",
}

var ToneChange_Type_value = map[string]int32{
	"TONE_TYPE_VALID":   0,
	"TONE_TYPE_INVALID": 10,
}

func (x ToneChange_Type) Enum() *ToneChange_Type {
	p := new(ToneChange_Type)
	*p = x
	return p
}

func (x ToneChange_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ToneChange_Type_name, int32(x))
}

func (x *ToneChange_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ToneChange_Type_value, data, "ToneChange_Type")
	if err != nil {
		return err
	}
	*x = ToneChange_Type(value)
	return nil
}

func (ToneChange_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{0, 0}
}

type ToneEstimationOptions_DownsampleMode int32

const (
	TONE_DOWNSAMPLE_UNKNOWN     ToneEstimationOptions_DownsampleMode = 0
	TONE_DOWNSAMPLE_NONE        ToneEstimationOptions_DownsampleMode = 1
	TONE_DOWNSAMPLE_TO_MAX_SIZE ToneEstimationOptions_DownsampleMode = 2
	TONE_DOWNSAMPLE_BY_FACTOR   ToneEstimationOptions_DownsampleMode = 3
	TONE_DOWNSAMPLE_TO_MIN_SIZE ToneEstimationOptions_DownsampleMode = 4
)

var ToneEstimationOptions_DownsampleMode_name = map[int32]string{
	0: "TONE_DOWNSAMPLE_UNKNOWN",
	1: "TONE_DOWNSAMPLE_NONE",
	2: "TONE_DOWNSAMPLE_TO_MAX_SIZE",
	3: "TONE_DOWNSAMPLE_BY_FACTOR",
	4: "TONE_DOWNSAMPLE_TO_MIN_SIZE",
}

var ToneEstimationOptions_DownsampleMode_value = map[string]int32{
	"TONE_DOWNSAMPLE_UNKNOWN":     0,
	"TONE_DOWNSAMPLE_NONE":        1,
	"TONE_DOWNSAMPLE_TO_MAX_SIZE": 2,
	"TONE_DOWNSAMPLE_BY_FACTOR":   3,
	"TONE_DOWNSAMPLE_TO_MIN_SIZE": 4,
}

func (x ToneEstimationOptions_DownsampleMode) Enum() *ToneEstimationOptions_DownsampleMode {
	p := new(ToneEstimationOptions_DownsampleMode)
	*p = x
	return p
}

func (x ToneEstimationOptions_DownsampleMode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ToneEstimationOptions_DownsampleMode_name, int32(x))
}

func (x *ToneEstimationOptions_DownsampleMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ToneEstimationOptions_DownsampleMode_value, data, "ToneEstimationOptions_DownsampleMode")
	if err != nil {
		return err
	}
	*x = ToneEstimationOptions_DownsampleMode(value)
	return nil
}

func (ToneEstimationOptions_DownsampleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{3, 0}
}

type ToneChange struct {
	GainBias           *GainBiasModel             `protobuf:"bytes,1,opt,name=gain_bias,json=gainBias" json:"gain_bias,omitempty"`
	Affine             *AffineToneModel           `protobuf:"bytes,2,opt,name=affine" json:"affine,omitempty"`
	MixtureGainBias    *MixtureGainBiasModel      `protobuf:"bytes,3,opt,name=mixture_gain_bias,json=mixtureGainBias" json:"mixture_gain_bias,omitempty"`
	MixtureAffine      *MixtureAffineToneModel    `protobuf:"bytes,4,opt,name=mixture_affine,json=mixtureAffine" json:"mixture_affine,omitempty"`
	MixtureDomainSigma float32                    `protobuf:"fixed32,5,opt,name=mixture_domain_sigma,json=mixtureDomainSigma" json:"mixture_domain_sigma"`
	FracClipped        *float32                   `protobuf:"fixed32,6,opt,name=frac_clipped,json=fracClipped,def=0" json:"frac_clipped,omitempty"`
	LowPercentile      float32                    `protobuf:"fixed32,8,opt,name=low_percentile,json=lowPercentile" json:"low_percentile"`
	LowMidPercentile   float32                    `protobuf:"fixed32,9,opt,name=low_mid_percentile,json=lowMidPercentile" json:"low_mid_percentile"`
	MidPercentile      float32                    `protobuf:"fixed32,10,opt,name=mid_percentile,json=midPercentile" json:"mid_percentile"`
	HighMidPercentile  float32                    `protobuf:"fixed32,11,opt,name=high_mid_percentile,json=highMidPercentile" json:"high_mid_percentile"`
	HighPercentile     float32                    `protobuf:"fixed32,12,opt,name=high_percentile,json=highPercentile" json:"high_percentile"`
	LogDomain          *bool                      `protobuf:"varint,13,opt,name=log_domain,json=logDomain,def=0" json:"log_domain,omitempty"`
	Type               *ToneChange_Type           `protobuf:"varint,14,opt,name=type,enum=mediapipe.ToneChange_Type,def=0" json:"type,omitempty"`
	StabilityStats     *ToneChange_StabilityStats `protobuf:"bytes,15,opt,name=stability_stats,json=stabilityStats" json:"stability_stats,omitempty"`
}

func (m *ToneChange) Reset()      { *m = ToneChange{} }
func (*ToneChange) ProtoMessage() {}
func (*ToneChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{0}
}
func (m *ToneChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneChange.Merge(m, src)
}
func (m *ToneChange) XXX_Size() int {
	return m.Size()
}
func (m *ToneChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneChange.DiscardUnknown(m)
}

var xxx_messageInfo_ToneChange proto.InternalMessageInfo

const Default_ToneChange_FracClipped float32 = 0
const Default_ToneChange_LogDomain bool = false
const Default_ToneChange_Type ToneChange_Type = TONE_TYPE_VALID

func (m *ToneChange) GetGainBias() *GainBiasModel {
	if m != nil {
		return m.GainBias
	}
	return nil
}

func (m *ToneChange) GetAffine() *AffineToneModel {
	if m != nil {
		return m.Affine
	}
	return nil
}

func (m *ToneChange) GetMixtureGainBias() *MixtureGainBiasModel {
	if m != nil {
		return m.MixtureGainBias
	}
	return nil
}

func (m *ToneChange) GetMixtureAffine() *MixtureAffineToneModel {
	if m != nil {
		return m.MixtureAffine
	}
	return nil
}

func (m *ToneChange) GetMixtureDomainSigma() float32 {
	if m != nil {
		return m.MixtureDomainSigma
	}
	return 0
}

func (m *ToneChange) GetFracClipped() float32 {
	if m != nil && m.FracClipped != nil {
		return *m.FracClipped
	}
	return Default_ToneChange_FracClipped
}

func (m *ToneChange) GetLowPercentile() float32 {
	if m != nil {
		return m.LowPercentile
	}
	return 0
}

func (m *ToneChange) GetLowMidPercentile() float32 {
	if m != nil {
		return m.LowMidPercentile
	}
	return 0
}

func (m *ToneChange) GetMidPercentile() float32 {
	if m != nil {
		return m.MidPercentile
	}
	return 0
}

func (m *ToneChange) GetHighMidPercentile() float32 {
	if m != nil {
		return m.HighMidPercentile
	}
	return 0
}

func (m *ToneChange) GetHighPercentile() float32 {
	if m != nil {
		return m.HighPercentile
	}
	return 0
}

func (m *ToneChange) GetLogDomain() bool {
	if m != nil && m.LogDomain != nil {
		return *m.LogDomain
	}
	return Default_ToneChange_LogDomain
}

func (m *ToneChange) GetType() ToneChange_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_ToneChange_Type
}

func (m *ToneChange) GetStabilityStats() *ToneChange_StabilityStats {
	if m != nil {
		return m.StabilityStats
	}
	return nil
}

type ToneChange_StabilityStats struct {
	NumInliers     int32   `protobuf:"varint,1,opt,name=num_inliers,json=numInliers" json:"num_inliers"`
	InlierFraction float32 `protobuf:"fixed32,2,opt,name=inlier_fraction,json=inlierFraction" json:"inlier_fraction"`
	InlierWeight   float64 `protobuf:"fixed64,3,opt,name=inlier_weight,json=inlierWeight" json:"inlier_weight"`
}

func (m *ToneChange_StabilityStats) Reset()      { *m = ToneChange_StabilityStats{} }
func (*ToneChange_StabilityStats) ProtoMessage() {}
func (*ToneChange_StabilityStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{0, 0}
}
func (m *ToneChange_StabilityStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneChange_StabilityStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneChange_StabilityStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneChange_StabilityStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneChange_StabilityStats.Merge(m, src)
}
func (m *ToneChange_StabilityStats) XXX_Size() int {
	return m.Size()
}
func (m *ToneChange_StabilityStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneChange_StabilityStats.DiscardUnknown(m)
}

var xxx_messageInfo_ToneChange_StabilityStats proto.InternalMessageInfo

func (m *ToneChange_StabilityStats) GetNumInliers() int32 {
	if m != nil {
		return m.NumInliers
	}
	return 0
}

func (m *ToneChange_StabilityStats) GetInlierFraction() float32 {
	if m != nil {
		return m.InlierFraction
	}
	return 0
}

func (m *ToneChange_StabilityStats) GetInlierWeight() float64 {
	if m != nil {
		return m.InlierWeight
	}
	return 0
}

type ToneMatchOptions struct {
	MinMatchPercentile   *float32 `protobuf:"fixed32,1,opt,name=min_match_percentile,json=minMatchPercentile,def=0.01" json:"min_match_percentile,omitempty"`
	MaxMatchPercentile   *float32 `protobuf:"fixed32,2,opt,name=max_match_percentile,json=maxMatchPercentile,def=0.99" json:"max_match_percentile,omitempty"`
	MatchPercentileSteps *int32   `protobuf:"varint,3,opt,name=match_percentile_steps,json=matchPercentileSteps,def=10" json:"match_percentile_steps,omitempty"`
	PatchRadius          *int32   `protobuf:"varint,4,opt,name=patch_radius,json=patchRadius,def=18" json:"patch_radius,omitempty"`
	MaxFracClipped       *float32 `protobuf:"fixed32,5,opt,name=max_frac_clipped,json=maxFracClipped,def=0.4" json:"max_frac_clipped,omitempty"`
	LogDomain            *bool    `protobuf:"varint,8,opt,name=log_domain,json=logDomain,def=0" json:"log_domain,omitempty"`
}

func (m *ToneMatchOptions) Reset()      { *m = ToneMatchOptions{} }
func (*ToneMatchOptions) ProtoMessage() {}
func (*ToneMatchOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{1}
}
func (m *ToneMatchOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneMatchOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneMatchOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneMatchOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneMatchOptions.Merge(m, src)
}
func (m *ToneMatchOptions) XXX_Size() int {
	return m.Size()
}
func (m *ToneMatchOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneMatchOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ToneMatchOptions proto.InternalMessageInfo

const Default_ToneMatchOptions_MinMatchPercentile float32 = 0.01
const Default_ToneMatchOptions_MaxMatchPercentile float32 = 0.99
const Default_ToneMatchOptions_MatchPercentileSteps int32 = 10
const Default_ToneMatchOptions_PatchRadius int32 = 18
const Default_ToneMatchOptions_MaxFracClipped float32 = 0.4
const Default_ToneMatchOptions_LogDomain bool = false

func (m *ToneMatchOptions) GetMinMatchPercentile() float32 {
	if m != nil && m.MinMatchPercentile != nil {
		return *m.MinMatchPercentile
	}
	return Default_ToneMatchOptions_MinMatchPercentile
}

func (m *ToneMatchOptions) GetMaxMatchPercentile() float32 {
	if m != nil && m.MaxMatchPercentile != nil {
		return *m.MaxMatchPercentile
	}
	return Default_ToneMatchOptions_MaxMatchPercentile
}

func (m *ToneMatchOptions) GetMatchPercentileSteps() int32 {
	if m != nil && m.MatchPercentileSteps != nil {
		return *m.MatchPercentileSteps
	}
	return Default_ToneMatchOptions_MatchPercentileSteps
}

func (m *ToneMatchOptions) GetPatchRadius() int32 {
	if m != nil && m.PatchRadius != nil {
		return *m.PatchRadius
	}
	return Default_ToneMatchOptions_PatchRadius
}

func (m *ToneMatchOptions) GetMaxFracClipped() float32 {
	if m != nil && m.MaxFracClipped != nil {
		return *m.MaxFracClipped
	}
	return Default_ToneMatchOptions_MaxFracClipped
}

func (m *ToneMatchOptions) GetLogDomain() bool {
	if m != nil && m.LogDomain != nil {
		return *m.LogDomain
	}
	return Default_ToneMatchOptions_LogDomain
}

type ClipMaskOptions struct {
	MinExposure        *float32 `protobuf:"fixed32,1,opt,name=min_exposure,json=minExposure,def=0.02" json:"min_exposure,omitempty"`
	MaxExposure        *float32 `protobuf:"fixed32,2,opt,name=max_exposure,json=maxExposure,def=0.98" json:"max_exposure,omitempty"`
	MaxClippedChannels *int32   `protobuf:"varint,4,opt,name=max_clipped_channels,json=maxClippedChannels,def=1" json:"max_clipped_channels,omitempty"`
	ClipMaskDiameter   *int32   `protobuf:"varint,5,opt,name=clip_mask_diameter,json=clipMaskDiameter,def=5" json:"clip_mask_diameter,omitempty"`
}

func (m *ClipMaskOptions) Reset()      { *m = ClipMaskOptions{} }
func (*ClipMaskOptions) ProtoMessage() {}
func (*ClipMaskOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{2}
}
func (m *ClipMaskOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClipMaskOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClipMaskOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClipMaskOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClipMaskOptions.Merge(m, src)
}
func (m *ClipMaskOptions) XXX_Size() int {
	return m.Size()
}
func (m *ClipMaskOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ClipMaskOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ClipMaskOptions proto.InternalMessageInfo

const Default_ClipMaskOptions_MinExposure float32 = 0.02
const Default_ClipMaskOptions_MaxExposure float32 = 0.98
const Default_ClipMaskOptions_MaxClippedChannels int32 = 1
const Default_ClipMaskOptions_ClipMaskDiameter int32 = 5

func (m *ClipMaskOptions) GetMinExposure() float32 {
	if m != nil && m.MinExposure != nil {
		return *m.MinExposure
	}
	return Default_ClipMaskOptions_MinExposure
}

func (m *ClipMaskOptions) GetMaxExposure() float32 {
	if m != nil && m.MaxExposure != nil {
		return *m.MaxExposure
	}
	return Default_ClipMaskOptions_MaxExposure
}

func (m *ClipMaskOptions) GetMaxClippedChannels() int32 {
	if m != nil && m.MaxClippedChannels != nil {
		return *m.MaxClippedChannels
	}
	return Default_ClipMaskOptions_MaxClippedChannels
}

func (m *ClipMaskOptions) GetClipMaskDiameter() int32 {
	if m != nil && m.ClipMaskDiameter != nil {
		return *m.ClipMaskDiameter
	}
	return Default_ClipMaskOptions_ClipMaskDiameter
}

type ToneEstimationOptions struct {
	ToneMatchOptions       *ToneMatchOptions                     `protobuf:"bytes,1,opt,name=tone_match_options,json=toneMatchOptions" json:"tone_match_options,omitempty"`
	ClipMaskOptions        *ClipMaskOptions                      `protobuf:"bytes,2,opt,name=clip_mask_options,json=clipMaskOptions" json:"clip_mask_options,omitempty"`
	StatsLowPercentile     *float32                              `protobuf:"fixed32,3,opt,name=stats_low_percentile,json=statsLowPercentile,def=0.05" json:"stats_low_percentile,omitempty"`
	StatsLowMidPercentile  *float32                              `protobuf:"fixed32,4,opt,name=stats_low_mid_percentile,json=statsLowMidPercentile,def=0.2" json:"stats_low_mid_percentile,omitempty"`
	StatsMidPercentile     *float32                              `protobuf:"fixed32,5,opt,name=stats_mid_percentile,json=statsMidPercentile,def=0.5" json:"stats_mid_percentile,omitempty"`
	StatsHighMidPercentile *float32                              `protobuf:"fixed32,6,opt,name=stats_high_mid_percentile,json=statsHighMidPercentile,def=0.8" json:"stats_high_mid_percentile,omitempty"`
	StatsHighPercentile    *float32                              `protobuf:"fixed32,7,opt,name=stats_high_percentile,json=statsHighPercentile,def=0.95" json:"stats_high_percentile,omitempty"`
	IrlsIterations         *int32                                `protobuf:"varint,8,opt,name=irls_iterations,json=irlsIterations,def=10" json:"irls_iterations,omitempty"`
	StableGainBiasBounds   *ToneEstimationOptions_GainBiasBounds `protobuf:"bytes,9,opt,name=stable_gain_bias_bounds,json=stableGainBiasBounds" json:"stable_gain_bias_bounds,omitempty"`
	DownsampleMode         *ToneEstimationOptions_DownsampleMode `protobuf:"varint,10,opt,name=downsample_mode,json=downsampleMode,enum=mediapipe.ToneEstimationOptions_DownsampleMode,def=1" json:"downsample_mode,omitempty"`
	DownsamplingSize       *int32                                `protobuf:"varint,11,opt,name=downsampling_size,json=downsamplingSize,def=256" json:"downsampling_size,omitempty"`
	DownsampleFactor       *float32                              `protobuf:"fixed32,12,opt,name=downsample_factor,json=downsampleFactor,def=2" json:"downsample_factor,omitempty"`
}

func (m *ToneEstimationOptions) Reset()      { *m = ToneEstimationOptions{} }
func (*ToneEstimationOptions) ProtoMessage() {}
func (*ToneEstimationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{3}
}
func (m *ToneEstimationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneEstimationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneEstimationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneEstimationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneEstimationOptions.Merge(m, src)
}
func (m *ToneEstimationOptions) XXX_Size() int {
	return m.Size()
}
func (m *ToneEstimationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneEstimationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ToneEstimationOptions proto.InternalMessageInfo

const Default_ToneEstimationOptions_StatsLowPercentile float32 = 0.05
const Default_ToneEstimationOptions_StatsLowMidPercentile float32 = 0.2
const Default_ToneEstimationOptions_StatsMidPercentile float32 = 0.5
const Default_ToneEstimationOptions_StatsHighMidPercentile float32 = 0.8
const Default_ToneEstimationOptions_StatsHighPercentile float32 = 0.95
const Default_ToneEstimationOptions_IrlsIterations int32 = 10
const Default_ToneEstimationOptions_DownsampleMode ToneEstimationOptions_DownsampleMode = TONE_DOWNSAMPLE_NONE
const Default_ToneEstimationOptions_DownsamplingSize int32 = 256
const Default_ToneEstimationOptions_DownsampleFactor float32 = 2

func (m *ToneEstimationOptions) GetToneMatchOptions() *ToneMatchOptions {
	if m != nil {
		return m.ToneMatchOptions
	}
	return nil
}

func (m *ToneEstimationOptions) GetClipMaskOptions() *ClipMaskOptions {
	if m != nil {
		return m.ClipMaskOptions
	}
	return nil
}

func (m *ToneEstimationOptions) GetStatsLowPercentile() float32 {
	if m != nil && m.StatsLowPercentile != nil {
		return *m.StatsLowPercentile
	}
	return Default_ToneEstimationOptions_StatsLowPercentile
}

func (m *ToneEstimationOptions) GetStatsLowMidPercentile() float32 {
	if m != nil && m.StatsLowMidPercentile != nil {
		return *m.StatsLowMidPercentile
	}
	return Default_ToneEstimationOptions_StatsLowMidPercentile
}

func (m *ToneEstimationOptions) GetStatsMidPercentile() float32 {
	if m != nil && m.StatsMidPercentile != nil {
		return *m.StatsMidPercentile
	}
	return Default_ToneEstimationOptions_StatsMidPercentile
}

func (m *ToneEstimationOptions) GetStatsHighMidPercentile() float32 {
	if m != nil && m.StatsHighMidPercentile != nil {
		return *m.StatsHighMidPercentile
	}
	return Default_ToneEstimationOptions_StatsHighMidPercentile
}

func (m *ToneEstimationOptions) GetStatsHighPercentile() float32 {
	if m != nil && m.StatsHighPercentile != nil {
		return *m.StatsHighPercentile
	}
	return Default_ToneEstimationOptions_StatsHighPercentile
}

func (m *ToneEstimationOptions) GetIrlsIterations() int32 {
	if m != nil && m.IrlsIterations != nil {
		return *m.IrlsIterations
	}
	return Default_ToneEstimationOptions_IrlsIterations
}

func (m *ToneEstimationOptions) GetStableGainBiasBounds() *ToneEstimationOptions_GainBiasBounds {
	if m != nil {
		return m.StableGainBiasBounds
	}
	return nil
}

func (m *ToneEstimationOptions) GetDownsampleMode() ToneEstimationOptions_DownsampleMode {
	if m != nil && m.DownsampleMode != nil {
		return *m.DownsampleMode
	}
	return Default_ToneEstimationOptions_DownsampleMode
}

func (m *ToneEstimationOptions) GetDownsamplingSize() int32 {
	if m != nil && m.DownsamplingSize != nil {
		return *m.DownsamplingSize
	}
	return Default_ToneEstimationOptions_DownsamplingSize
}

func (m *ToneEstimationOptions) GetDownsampleFactor() float32 {
	if m != nil && m.DownsampleFactor != nil {
		return *m.DownsampleFactor
	}
	return Default_ToneEstimationOptions_DownsampleFactor
}

type ToneEstimationOptions_GainBiasBounds struct {
	MinInlierFraction *float32 `protobuf:"fixed32,1,opt,name=min_inlier_fraction,json=minInlierFraction,def=0.75" json:"min_inlier_fraction,omitempty"`
	MinInlierWeight   *float32 `protobuf:"fixed32,2,opt,name=min_inlier_weight,json=minInlierWeight,def=0.5" json:"min_inlier_weight,omitempty"`
	LowerGain         *float32 `protobuf:"fixed32,3,opt,name=lower_gain,json=lowerGain,def=0.75" json:"lower_gain,omitempty"`
	UpperGain         *float32 `protobuf:"fixed32,4,opt,name=upper_gain,json=upperGain,def=1.334" json:"upper_gain,omitempty"`
	LowerBias         *float32 `protobuf:"fixed32,5,opt,name=lower_bias,json=lowerBias,def=-0.2" json:"lower_bias,omitempty"`
	UpperBias         *float32 `protobuf:"fixed32,6,opt,name=upper_bias,json=upperBias,def=0.2" json:"upper_bias,omitempty"`
}

func (m *ToneEstimationOptions_GainBiasBounds) Reset()      { *m = ToneEstimationOptions_GainBiasBounds{} }
func (*ToneEstimationOptions_GainBiasBounds) ProtoMessage() {}
func (*ToneEstimationOptions_GainBiasBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{3, 0}
}
func (m *ToneEstimationOptions_GainBiasBounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneEstimationOptions_GainBiasBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneEstimationOptions_GainBiasBounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneEstimationOptions_GainBiasBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneEstimationOptions_GainBiasBounds.Merge(m, src)
}
func (m *ToneEstimationOptions_GainBiasBounds) XXX_Size() int {
	return m.Size()
}
func (m *ToneEstimationOptions_GainBiasBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneEstimationOptions_GainBiasBounds.DiscardUnknown(m)
}

var xxx_messageInfo_ToneEstimationOptions_GainBiasBounds proto.InternalMessageInfo

const Default_ToneEstimationOptions_GainBiasBounds_MinInlierFraction float32 = 0.75
const Default_ToneEstimationOptions_GainBiasBounds_MinInlierWeight float32 = 0.5
const Default_ToneEstimationOptions_GainBiasBounds_LowerGain float32 = 0.75
const Default_ToneEstimationOptions_GainBiasBounds_UpperGain float32 = 1.334
const Default_ToneEstimationOptions_GainBiasBounds_LowerBias float32 = -0.2
const Default_ToneEstimationOptions_GainBiasBounds_UpperBias float32 = 0.2

func (m *ToneEstimationOptions_GainBiasBounds) GetMinInlierFraction() float32 {
	if m != nil && m.MinInlierFraction != nil {
		return *m.MinInlierFraction
	}
	return Default_ToneEstimationOptions_GainBiasBounds_MinInlierFraction
}

func (m *ToneEstimationOptions_GainBiasBounds) GetMinInlierWeight() float32 {
	if m != nil && m.MinInlierWeight != nil {
		return *m.MinInlierWeight
	}
	return Default_ToneEstimationOptions_GainBiasBounds_MinInlierWeight
}

func (m *ToneEstimationOptions_GainBiasBounds) GetLowerGain() float32 {
	if m != nil && m.LowerGain != nil {
		return *m.LowerGain
	}
	return Default_ToneEstimationOptions_GainBiasBounds_LowerGain
}

func (m *ToneEstimationOptions_GainBiasBounds) GetUpperGain() float32 {
	if m != nil && m.UpperGain != nil {
		return *m.UpperGain
	}
	return Default_ToneEstimationOptions_GainBiasBounds_UpperGain
}

func (m *ToneEstimationOptions_GainBiasBounds) GetLowerBias() float32 {
	if m != nil && m.LowerBias != nil {
		return *m.LowerBias
	}
	return Default_ToneEstimationOptions_GainBiasBounds_LowerBias
}

func (m *ToneEstimationOptions_GainBiasBounds) GetUpperBias() float32 {
	if m != nil && m.UpperBias != nil {
		return *m.UpperBias
	}
	return Default_ToneEstimationOptions_GainBiasBounds_UpperBias
}

type ToneMatch struct {
	CurrVal float32 `protobuf:"fixed32,1,opt,name=curr_val,json=currVal" json:"curr_val"`
	PrevVal float32 `protobuf:"fixed32,2,opt,name=prev_val,json=prevVal" json:"prev_val"`
}

func (m *ToneMatch) Reset()      { *m = ToneMatch{} }
func (*ToneMatch) ProtoMessage() {}
func (*ToneMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{4}
}
func (m *ToneMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToneMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToneMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToneMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToneMatch.Merge(m, src)
}
func (m *ToneMatch) XXX_Size() int {
	return m.Size()
}
func (m *ToneMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ToneMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ToneMatch proto.InternalMessageInfo

func (m *ToneMatch) GetCurrVal() float32 {
	if m != nil {
		return m.CurrVal
	}
	return 0
}

func (m *ToneMatch) GetPrevVal() float32 {
	if m != nil {
		return m.PrevVal
	}
	return 0
}

type PatchToneMatch struct {
	ToneMatch  []*ToneMatch `protobuf:"bytes,1,rep,name=tone_match,json=toneMatch" json:"tone_match,omitempty"`
	IrlsWeight *float32     `protobuf:"fixed32,2,opt,name=irls_weight,json=irlsWeight,def=1" json:"irls_weight,omitempty"`
}

func (m *PatchToneMatch) Reset()      { *m = PatchToneMatch{} }
func (*PatchToneMatch) ProtoMessage() {}
func (*PatchToneMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_edbd06b6deff37fd, []int{5}
}
func (m *PatchToneMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatchToneMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatchToneMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PatchToneMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatchToneMatch.Merge(m, src)
}
func (m *PatchToneMatch) XXX_Size() int {
	return m.Size()
}
func (m *PatchToneMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PatchToneMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PatchToneMatch proto.InternalMessageInfo

const Default_PatchToneMatch_IrlsWeight float32 = 1

func (m *PatchToneMatch) GetToneMatch() []*ToneMatch {
	if m != nil {
		return m.ToneMatch
	}
	return nil
}

func (m *PatchToneMatch) GetIrlsWeight() float32 {
	if m != nil && m.IrlsWeight != nil {
		return *m.IrlsWeight
	}
	return Default_PatchToneMatch_IrlsWeight
}

func init() {
	proto.RegisterEnum("mediapipe.ToneChange_Type", ToneChange_Type_name, ToneChange_Type_value)
	proto.RegisterEnum("mediapipe.ToneEstimationOptions_DownsampleMode", ToneEstimationOptions_DownsampleMode_name, ToneEstimationOptions_DownsampleMode_value)
	proto.RegisterType((*ToneChange)(nil), "mediapipe.ToneChange")
	proto.RegisterType((*ToneChange_StabilityStats)(nil), "mediapipe.ToneChange.StabilityStats")
	proto.RegisterType((*ToneMatchOptions)(nil), "mediapipe.ToneMatchOptions")
	proto.RegisterType((*ClipMaskOptions)(nil), "mediapipe.ClipMaskOptions")
	proto.RegisterType((*ToneEstimationOptions)(nil), "mediapipe.ToneEstimationOptions")
	proto.RegisterType((*ToneEstimationOptions_GainBiasBounds)(nil), "mediapipe.ToneEstimationOptions.GainBiasBounds")
	proto.RegisterType((*ToneMatch)(nil), "mediapipe.ToneMatch")
	proto.RegisterType((*PatchToneMatch)(nil), "mediapipe.PatchToneMatch")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/tone_estimation.proto", fileDescriptor_edbd06b6deff37fd)
}

var fileDescriptor_edbd06b6deff37fd = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0xcb, 0x72, 0x13, 0x47,
	0x14, 0xd5, 0xc8, 0xf2, 0x43, 0x57, 0xf6, 0x48, 0x6e, 0xdb, 0x20, 0x4c, 0x45, 0x76, 0x14, 0xa8,
	0x98, 0xa2, 0x2c, 0xd9, 0xb2, 0x05, 0x46, 0x95, 0x4a, 0xca, 0xcf, 0xa0, 0x02, 0xc9, 0xae, 0xb6,
	0x03, 0x81, 0xcd, 0x54, 0x5b, 0x6a, 0xcb, 0x5d, 0xcc, 0xab, 0x66, 0x46, 0x58, 0xb0, 0xca, 0x3e,
	0x9b, 0xe4, 0x2f, 0xf8, 0x84, 0x7c, 0x02, 0xd9, 0xb1, 0x64, 0x93, 0x54, 0x10, 0x9b, 0x2c, 0xc9,
	0x1f, 0xa4, 0xba, 0x7b, 0x66, 0x34, 0x33, 0x36, 0xa9, 0x2c, 0x75, 0xef, 0x39, 0xb7, 0xbb, 0xef,
	0xe3, 0xdc, 0x11, 0xac, 0x1a, 0xb4, 0xcb, 0x88, 0xcd, 0x6c, 0x5a, 0xed, 0x7b, 0x4c, 0xaf, 0x7a,
	0x0e, 0xe9, 0xbc, 0x60, 0x66, 0xaf, 0xea, 0x59, 0x26, 0xd5, 0xa8, 0xeb, 0x31, 0x83, 0x78, 0xcc,
	0x32, 0x2b, 0xb6, 0x63, 0x79, 0x16, 0xca, 0x86, 0xf0, 0xc5, 0x3b, 0xff, 0xc9, 0x34, 0xac, 0x2e,
	0xd5, 0x5d, 0xc9, 0x2a, 0xff, 0x31, 0x09, 0x70, 0x62, 0x99, 0x74, 0xf7, 0x9c, 0x98, 0x3d, 0x8a,
	0xea, 0x90, 0xed, 0x11, 0x66, 0x6a, 0xa7, 0x8c, 0xb8, 0x45, 0x65, 0x59, 0x59, 0xc9, 0xd5, 0x8a,
	0x95, 0x30, 0x5a, 0xe5, 0x7b, 0xc2, 0xcc, 0x1d, 0x46, 0xdc, 0x16, 0x0f, 0x81, 0xa7, 0x7a, 0xfe,
	0x4f, 0x54, 0x83, 0x09, 0x72, 0x76, 0xc6, 0x4c, 0x5a, 0x4c, 0x0b, 0xce, 0x62, 0x84, 0xb3, 0x2d,
	0x1c, 0xfc, 0x0c, 0xc9, 0xf2, 0x91, 0xe8, 0x11, 0xcc, 0x1a, 0x6c, 0xe0, 0xf5, 0x1d, 0xaa, 0x8d,
	0x8e, 0x1c, 0x13, 0xf4, 0xa5, 0x08, 0xbd, 0x25, 0x31, 0xf1, 0x93, 0xf3, 0x46, 0xdc, 0x8a, 0x1e,
	0x82, 0x1a, 0x04, 0xf3, 0x2f, 0x92, 0x11, 0x91, 0xbe, 0xbc, 0x1c, 0x29, 0x79, 0x9f, 0x19, 0x23,
	0x6a, 0x47, 0xf7, 0x60, 0x3e, 0x88, 0xd4, 0xb5, 0x0c, 0x7e, 0x31, 0x97, 0xf5, 0x0c, 0x52, 0x1c,
	0x5f, 0x56, 0x56, 0xd2, 0x3b, 0x99, 0xb7, 0x7f, 0x2e, 0xa5, 0x30, 0xf2, 0x11, 0x7b, 0x02, 0x70,
	0xcc, 0xfd, 0xe8, 0x16, 0x4c, 0x9f, 0x39, 0xa4, 0xa3, 0x75, 0x74, 0x66, 0xdb, 0xb4, 0x5b, 0x9c,
	0xe0, 0xf8, 0x86, 0xb2, 0x86, 0x73, 0xdc, 0xbc, 0x2b, 0xad, 0xe8, 0x2e, 0xa8, 0xba, 0x75, 0xa1,
	0xd9, 0xd4, 0xe9, 0x50, 0xd3, 0x63, 0x3a, 0x2d, 0x4e, 0x45, 0xe2, 0xce, 0xe8, 0xd6, 0xc5, 0x51,
	0xe8, 0x42, 0x35, 0x40, 0x1c, 0x6c, 0xb0, 0x6e, 0x94, 0x90, 0x8d, 0x10, 0x0a, 0xba, 0x75, 0xd1,
	0x62, 0xdd, 0x08, 0xe7, 0x2e, 0x4f, 0x44, 0x0c, 0x0f, 0xd1, 0x03, 0x8c, 0x18, 0x78, 0x13, 0xe6,
	0xce, 0x59, 0xef, 0x3c, 0x79, 0x42, 0x2e, 0xc2, 0x98, 0xe5, 0x80, 0xf8, 0x11, 0xab, 0x90, 0x17,
	0xac, 0x08, 0x63, 0x3a, 0xc2, 0x50, 0xb9, 0x33, 0x02, 0xbf, 0x05, 0xa0, 0x5b, 0x3d, 0x3f, 0x99,
	0xc5, 0x99, 0x65, 0x65, 0x65, 0xaa, 0x31, 0x7e, 0x46, 0x74, 0x97, 0xe2, 0xac, 0x6e, 0xf5, 0x64,
	0x0e, 0xd1, 0x77, 0x90, 0xf1, 0x5e, 0xd9, 0xb4, 0xa8, 0x2e, 0x2b, 0x2b, 0x6a, 0xac, 0x7f, 0x46,
	0xdd, 0x59, 0x39, 0x79, 0x65, 0xd3, 0x46, 0xfe, 0xe4, 0xb0, 0xbd, 0xaf, 0x9d, 0x3c, 0x3b, 0xda,
	0xd7, 0x9e, 0x6c, 0x3f, 0x6e, 0xee, 0x61, 0x41, 0x44, 0x2d, 0xc8, 0xbb, 0x1e, 0x39, 0x65, 0x3a,
	0xf3, 0x5e, 0x69, 0xae, 0x47, 0x3c, 0xb7, 0x98, 0x17, 0x2d, 0x70, 0xeb, 0xea, 0x58, 0xc7, 0x01,
	0xf8, 0x98, 0x63, 0xb1, 0xea, 0xc6, 0x7e, 0x2f, 0xfe, 0xaa, 0x80, 0x1a, 0x87, 0xa0, 0xdb, 0x90,
	0x33, 0xfb, 0x86, 0xc6, 0x4c, 0x9d, 0x51, 0x47, 0x4e, 0xc7, 0xb8, 0xff, 0x66, 0x30, 0xfb, 0x46,
	0x53, 0xda, 0x79, 0x7a, 0x24, 0x44, 0xe3, 0x85, 0xe7, 0x03, 0x2a, 0x86, 0x22, 0x4c, 0x8f, 0x74,
	0x1e, 0xf8, 0x3e, 0x74, 0x07, 0x66, 0x7c, 0xf8, 0x05, 0x65, 0xbd, 0x73, 0x4f, 0x8c, 0x80, 0xe2,
	0x83, 0xa7, 0xa5, 0xeb, 0xa9, 0xf0, 0x94, 0x6b, 0x90, 0xe1, 0x19, 0x40, 0x73, 0x90, 0xcc, 0x41,
	0x21, 0x85, 0x16, 0x60, 0x76, 0x64, 0x6c, 0xb6, 0xa5, 0x19, 0xca, 0xbf, 0xa5, 0xa1, 0x20, 0x7a,
	0x9d, 0x78, 0x9d, 0xf3, 0x43, 0x9b, 0x1f, 0xe9, 0xca, 0x1e, 0x37, 0x35, 0x83, 0xdb, 0xa2, 0x65,
	0x54, 0x44, 0xcf, 0x66, 0xd6, 0x2a, 0x6b, 0xeb, 0xbc, 0xc7, 0x4d, 0x41, 0x8a, 0x94, 0x92, 0xf3,
	0xc8, 0xe0, 0x32, 0x2f, 0x1d, 0xf0, 0x1e, 0x3c, 0xc0, 0xc8, 0x20, 0x83, 0x24, 0x6f, 0x0b, 0xae,
	0x25, 0x39, 0x9a, 0xeb, 0x51, 0x5b, 0xce, 0xfb, 0x78, 0x23, 0xbd, 0xbe, 0x86, 0xe7, 0x8d, 0x38,
	0xe9, 0x98, 0xfb, 0xd1, 0x6d, 0x98, 0xb6, 0x05, 0xd3, 0x21, 0x5d, 0xd6, 0x77, 0xc5, 0x54, 0x73,
	0xfc, 0x16, 0xce, 0x09, 0x3b, 0x16, 0x66, 0xb4, 0x0a, 0x05, 0x7e, 0xb1, 0xd8, 0x00, 0x8a, 0x81,
	0x6d, 0x8c, 0xad, 0x55, 0x36, 0xb1, 0x6a, 0x90, 0xc1, 0x41, 0x64, 0x0a, 0xe3, 0x2d, 0x39, 0x75,
	0x75, 0x4b, 0x96, 0x7f, 0x57, 0x20, 0xcf, 0x19, 0x2d, 0xe2, 0xbe, 0x08, 0x32, 0xf7, 0x35, 0x4c,
	0xf3, 0xcc, 0xd1, 0x81, 0x6d, 0xb9, 0x7d, 0x27, 0x9a, 0xb1, 0x1a, 0xce, 0x19, 0xcc, 0xdc, 0xf7,
	0x1d, 0x02, 0x48, 0x06, 0x23, 0xe0, 0x28, 0x45, 0x5b, 0x38, 0x67, 0x90, 0x41, 0x08, 0xdc, 0x90,
	0x39, 0xf5, 0x6f, 0xad, 0x75, 0xce, 0x89, 0x69, 0x52, 0x3d, 0x78, 0xa9, 0xb2, 0x2e, 0x12, 0xea,
	0x5f, 0x7c, 0xd7, 0x77, 0xa2, 0x2a, 0x20, 0x4e, 0xd0, 0x0c, 0xe2, 0xbe, 0xd0, 0xba, 0x8c, 0x18,
	0xd4, 0xa3, 0x8e, 0x78, 0xf1, 0x78, 0x43, 0xa9, 0xe3, 0x42, 0xc7, 0xbf, 0xf6, 0x9e, 0xef, 0x2a,
	0xff, 0x93, 0x85, 0x05, 0xde, 0x06, 0xfb, 0xe1, 0xd6, 0x08, 0x5e, 0xd4, 0x04, 0x24, 0xb7, 0x82,
	0x48, 0xb3, 0x25, 0xad, 0xbe, 0xf4, 0xdf, 0x4c, 0x8c, 0x4e, 0xb4, 0x89, 0x70, 0xc1, 0x4b, 0xb6,
	0xd5, 0x01, 0xcc, 0x8e, 0x6e, 0x15, 0x44, 0xba, 0xbc, 0x10, 0x12, 0x39, 0xc5, 0xf9, 0x4e, 0x22,
	0xc9, 0xf7, 0x60, 0x5e, 0x0c, 0xb0, 0x96, 0x90, 0xca, 0xb1, 0x30, 0xd9, 0x75, 0x8c, 0x04, 0xe2,
	0x71, 0x4c, 0x2f, 0xbf, 0x81, 0xe2, 0x88, 0x97, 0xd0, 0xb4, 0x4c, 0xd0, 0x0d, 0x35, 0xbc, 0x10,
	0x50, 0xe3, 0xb2, 0x56, 0x0f, 0x4e, 0x4d, 0x30, 0xc3, 0x3e, 0x0a, 0x0e, 0x8d, 0xd3, 0xbe, 0x85,
	0x1b, 0x92, 0x76, 0x95, 0x92, 0x4e, 0x04, 0xdc, 0x2d, 0x7c, 0x4d, 0xa0, 0x1e, 0x5e, 0x52, 0xd3,
	0x2d, 0x58, 0x88, 0xf0, 0x23, 0xdc, 0xc9, 0xb0, 0x63, 0xea, 0x78, 0x2e, 0x24, 0xc7, 0xa4, 0x3e,
	0xcf, 0x1c, 0xdd, 0xd5, 0x98, 0x47, 0x1d, 0x22, 0x93, 0x3d, 0x15, 0x8e, 0x93, 0xca, 0x5d, 0xcd,
	0xd0, 0x83, 0xce, 0xe0, 0x3a, 0x57, 0x38, 0x3d, 0xb2, 0x6c, 0xb5, 0x53, 0xab, 0x6f, 0x76, 0x5d,
	0xb1, 0x50, 0x72, 0xb5, 0x6a, 0xa2, 0xd6, 0x97, 0x3a, 0x25, 0x5c, 0xfe, 0x3b, 0x82, 0x86, 0xe7,
	0x65, 0xbc, 0xb8, 0x15, 0x99, 0x90, 0xef, 0x5a, 0x17, 0xa6, 0x4b, 0x0c, 0x5b, 0x97, 0x9f, 0x1a,
	0x62, 0x01, 0xa9, 0xff, 0x23, 0xfe, 0x5e, 0xc8, 0xe3, 0x8b, 0xb9, 0x31, 0x2f, 0xe4, 0x6c, 0xef,
	0xf0, 0x69, 0xfb, 0x78, 0xbb, 0x75, 0xf4, 0x78, 0x5f, 0x6b, 0x1f, 0xb6, 0xf7, 0xb1, 0xda, 0x8d,
	0xa1, 0xd0, 0x1a, 0xcc, 0x86, 0x16, 0x66, 0xf6, 0x34, 0x97, 0xbd, 0x96, 0x0b, 0x6c, 0xbc, 0x31,
	0x56, 0xab, 0xdf, 0xc3, 0x85, 0xa8, 0xf7, 0x98, 0xbd, 0xa6, 0xa8, 0x12, 0x61, 0x50, 0xed, 0x8c,
	0x74, 0x3c, 0xcb, 0x91, 0x0b, 0xac, 0xa1, 0xd4, 0x22, 0x78, 0x7a, 0x20, 0x5c, 0x8b, 0x3f, 0xa7,
	0x41, 0x4d, 0x3c, 0x72, 0x13, 0xe6, 0xb8, 0x0a, 0x24, 0x65, 0x3e, 0x14, 0x83, 0xfb, 0x75, 0x3c,
	0x6b, 0x30, 0xb3, 0x19, 0x57, 0xfa, 0x2a, 0xff, 0xe0, 0x09, 0x59, 0xbe, 0xda, 0xa7, 0x47, 0xdd,
	0x95, 0x0f, 0x29, 0x52, 0xef, 0xd1, 0x57, 0x5c, 0xa6, 0x2e, 0xa8, 0x23, 0x4a, 0x36, 0xea, 0xfe,
	0xfb, 0x75, 0xae, 0x52, 0x17, 0xd4, 0xe1, 0xb7, 0xe2, 0x5a, 0xd6, 0xb7, 0xed, 0x00, 0x24, 0xdb,
	0x7c, 0x7c, 0xbd, 0xb2, 0xb1, 0xb1, 0x89, 0xb3, 0xc2, 0x21, 0x50, 0x61, 0x28, 0xf1, 0x95, 0x25,
	0x5b, 0x3a, 0xb3, 0xca, 0xa7, 0x41, 0x86, 0x12, 0x1f, 0x51, 0xe5, 0x20, 0x94, 0x00, 0x4d, 0x8c,
	0x26, 0x46, 0x06, 0xe2, 0x98, 0xf2, 0x1b, 0x05, 0xd4, 0x78, 0xa1, 0xd0, 0x4d, 0xb8, 0x9e, 0x2c,
	0xd5, 0x0f, 0xed, 0x47, 0xed, 0xc3, 0xa7, 0xed, 0x42, 0x0a, 0x15, 0xe1, 0xca, 0x3a, 0x16, 0x14,
	0xb4, 0x04, 0x37, 0x93, 0x9e, 0x93, 0x43, 0xad, 0xb5, 0xfd, 0xa3, 0x76, 0xdc, 0x7c, 0xbe, 0x5f,
	0x48, 0xa3, 0x2f, 0xe0, 0x46, 0x12, 0xb0, 0xf3, 0x4c, 0x3b, 0xd8, 0xde, 0x3d, 0x39, 0xc4, 0x85,
	0xb1, 0xcf, 0xf1, 0x9b, 0x6d, 0xc9, 0xcf, 0x94, 0x5b, 0x90, 0x0d, 0x45, 0x0b, 0x2d, 0xc1, 0x54,
	0xa7, 0xef, 0x38, 0xda, 0x4b, 0xa2, 0xcb, 0x3a, 0xf9, 0x1b, 0x76, 0x92, 0x5b, 0x9f, 0x10, 0x9d,
	0x03, 0x6c, 0x87, 0xbe, 0x14, 0x80, 0xe8, 0xbe, 0x9e, 0xe4, 0xd6, 0x27, 0x44, 0x2f, 0x33, 0x50,
	0x8f, 0x78, 0xa8, 0x51, 0xcc, 0x0d, 0x80, 0x91, 0x74, 0x16, 0x95, 0xe5, 0xb1, 0x95, 0x5c, 0x6d,
	0xfe, 0x2a, 0xc9, 0xc4, 0xd9, 0x50, 0x2b, 0x51, 0x19, 0x72, 0x62, 0x6a, 0x63, 0xf5, 0x57, 0xd6,
	0x31, 0x70, 0xab, 0x2c, 0xfc, 0x0e, 0x7b, 0xf7, 0xa1, 0x94, 0x7a, 0xff, 0xa1, 0x94, 0xfa, 0xf4,
	0xa1, 0xa4, 0xfc, 0x34, 0x2c, 0x29, 0x6f, 0x86, 0x25, 0xe5, 0xed, 0xb0, 0xa4, 0xbc, 0x1b, 0x96,
	0x94, 0xbf, 0x86, 0x25, 0xe5, 0xef, 0x61, 0x29, 0xf5, 0x69, 0x58, 0x52, 0x7e, 0xf9, 0x58, 0x4a,
	0xbd, 0xfb, 0x58, 0x4a, 0xbd, 0xff, 0x58, 0x4a, 0x3d, 0xdf, 0xe8, 0x31, 0xef, 0xbc, 0x7f, 0x5a,
	0xe9, 0x58, 0x46, 0xb5, 0x67, 0x59, 0x3d, 0x9d, 0x56, 0x47, 0xff, 0x03, 0x3e, 0xf3, 0x8f, 0xe0,
	0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x26, 0x55, 0xf6, 0x65, 0x0c, 0x00, 0x00,
}

func (x ToneChange_Type) String() string {
	s, ok := ToneChange_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ToneEstimationOptions_DownsampleMode) String() string {
	s, ok := ToneEstimationOptions_DownsampleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ToneChange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneChange)
	if !ok {
		that2, ok := that.(ToneChange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GainBias.Equal(that1.GainBias) {
		return false
	}
	if !this.Affine.Equal(that1.Affine) {
		return false
	}
	if !this.MixtureGainBias.Equal(that1.MixtureGainBias) {
		return false
	}
	if !this.MixtureAffine.Equal(that1.MixtureAffine) {
		return false
	}
	if this.MixtureDomainSigma != that1.MixtureDomainSigma {
		return false
	}
	if this.FracClipped != nil && that1.FracClipped != nil {
		if *this.FracClipped != *that1.FracClipped {
			return false
		}
	} else if this.FracClipped != nil {
		return false
	} else if that1.FracClipped != nil {
		return false
	}
	if this.LowPercentile != that1.LowPercentile {
		return false
	}
	if this.LowMidPercentile != that1.LowMidPercentile {
		return false
	}
	if this.MidPercentile != that1.MidPercentile {
		return false
	}
	if this.HighMidPercentile != that1.HighMidPercentile {
		return false
	}
	if this.HighPercentile != that1.HighPercentile {
		return false
	}
	if this.LogDomain != nil && that1.LogDomain != nil {
		if *this.LogDomain != *that1.LogDomain {
			return false
		}
	} else if this.LogDomain != nil {
		return false
	} else if that1.LogDomain != nil {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !this.StabilityStats.Equal(that1.StabilityStats) {
		return false
	}
	return true
}
func (this *ToneChange_StabilityStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneChange_StabilityStats)
	if !ok {
		that2, ok := that.(ToneChange_StabilityStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumInliers != that1.NumInliers {
		return false
	}
	if this.InlierFraction != that1.InlierFraction {
		return false
	}
	if this.InlierWeight != that1.InlierWeight {
		return false
	}
	return true
}
func (this *ToneMatchOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneMatchOptions)
	if !ok {
		that2, ok := that.(ToneMatchOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinMatchPercentile != nil && that1.MinMatchPercentile != nil {
		if *this.MinMatchPercentile != *that1.MinMatchPercentile {
			return false
		}
	} else if this.MinMatchPercentile != nil {
		return false
	} else if that1.MinMatchPercentile != nil {
		return false
	}
	if this.MaxMatchPercentile != nil && that1.MaxMatchPercentile != nil {
		if *this.MaxMatchPercentile != *that1.MaxMatchPercentile {
			return false
		}
	} else if this.MaxMatchPercentile != nil {
		return false
	} else if that1.MaxMatchPercentile != nil {
		return false
	}
	if this.MatchPercentileSteps != nil && that1.MatchPercentileSteps != nil {
		if *this.MatchPercentileSteps != *that1.MatchPercentileSteps {
			return false
		}
	} else if this.MatchPercentileSteps != nil {
		return false
	} else if that1.MatchPercentileSteps != nil {
		return false
	}
	if this.PatchRadius != nil && that1.PatchRadius != nil {
		if *this.PatchRadius != *that1.PatchRadius {
			return false
		}
	} else if this.PatchRadius != nil {
		return false
	} else if that1.PatchRadius != nil {
		return false
	}
	if this.MaxFracClipped != nil && that1.MaxFracClipped != nil {
		if *this.MaxFracClipped != *that1.MaxFracClipped {
			return false
		}
	} else if this.MaxFracClipped != nil {
		return false
	} else if that1.MaxFracClipped != nil {
		return false
	}
	if this.LogDomain != nil && that1.LogDomain != nil {
		if *this.LogDomain != *that1.LogDomain {
			return false
		}
	} else if this.LogDomain != nil {
		return false
	} else if that1.LogDomain != nil {
		return false
	}
	return true
}
func (this *ClipMaskOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClipMaskOptions)
	if !ok {
		that2, ok := that.(ClipMaskOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinExposure != nil && that1.MinExposure != nil {
		if *this.MinExposure != *that1.MinExposure {
			return false
		}
	} else if this.MinExposure != nil {
		return false
	} else if that1.MinExposure != nil {
		return false
	}
	if this.MaxExposure != nil && that1.MaxExposure != nil {
		if *this.MaxExposure != *that1.MaxExposure {
			return false
		}
	} else if this.MaxExposure != nil {
		return false
	} else if that1.MaxExposure != nil {
		return false
	}
	if this.MaxClippedChannels != nil && that1.MaxClippedChannels != nil {
		if *this.MaxClippedChannels != *that1.MaxClippedChannels {
			return false
		}
	} else if this.MaxClippedChannels != nil {
		return false
	} else if that1.MaxClippedChannels != nil {
		return false
	}
	if this.ClipMaskDiameter != nil && that1.ClipMaskDiameter != nil {
		if *this.ClipMaskDiameter != *that1.ClipMaskDiameter {
			return false
		}
	} else if this.ClipMaskDiameter != nil {
		return false
	} else if that1.ClipMaskDiameter != nil {
		return false
	}
	return true
}
func (this *ToneEstimationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneEstimationOptions)
	if !ok {
		that2, ok := that.(ToneEstimationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ToneMatchOptions.Equal(that1.ToneMatchOptions) {
		return false
	}
	if !this.ClipMaskOptions.Equal(that1.ClipMaskOptions) {
		return false
	}
	if this.StatsLowPercentile != nil && that1.StatsLowPercentile != nil {
		if *this.StatsLowPercentile != *that1.StatsLowPercentile {
			return false
		}
	} else if this.StatsLowPercentile != nil {
		return false
	} else if that1.StatsLowPercentile != nil {
		return false
	}
	if this.StatsLowMidPercentile != nil && that1.StatsLowMidPercentile != nil {
		if *this.StatsLowMidPercentile != *that1.StatsLowMidPercentile {
			return false
		}
	} else if this.StatsLowMidPercentile != nil {
		return false
	} else if that1.StatsLowMidPercentile != nil {
		return false
	}
	if this.StatsMidPercentile != nil && that1.StatsMidPercentile != nil {
		if *this.StatsMidPercentile != *that1.StatsMidPercentile {
			return false
		}
	} else if this.StatsMidPercentile != nil {
		return false
	} else if that1.StatsMidPercentile != nil {
		return false
	}
	if this.StatsHighMidPercentile != nil && that1.StatsHighMidPercentile != nil {
		if *this.StatsHighMidPercentile != *that1.StatsHighMidPercentile {
			return false
		}
	} else if this.StatsHighMidPercentile != nil {
		return false
	} else if that1.StatsHighMidPercentile != nil {
		return false
	}
	if this.StatsHighPercentile != nil && that1.StatsHighPercentile != nil {
		if *this.StatsHighPercentile != *that1.StatsHighPercentile {
			return false
		}
	} else if this.StatsHighPercentile != nil {
		return false
	} else if that1.StatsHighPercentile != nil {
		return false
	}
	if this.IrlsIterations != nil && that1.IrlsIterations != nil {
		if *this.IrlsIterations != *that1.IrlsIterations {
			return false
		}
	} else if this.IrlsIterations != nil {
		return false
	} else if that1.IrlsIterations != nil {
		return false
	}
	if !this.StableGainBiasBounds.Equal(that1.StableGainBiasBounds) {
		return false
	}
	if this.DownsampleMode != nil && that1.DownsampleMode != nil {
		if *this.DownsampleMode != *that1.DownsampleMode {
			return false
		}
	} else if this.DownsampleMode != nil {
		return false
	} else if that1.DownsampleMode != nil {
		return false
	}
	if this.DownsamplingSize != nil && that1.DownsamplingSize != nil {
		if *this.DownsamplingSize != *that1.DownsamplingSize {
			return false
		}
	} else if this.DownsamplingSize != nil {
		return false
	} else if that1.DownsamplingSize != nil {
		return false
	}
	if this.DownsampleFactor != nil && that1.DownsampleFactor != nil {
		if *this.DownsampleFactor != *that1.DownsampleFactor {
			return false
		}
	} else if this.DownsampleFactor != nil {
		return false
	} else if that1.DownsampleFactor != nil {
		return false
	}
	return true
}
func (this *ToneEstimationOptions_GainBiasBounds) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneEstimationOptions_GainBiasBounds)
	if !ok {
		that2, ok := that.(ToneEstimationOptions_GainBiasBounds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinInlierFraction != nil && that1.MinInlierFraction != nil {
		if *this.MinInlierFraction != *that1.MinInlierFraction {
			return false
		}
	} else if this.MinInlierFraction != nil {
		return false
	} else if that1.MinInlierFraction != nil {
		return false
	}
	if this.MinInlierWeight != nil && that1.MinInlierWeight != nil {
		if *this.MinInlierWeight != *that1.MinInlierWeight {
			return false
		}
	} else if this.MinInlierWeight != nil {
		return false
	} else if that1.MinInlierWeight != nil {
		return false
	}
	if this.LowerGain != nil && that1.LowerGain != nil {
		if *this.LowerGain != *that1.LowerGain {
			return false
		}
	} else if this.LowerGain != nil {
		return false
	} else if that1.LowerGain != nil {
		return false
	}
	if this.UpperGain != nil && that1.UpperGain != nil {
		if *this.UpperGain != *that1.UpperGain {
			return false
		}
	} else if this.UpperGain != nil {
		return false
	} else if that1.UpperGain != nil {
		return false
	}
	if this.LowerBias != nil && that1.LowerBias != nil {
		if *this.LowerBias != *that1.LowerBias {
			return false
		}
	} else if this.LowerBias != nil {
		return false
	} else if that1.LowerBias != nil {
		return false
	}
	if this.UpperBias != nil && that1.UpperBias != nil {
		if *this.UpperBias != *that1.UpperBias {
			return false
		}
	} else if this.UpperBias != nil {
		return false
	} else if that1.UpperBias != nil {
		return false
	}
	return true
}
func (this *ToneMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ToneMatch)
	if !ok {
		that2, ok := that.(ToneMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CurrVal != that1.CurrVal {
		return false
	}
	if this.PrevVal != that1.PrevVal {
		return false
	}
	return true
}
func (this *PatchToneMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PatchToneMatch)
	if !ok {
		that2, ok := that.(PatchToneMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ToneMatch) != len(that1.ToneMatch) {
		return false
	}
	for i := range this.ToneMatch {
		if !this.ToneMatch[i].Equal(that1.ToneMatch[i]) {
			return false
		}
	}
	if this.IrlsWeight != nil && that1.IrlsWeight != nil {
		if *this.IrlsWeight != *that1.IrlsWeight {
			return false
		}
	} else if this.IrlsWeight != nil {
		return false
	} else if that1.IrlsWeight != nil {
		return false
	}
	return true
}
func (this *ToneChange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&tracking.ToneChange{")
	if this.GainBias != nil {
		s = append(s, "GainBias: "+fmt.Sprintf("%#v", this.GainBias)+",\n")
	}
	if this.Affine != nil {
		s = append(s, "Affine: "+fmt.Sprintf("%#v", this.Affine)+",\n")
	}
	if this.MixtureGainBias != nil {
		s = append(s, "MixtureGainBias: "+fmt.Sprintf("%#v", this.MixtureGainBias)+",\n")
	}
	if this.MixtureAffine != nil {
		s = append(s, "MixtureAffine: "+fmt.Sprintf("%#v", this.MixtureAffine)+",\n")
	}
	s = append(s, "MixtureDomainSigma: "+fmt.Sprintf("%#v", this.MixtureDomainSigma)+",\n")
	if this.FracClipped != nil {
		s = append(s, "FracClipped: "+valueToGoStringToneEstimation(this.FracClipped, "float32")+",\n")
	}
	s = append(s, "LowPercentile: "+fmt.Sprintf("%#v", this.LowPercentile)+",\n")
	s = append(s, "LowMidPercentile: "+fmt.Sprintf("%#v", this.LowMidPercentile)+",\n")
	s = append(s, "MidPercentile: "+fmt.Sprintf("%#v", this.MidPercentile)+",\n")
	s = append(s, "HighMidPercentile: "+fmt.Sprintf("%#v", this.HighMidPercentile)+",\n")
	s = append(s, "HighPercentile: "+fmt.Sprintf("%#v", this.HighPercentile)+",\n")
	if this.LogDomain != nil {
		s = append(s, "LogDomain: "+valueToGoStringToneEstimation(this.LogDomain, "bool")+",\n")
	}
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringToneEstimation(this.Type, "ToneChange_Type")+",\n")
	}
	if this.StabilityStats != nil {
		s = append(s, "StabilityStats: "+fmt.Sprintf("%#v", this.StabilityStats)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToneChange_StabilityStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.ToneChange_StabilityStats{")
	s = append(s, "NumInliers: "+fmt.Sprintf("%#v", this.NumInliers)+",\n")
	s = append(s, "InlierFraction: "+fmt.Sprintf("%#v", this.InlierFraction)+",\n")
	s = append(s, "InlierWeight: "+fmt.Sprintf("%#v", this.InlierWeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToneMatchOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.ToneMatchOptions{")
	if this.MinMatchPercentile != nil {
		s = append(s, "MinMatchPercentile: "+valueToGoStringToneEstimation(this.MinMatchPercentile, "float32")+",\n")
	}
	if this.MaxMatchPercentile != nil {
		s = append(s, "MaxMatchPercentile: "+valueToGoStringToneEstimation(this.MaxMatchPercentile, "float32")+",\n")
	}
	if this.MatchPercentileSteps != nil {
		s = append(s, "MatchPercentileSteps: "+valueToGoStringToneEstimation(this.MatchPercentileSteps, "int32")+",\n")
	}
	if this.PatchRadius != nil {
		s = append(s, "PatchRadius: "+valueToGoStringToneEstimation(this.PatchRadius, "int32")+",\n")
	}
	if this.MaxFracClipped != nil {
		s = append(s, "MaxFracClipped: "+valueToGoStringToneEstimation(this.MaxFracClipped, "float32")+",\n")
	}
	if this.LogDomain != nil {
		s = append(s, "LogDomain: "+valueToGoStringToneEstimation(this.LogDomain, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClipMaskOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tracking.ClipMaskOptions{")
	if this.MinExposure != nil {
		s = append(s, "MinExposure: "+valueToGoStringToneEstimation(this.MinExposure, "float32")+",\n")
	}
	if this.MaxExposure != nil {
		s = append(s, "MaxExposure: "+valueToGoStringToneEstimation(this.MaxExposure, "float32")+",\n")
	}
	if this.MaxClippedChannels != nil {
		s = append(s, "MaxClippedChannels: "+valueToGoStringToneEstimation(this.MaxClippedChannels, "int32")+",\n")
	}
	if this.ClipMaskDiameter != nil {
		s = append(s, "ClipMaskDiameter: "+valueToGoStringToneEstimation(this.ClipMaskDiameter, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToneEstimationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&tracking.ToneEstimationOptions{")
	if this.ToneMatchOptions != nil {
		s = append(s, "ToneMatchOptions: "+fmt.Sprintf("%#v", this.ToneMatchOptions)+",\n")
	}
	if this.ClipMaskOptions != nil {
		s = append(s, "ClipMaskOptions: "+fmt.Sprintf("%#v", this.ClipMaskOptions)+",\n")
	}
	if this.StatsLowPercentile != nil {
		s = append(s, "StatsLowPercentile: "+valueToGoStringToneEstimation(this.StatsLowPercentile, "float32")+",\n")
	}
	if this.StatsLowMidPercentile != nil {
		s = append(s, "StatsLowMidPercentile: "+valueToGoStringToneEstimation(this.StatsLowMidPercentile, "float32")+",\n")
	}
	if this.StatsMidPercentile != nil {
		s = append(s, "StatsMidPercentile: "+valueToGoStringToneEstimation(this.StatsMidPercentile, "float32")+",\n")
	}
	if this.StatsHighMidPercentile != nil {
		s = append(s, "StatsHighMidPercentile: "+valueToGoStringToneEstimation(this.StatsHighMidPercentile, "float32")+",\n")
	}
	if this.StatsHighPercentile != nil {
		s = append(s, "StatsHighPercentile: "+valueToGoStringToneEstimation(this.StatsHighPercentile, "float32")+",\n")
	}
	if this.IrlsIterations != nil {
		s = append(s, "IrlsIterations: "+valueToGoStringToneEstimation(this.IrlsIterations, "int32")+",\n")
	}
	if this.StableGainBiasBounds != nil {
		s = append(s, "StableGainBiasBounds: "+fmt.Sprintf("%#v", this.StableGainBiasBounds)+",\n")
	}
	if this.DownsampleMode != nil {
		s = append(s, "DownsampleMode: "+valueToGoStringToneEstimation(this.DownsampleMode, "ToneEstimationOptions_DownsampleMode")+",\n")
	}
	if this.DownsamplingSize != nil {
		s = append(s, "DownsamplingSize: "+valueToGoStringToneEstimation(this.DownsamplingSize, "int32")+",\n")
	}
	if this.DownsampleFactor != nil {
		s = append(s, "DownsampleFactor: "+valueToGoStringToneEstimation(this.DownsampleFactor, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToneEstimationOptions_GainBiasBounds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tracking.ToneEstimationOptions_GainBiasBounds{")
	if this.MinInlierFraction != nil {
		s = append(s, "MinInlierFraction: "+valueToGoStringToneEstimation(this.MinInlierFraction, "float32")+",\n")
	}
	if this.MinInlierWeight != nil {
		s = append(s, "MinInlierWeight: "+valueToGoStringToneEstimation(this.MinInlierWeight, "float32")+",\n")
	}
	if this.LowerGain != nil {
		s = append(s, "LowerGain: "+valueToGoStringToneEstimation(this.LowerGain, "float32")+",\n")
	}
	if this.UpperGain != nil {
		s = append(s, "UpperGain: "+valueToGoStringToneEstimation(this.UpperGain, "float32")+",\n")
	}
	if this.LowerBias != nil {
		s = append(s, "LowerBias: "+valueToGoStringToneEstimation(this.LowerBias, "float32")+",\n")
	}
	if this.UpperBias != nil {
		s = append(s, "UpperBias: "+valueToGoStringToneEstimation(this.UpperBias, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ToneMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.ToneMatch{")
	s = append(s, "CurrVal: "+fmt.Sprintf("%#v", this.CurrVal)+",\n")
	s = append(s, "PrevVal: "+fmt.Sprintf("%#v", this.PrevVal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PatchToneMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tracking.PatchToneMatch{")
	if this.ToneMatch != nil {
		s = append(s, "ToneMatch: "+fmt.Sprintf("%#v", this.ToneMatch)+",\n")
	}
	if this.IrlsWeight != nil {
		s = append(s, "IrlsWeight: "+valueToGoStringToneEstimation(this.IrlsWeight, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringToneEstimation(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ToneChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StabilityStats != nil {
		{
			size, err := m.StabilityStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Type != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x70
	}
	if m.LogDomain != nil {
		i--
		if *m.LogDomain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HighPercentile))))
	i--
	dAtA[i] = 0x65
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HighMidPercentile))))
	i--
	dAtA[i] = 0x5d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MidPercentile))))
	i--
	dAtA[i] = 0x55
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LowMidPercentile))))
	i--
	dAtA[i] = 0x4d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LowPercentile))))
	i--
	dAtA[i] = 0x45
	if m.FracClipped != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FracClipped))))
		i--
		dAtA[i] = 0x35
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MixtureDomainSigma))))
	i--
	dAtA[i] = 0x2d
	if m.MixtureAffine != nil {
		{
			size, err := m.MixtureAffine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MixtureGainBias != nil {
		{
			size, err := m.MixtureGainBias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Affine != nil {
		{
			size, err := m.Affine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GainBias != nil {
		{
			size, err := m.GainBias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ToneChange_StabilityStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneChange_StabilityStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneChange_StabilityStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InlierWeight))))
	i--
	dAtA[i] = 0x19
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierFraction))))
	i--
	dAtA[i] = 0x15
	i = encodeVarintToneEstimation(dAtA, i, uint64(m.NumInliers))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ToneMatchOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneMatchOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneMatchOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogDomain != nil {
		i--
		if *m.LogDomain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.MaxFracClipped != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxFracClipped))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PatchRadius != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.PatchRadius))
		i--
		dAtA[i] = 0x20
	}
	if m.MatchPercentileSteps != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.MatchPercentileSteps))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxMatchPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxMatchPercentile))))
		i--
		dAtA[i] = 0x15
	}
	if m.MinMatchPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinMatchPercentile))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ClipMaskOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClipMaskOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClipMaskOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClipMaskDiameter != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.ClipMaskDiameter))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxClippedChannels != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.MaxClippedChannels))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxExposure != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MaxExposure))))
		i--
		dAtA[i] = 0x15
	}
	if m.MinExposure != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinExposure))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ToneEstimationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneEstimationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneEstimationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownsampleFactor != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DownsampleFactor))))
		i--
		dAtA[i] = 0x65
	}
	if m.DownsamplingSize != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.DownsamplingSize))
		i--
		dAtA[i] = 0x58
	}
	if m.DownsampleMode != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.DownsampleMode))
		i--
		dAtA[i] = 0x50
	}
	if m.StableGainBiasBounds != nil {
		{
			size, err := m.StableGainBiasBounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.IrlsIterations != nil {
		i = encodeVarintToneEstimation(dAtA, i, uint64(*m.IrlsIterations))
		i--
		dAtA[i] = 0x40
	}
	if m.StatsHighPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StatsHighPercentile))))
		i--
		dAtA[i] = 0x3d
	}
	if m.StatsHighMidPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StatsHighMidPercentile))))
		i--
		dAtA[i] = 0x35
	}
	if m.StatsMidPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StatsMidPercentile))))
		i--
		dAtA[i] = 0x2d
	}
	if m.StatsLowMidPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StatsLowMidPercentile))))
		i--
		dAtA[i] = 0x25
	}
	if m.StatsLowPercentile != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StatsLowPercentile))))
		i--
		dAtA[i] = 0x1d
	}
	if m.ClipMaskOptions != nil {
		{
			size, err := m.ClipMaskOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ToneMatchOptions != nil {
		{
			size, err := m.ToneMatchOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintToneEstimation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ToneEstimationOptions_GainBiasBounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneEstimationOptions_GainBiasBounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneEstimationOptions_GainBiasBounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpperBias != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.UpperBias))))
		i--
		dAtA[i] = 0x35
	}
	if m.LowerBias != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LowerBias))))
		i--
		dAtA[i] = 0x2d
	}
	if m.UpperGain != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.UpperGain))))
		i--
		dAtA[i] = 0x25
	}
	if m.LowerGain != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LowerGain))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MinInlierWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierWeight))))
		i--
		dAtA[i] = 0x15
	}
	if m.MinInlierFraction != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierFraction))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ToneMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToneMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToneMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PrevVal))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CurrVal))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *PatchToneMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatchToneMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PatchToneMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IrlsWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.IrlsWeight))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.ToneMatch) > 0 {
		for iNdEx := len(m.ToneMatch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToneMatch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintToneEstimation(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintToneEstimation(dAtA []byte, offset int, v uint64) int {
	offset -= sovToneEstimation(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ToneChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GainBias != nil {
		l = m.GainBias.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.Affine != nil {
		l = m.Affine.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.MixtureGainBias != nil {
		l = m.MixtureGainBias.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.MixtureAffine != nil {
		l = m.MixtureAffine.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	n += 5
	if m.FracClipped != nil {
		n += 5
	}
	n += 5
	n += 5
	n += 5
	n += 5
	n += 5
	if m.LogDomain != nil {
		n += 2
	}
	if m.Type != nil {
		n += 1 + sovToneEstimation(uint64(*m.Type))
	}
	if m.StabilityStats != nil {
		l = m.StabilityStats.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	return n
}

func (m *ToneChange_StabilityStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovToneEstimation(uint64(m.NumInliers))
	n += 5
	n += 9
	return n
}

func (m *ToneMatchOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinMatchPercentile != nil {
		n += 5
	}
	if m.MaxMatchPercentile != nil {
		n += 5
	}
	if m.MatchPercentileSteps != nil {
		n += 1 + sovToneEstimation(uint64(*m.MatchPercentileSteps))
	}
	if m.PatchRadius != nil {
		n += 1 + sovToneEstimation(uint64(*m.PatchRadius))
	}
	if m.MaxFracClipped != nil {
		n += 5
	}
	if m.LogDomain != nil {
		n += 2
	}
	return n
}

func (m *ClipMaskOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinExposure != nil {
		n += 5
	}
	if m.MaxExposure != nil {
		n += 5
	}
	if m.MaxClippedChannels != nil {
		n += 1 + sovToneEstimation(uint64(*m.MaxClippedChannels))
	}
	if m.ClipMaskDiameter != nil {
		n += 1 + sovToneEstimation(uint64(*m.ClipMaskDiameter))
	}
	return n
}

func (m *ToneEstimationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToneMatchOptions != nil {
		l = m.ToneMatchOptions.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.ClipMaskOptions != nil {
		l = m.ClipMaskOptions.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.StatsLowPercentile != nil {
		n += 5
	}
	if m.StatsLowMidPercentile != nil {
		n += 5
	}
	if m.StatsMidPercentile != nil {
		n += 5
	}
	if m.StatsHighMidPercentile != nil {
		n += 5
	}
	if m.StatsHighPercentile != nil {
		n += 5
	}
	if m.IrlsIterations != nil {
		n += 1 + sovToneEstimation(uint64(*m.IrlsIterations))
	}
	if m.StableGainBiasBounds != nil {
		l = m.StableGainBiasBounds.Size()
		n += 1 + l + sovToneEstimation(uint64(l))
	}
	if m.DownsampleMode != nil {
		n += 1 + sovToneEstimation(uint64(*m.DownsampleMode))
	}
	if m.DownsamplingSize != nil {
		n += 1 + sovToneEstimation(uint64(*m.DownsamplingSize))
	}
	if m.DownsampleFactor != nil {
		n += 5
	}
	return n
}

func (m *ToneEstimationOptions_GainBiasBounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinInlierFraction != nil {
		n += 5
	}
	if m.MinInlierWeight != nil {
		n += 5
	}
	if m.LowerGain != nil {
		n += 5
	}
	if m.UpperGain != nil {
		n += 5
	}
	if m.LowerBias != nil {
		n += 5
	}
	if m.UpperBias != nil {
		n += 5
	}
	return n
}

func (m *ToneMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	return n
}

func (m *PatchToneMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ToneMatch) > 0 {
		for _, e := range m.ToneMatch {
			l = e.Size()
			n += 1 + l + sovToneEstimation(uint64(l))
		}
	}
	if m.IrlsWeight != nil {
		n += 5
	}
	return n
}

func sovToneEstimation(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozToneEstimation(x uint64) (n int) {
	return sovToneEstimation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ToneChange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneChange{`,
		`GainBias:` + strings.Replace(fmt.Sprintf("%v", this.GainBias), "GainBiasModel", "GainBiasModel", 1) + `,`,
		`Affine:` + strings.Replace(fmt.Sprintf("%v", this.Affine), "AffineToneModel", "AffineToneModel", 1) + `,`,
		`MixtureGainBias:` + strings.Replace(fmt.Sprintf("%v", this.MixtureGainBias), "MixtureGainBiasModel", "MixtureGainBiasModel", 1) + `,`,
		`MixtureAffine:` + strings.Replace(fmt.Sprintf("%v", this.MixtureAffine), "MixtureAffineToneModel", "MixtureAffineToneModel", 1) + `,`,
		`MixtureDomainSigma:` + fmt.Sprintf("%v", this.MixtureDomainSigma) + `,`,
		`FracClipped:` + valueToStringToneEstimation(this.FracClipped) + `,`,
		`LowPercentile:` + fmt.Sprintf("%v", this.LowPercentile) + `,`,
		`LowMidPercentile:` + fmt.Sprintf("%v", this.LowMidPercentile) + `,`,
		`MidPercentile:` + fmt.Sprintf("%v", this.MidPercentile) + `,`,
		`HighMidPercentile:` + fmt.Sprintf("%v", this.HighMidPercentile) + `,`,
		`HighPercentile:` + fmt.Sprintf("%v", this.HighPercentile) + `,`,
		`LogDomain:` + valueToStringToneEstimation(this.LogDomain) + `,`,
		`Type:` + valueToStringToneEstimation(this.Type) + `,`,
		`StabilityStats:` + strings.Replace(fmt.Sprintf("%v", this.StabilityStats), "ToneChange_StabilityStats", "ToneChange_StabilityStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToneChange_StabilityStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneChange_StabilityStats{`,
		`NumInliers:` + fmt.Sprintf("%v", this.NumInliers) + `,`,
		`InlierFraction:` + fmt.Sprintf("%v", this.InlierFraction) + `,`,
		`InlierWeight:` + fmt.Sprintf("%v", this.InlierWeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToneMatchOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneMatchOptions{`,
		`MinMatchPercentile:` + valueToStringToneEstimation(this.MinMatchPercentile) + `,`,
		`MaxMatchPercentile:` + valueToStringToneEstimation(this.MaxMatchPercentile) + `,`,
		`MatchPercentileSteps:` + valueToStringToneEstimation(this.MatchPercentileSteps) + `,`,
		`PatchRadius:` + valueToStringToneEstimation(this.PatchRadius) + `,`,
		`MaxFracClipped:` + valueToStringToneEstimation(this.MaxFracClipped) + `,`,
		`LogDomain:` + valueToStringToneEstimation(this.LogDomain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClipMaskOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClipMaskOptions{`,
		`MinExposure:` + valueToStringToneEstimation(this.MinExposure) + `,`,
		`MaxExposure:` + valueToStringToneEstimation(this.MaxExposure) + `,`,
		`MaxClippedChannels:` + valueToStringToneEstimation(this.MaxClippedChannels) + `,`,
		`ClipMaskDiameter:` + valueToStringToneEstimation(this.ClipMaskDiameter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToneEstimationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneEstimationOptions{`,
		`ToneMatchOptions:` + strings.Replace(this.ToneMatchOptions.String(), "ToneMatchOptions", "ToneMatchOptions", 1) + `,`,
		`ClipMaskOptions:` + strings.Replace(this.ClipMaskOptions.String(), "ClipMaskOptions", "ClipMaskOptions", 1) + `,`,
		`StatsLowPercentile:` + valueToStringToneEstimation(this.StatsLowPercentile) + `,`,
		`StatsLowMidPercentile:` + valueToStringToneEstimation(this.StatsLowMidPercentile) + `,`,
		`StatsMidPercentile:` + valueToStringToneEstimation(this.StatsMidPercentile) + `,`,
		`StatsHighMidPercentile:` + valueToStringToneEstimation(this.StatsHighMidPercentile) + `,`,
		`StatsHighPercentile:` + valueToStringToneEstimation(this.StatsHighPercentile) + `,`,
		`IrlsIterations:` + valueToStringToneEstimation(this.IrlsIterations) + `,`,
		`StableGainBiasBounds:` + strings.Replace(fmt.Sprintf("%v", this.StableGainBiasBounds), "ToneEstimationOptions_GainBiasBounds", "ToneEstimationOptions_GainBiasBounds", 1) + `,`,
		`DownsampleMode:` + valueToStringToneEstimation(this.DownsampleMode) + `,`,
		`DownsamplingSize:` + valueToStringToneEstimation(this.DownsamplingSize) + `,`,
		`DownsampleFactor:` + valueToStringToneEstimation(this.DownsampleFactor) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToneEstimationOptions_GainBiasBounds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneEstimationOptions_GainBiasBounds{`,
		`MinInlierFraction:` + valueToStringToneEstimation(this.MinInlierFraction) + `,`,
		`MinInlierWeight:` + valueToStringToneEstimation(this.MinInlierWeight) + `,`,
		`LowerGain:` + valueToStringToneEstimation(this.LowerGain) + `,`,
		`UpperGain:` + valueToStringToneEstimation(this.UpperGain) + `,`,
		`LowerBias:` + valueToStringToneEstimation(this.LowerBias) + `,`,
		`UpperBias:` + valueToStringToneEstimation(this.UpperBias) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ToneMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ToneMatch{`,
		`CurrVal:` + fmt.Sprintf("%v", this.CurrVal) + `,`,
		`PrevVal:` + fmt.Sprintf("%v", this.PrevVal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PatchToneMatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForToneMatch := "[]*ToneMatch{"
	for _, f := range this.ToneMatch {
		repeatedStringForToneMatch += strings.Replace(f.String(), "ToneMatch", "ToneMatch", 1) + ","
	}
	repeatedStringForToneMatch += "}"
	s := strings.Join([]string{`&PatchToneMatch{`,
		`ToneMatch:` + repeatedStringForToneMatch + `,`,
		`IrlsWeight:` + valueToStringToneEstimation(this.IrlsWeight) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringToneEstimation(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ToneChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToneChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToneChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainBias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GainBias == nil {
				m.GainBias = &GainBiasModel{}
			}
			if err := m.GainBias.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affine == nil {
				m.Affine = &AffineToneModel{}
			}
			if err := m.Affine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureGainBias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MixtureGainBias == nil {
				m.MixtureGainBias = &MixtureGainBiasModel{}
			}
			if err := m.MixtureGainBias.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureAffine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MixtureAffine == nil {
				m.MixtureAffine = &MixtureAffineToneModel{}
			}
			if err := m.MixtureAffine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixtureDomainSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MixtureDomainSigma = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FracClipped", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FracClipped = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LowPercentile = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowMidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LowMidPercentile = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MidPercentile = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighMidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HighMidPercentile = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HighPercentile = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogDomain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LogDomain = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ToneChange_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ToneChange_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StabilityStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StabilityStats == nil {
				m.StabilityStats = &ToneChange_StabilityStats{}
			}
			if err := m.StabilityStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToneChange_StabilityStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StabilityStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StabilityStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInliers", wireType)
			}
			m.NumInliers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInliers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierFraction = float32(math.Float32frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierWeight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InlierWeight = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToneMatchOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToneMatchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToneMatchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMatchPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinMatchPercentile = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMatchPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxMatchPercentile = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPercentileSteps", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchPercentileSteps = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchRadius", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PatchRadius = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFracClipped", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxFracClipped = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogDomain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LogDomain = &b
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClipMaskOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClipMaskOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClipMaskOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinExposure", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinExposure = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExposure", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MaxExposure = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClippedChannels", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxClippedChannels = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClipMaskDiameter", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClipMaskDiameter = &v
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToneEstimationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToneEstimationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToneEstimationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToneMatchOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToneMatchOptions == nil {
				m.ToneMatchOptions = &ToneMatchOptions{}
			}
			if err := m.ToneMatchOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClipMaskOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClipMaskOptions == nil {
				m.ClipMaskOptions = &ClipMaskOptions{}
			}
			if err := m.ClipMaskOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsLowPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StatsLowPercentile = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsLowMidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StatsLowMidPercentile = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsMidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StatsMidPercentile = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsHighMidPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StatsHighMidPercentile = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsHighPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StatsHighPercentile = &v2
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsIterations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrlsIterations = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableGainBiasBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StableGainBiasBounds == nil {
				m.StableGainBiasBounds = &ToneEstimationOptions_GainBiasBounds{}
			}
			if err := m.StableGainBiasBounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleMode", wireType)
			}
			var v ToneEstimationOptions_DownsampleMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ToneEstimationOptions_DownsampleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DownsampleMode = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsamplingSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DownsamplingSize = &v
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownsampleFactor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DownsampleFactor = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToneEstimationOptions_GainBiasBounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GainBiasBounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GainBiasBounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierFraction = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierWeight = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerGain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LowerGain = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperGain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.UpperGain = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBias", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LowerBias = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBias", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.UpperBias = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToneMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToneMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToneMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrVal", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CurrVal = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevVal", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PrevVal = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatchToneMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatchToneMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatchToneMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToneMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToneEstimation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToneMatch = append(m.ToneMatch, &ToneMatch{})
			if err := m.ToneMatch[len(m.ToneMatch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.IrlsWeight = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipToneEstimation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthToneEstimation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipToneEstimation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowToneEstimation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowToneEstimation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthToneEstimation
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupToneEstimation
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthToneEstimation
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthToneEstimation        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowToneEstimation          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupToneEstimation = fmt.Errorf("proto: unexpected end of group")
)
