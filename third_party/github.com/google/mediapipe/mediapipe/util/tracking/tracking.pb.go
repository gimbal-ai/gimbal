// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mediapipe/util/tracking/tracking.proto

package tracking

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MotionBoxState_TrackStatus int32

const (
	BOX_UNTRACKED            MotionBoxState_TrackStatus = 0
	BOX_EMPTY                MotionBoxState_TrackStatus = 1
	BOX_NO_FEATURES          MotionBoxState_TrackStatus = 2
	BOX_TRACKED              MotionBoxState_TrackStatus = 3
	BOX_DUPLICATED           MotionBoxState_TrackStatus = 4
	BOX_TRACKED_OUT_OF_BOUND MotionBoxState_TrackStatus = 5
)

var MotionBoxState_TrackStatus_name = map[int32]string{
	0: "BOX_UNTRACKED",
	1: "BOX_EMPTY",
	2: "BOX_NO_FEATURES",
	3: "BOX_TRACKED",
	4: "BOX_DUPLICATED",
	5: "BOX_TRACKED_OUT_OF_BOUND",
}

var MotionBoxState_TrackStatus_value = map[string]int32{
	"BOX_UNTRACKED":            0,
	"BOX_EMPTY":                1,
	"BOX_NO_FEATURES":          2,
	"BOX_TRACKED":              3,
	"BOX_DUPLICATED":           4,
	"BOX_TRACKED_OUT_OF_BOUND": 5,
}

func (x MotionBoxState_TrackStatus) Enum() *MotionBoxState_TrackStatus {
	p := new(MotionBoxState_TrackStatus)
	*p = x
	return p
}

func (x MotionBoxState_TrackStatus) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MotionBoxState_TrackStatus_name, int32(x))
}

func (x *MotionBoxState_TrackStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MotionBoxState_TrackStatus_value, data, "MotionBoxState_TrackStatus")
	if err != nil {
		return err
	}
	*x = MotionBoxState_TrackStatus(value)
	return nil
}

func (MotionBoxState_TrackStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{0, 0}
}

type TrackStepOptions_TrackingDegrees int32

const (
	TRACKING_DEGREE_TRANSLATION           TrackStepOptions_TrackingDegrees = 0
	TRACKING_DEGREE_CAMERA_SCALE          TrackStepOptions_TrackingDegrees = 1
	TRACKING_DEGREE_CAMERA_ROTATION       TrackStepOptions_TrackingDegrees = 2
	TRACKING_DEGREE_CAMERA_ROTATION_SCALE TrackStepOptions_TrackingDegrees = 3
	TRACKING_DEGREE_CAMERA_PERSPECTIVE    TrackStepOptions_TrackingDegrees = 4
	TRACKING_DEGREE_OBJECT_SCALE          TrackStepOptions_TrackingDegrees = 5
	TRACKING_DEGREE_OBJECT_ROTATION       TrackStepOptions_TrackingDegrees = 6
	TRACKING_DEGREE_OBJECT_ROTATION_SCALE TrackStepOptions_TrackingDegrees = 7
	TRACKING_DEGREE_OBJECT_PERSPECTIVE    TrackStepOptions_TrackingDegrees = 8
)

var TrackStepOptions_TrackingDegrees_name = map[int32]string{
	0: "TRACKING_DEGREE_TRANSLATION",
	1: "TRACKING_DEGREE_CAMERA_SCALE",
	2: "TRACKING_DEGREE_CAMERA_ROTATION",
	3: "TRACKING_DEGREE_CAMERA_ROTATION_SCALE",
	4: "TRACKING_DEGREE_CAMERA_PERSPECTIVE",
	5: "TRACKING_DEGREE_OBJECT_SCALE",
	6: "TRACKING_DEGREE_OBJECT_ROTATION",
	7: "TRACKING_DEGREE_OBJECT_ROTATION_SCALE",
	8: "TRACKING_DEGREE_OBJECT_PERSPECTIVE",
}

var TrackStepOptions_TrackingDegrees_value = map[string]int32{
	"TRACKING_DEGREE_TRANSLATION":           0,
	"TRACKING_DEGREE_CAMERA_SCALE":          1,
	"TRACKING_DEGREE_CAMERA_ROTATION":       2,
	"TRACKING_DEGREE_CAMERA_ROTATION_SCALE": 3,
	"TRACKING_DEGREE_CAMERA_PERSPECTIVE":    4,
	"TRACKING_DEGREE_OBJECT_SCALE":          5,
	"TRACKING_DEGREE_OBJECT_ROTATION":       6,
	"TRACKING_DEGREE_OBJECT_ROTATION_SCALE": 7,
	"TRACKING_DEGREE_OBJECT_PERSPECTIVE":    8,
}

func (x TrackStepOptions_TrackingDegrees) Enum() *TrackStepOptions_TrackingDegrees {
	p := new(TrackStepOptions_TrackingDegrees)
	*p = x
	return p
}

func (x TrackStepOptions_TrackingDegrees) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TrackStepOptions_TrackingDegrees_name, int32(x))
}

func (x *TrackStepOptions_TrackingDegrees) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TrackStepOptions_TrackingDegrees_value, data, "TrackStepOptions_TrackingDegrees")
	if err != nil {
		return err
	}
	*x = TrackStepOptions_TrackingDegrees(value)
	return nil
}

func (TrackStepOptions_TrackingDegrees) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{2, 0}
}

type MotionBoxState struct {
	PosX                     float32                     `protobuf:"fixed32,1,opt,name=pos_x,json=posX" json:"pos_x"`
	PosY                     float32                     `protobuf:"fixed32,2,opt,name=pos_y,json=posY" json:"pos_y"`
	Width                    float32                     `protobuf:"fixed32,3,opt,name=width" json:"width"`
	Height                   float32                     `protobuf:"fixed32,4,opt,name=height" json:"height"`
	Scale                    *float32                    `protobuf:"fixed32,5,opt,name=scale,def=1" json:"scale,omitempty"`
	Rotation                 *float32                    `protobuf:"fixed32,30,opt,name=rotation,def=0" json:"rotation,omitempty"`
	Quad                     *MotionBoxState_Quad        `protobuf:"bytes,34,opt,name=quad" json:"quad,omitempty"`
	AspectRatio              float32                     `protobuf:"fixed32,35,opt,name=aspect_ratio,json=aspectRatio" json:"aspect_ratio"`
	RequestGrouping          *bool                       `protobuf:"varint,37,opt,name=request_grouping,json=requestGrouping,def=0" json:"request_grouping,omitempty"`
	PnpHomography            *Homography                 `protobuf:"bytes,36,opt,name=pnp_homography,json=pnpHomography" json:"pnp_homography,omitempty"`
	Dx                       float32                     `protobuf:"fixed32,7,opt,name=dx" json:"dx"`
	Dy                       float32                     `protobuf:"fixed32,8,opt,name=dy" json:"dy"`
	KineticEnergy            float32                     `protobuf:"fixed32,17,opt,name=kinetic_energy,json=kineticEnergy" json:"kinetic_energy"`
	PriorWeight              float32                     `protobuf:"fixed32,9,opt,name=prior_weight,json=priorWeight" json:"prior_weight"`
	TrackStatus              *MotionBoxState_TrackStatus `protobuf:"varint,10,opt,name=track_status,json=trackStatus,enum=mediapipe.MotionBoxState_TrackStatus,def=0" json:"track_status,omitempty"`
	SpatialPriorGridSize     *int32                      `protobuf:"varint,11,opt,name=spatial_prior_grid_size,json=spatialPriorGridSize,def=10" json:"spatial_prior_grid_size,omitempty"`
	SpatialPrior             []float32                   `protobuf:"fixed32,12,rep,packed,name=spatial_prior,json=spatialPrior" json:"spatial_prior,omitempty"`
	SpatialConfidence        []float32                   `protobuf:"fixed32,13,rep,packed,name=spatial_confidence,json=spatialConfidence" json:"spatial_confidence,omitempty"`
	PriorDiff                float32                     `protobuf:"fixed32,14,opt,name=prior_diff,json=priorDiff" json:"prior_diff"`
	MotionDisparity          float32                     `protobuf:"fixed32,15,opt,name=motion_disparity,json=motionDisparity" json:"motion_disparity"`
	BackgroundDiscrimination float32                     `protobuf:"fixed32,16,opt,name=background_discrimination,json=backgroundDiscrimination" json:"background_discrimination"`
	InlierCenterX            float32                     `protobuf:"fixed32,18,opt,name=inlier_center_x,json=inlierCenterX" json:"inlier_center_x"`
	InlierCenterY            float32                     `protobuf:"fixed32,19,opt,name=inlier_center_y,json=inlierCenterY" json:"inlier_center_y"`
	InlierSum                float32                     `protobuf:"fixed32,24,opt,name=inlier_sum,json=inlierSum" json:"inlier_sum"`
	InlierRatio              float32                     `protobuf:"fixed32,25,opt,name=inlier_ratio,json=inlierRatio" json:"inlier_ratio"`
	InlierWidth              float32                     `protobuf:"fixed32,22,opt,name=inlier_width,json=inlierWidth" json:"inlier_width"`
	InlierHeight             float32                     `protobuf:"fixed32,23,opt,name=inlier_height,json=inlierHeight" json:"inlier_height"`
	InlierIds                []uint32                    `protobuf:"varint,26,rep,packed,name=inlier_ids,json=inlierIds" json:"inlier_ids,omitempty"`
	InlierIdMatchPos         []uint32                    `protobuf:"varint,31,rep,packed,name=inlier_id_match_pos,json=inlierIdMatchPos" json:"inlier_id_match_pos,omitempty"`
	InlierLength             []uint32                    `protobuf:"varint,27,rep,packed,name=inlier_length,json=inlierLength" json:"inlier_length,omitempty"`
	OutlierIds               []uint32                    `protobuf:"varint,28,rep,packed,name=outlier_ids,json=outlierIds" json:"outlier_ids,omitempty"`
	OutlierIdMatchPos        []uint32                    `protobuf:"varint,32,rep,packed,name=outlier_id_match_pos,json=outlierIdMatchPos" json:"outlier_id_match_pos,omitempty"`
	TrackingConfidence       float32                     `protobuf:"fixed32,33,opt,name=tracking_confidence,json=trackingConfidence" json:"tracking_confidence"`
	Internal                 *MotionBoxInternalState     `protobuf:"bytes,29,opt,name=internal" json:"internal,omitempty"`
}

func (m *MotionBoxState) Reset()      { *m = MotionBoxState{} }
func (*MotionBoxState) ProtoMessage() {}
func (*MotionBoxState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{0}
}
func (m *MotionBoxState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionBoxState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionBoxState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionBoxState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionBoxState.Merge(m, src)
}
func (m *MotionBoxState) XXX_Size() int {
	return m.Size()
}
func (m *MotionBoxState) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionBoxState.DiscardUnknown(m)
}

var xxx_messageInfo_MotionBoxState proto.InternalMessageInfo

const Default_MotionBoxState_Scale float32 = 1
const Default_MotionBoxState_Rotation float32 = 0
const Default_MotionBoxState_RequestGrouping bool = false
const Default_MotionBoxState_TrackStatus MotionBoxState_TrackStatus = BOX_UNTRACKED
const Default_MotionBoxState_SpatialPriorGridSize int32 = 10

func (m *MotionBoxState) GetPosX() float32 {
	if m != nil {
		return m.PosX
	}
	return 0
}

func (m *MotionBoxState) GetPosY() float32 {
	if m != nil {
		return m.PosY
	}
	return 0
}

func (m *MotionBoxState) GetWidth() float32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *MotionBoxState) GetHeight() float32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MotionBoxState) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_MotionBoxState_Scale
}

func (m *MotionBoxState) GetRotation() float32 {
	if m != nil && m.Rotation != nil {
		return *m.Rotation
	}
	return Default_MotionBoxState_Rotation
}

func (m *MotionBoxState) GetQuad() *MotionBoxState_Quad {
	if m != nil {
		return m.Quad
	}
	return nil
}

func (m *MotionBoxState) GetAspectRatio() float32 {
	if m != nil {
		return m.AspectRatio
	}
	return 0
}

func (m *MotionBoxState) GetRequestGrouping() bool {
	if m != nil && m.RequestGrouping != nil {
		return *m.RequestGrouping
	}
	return Default_MotionBoxState_RequestGrouping
}

func (m *MotionBoxState) GetPnpHomography() *Homography {
	if m != nil {
		return m.PnpHomography
	}
	return nil
}

func (m *MotionBoxState) GetDx() float32 {
	if m != nil {
		return m.Dx
	}
	return 0
}

func (m *MotionBoxState) GetDy() float32 {
	if m != nil {
		return m.Dy
	}
	return 0
}

func (m *MotionBoxState) GetKineticEnergy() float32 {
	if m != nil {
		return m.KineticEnergy
	}
	return 0
}

func (m *MotionBoxState) GetPriorWeight() float32 {
	if m != nil {
		return m.PriorWeight
	}
	return 0
}

func (m *MotionBoxState) GetTrackStatus() MotionBoxState_TrackStatus {
	if m != nil && m.TrackStatus != nil {
		return *m.TrackStatus
	}
	return Default_MotionBoxState_TrackStatus
}

func (m *MotionBoxState) GetSpatialPriorGridSize() int32 {
	if m != nil && m.SpatialPriorGridSize != nil {
		return *m.SpatialPriorGridSize
	}
	return Default_MotionBoxState_SpatialPriorGridSize
}

func (m *MotionBoxState) GetSpatialPrior() []float32 {
	if m != nil {
		return m.SpatialPrior
	}
	return nil
}

func (m *MotionBoxState) GetSpatialConfidence() []float32 {
	if m != nil {
		return m.SpatialConfidence
	}
	return nil
}

func (m *MotionBoxState) GetPriorDiff() float32 {
	if m != nil {
		return m.PriorDiff
	}
	return 0
}

func (m *MotionBoxState) GetMotionDisparity() float32 {
	if m != nil {
		return m.MotionDisparity
	}
	return 0
}

func (m *MotionBoxState) GetBackgroundDiscrimination() float32 {
	if m != nil {
		return m.BackgroundDiscrimination
	}
	return 0
}

func (m *MotionBoxState) GetInlierCenterX() float32 {
	if m != nil {
		return m.InlierCenterX
	}
	return 0
}

func (m *MotionBoxState) GetInlierCenterY() float32 {
	if m != nil {
		return m.InlierCenterY
	}
	return 0
}

func (m *MotionBoxState) GetInlierSum() float32 {
	if m != nil {
		return m.InlierSum
	}
	return 0
}

func (m *MotionBoxState) GetInlierRatio() float32 {
	if m != nil {
		return m.InlierRatio
	}
	return 0
}

func (m *MotionBoxState) GetInlierWidth() float32 {
	if m != nil {
		return m.InlierWidth
	}
	return 0
}

func (m *MotionBoxState) GetInlierHeight() float32 {
	if m != nil {
		return m.InlierHeight
	}
	return 0
}

func (m *MotionBoxState) GetInlierIds() []uint32 {
	if m != nil {
		return m.InlierIds
	}
	return nil
}

func (m *MotionBoxState) GetInlierIdMatchPos() []uint32 {
	if m != nil {
		return m.InlierIdMatchPos
	}
	return nil
}

func (m *MotionBoxState) GetInlierLength() []uint32 {
	if m != nil {
		return m.InlierLength
	}
	return nil
}

func (m *MotionBoxState) GetOutlierIds() []uint32 {
	if m != nil {
		return m.OutlierIds
	}
	return nil
}

func (m *MotionBoxState) GetOutlierIdMatchPos() []uint32 {
	if m != nil {
		return m.OutlierIdMatchPos
	}
	return nil
}

func (m *MotionBoxState) GetTrackingConfidence() float32 {
	if m != nil {
		return m.TrackingConfidence
	}
	return 0
}

func (m *MotionBoxState) GetInternal() *MotionBoxInternalState {
	if m != nil {
		return m.Internal
	}
	return nil
}

type MotionBoxState_Quad struct {
	Vertices []float32 `protobuf:"fixed32,1,rep,name=vertices" json:"vertices,omitempty"`
}

func (m *MotionBoxState_Quad) Reset()      { *m = MotionBoxState_Quad{} }
func (*MotionBoxState_Quad) ProtoMessage() {}
func (*MotionBoxState_Quad) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{0, 0}
}
func (m *MotionBoxState_Quad) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionBoxState_Quad) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionBoxState_Quad.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionBoxState_Quad) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionBoxState_Quad.Merge(m, src)
}
func (m *MotionBoxState_Quad) XXX_Size() int {
	return m.Size()
}
func (m *MotionBoxState_Quad) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionBoxState_Quad.DiscardUnknown(m)
}

var xxx_messageInfo_MotionBoxState_Quad proto.InternalMessageInfo

func (m *MotionBoxState_Quad) GetVertices() []float32 {
	if m != nil {
		return m.Vertices
	}
	return nil
}

type MotionBoxInternalState struct {
	PosX        []float32 `protobuf:"fixed32,1,rep,packed,name=pos_x,json=posX" json:"pos_x,omitempty"`
	PosY        []float32 `protobuf:"fixed32,2,rep,packed,name=pos_y,json=posY" json:"pos_y,omitempty"`
	Dx          []float32 `protobuf:"fixed32,3,rep,packed,name=dx" json:"dx,omitempty"`
	Dy          []float32 `protobuf:"fixed32,4,rep,packed,name=dy" json:"dy,omitempty"`
	CameraDx    []float32 `protobuf:"fixed32,5,rep,packed,name=camera_dx,json=cameraDx" json:"camera_dx,omitempty"`
	CameraDy    []float32 `protobuf:"fixed32,6,rep,packed,name=camera_dy,json=cameraDy" json:"camera_dy,omitempty"`
	TrackId     []int32   `protobuf:"varint,7,rep,packed,name=track_id,json=trackId" json:"track_id,omitempty"`
	InlierScore []float32 `protobuf:"fixed32,8,rep,packed,name=inlier_score,json=inlierScore" json:"inlier_score,omitempty"`
}

func (m *MotionBoxInternalState) Reset()      { *m = MotionBoxInternalState{} }
func (*MotionBoxInternalState) ProtoMessage() {}
func (*MotionBoxInternalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{1}
}
func (m *MotionBoxInternalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MotionBoxInternalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MotionBoxInternalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MotionBoxInternalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MotionBoxInternalState.Merge(m, src)
}
func (m *MotionBoxInternalState) XXX_Size() int {
	return m.Size()
}
func (m *MotionBoxInternalState) XXX_DiscardUnknown() {
	xxx_messageInfo_MotionBoxInternalState.DiscardUnknown(m)
}

var xxx_messageInfo_MotionBoxInternalState proto.InternalMessageInfo

func (m *MotionBoxInternalState) GetPosX() []float32 {
	if m != nil {
		return m.PosX
	}
	return nil
}

func (m *MotionBoxInternalState) GetPosY() []float32 {
	if m != nil {
		return m.PosY
	}
	return nil
}

func (m *MotionBoxInternalState) GetDx() []float32 {
	if m != nil {
		return m.Dx
	}
	return nil
}

func (m *MotionBoxInternalState) GetDy() []float32 {
	if m != nil {
		return m.Dy
	}
	return nil
}

func (m *MotionBoxInternalState) GetCameraDx() []float32 {
	if m != nil {
		return m.CameraDx
	}
	return nil
}

func (m *MotionBoxInternalState) GetCameraDy() []float32 {
	if m != nil {
		return m.CameraDy
	}
	return nil
}

func (m *MotionBoxInternalState) GetTrackId() []int32 {
	if m != nil {
		return m.TrackId
	}
	return nil
}

func (m *MotionBoxInternalState) GetInlierScore() []float32 {
	if m != nil {
		return m.InlierScore
	}
	return nil
}

type TrackStepOptions struct {
	TrackingDegrees                    *TrackStepOptions_TrackingDegrees                    `protobuf:"varint,28,opt,name=tracking_degrees,json=trackingDegrees,enum=mediapipe.TrackStepOptions_TrackingDegrees,def=0" json:"tracking_degrees,omitempty"`
	TrackObjectAndCamera               *bool                                                `protobuf:"varint,32,opt,name=track_object_and_camera,json=trackObjectAndCamera,def=0" json:"track_object_and_camera,omitempty"`
	IrlsIterations                     *int32                                               `protobuf:"varint,1,opt,name=irls_iterations,json=irlsIterations,def=5" json:"irls_iterations,omitempty"`
	SpatialSigma                       *float32                                             `protobuf:"fixed32,2,opt,name=spatial_sigma,json=spatialSigma,def=0.15" json:"spatial_sigma,omitempty"`
	MinMotionSigma                     *float32                                             `protobuf:"fixed32,3,opt,name=min_motion_sigma,json=minMotionSigma,def=0.002" json:"min_motion_sigma,omitempty"`
	RelativeMotionSigma                *float32                                             `protobuf:"fixed32,4,opt,name=relative_motion_sigma,json=relativeMotionSigma,def=0.3" json:"relative_motion_sigma,omitempty"`
	MotionDisparityLowLevel            *float32                                             `protobuf:"fixed32,6,opt,name=motion_disparity_low_level,json=motionDisparityLowLevel,def=0.008" json:"motion_disparity_low_level,omitempty"`
	MotionDisparityHighLevel           *float32                                             `protobuf:"fixed32,7,opt,name=motion_disparity_high_level,json=motionDisparityHighLevel,def=0.016" json:"motion_disparity_high_level,omitempty"`
	DisparityDecay                     *float32                                             `protobuf:"fixed32,8,opt,name=disparity_decay,json=disparityDecay,def=0.8" json:"disparity_decay,omitempty"`
	MotionPriorWeight                  *float32                                             `protobuf:"fixed32,9,opt,name=motion_prior_weight,json=motionPriorWeight,def=0.2" json:"motion_prior_weight,omitempty"`
	BackgroundDiscriminationLowLevel   *float32                                             `protobuf:"fixed32,10,opt,name=background_discrimination_low_level,json=backgroundDiscriminationLowLevel,def=0.004" json:"background_discrimination_low_level,omitempty"`
	BackgroundDiscriminationHighLevel  *float32                                             `protobuf:"fixed32,11,opt,name=background_discrimination_high_level,json=backgroundDiscriminationHighLevel,def=0.008" json:"background_discrimination_high_level,omitempty"`
	InlierCenterRelativeDistance       *float32                                             `protobuf:"fixed32,12,opt,name=inlier_center_relative_distance,json=inlierCenterRelativeDistance,def=0.1" json:"inlier_center_relative_distance,omitempty"`
	InlierSpringForce                  *float32                                             `protobuf:"fixed32,13,opt,name=inlier_spring_force,json=inlierSpringForce,def=0.3" json:"inlier_spring_force,omitempty"`
	KineticCenterRelativeDistance      *float32                                             `protobuf:"fixed32,14,opt,name=kinetic_center_relative_distance,json=kineticCenterRelativeDistance,def=0.4" json:"kinetic_center_relative_distance,omitempty"`
	KineticSpringForce                 *float32                                             `protobuf:"fixed32,15,opt,name=kinetic_spring_force,json=kineticSpringForce,def=0.5" json:"kinetic_spring_force,omitempty"`
	KineticSpringForceMinKineticEnergy *float32                                             `protobuf:"fixed32,21,opt,name=kinetic_spring_force_min_kinetic_energy,json=kineticSpringForceMinKineticEnergy,def=0.003" json:"kinetic_spring_force_min_kinetic_energy,omitempty"`
	VelocityUpdateWeight               *float32                                             `protobuf:"fixed32,16,opt,name=velocity_update_weight,json=velocityUpdateWeight,def=0.7" json:"velocity_update_weight,omitempty"`
	MaxTrackFailures                   *int32                                               `protobuf:"varint,17,opt,name=max_track_failures,json=maxTrackFailures,def=10" json:"max_track_failures,omitempty"`
	ExpansionSize                      *float32                                             `protobuf:"fixed32,18,opt,name=expansion_size,json=expansionSize,def=0.05" json:"expansion_size,omitempty"`
	InlierLowWeight                    *float32                                             `protobuf:"fixed32,19,opt,name=inlier_low_weight,json=inlierLowWeight,def=250" json:"inlier_low_weight,omitempty"`
	InlierHighWeight                   *float32                                             `protobuf:"fixed32,20,opt,name=inlier_high_weight,json=inlierHighWeight,def=500" json:"inlier_high_weight,omitempty"`
	KineticEnergyDecay                 *float32                                             `protobuf:"fixed32,22,opt,name=kinetic_energy_decay,json=kineticEnergyDecay,def=0.98" json:"kinetic_energy_decay,omitempty"`
	PriorWeightIncrease                *float32                                             `protobuf:"fixed32,23,opt,name=prior_weight_increase,json=priorWeightIncrease,def=0.2" json:"prior_weight_increase,omitempty"`
	LowKineticEnergy                   *float32                                             `protobuf:"fixed32,24,opt,name=low_kinetic_energy,json=lowKineticEnergy,def=0.001" json:"low_kinetic_energy,omitempty"`
	HighKineticEnergy                  *float32                                             `protobuf:"fixed32,25,opt,name=high_kinetic_energy,json=highKineticEnergy,def=0.004" json:"high_kinetic_energy,omitempty"`
	ReturnInternalState                *bool                                                `protobuf:"varint,26,opt,name=return_internal_state,json=returnInternalState,def=0" json:"return_internal_state,omitempty"`
	UsePostEstimationWeightsForState   *bool                                                `protobuf:"varint,29,opt,name=use_post_estimation_weights_for_state,json=usePostEstimationWeightsForState,def=1" json:"use_post_estimation_weights_for_state,omitempty"`
	ComputeSpatialPrior                *bool                                                `protobuf:"varint,27,opt,name=compute_spatial_prior,json=computeSpatialPrior,def=0" json:"compute_spatial_prior,omitempty"`
	IrlsInitialization                 *TrackStepOptions_IrlsInitialization                 `protobuf:"bytes,30,opt,name=irls_initialization,json=irlsInitialization" json:"irls_initialization,omitempty"`
	StaticMotionTemporalRatio          *float32                                             `protobuf:"fixed32,33,opt,name=static_motion_temporal_ratio,json=staticMotionTemporalRatio,def=0.003" json:"static_motion_temporal_ratio,omitempty"`
	CancelTrackingWithOcclusionOptions *TrackStepOptions_CancelTrackingWithOcclusionOptions `protobuf:"bytes,34,opt,name=cancel_tracking_with_occlusion_options,json=cancelTrackingWithOcclusionOptions" json:"cancel_tracking_with_occlusion_options,omitempty"`
	ObjectSimilarityMinContdInliers    *int32                                               `protobuf:"varint,35,opt,name=object_similarity_min_contd_inliers,json=objectSimilarityMinContdInliers,def=30" json:"object_similarity_min_contd_inliers,omitempty"`
	BoxSimilarityMaxScale              *float32                                             `protobuf:"fixed32,36,opt,name=box_similarity_max_scale,json=boxSimilarityMaxScale,def=1.05" json:"box_similarity_max_scale,omitempty"`
	BoxSimilarityMaxRotation           *float32                                             `protobuf:"fixed32,37,opt,name=box_similarity_max_rotation,json=boxSimilarityMaxRotation,def=0.2" json:"box_similarity_max_rotation,omitempty"`
	QuadHomographyMaxScale             *float32                                             `protobuf:"fixed32,38,opt,name=quad_homography_max_scale,json=quadHomographyMaxScale,def=1.2" json:"quad_homography_max_scale,omitempty"`
	QuadHomographyMaxRotation          *float32                                             `protobuf:"fixed32,39,opt,name=quad_homography_max_rotation,json=quadHomographyMaxRotation,def=0.3" json:"quad_homography_max_rotation,omitempty"`
	CameraIntrinsics                   *TrackStepOptions_CameraIntrinsics                   `protobuf:"bytes,40,opt,name=camera_intrinsics,json=cameraIntrinsics" json:"camera_intrinsics,omitempty"`
	ForcedPnpTracking                  *bool                                                `protobuf:"varint,41,opt,name=forced_pnp_tracking,json=forcedPnpTracking,def=0" json:"forced_pnp_tracking,omitempty"`
}

func (m *TrackStepOptions) Reset()      { *m = TrackStepOptions{} }
func (*TrackStepOptions) ProtoMessage() {}
func (*TrackStepOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{2}
}
func (m *TrackStepOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackStepOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackStepOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackStepOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackStepOptions.Merge(m, src)
}
func (m *TrackStepOptions) XXX_Size() int {
	return m.Size()
}
func (m *TrackStepOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackStepOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TrackStepOptions proto.InternalMessageInfo

const Default_TrackStepOptions_TrackingDegrees TrackStepOptions_TrackingDegrees = TRACKING_DEGREE_TRANSLATION
const Default_TrackStepOptions_TrackObjectAndCamera bool = false
const Default_TrackStepOptions_IrlsIterations int32 = 5
const Default_TrackStepOptions_SpatialSigma float32 = 0.15
const Default_TrackStepOptions_MinMotionSigma float32 = 0.002
const Default_TrackStepOptions_RelativeMotionSigma float32 = 0.3
const Default_TrackStepOptions_MotionDisparityLowLevel float32 = 0.008
const Default_TrackStepOptions_MotionDisparityHighLevel float32 = 0.016
const Default_TrackStepOptions_DisparityDecay float32 = 0.8
const Default_TrackStepOptions_MotionPriorWeight float32 = 0.2
const Default_TrackStepOptions_BackgroundDiscriminationLowLevel float32 = 0.004
const Default_TrackStepOptions_BackgroundDiscriminationHighLevel float32 = 0.008
const Default_TrackStepOptions_InlierCenterRelativeDistance float32 = 0.1
const Default_TrackStepOptions_InlierSpringForce float32 = 0.3
const Default_TrackStepOptions_KineticCenterRelativeDistance float32 = 0.4
const Default_TrackStepOptions_KineticSpringForce float32 = 0.5
const Default_TrackStepOptions_KineticSpringForceMinKineticEnergy float32 = 0.003
const Default_TrackStepOptions_VelocityUpdateWeight float32 = 0.7
const Default_TrackStepOptions_MaxTrackFailures int32 = 10
const Default_TrackStepOptions_ExpansionSize float32 = 0.05
const Default_TrackStepOptions_InlierLowWeight float32 = 250
const Default_TrackStepOptions_InlierHighWeight float32 = 500
const Default_TrackStepOptions_KineticEnergyDecay float32 = 0.98
const Default_TrackStepOptions_PriorWeightIncrease float32 = 0.2
const Default_TrackStepOptions_LowKineticEnergy float32 = 0.001
const Default_TrackStepOptions_HighKineticEnergy float32 = 0.004
const Default_TrackStepOptions_ReturnInternalState bool = false
const Default_TrackStepOptions_UsePostEstimationWeightsForState bool = true
const Default_TrackStepOptions_ComputeSpatialPrior bool = false
const Default_TrackStepOptions_StaticMotionTemporalRatio float32 = 0.003
const Default_TrackStepOptions_ObjectSimilarityMinContdInliers int32 = 30
const Default_TrackStepOptions_BoxSimilarityMaxScale float32 = 1.05
const Default_TrackStepOptions_BoxSimilarityMaxRotation float32 = 0.2
const Default_TrackStepOptions_QuadHomographyMaxScale float32 = 1.2
const Default_TrackStepOptions_QuadHomographyMaxRotation float32 = 0.3
const Default_TrackStepOptions_ForcedPnpTracking bool = false

func (m *TrackStepOptions) GetTrackingDegrees() TrackStepOptions_TrackingDegrees {
	if m != nil && m.TrackingDegrees != nil {
		return *m.TrackingDegrees
	}
	return Default_TrackStepOptions_TrackingDegrees
}

func (m *TrackStepOptions) GetTrackObjectAndCamera() bool {
	if m != nil && m.TrackObjectAndCamera != nil {
		return *m.TrackObjectAndCamera
	}
	return Default_TrackStepOptions_TrackObjectAndCamera
}

func (m *TrackStepOptions) GetIrlsIterations() int32 {
	if m != nil && m.IrlsIterations != nil {
		return *m.IrlsIterations
	}
	return Default_TrackStepOptions_IrlsIterations
}

func (m *TrackStepOptions) GetSpatialSigma() float32 {
	if m != nil && m.SpatialSigma != nil {
		return *m.SpatialSigma
	}
	return Default_TrackStepOptions_SpatialSigma
}

func (m *TrackStepOptions) GetMinMotionSigma() float32 {
	if m != nil && m.MinMotionSigma != nil {
		return *m.MinMotionSigma
	}
	return Default_TrackStepOptions_MinMotionSigma
}

func (m *TrackStepOptions) GetRelativeMotionSigma() float32 {
	if m != nil && m.RelativeMotionSigma != nil {
		return *m.RelativeMotionSigma
	}
	return Default_TrackStepOptions_RelativeMotionSigma
}

func (m *TrackStepOptions) GetMotionDisparityLowLevel() float32 {
	if m != nil && m.MotionDisparityLowLevel != nil {
		return *m.MotionDisparityLowLevel
	}
	return Default_TrackStepOptions_MotionDisparityLowLevel
}

func (m *TrackStepOptions) GetMotionDisparityHighLevel() float32 {
	if m != nil && m.MotionDisparityHighLevel != nil {
		return *m.MotionDisparityHighLevel
	}
	return Default_TrackStepOptions_MotionDisparityHighLevel
}

func (m *TrackStepOptions) GetDisparityDecay() float32 {
	if m != nil && m.DisparityDecay != nil {
		return *m.DisparityDecay
	}
	return Default_TrackStepOptions_DisparityDecay
}

func (m *TrackStepOptions) GetMotionPriorWeight() float32 {
	if m != nil && m.MotionPriorWeight != nil {
		return *m.MotionPriorWeight
	}
	return Default_TrackStepOptions_MotionPriorWeight
}

func (m *TrackStepOptions) GetBackgroundDiscriminationLowLevel() float32 {
	if m != nil && m.BackgroundDiscriminationLowLevel != nil {
		return *m.BackgroundDiscriminationLowLevel
	}
	return Default_TrackStepOptions_BackgroundDiscriminationLowLevel
}

func (m *TrackStepOptions) GetBackgroundDiscriminationHighLevel() float32 {
	if m != nil && m.BackgroundDiscriminationHighLevel != nil {
		return *m.BackgroundDiscriminationHighLevel
	}
	return Default_TrackStepOptions_BackgroundDiscriminationHighLevel
}

func (m *TrackStepOptions) GetInlierCenterRelativeDistance() float32 {
	if m != nil && m.InlierCenterRelativeDistance != nil {
		return *m.InlierCenterRelativeDistance
	}
	return Default_TrackStepOptions_InlierCenterRelativeDistance
}

func (m *TrackStepOptions) GetInlierSpringForce() float32 {
	if m != nil && m.InlierSpringForce != nil {
		return *m.InlierSpringForce
	}
	return Default_TrackStepOptions_InlierSpringForce
}

func (m *TrackStepOptions) GetKineticCenterRelativeDistance() float32 {
	if m != nil && m.KineticCenterRelativeDistance != nil {
		return *m.KineticCenterRelativeDistance
	}
	return Default_TrackStepOptions_KineticCenterRelativeDistance
}

func (m *TrackStepOptions) GetKineticSpringForce() float32 {
	if m != nil && m.KineticSpringForce != nil {
		return *m.KineticSpringForce
	}
	return Default_TrackStepOptions_KineticSpringForce
}

func (m *TrackStepOptions) GetKineticSpringForceMinKineticEnergy() float32 {
	if m != nil && m.KineticSpringForceMinKineticEnergy != nil {
		return *m.KineticSpringForceMinKineticEnergy
	}
	return Default_TrackStepOptions_KineticSpringForceMinKineticEnergy
}

func (m *TrackStepOptions) GetVelocityUpdateWeight() float32 {
	if m != nil && m.VelocityUpdateWeight != nil {
		return *m.VelocityUpdateWeight
	}
	return Default_TrackStepOptions_VelocityUpdateWeight
}

func (m *TrackStepOptions) GetMaxTrackFailures() int32 {
	if m != nil && m.MaxTrackFailures != nil {
		return *m.MaxTrackFailures
	}
	return Default_TrackStepOptions_MaxTrackFailures
}

func (m *TrackStepOptions) GetExpansionSize() float32 {
	if m != nil && m.ExpansionSize != nil {
		return *m.ExpansionSize
	}
	return Default_TrackStepOptions_ExpansionSize
}

func (m *TrackStepOptions) GetInlierLowWeight() float32 {
	if m != nil && m.InlierLowWeight != nil {
		return *m.InlierLowWeight
	}
	return Default_TrackStepOptions_InlierLowWeight
}

func (m *TrackStepOptions) GetInlierHighWeight() float32 {
	if m != nil && m.InlierHighWeight != nil {
		return *m.InlierHighWeight
	}
	return Default_TrackStepOptions_InlierHighWeight
}

func (m *TrackStepOptions) GetKineticEnergyDecay() float32 {
	if m != nil && m.KineticEnergyDecay != nil {
		return *m.KineticEnergyDecay
	}
	return Default_TrackStepOptions_KineticEnergyDecay
}

func (m *TrackStepOptions) GetPriorWeightIncrease() float32 {
	if m != nil && m.PriorWeightIncrease != nil {
		return *m.PriorWeightIncrease
	}
	return Default_TrackStepOptions_PriorWeightIncrease
}

func (m *TrackStepOptions) GetLowKineticEnergy() float32 {
	if m != nil && m.LowKineticEnergy != nil {
		return *m.LowKineticEnergy
	}
	return Default_TrackStepOptions_LowKineticEnergy
}

func (m *TrackStepOptions) GetHighKineticEnergy() float32 {
	if m != nil && m.HighKineticEnergy != nil {
		return *m.HighKineticEnergy
	}
	return Default_TrackStepOptions_HighKineticEnergy
}

func (m *TrackStepOptions) GetReturnInternalState() bool {
	if m != nil && m.ReturnInternalState != nil {
		return *m.ReturnInternalState
	}
	return Default_TrackStepOptions_ReturnInternalState
}

func (m *TrackStepOptions) GetUsePostEstimationWeightsForState() bool {
	if m != nil && m.UsePostEstimationWeightsForState != nil {
		return *m.UsePostEstimationWeightsForState
	}
	return Default_TrackStepOptions_UsePostEstimationWeightsForState
}

func (m *TrackStepOptions) GetComputeSpatialPrior() bool {
	if m != nil && m.ComputeSpatialPrior != nil {
		return *m.ComputeSpatialPrior
	}
	return Default_TrackStepOptions_ComputeSpatialPrior
}

func (m *TrackStepOptions) GetIrlsInitialization() *TrackStepOptions_IrlsInitialization {
	if m != nil {
		return m.IrlsInitialization
	}
	return nil
}

func (m *TrackStepOptions) GetStaticMotionTemporalRatio() float32 {
	if m != nil && m.StaticMotionTemporalRatio != nil {
		return *m.StaticMotionTemporalRatio
	}
	return Default_TrackStepOptions_StaticMotionTemporalRatio
}

func (m *TrackStepOptions) GetCancelTrackingWithOcclusionOptions() *TrackStepOptions_CancelTrackingWithOcclusionOptions {
	if m != nil {
		return m.CancelTrackingWithOcclusionOptions
	}
	return nil
}

func (m *TrackStepOptions) GetObjectSimilarityMinContdInliers() int32 {
	if m != nil && m.ObjectSimilarityMinContdInliers != nil {
		return *m.ObjectSimilarityMinContdInliers
	}
	return Default_TrackStepOptions_ObjectSimilarityMinContdInliers
}

func (m *TrackStepOptions) GetBoxSimilarityMaxScale() float32 {
	if m != nil && m.BoxSimilarityMaxScale != nil {
		return *m.BoxSimilarityMaxScale
	}
	return Default_TrackStepOptions_BoxSimilarityMaxScale
}

func (m *TrackStepOptions) GetBoxSimilarityMaxRotation() float32 {
	if m != nil && m.BoxSimilarityMaxRotation != nil {
		return *m.BoxSimilarityMaxRotation
	}
	return Default_TrackStepOptions_BoxSimilarityMaxRotation
}

func (m *TrackStepOptions) GetQuadHomographyMaxScale() float32 {
	if m != nil && m.QuadHomographyMaxScale != nil {
		return *m.QuadHomographyMaxScale
	}
	return Default_TrackStepOptions_QuadHomographyMaxScale
}

func (m *TrackStepOptions) GetQuadHomographyMaxRotation() float32 {
	if m != nil && m.QuadHomographyMaxRotation != nil {
		return *m.QuadHomographyMaxRotation
	}
	return Default_TrackStepOptions_QuadHomographyMaxRotation
}

func (m *TrackStepOptions) GetCameraIntrinsics() *TrackStepOptions_CameraIntrinsics {
	if m != nil {
		return m.CameraIntrinsics
	}
	return nil
}

func (m *TrackStepOptions) GetForcedPnpTracking() bool {
	if m != nil && m.ForcedPnpTracking != nil {
		return *m.ForcedPnpTracking
	}
	return Default_TrackStepOptions_ForcedPnpTracking
}

type TrackStepOptions_IrlsInitialization struct {
	Activated *bool    `protobuf:"varint,1,opt,name=activated,def=0" json:"activated,omitempty"`
	Rounds    *int32   `protobuf:"varint,2,opt,name=rounds,def=50" json:"rounds,omitempty"`
	Cutoff    *float32 `protobuf:"fixed32,3,opt,name=cutoff,def=0.005" json:"cutoff,omitempty"`
}

func (m *TrackStepOptions_IrlsInitialization) Reset()      { *m = TrackStepOptions_IrlsInitialization{} }
func (*TrackStepOptions_IrlsInitialization) ProtoMessage() {}
func (*TrackStepOptions_IrlsInitialization) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{2, 0}
}
func (m *TrackStepOptions_IrlsInitialization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackStepOptions_IrlsInitialization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackStepOptions_IrlsInitialization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackStepOptions_IrlsInitialization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackStepOptions_IrlsInitialization.Merge(m, src)
}
func (m *TrackStepOptions_IrlsInitialization) XXX_Size() int {
	return m.Size()
}
func (m *TrackStepOptions_IrlsInitialization) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackStepOptions_IrlsInitialization.DiscardUnknown(m)
}

var xxx_messageInfo_TrackStepOptions_IrlsInitialization proto.InternalMessageInfo

const Default_TrackStepOptions_IrlsInitialization_Activated bool = false
const Default_TrackStepOptions_IrlsInitialization_Rounds int32 = 50
const Default_TrackStepOptions_IrlsInitialization_Cutoff float32 = 0.005

func (m *TrackStepOptions_IrlsInitialization) GetActivated() bool {
	if m != nil && m.Activated != nil {
		return *m.Activated
	}
	return Default_TrackStepOptions_IrlsInitialization_Activated
}

func (m *TrackStepOptions_IrlsInitialization) GetRounds() int32 {
	if m != nil && m.Rounds != nil {
		return *m.Rounds
	}
	return Default_TrackStepOptions_IrlsInitialization_Rounds
}

func (m *TrackStepOptions_IrlsInitialization) GetCutoff() float32 {
	if m != nil && m.Cutoff != nil {
		return *m.Cutoff
	}
	return Default_TrackStepOptions_IrlsInitialization_Cutoff
}

type TrackStepOptions_CancelTrackingWithOcclusionOptions struct {
	Activated           *bool    `protobuf:"varint,1,opt,name=activated,def=0" json:"activated,omitempty"`
	MinMotionContinuity *float32 `protobuf:"fixed32,2,opt,name=min_motion_continuity,json=minMotionContinuity,def=0.4" json:"min_motion_continuity,omitempty"`
	MinInlierRatio      *float32 `protobuf:"fixed32,3,opt,name=min_inlier_ratio,json=minInlierRatio,def=0.1" json:"min_inlier_ratio,omitempty"`
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) Reset() {
	*m = TrackStepOptions_CancelTrackingWithOcclusionOptions{}
}
func (*TrackStepOptions_CancelTrackingWithOcclusionOptions) ProtoMessage() {}
func (*TrackStepOptions_CancelTrackingWithOcclusionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{2, 1}
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackStepOptions_CancelTrackingWithOcclusionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackStepOptions_CancelTrackingWithOcclusionOptions.Merge(m, src)
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) XXX_Size() int {
	return m.Size()
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackStepOptions_CancelTrackingWithOcclusionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TrackStepOptions_CancelTrackingWithOcclusionOptions proto.InternalMessageInfo

const Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_Activated bool = false
const Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_MinMotionContinuity float32 = 0.4
const Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_MinInlierRatio float32 = 0.1

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) GetActivated() bool {
	if m != nil && m.Activated != nil {
		return *m.Activated
	}
	return Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_Activated
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) GetMinMotionContinuity() float32 {
	if m != nil && m.MinMotionContinuity != nil {
		return *m.MinMotionContinuity
	}
	return Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_MinMotionContinuity
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) GetMinInlierRatio() float32 {
	if m != nil && m.MinInlierRatio != nil {
		return *m.MinInlierRatio
	}
	return Default_TrackStepOptions_CancelTrackingWithOcclusionOptions_MinInlierRatio
}

type TrackStepOptions_CameraIntrinsics struct {
	Fx float32 `protobuf:"fixed32,1,opt,name=fx" json:"fx"`
	Fy float32 `protobuf:"fixed32,2,opt,name=fy" json:"fy"`
	Cx float32 `protobuf:"fixed32,3,opt,name=cx" json:"cx"`
	Cy float32 `protobuf:"fixed32,4,opt,name=cy" json:"cy"`
	K0 float32 `protobuf:"fixed32,5,opt,name=k0" json:"k0"`
	K1 float32 `protobuf:"fixed32,6,opt,name=k1" json:"k1"`
	K2 float32 `protobuf:"fixed32,7,opt,name=k2" json:"k2"`
	W  int32   `protobuf:"varint,8,opt,name=w" json:"w"`
	H  int32   `protobuf:"varint,9,opt,name=h" json:"h"`
}

func (m *TrackStepOptions_CameraIntrinsics) Reset()      { *m = TrackStepOptions_CameraIntrinsics{} }
func (*TrackStepOptions_CameraIntrinsics) ProtoMessage() {}
func (*TrackStepOptions_CameraIntrinsics) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f10fc8bfc6f9ba0, []int{2, 2}
}
func (m *TrackStepOptions_CameraIntrinsics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackStepOptions_CameraIntrinsics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackStepOptions_CameraIntrinsics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrackStepOptions_CameraIntrinsics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackStepOptions_CameraIntrinsics.Merge(m, src)
}
func (m *TrackStepOptions_CameraIntrinsics) XXX_Size() int {
	return m.Size()
}
func (m *TrackStepOptions_CameraIntrinsics) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackStepOptions_CameraIntrinsics.DiscardUnknown(m)
}

var xxx_messageInfo_TrackStepOptions_CameraIntrinsics proto.InternalMessageInfo

func (m *TrackStepOptions_CameraIntrinsics) GetFx() float32 {
	if m != nil {
		return m.Fx
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetFy() float32 {
	if m != nil {
		return m.Fy
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetCx() float32 {
	if m != nil {
		return m.Cx
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetCy() float32 {
	if m != nil {
		return m.Cy
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetK0() float32 {
	if m != nil {
		return m.K0
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetK1() float32 {
	if m != nil {
		return m.K1
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetK2() float32 {
	if m != nil {
		return m.K2
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetW() int32 {
	if m != nil {
		return m.W
	}
	return 0
}

func (m *TrackStepOptions_CameraIntrinsics) GetH() int32 {
	if m != nil {
		return m.H
	}
	return 0
}

func init() {
	proto.RegisterEnum("mediapipe.MotionBoxState_TrackStatus", MotionBoxState_TrackStatus_name, MotionBoxState_TrackStatus_value)
	proto.RegisterEnum("mediapipe.TrackStepOptions_TrackingDegrees", TrackStepOptions_TrackingDegrees_name, TrackStepOptions_TrackingDegrees_value)
	proto.RegisterType((*MotionBoxState)(nil), "mediapipe.MotionBoxState")
	proto.RegisterType((*MotionBoxState_Quad)(nil), "mediapipe.MotionBoxState.Quad")
	proto.RegisterType((*MotionBoxInternalState)(nil), "mediapipe.MotionBoxInternalState")
	proto.RegisterType((*TrackStepOptions)(nil), "mediapipe.TrackStepOptions")
	proto.RegisterType((*TrackStepOptions_IrlsInitialization)(nil), "mediapipe.TrackStepOptions.IrlsInitialization")
	proto.RegisterType((*TrackStepOptions_CancelTrackingWithOcclusionOptions)(nil), "mediapipe.TrackStepOptions.CancelTrackingWithOcclusionOptions")
	proto.RegisterType((*TrackStepOptions_CameraIntrinsics)(nil), "mediapipe.TrackStepOptions.CameraIntrinsics")
}

func init() {
	proto.RegisterFile("mediapipe/util/tracking/tracking.proto", fileDescriptor_6f10fc8bfc6f9ba0)
}

var fileDescriptor_6f10fc8bfc6f9ba0 = []byte{
	// 2359 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0xcd, 0x53, 0x1b, 0xc9,
	0x15, 0x67, 0x84, 0x84, 0xa1, 0x31, 0x20, 0x5a, 0x7c, 0x0c, 0x1f, 0x16, 0x32, 0x18, 0x1b, 0xc7,
	0x0e, 0x48, 0xb0, 0xac, 0x6d, 0x6a, 0x77, 0xab, 0x40, 0x12, 0xb6, 0xbc, 0x7c, 0xa5, 0x25, 0xd6,
	0xf6, 0x5e, 0xa6, 0xc6, 0x33, 0x2d, 0xa9, 0x83, 0x34, 0x33, 0x3b, 0x33, 0x32, 0x92, 0x4f, 0xb9,
	0xe5, 0x9a, 0xca, 0x25, 0xff, 0x42, 0xae, 0xf9, 0x0f, 0x72, 0xdc, 0xa3, 0x0f, 0x39, 0xec, 0x29,
	0x15, 0xe3, 0xaa, 0x54, 0x8e, 0x7b, 0xce, 0x29, 0xd5, 0x1f, 0xd3, 0x6a, 0x09, 0x64, 0xe7, 0x26,
	0xbd, 0xf7, 0x7b, 0x6f, 0x5e, 0x77, 0xbf, 0x8f, 0x5f, 0x37, 0xb8, 0xdf, 0xc4, 0x36, 0x31, 0x3d,
	0xe2, 0xe1, 0xad, 0x56, 0x48, 0x1a, 0x5b, 0xa1, 0x6f, 0x5a, 0x17, 0xc4, 0xa9, 0xc9, 0x1f, 0x9b,
	0x9e, 0xef, 0x86, 0x2e, 0x1c, 0x93, 0xb8, 0xc5, 0x47, 0x83, 0x4c, 0x9a, 0x6e, 0x48, 0x5c, 0xc7,
	0x68, 0xba, 0x36, 0x6e, 0x04, 0xdc, 0x6e, 0xf5, 0x2f, 0x13, 0x60, 0xf2, 0x98, 0xc9, 0x0f, 0xdc,
	0x76, 0x39, 0x34, 0x43, 0x0c, 0x17, 0x40, 0xc2, 0x73, 0x03, 0xa3, 0xad, 0x6b, 0x19, 0x6d, 0x23,
	0x76, 0x10, 0xff, 0xf9, 0x9f, 0x2b, 0x43, 0x28, 0xee, 0xb9, 0xc1, 0xeb, 0x48, 0xd5, 0xd1, 0x63,
	0x7d, 0xaa, 0x37, 0x70, 0x11, 0x24, 0x2e, 0x89, 0x1d, 0xd6, 0xf5, 0x61, 0x45, 0xc5, 0x45, 0x70,
	0x19, 0x8c, 0xd4, 0x31, 0xa9, 0xd5, 0x43, 0x3d, 0xae, 0x28, 0x85, 0x0c, 0xce, 0x83, 0x44, 0x60,
	0x99, 0x0d, 0xac, 0x27, 0xa8, 0x72, 0x4f, 0xcb, 0x21, 0xfe, 0x1f, 0xde, 0x01, 0xa3, 0xbe, 0x1b,
	0x9a, 0x34, 0x38, 0x3d, 0xcd, 0x75, 0x59, 0x24, 0x45, 0x70, 0x1b, 0xc4, 0x7f, 0x6a, 0x99, 0xb6,
	0xbe, 0x9a, 0xd1, 0x36, 0xc6, 0xb7, 0xd3, 0x9b, 0x72, 0xd9, 0x9b, 0xbd, 0x0b, 0xda, 0xfc, 0x5d,
	0xcb, 0xb4, 0x11, 0xc3, 0xc2, 0x07, 0xe0, 0xb6, 0x19, 0x78, 0xd8, 0x0a, 0x0d, 0x9f, 0x3a, 0xd1,
	0xd7, 0x94, 0x78, 0xc6, 0xb9, 0x06, 0x51, 0x05, 0xcc, 0x82, 0xa4, 0x8f, 0x7f, 0x6a, 0xe1, 0x20,
	0x34, 0x6a, 0xbe, 0xdb, 0xf2, 0x88, 0x53, 0xd3, 0xd7, 0x33, 0xda, 0xc6, 0xe8, 0x5e, 0xa2, 0x6a,
	0x36, 0x02, 0x8c, 0xa6, 0x84, 0xfa, 0xb9, 0xd0, 0xc2, 0x6f, 0xc0, 0xa4, 0xe7, 0x78, 0x46, 0xdd,
	0x6d, 0xba, 0x35, 0xdf, 0xf4, 0xea, 0x1d, 0xfd, 0x1e, 0x0b, 0x6c, 0x56, 0x09, 0xec, 0x85, 0x54,
	0xa2, 0x09, 0xcf, 0xf1, 0xba, 0x7f, 0xe1, 0x0c, 0x88, 0xd9, 0x6d, 0xfd, 0x96, 0x12, 0x4e, 0xcc,
	0x6e, 0x33, 0x69, 0x47, 0x1f, 0xed, 0x91, 0x76, 0xe0, 0x23, 0x30, 0x79, 0x41, 0x1c, 0x1c, 0x12,
	0xcb, 0xc0, 0x0e, 0xf6, 0x6b, 0x1d, 0x7d, 0x5a, 0x41, 0x4c, 0x08, 0x5d, 0x91, 0xa9, 0xe8, 0x8a,
	0x3d, 0x9f, 0xb8, 0xbe, 0x71, 0xc9, 0x4f, 0x60, 0x4c, 0x5d, 0x31, 0xd3, 0xbc, 0xe2, 0xc7, 0xf0,
	0x0a, 0xdc, 0x66, 0x99, 0x62, 0x04, 0xa1, 0x19, 0xb6, 0x02, 0x1d, 0x64, 0xb4, 0x8d, 0xc9, 0xed,
	0xf5, 0xc1, 0xdb, 0x5a, 0xa1, 0xe8, 0x32, 0x03, 0xef, 0x4d, 0x1c, 0x9c, 0xbe, 0x36, 0xce, 0x4f,
	0x2a, 0x68, 0x3f, 0xff, 0x7d, 0xb1, 0x80, 0xc6, 0xc3, 0xae, 0x0e, 0x3e, 0x03, 0xf3, 0x81, 0x67,
	0x86, 0xc4, 0x6c, 0x18, 0x3c, 0x92, 0x9a, 0x4f, 0x6c, 0x23, 0x20, 0xef, 0xb1, 0x3e, 0x9e, 0xd1,
	0x36, 0x12, 0x7b, 0xb1, 0x5c, 0x16, 0xcd, 0x08, 0xc8, 0x19, 0x45, 0x3c, 0xf7, 0x89, 0x5d, 0x26,
	0xef, 0x31, 0x7c, 0x00, 0x26, 0x7a, 0x4c, 0xf5, 0xdb, 0x99, 0xe1, 0x8d, 0xd8, 0x41, 0x2c, 0xa9,
	0xa1, 0xdb, 0xaa, 0x01, 0xcc, 0x01, 0x18, 0x01, 0x2d, 0xd7, 0xa9, 0x12, 0x1b, 0x3b, 0x16, 0xd6,
	0x27, 0x24, 0x7a, 0x5a, 0x68, 0xf3, 0x52, 0x09, 0xd7, 0x00, 0xe0, 0xe1, 0xd8, 0xa4, 0x5a, 0xd5,
	0x27, 0x95, 0x6d, 0x19, 0x63, 0xf2, 0x02, 0xa9, 0x56, 0xe1, 0x16, 0x48, 0x8a, 0xaa, 0xb1, 0x49,
	0xe0, 0x99, 0x3e, 0x09, 0x3b, 0xfa, 0x94, 0x02, 0x9d, 0xe2, 0xda, 0x42, 0xa4, 0x84, 0xfb, 0x60,
	0xe1, 0xad, 0x69, 0x5d, 0xd0, 0x9c, 0x71, 0x6c, 0x6a, 0x64, 0xf9, 0xa4, 0x49, 0x1c, 0x9e, 0xc4,
	0x49, 0xc5, 0x52, 0xef, 0xc2, 0x0a, 0x3d, 0x28, 0xf8, 0x18, 0x4c, 0x11, 0xa7, 0x41, 0xb0, 0x6f,
	0x58, 0xd8, 0x09, 0xb1, 0x6f, 0xb4, 0x75, 0xa8, 0x9e, 0x2f, 0x57, 0xe6, 0x99, 0xee, 0xf5, 0x75,
	0x74, 0x47, 0x4f, 0x0d, 0x42, 0xbf, 0xa1, 0x8b, 0x16, 0xe8, 0xa0, 0xd5, 0xd4, 0x75, 0x75, 0xd1,
	0x5c, 0x5e, 0x6e, 0x35, 0x69, 0xca, 0x08, 0x10, 0x2f, 0x92, 0x05, 0x35, 0x65, 0xb8, 0x86, 0x17,
	0x49, 0x17, 0xc8, 0x4b, 0x7f, 0xee, 0x3a, 0xf0, 0x15, 0x6b, 0x00, 0x0f, 0x81, 0x88, 0xc3, 0x10,
	0x7d, 0x60, 0x5e, 0x41, 0x0a, 0x1f, 0x2f, 0x78, 0x1a, 0xde, 0x95, 0x11, 0x12, 0x3b, 0xd0, 0x17,
	0x33, 0xc3, 0x1b, 0x13, 0xec, 0x04, 0x45, 0x7c, 0x25, 0x3b, 0x80, 0x39, 0x90, 0x92, 0x10, 0xa3,
	0x69, 0x86, 0x56, 0xdd, 0xf0, 0xdc, 0x40, 0x5f, 0x91, 0xd8, 0x64, 0x84, 0x3d, 0xa6, 0xca, 0x33,
	0x37, 0xa0, 0x89, 0x24, 0x4c, 0x1a, 0xd8, 0xa9, 0x85, 0x75, 0x7d, 0x49, 0x82, 0xc5, 0xe7, 0x8f,
	0x98, 0x1c, 0xae, 0x81, 0x71, 0xb7, 0x15, 0xca, 0xef, 0x2f, 0x4b, 0x18, 0x10, 0x62, 0x1a, 0xc0,
	0x0e, 0x98, 0xe9, 0x82, 0x94, 0x08, 0x32, 0x12, 0x3d, 0x2d, 0xd1, 0x32, 0x84, 0x5d, 0x90, 0x8a,
	0x3a, 0xb1, 0x9a, 0xa3, 0x77, 0x95, 0x9d, 0x80, 0x11, 0x40, 0x49, 0xd3, 0x6f, 0xc1, 0x28, 0xa1,
	0x67, 0xe7, 0x98, 0x0d, 0xfd, 0x0e, 0x6b, 0x28, 0x77, 0x6f, 0x2a, 0xc9, 0x92, 0xc0, 0xb0, 0xd2,
	0x44, 0xd2, 0x64, 0x71, 0x15, 0xc4, 0x69, 0xfb, 0x83, 0x8b, 0x60, 0xf4, 0x1d, 0xf6, 0x43, 0x62,
	0xe1, 0x40, 0xd7, 0x68, 0x59, 0x20, 0xf9, 0x7f, 0xf5, 0x8f, 0x1a, 0x18, 0x57, 0x8a, 0x19, 0x4e,
	0x83, 0xde, 0x72, 0x4e, 0x0e, 0xc1, 0x09, 0x30, 0x46, 0x45, 0xc5, 0xe3, 0xb3, 0xca, 0x9b, 0xa4,
	0x06, 0x53, 0x60, 0x8a, 0xfe, 0x3d, 0x39, 0x35, 0x0e, 0x8b, 0xfb, 0x95, 0x73, 0x54, 0x2c, 0x27,
	0x63, 0x70, 0x0a, 0x8c, 0x53, 0x61, 0x64, 0x34, 0x0c, 0x21, 0x98, 0xa4, 0x82, 0xc2, 0xf9, 0xd9,
	0x51, 0x29, 0xbf, 0x5f, 0x29, 0x16, 0x92, 0x71, 0xb8, 0x0c, 0x74, 0x05, 0x64, 0x9c, 0x9e, 0x57,
	0x8c, 0xd3, 0x43, 0xe3, 0xe0, 0xf4, 0xfc, 0xa4, 0x90, 0x4c, 0xbc, 0x8c, 0x8f, 0xce, 0x24, 0x67,
	0x5f, 0xc6, 0x47, 0x67, 0x93, 0x73, 0xab, 0xff, 0xd5, 0xc0, 0xdc, 0xcd, 0xcb, 0xa3, 0x13, 0x23,
	0x9a, 0x50, 0x51, 0x81, 0xf3, 0xf9, 0x34, 0xdf, 0x9d, 0x4f, 0xaa, 0xe2, 0x0d, 0x84, 0xac, 0xbd,
	0x0e, 0x4b, 0x29, 0x6d, 0xae, 0x90, 0x35, 0xd7, 0xb8, 0x22, 0xeb, 0xc0, 0x15, 0x30, 0x66, 0x99,
	0x4d, 0xec, 0x9b, 0x86, 0xdd, 0xd6, 0x13, 0x52, 0x35, 0xca, 0x85, 0x85, 0xb6, 0x0a, 0xe8, 0xe8,
	0x23, 0xd7, 0x00, 0x1d, 0x3a, 0xb4, 0x78, 0x1b, 0x25, 0xb6, 0x7e, 0x2b, 0x33, 0xbc, 0x91, 0x60,
	0xfa, 0x5b, 0x4c, 0x56, 0xb2, 0xe1, 0xba, 0x2c, 0x99, 0xc0, 0x72, 0x7d, 0xac, 0x8f, 0x4a, 0x17,
	0xa2, 0x60, 0xca, 0x54, 0xbc, 0xfa, 0xf7, 0x25, 0x90, 0x14, 0x47, 0x82, 0xbd, 0x53, 0x8f, 0xee,
	0x42, 0x00, 0x03, 0x90, 0x94, 0x19, 0x64, 0xe3, 0x9a, 0x8f, 0x31, 0x4d, 0x50, 0xda, 0xa5, 0x1f,
	0x29, 0x29, 0xd1, 0x6f, 0xc6, 0x05, 0xc4, 0xa9, 0x15, 0xb8, 0xc9, 0xde, 0x12, 0xdb, 0xfc, 0xd2,
	0xc9, 0x73, 0xa3, 0x50, 0x7c, 0x8e, 0x8a, 0x45, 0x7a, 0x18, 0x27, 0xe5, 0xa3, 0xfd, 0x4a, 0xe9,
	0xf4, 0x04, 0x4d, 0x85, 0xbd, 0x68, 0xf8, 0x0d, 0x98, 0xe7, 0xeb, 0x71, 0xdf, 0xfe, 0x9e, 0xce,
	0x4d, 0xd3, 0xb1, 0x0d, 0xbe, 0x58, 0x3d, 0xa3, 0xce, 0xc3, 0x19, 0x86, 0x3a, 0x65, 0xa0, 0x7d,
	0xc7, 0xce, 0x33, 0x08, 0xfc, 0x0d, 0x98, 0x22, 0x7e, 0x23, 0x30, 0x48, 0x88, 0x59, 0x2f, 0x71,
	0x02, 0xc6, 0x2a, 0x12, 0x7b, 0xda, 0x2e, 0x9a, 0xa4, 0x9a, 0x92, 0x54, 0xd0, 0x26, 0x11, 0xf5,
	0xf0, 0x80, 0xd4, 0x9a, 0x26, 0x27, 0x19, 0x7b, 0xf1, 0xec, 0x66, 0x6e, 0x57, 0xb6, 0xfb, 0x32,
	0xd5, 0xb0, 0xb6, 0x4c, 0x28, 0x93, 0x61, 0xad, 0x99, 0xa3, 0x19, 0xef, 0xd8, 0x4b, 0x64, 0x37,
	0xb3, 0xd9, 0x6d, 0x34, 0xd9, 0x24, 0x0e, 0x4f, 0x1e, 0x6e, 0xf0, 0x04, 0xcc, 0xfa, 0xb8, 0x61,
	0x86, 0xe4, 0x1d, 0xee, 0xb5, 0x62, 0x84, 0x64, 0x6f, 0x38, 0xbb, 0xb9, 0x83, 0x52, 0x11, 0x42,
	0x35, 0x3c, 0x00, 0x8b, 0xfd, 0x03, 0xc0, 0x68, 0xb8, 0x97, 0x46, 0x03, 0xbf, 0xc3, 0x0d, 0x7d,
	0xa4, 0xfb, 0xcd, 0xa7, 0x68, 0xbe, 0x6f, 0x16, 0x1c, 0xb9, 0x97, 0x47, 0x14, 0x05, 0x0b, 0x60,
	0xe9, 0x9a, 0x8f, 0x3a, 0xa9, 0xd5, 0x85, 0x93, 0x5b, 0xd2, 0x49, 0xee, 0x6b, 0xa4, 0xf7, 0x39,
	0x79, 0x41, 0x6a, 0x75, 0xee, 0xe5, 0x31, 0x98, 0xea, 0x9a, 0xdb, 0xd8, 0x32, 0x05, 0x31, 0xa0,
	0xc1, 0x3f, 0x45, 0x93, 0x52, 0x57, 0xa0, 0x2a, 0xb8, 0x03, 0x52, 0xe2, 0x9b, 0xd7, 0xa7, 0x3f,
	0xb5, 0xd8, 0x46, 0xd3, 0x5c, 0x7f, 0xa6, 0x50, 0x80, 0x0a, 0x58, 0x1b, 0x38, 0xbc, 0x94, 0x55,
	0x83, 0xee, 0xaa, 0xbf, 0x42, 0x99, 0x41, 0x73, 0x4c, 0x2e, 0xff, 0x07, 0x70, 0x6f, 0xb0, 0x57,
	0x65, 0x1f, 0xc6, 0xd5, 0xcd, 0xbc, 0x3b, 0xc8, 0x6d, 0x77, 0x43, 0x5e, 0x82, 0x95, 0xde, 0xc9,
	0x27, 0x4f, 0xd8, 0x26, 0x41, 0x68, 0xd2, 0xe6, 0x7a, 0x3b, 0x5a, 0x6e, 0x0e, 0x2d, 0xab, 0x83,
	0x10, 0x09, 0x64, 0x41, 0x00, 0xe9, 0x76, 0x45, 0x65, 0xe9, 0xf9, 0xb4, 0xbe, 0xaa, 0xae, 0xcf,
	0x08, 0x84, 0xcc, 0x8e, 0x69, 0x51, 0x9e, 0x4c, 0x7d, 0x48, 0xb5, 0xf0, 0x08, 0x64, 0x22, 0x1e,
	0x36, 0x30, 0x82, 0xc9, 0xc8, 0xc3, 0x57, 0xe8, 0x8e, 0x00, 0x0f, 0x08, 0x61, 0x17, 0xcc, 0x44,
	0xde, 0x7a, 0x62, 0x98, 0x8a, 0x3c, 0xec, 0x22, 0x28, 0x00, 0x6a, 0x10, 0x3f, 0x82, 0x07, 0x37,
	0x99, 0x19, 0xb4, 0x3e, 0xfa, 0x58, 0xe2, 0x6c, 0x77, 0x83, 0x77, 0xd0, 0xea, 0x75, 0x5f, 0xc7,
	0xc4, 0xf9, 0xbe, 0x87, 0x3b, 0x3e, 0x03, 0x73, 0xef, 0x70, 0xc3, 0xb5, 0x68, 0xc6, 0xb5, 0x3c,
	0xdb, 0x0c, 0x71, 0x94, 0x47, 0xc9, 0x28, 0xa8, 0x27, 0x68, 0x26, 0x82, 0x9c, 0x33, 0x84, 0x48,
	0xa5, 0x2c, 0x80, 0x4d, 0xb3, 0x6d, 0xf0, 0xd6, 0x51, 0x35, 0x49, 0xa3, 0xe5, 0xe3, 0x80, 0xf1,
	0x54, 0xce, 0xf7, 0x92, 0x4d, 0xb3, 0xcd, 0x1a, 0xd3, 0xa1, 0xd0, 0x51, 0x56, 0x8b, 0xdb, 0x9e,
	0xe9, 0x04, 0xbc, 0x38, 0xdf, 0x63, 0xce, 0x7a, 0x68, 0xfd, 0x67, 0x77, 0xd1, 0x84, 0xd4, 0x31,
	0x62, 0xb8, 0x05, 0xa6, 0xa3, 0x79, 0xee, 0x5e, 0x46, 0x41, 0xa5, 0x78, 0x50, 0xdb, 0xbb, 0x59,
	0x24, 0x38, 0xd1, 0x91, 0x7b, 0x29, 0xe2, 0xc9, 0x01, 0x18, 0x31, 0x10, 0x9a, 0x71, 0xc2, 0x62,
	0x86, 0x5b, 0xec, 0x66, 0xb3, 0x11, 0x67, 0xa0, 0xe9, 0x25, 0x4c, 0xbe, 0xee, 0x1e, 0x08, 0xdf,
	0x40, 0x51, 0x75, 0x73, 0x51, 0x58, 0xcf, 0x9e, 0xca, 0x13, 0xe1, 0x1b, 0xc6, 0x4b, 0xef, 0x09,
	0x98, 0x55, 0x6b, 0xce, 0x20, 0x8e, 0xe5, 0x63, 0x33, 0xc0, 0x9c, 0xf4, 0xf0, 0xe2, 0x4b, 0x29,
	0xcc, 0xbb, 0x24, 0xf4, 0x70, 0x07, 0x40, 0xba, 0x9a, 0xbe, 0x53, 0xd3, 0xbb, 0xa7, 0x96, 0x43,
	0xc9, 0x86, 0x7b, 0xd9, 0x7b, 0x46, 0xbb, 0x20, 0xc5, 0x56, 0xd4, 0x67, 0xb5, 0xa0, 0xd6, 0xe8,
	0x34, 0x45, 0xf4, 0x1f, 0xed, 0xac, 0x8f, 0xc3, 0x96, 0xef, 0x18, 0x11, 0x55, 0x60, 0xbc, 0x1f,
	0xeb, 0x8b, 0x6a, 0x53, 0x4f, 0x71, 0x4c, 0xef, 0xf4, 0x3d, 0x07, 0xeb, 0xad, 0x00, 0x53, 0xc2,
	0x13, 0x1a, 0x38, 0x08, 0x49, 0x93, 0x57, 0x32, 0x5f, 0x6d, 0x40, 0xd3, 0x4f, 0xb8, 0xba, 0xc3,
	0x5c, 0xc5, 0x43, 0xbf, 0x85, 0x51, 0xa6, 0x15, 0xe0, 0x33, 0x37, 0x08, 0x8b, 0xd2, 0x80, 0x2f,
	0x3e, 0x38, 0x74, 0x7d, 0xee, 0xf6, 0x19, 0x98, 0xb5, 0xdc, 0xa6, 0xd7, 0x0a, 0xb1, 0xd1, 0xcb,
	0xf9, 0x97, 0x7a, 0x22, 0x12, 0x98, 0xb2, 0xca, 0xfe, 0x0d, 0x90, 0xe2, 0x53, 0xc6, 0x21, 0x54,
	0x48, 0xde, 0x77, 0xef, 0x8c, 0xe3, 0xdb, 0x9b, 0x9f, 0x9b, 0x8d, 0x25, 0x3a, 0x82, 0x7a, 0xac,
	0x10, 0x24, 0xd7, 0x64, 0xf0, 0x10, 0x2c, 0xd3, 0x25, 0x11, 0x2b, 0x1a, 0x1e, 0x21, 0x6e, 0x7a,
	0xae, 0x6f, 0x36, 0x04, 0x43, 0xbe, 0xab, 0x56, 0xd6, 0x02, 0x87, 0xf2, 0x29, 0x52, 0x11, 0x40,
	0x4e, 0x98, 0xff, 0xac, 0x81, 0xfb, 0x16, 0xad, 0xf6, 0x86, 0x21, 0x27, 0xf9, 0x25, 0x09, 0xeb,
	0x86, 0x6b, 0x59, 0x8d, 0x16, 0xcb, 0x7c, 0x97, 0x47, 0x26, 0x6e, 0xb5, 0xdf, 0x7d, 0x2e, 0xf8,
	0x3c, 0xf3, 0x14, 0x8d, 0xf7, 0x57, 0x24, 0xac, 0x9f, 0x46, 0x6e, 0x04, 0x04, 0xad, 0x5a, 0x5f,
	0xc4, 0xc0, 0x33, 0xb0, 0x26, 0x66, 0x7b, 0x40, 0x9a, 0xa4, 0xc1, 0x07, 0x0c, 0x6d, 0x1f, 0x96,
	0xeb, 0x84, 0xb6, 0xc1, 0xeb, 0x22, 0x60, 0x57, 0xe5, 0xc4, 0x5e, 0x6c, 0x27, 0x8b, 0x56, 0x38,
	0xbc, 0x2c, 0xd1, 0xc7, 0xc4, 0xc9, 0x53, 0x6c, 0x89, 0x43, 0xe1, 0xb7, 0x40, 0x7f, 0xeb, 0xb6,
	0x7b, 0xdc, 0x99, 0x6d, 0x83, 0x5f, 0xf2, 0xef, 0xf1, 0xea, 0xc9, 0xd1, 0xa2, 0x9e, 0x7d, 0xeb,
	0xb6, 0x15, 0x2f, 0x66, 0xbb, 0xcc, 0xee, 0xfd, 0x07, 0x60, 0xe9, 0x06, 0x73, 0xf9, 0x14, 0xb0,
	0xde, 0x2d, 0x23, 0xbd, 0xdf, 0x01, 0x8a, 0x1e, 0x07, 0xbe, 0x03, 0x0b, 0xf4, 0xc2, 0xaf, 0x5c,
	0xc7, 0x95, 0x18, 0xee, 0x73, 0x0f, 0xb9, 0xcd, 0x6d, 0x34, 0x47, 0x51, 0xdd, 0x7b, 0xb8, 0x8c,
	0xa1, 0x00, 0x96, 0x6f, 0xb2, 0x97, 0x41, 0x3c, 0xe8, 0x4e, 0x86, 0x85, 0x6b, 0x2e, 0x64, 0x14,
	0x6f, 0xc0, 0xb4, 0x60, 0x8b, 0xc4, 0x09, 0x7d, 0xe2, 0x04, 0xc4, 0x0a, 0xf4, 0x0d, 0x76, 0xb2,
	0x8f, 0x3f, 0x7f, 0xb2, 0xd4, 0xa8, 0x24, 0x6d, 0x50, 0xd2, 0xea, 0x93, 0xd0, 0xba, 0x67, 0x8d,
	0xde, 0x36, 0x3c, 0xc7, 0x93, 0xd9, 0xa4, 0x3f, 0x54, 0x8b, 0x65, 0x9a, 0x23, 0xce, 0x1c, 0x2f,
	0x4a, 0x80, 0xc5, 0x10, 0xc0, 0xeb, 0x39, 0x0f, 0xd7, 0xc0, 0x98, 0x69, 0x85, 0xe4, 0x9d, 0x19,
	0x62, 0x9b, 0x11, 0x34, 0xe9, 0xa2, 0x2b, 0x87, 0x8b, 0x60, 0x84, 0xcd, 0xe3, 0x80, 0x11, 0xb3,
	0xc4, 0x5e, 0x6c, 0x37, 0x8b, 0x84, 0x04, 0xde, 0x01, 0x23, 0x56, 0x2b, 0x74, 0xab, 0x55, 0x95,
	0x86, 0xed, 0x22, 0x21, 0x5c, 0xfc, 0x9b, 0x06, 0x56, 0xbf, 0x9c, 0xad, 0xff, 0x5f, 0x18, 0x4f,
	0xc0, 0xac, 0xc2, 0xfd, 0x68, 0x8e, 0x12, 0xa7, 0x45, 0xef, 0xe5, 0xb1, 0xee, 0xa8, 0x4d, 0x49,
	0xfa, 0x97, 0x97, 0x7a, 0xf8, 0x5b, 0x4e, 0x1a, 0x7b, 0xae, 0xb6, 0xc3, 0x5d, 0x82, 0x40, 0x29,
	0x63, 0xa9, 0x7b, 0xb9, 0x5d, 0xfc, 0x87, 0x06, 0x92, 0xfd, 0xe7, 0x00, 0x67, 0x40, 0xac, 0xda,
	0xfb, 0x30, 0x16, 0xab, 0xb2, 0x67, 0x9a, 0x6a, 0xef, 0x9b, 0x58, 0xac, 0xca, 0x9e, 0x74, 0xac,
	0x76, 0xcf, 0x73, 0x58, 0xcc, 0x62, 0x58, 0xab, 0xd3, 0xf3, 0x0e, 0x16, 0xb3, 0x18, 0xf6, 0x22,
	0xcb, 0x1f, 0xc0, 0x22, 0xe9, 0x45, 0x96, 0x49, 0x73, 0x9c, 0x64, 0x4a, 0x69, 0x8e, 0x49, 0xb7,
	0x7b, 0x9f, 0x8a, 0x2e, 0xb6, 0x21, 0x04, 0xda, 0x25, 0x23, 0x84, 0x09, 0x21, 0xd4, 0x2e, 0xa9,
	0xac, 0xce, 0x28, 0x9f, 0x94, 0xd5, 0x57, 0xff, 0x1d, 0x03, 0x53, 0x7d, 0x37, 0x02, 0xb8, 0x02,
	0x3e, 0x77, 0x27, 0x48, 0x0e, 0xc1, 0x0c, 0x58, 0xee, 0x07, 0xe4, 0xf7, 0x8f, 0x8b, 0x68, 0xdf,
	0x28, 0xe7, 0xf7, 0x8f, 0x8a, 0x49, 0x0d, 0xae, 0x81, 0x95, 0x01, 0x08, 0x74, 0x5a, 0xe1, 0x6e,
	0x62, 0xf0, 0x21, 0x58, 0xff, 0x02, 0x48, 0xf8, 0x1b, 0x86, 0xf7, 0xc1, 0xea, 0x00, 0xe8, 0x59,
	0x11, 0x95, 0xcf, 0x8a, 0xf9, 0x4a, 0xe9, 0x87, 0x62, 0x32, 0x7e, 0x53, 0x64, 0xa7, 0x07, 0x2f,
	0x8b, 0xf9, 0x8a, 0xf0, 0x94, 0xb8, 0x29, 0x32, 0x81, 0x90, 0x91, 0x8d, 0xdc, 0x14, 0x59, 0x1f,
	0x48, 0xf8, 0xbb, 0x75, 0x53, 0x64, 0x02, 0xaa, 0x46, 0x36, 0x7a, 0x40, 0x3e, 0x7c, 0x4c, 0x0f,
	0xfd, 0xf2, 0x31, 0x3d, 0xf4, 0xeb, 0xc7, 0xb4, 0xf6, 0x87, 0xab, 0xb4, 0xf6, 0xd7, 0xab, 0xb4,
	0xf6, 0xf3, 0x55, 0x5a, 0xfb, 0x70, 0x95, 0xd6, 0xfe, 0x75, 0x95, 0xd6, 0xfe, 0x73, 0x95, 0x1e,
	0xfa, 0xf5, 0x2a, 0xad, 0xfd, 0xe9, 0x53, 0x7a, 0xe8, 0xc3, 0xa7, 0xf4, 0xd0, 0x2f, 0x9f, 0xd2,
	0x43, 0x3f, 0xee, 0xd4, 0x48, 0x58, 0x6f, 0xbd, 0xdd, 0xb4, 0xdc, 0xe6, 0x56, 0xcd, 0x75, 0x6b,
	0x0d, 0xbc, 0xd5, 0x7d, 0xce, 0x1d, 0xf0, 0xb0, 0xfb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x84,
	0xd1, 0xc7, 0xaf, 0x25, 0x16, 0x00, 0x00,
}

func (x MotionBoxState_TrackStatus) String() string {
	s, ok := MotionBoxState_TrackStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrackStepOptions_TrackingDegrees) String() string {
	s, ok := TrackStepOptions_TrackingDegrees_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *MotionBoxState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionBoxState)
	if !ok {
		that2, ok := that.(MotionBoxState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PosX != that1.PosX {
		return false
	}
	if this.PosY != that1.PosY {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Scale != nil && that1.Scale != nil {
		if *this.Scale != *that1.Scale {
			return false
		}
	} else if this.Scale != nil {
		return false
	} else if that1.Scale != nil {
		return false
	}
	if this.Rotation != nil && that1.Rotation != nil {
		if *this.Rotation != *that1.Rotation {
			return false
		}
	} else if this.Rotation != nil {
		return false
	} else if that1.Rotation != nil {
		return false
	}
	if !this.Quad.Equal(that1.Quad) {
		return false
	}
	if this.AspectRatio != that1.AspectRatio {
		return false
	}
	if this.RequestGrouping != nil && that1.RequestGrouping != nil {
		if *this.RequestGrouping != *that1.RequestGrouping {
			return false
		}
	} else if this.RequestGrouping != nil {
		return false
	} else if that1.RequestGrouping != nil {
		return false
	}
	if !this.PnpHomography.Equal(that1.PnpHomography) {
		return false
	}
	if this.Dx != that1.Dx {
		return false
	}
	if this.Dy != that1.Dy {
		return false
	}
	if this.KineticEnergy != that1.KineticEnergy {
		return false
	}
	if this.PriorWeight != that1.PriorWeight {
		return false
	}
	if this.TrackStatus != nil && that1.TrackStatus != nil {
		if *this.TrackStatus != *that1.TrackStatus {
			return false
		}
	} else if this.TrackStatus != nil {
		return false
	} else if that1.TrackStatus != nil {
		return false
	}
	if this.SpatialPriorGridSize != nil && that1.SpatialPriorGridSize != nil {
		if *this.SpatialPriorGridSize != *that1.SpatialPriorGridSize {
			return false
		}
	} else if this.SpatialPriorGridSize != nil {
		return false
	} else if that1.SpatialPriorGridSize != nil {
		return false
	}
	if len(this.SpatialPrior) != len(that1.SpatialPrior) {
		return false
	}
	for i := range this.SpatialPrior {
		if this.SpatialPrior[i] != that1.SpatialPrior[i] {
			return false
		}
	}
	if len(this.SpatialConfidence) != len(that1.SpatialConfidence) {
		return false
	}
	for i := range this.SpatialConfidence {
		if this.SpatialConfidence[i] != that1.SpatialConfidence[i] {
			return false
		}
	}
	if this.PriorDiff != that1.PriorDiff {
		return false
	}
	if this.MotionDisparity != that1.MotionDisparity {
		return false
	}
	if this.BackgroundDiscrimination != that1.BackgroundDiscrimination {
		return false
	}
	if this.InlierCenterX != that1.InlierCenterX {
		return false
	}
	if this.InlierCenterY != that1.InlierCenterY {
		return false
	}
	if this.InlierSum != that1.InlierSum {
		return false
	}
	if this.InlierRatio != that1.InlierRatio {
		return false
	}
	if this.InlierWidth != that1.InlierWidth {
		return false
	}
	if this.InlierHeight != that1.InlierHeight {
		return false
	}
	if len(this.InlierIds) != len(that1.InlierIds) {
		return false
	}
	for i := range this.InlierIds {
		if this.InlierIds[i] != that1.InlierIds[i] {
			return false
		}
	}
	if len(this.InlierIdMatchPos) != len(that1.InlierIdMatchPos) {
		return false
	}
	for i := range this.InlierIdMatchPos {
		if this.InlierIdMatchPos[i] != that1.InlierIdMatchPos[i] {
			return false
		}
	}
	if len(this.InlierLength) != len(that1.InlierLength) {
		return false
	}
	for i := range this.InlierLength {
		if this.InlierLength[i] != that1.InlierLength[i] {
			return false
		}
	}
	if len(this.OutlierIds) != len(that1.OutlierIds) {
		return false
	}
	for i := range this.OutlierIds {
		if this.OutlierIds[i] != that1.OutlierIds[i] {
			return false
		}
	}
	if len(this.OutlierIdMatchPos) != len(that1.OutlierIdMatchPos) {
		return false
	}
	for i := range this.OutlierIdMatchPos {
		if this.OutlierIdMatchPos[i] != that1.OutlierIdMatchPos[i] {
			return false
		}
	}
	if this.TrackingConfidence != that1.TrackingConfidence {
		return false
	}
	if !this.Internal.Equal(that1.Internal) {
		return false
	}
	return true
}
func (this *MotionBoxState_Quad) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionBoxState_Quad)
	if !ok {
		that2, ok := that.(MotionBoxState_Quad)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Vertices) != len(that1.Vertices) {
		return false
	}
	for i := range this.Vertices {
		if this.Vertices[i] != that1.Vertices[i] {
			return false
		}
	}
	return true
}
func (this *MotionBoxInternalState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MotionBoxInternalState)
	if !ok {
		that2, ok := that.(MotionBoxInternalState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PosX) != len(that1.PosX) {
		return false
	}
	for i := range this.PosX {
		if this.PosX[i] != that1.PosX[i] {
			return false
		}
	}
	if len(this.PosY) != len(that1.PosY) {
		return false
	}
	for i := range this.PosY {
		if this.PosY[i] != that1.PosY[i] {
			return false
		}
	}
	if len(this.Dx) != len(that1.Dx) {
		return false
	}
	for i := range this.Dx {
		if this.Dx[i] != that1.Dx[i] {
			return false
		}
	}
	if len(this.Dy) != len(that1.Dy) {
		return false
	}
	for i := range this.Dy {
		if this.Dy[i] != that1.Dy[i] {
			return false
		}
	}
	if len(this.CameraDx) != len(that1.CameraDx) {
		return false
	}
	for i := range this.CameraDx {
		if this.CameraDx[i] != that1.CameraDx[i] {
			return false
		}
	}
	if len(this.CameraDy) != len(that1.CameraDy) {
		return false
	}
	for i := range this.CameraDy {
		if this.CameraDy[i] != that1.CameraDy[i] {
			return false
		}
	}
	if len(this.TrackId) != len(that1.TrackId) {
		return false
	}
	for i := range this.TrackId {
		if this.TrackId[i] != that1.TrackId[i] {
			return false
		}
	}
	if len(this.InlierScore) != len(that1.InlierScore) {
		return false
	}
	for i := range this.InlierScore {
		if this.InlierScore[i] != that1.InlierScore[i] {
			return false
		}
	}
	return true
}
func (this *TrackStepOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackStepOptions)
	if !ok {
		that2, ok := that.(TrackStepOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrackingDegrees != nil && that1.TrackingDegrees != nil {
		if *this.TrackingDegrees != *that1.TrackingDegrees {
			return false
		}
	} else if this.TrackingDegrees != nil {
		return false
	} else if that1.TrackingDegrees != nil {
		return false
	}
	if this.TrackObjectAndCamera != nil && that1.TrackObjectAndCamera != nil {
		if *this.TrackObjectAndCamera != *that1.TrackObjectAndCamera {
			return false
		}
	} else if this.TrackObjectAndCamera != nil {
		return false
	} else if that1.TrackObjectAndCamera != nil {
		return false
	}
	if this.IrlsIterations != nil && that1.IrlsIterations != nil {
		if *this.IrlsIterations != *that1.IrlsIterations {
			return false
		}
	} else if this.IrlsIterations != nil {
		return false
	} else if that1.IrlsIterations != nil {
		return false
	}
	if this.SpatialSigma != nil && that1.SpatialSigma != nil {
		if *this.SpatialSigma != *that1.SpatialSigma {
			return false
		}
	} else if this.SpatialSigma != nil {
		return false
	} else if that1.SpatialSigma != nil {
		return false
	}
	if this.MinMotionSigma != nil && that1.MinMotionSigma != nil {
		if *this.MinMotionSigma != *that1.MinMotionSigma {
			return false
		}
	} else if this.MinMotionSigma != nil {
		return false
	} else if that1.MinMotionSigma != nil {
		return false
	}
	if this.RelativeMotionSigma != nil && that1.RelativeMotionSigma != nil {
		if *this.RelativeMotionSigma != *that1.RelativeMotionSigma {
			return false
		}
	} else if this.RelativeMotionSigma != nil {
		return false
	} else if that1.RelativeMotionSigma != nil {
		return false
	}
	if this.MotionDisparityLowLevel != nil && that1.MotionDisparityLowLevel != nil {
		if *this.MotionDisparityLowLevel != *that1.MotionDisparityLowLevel {
			return false
		}
	} else if this.MotionDisparityLowLevel != nil {
		return false
	} else if that1.MotionDisparityLowLevel != nil {
		return false
	}
	if this.MotionDisparityHighLevel != nil && that1.MotionDisparityHighLevel != nil {
		if *this.MotionDisparityHighLevel != *that1.MotionDisparityHighLevel {
			return false
		}
	} else if this.MotionDisparityHighLevel != nil {
		return false
	} else if that1.MotionDisparityHighLevel != nil {
		return false
	}
	if this.DisparityDecay != nil && that1.DisparityDecay != nil {
		if *this.DisparityDecay != *that1.DisparityDecay {
			return false
		}
	} else if this.DisparityDecay != nil {
		return false
	} else if that1.DisparityDecay != nil {
		return false
	}
	if this.MotionPriorWeight != nil && that1.MotionPriorWeight != nil {
		if *this.MotionPriorWeight != *that1.MotionPriorWeight {
			return false
		}
	} else if this.MotionPriorWeight != nil {
		return false
	} else if that1.MotionPriorWeight != nil {
		return false
	}
	if this.BackgroundDiscriminationLowLevel != nil && that1.BackgroundDiscriminationLowLevel != nil {
		if *this.BackgroundDiscriminationLowLevel != *that1.BackgroundDiscriminationLowLevel {
			return false
		}
	} else if this.BackgroundDiscriminationLowLevel != nil {
		return false
	} else if that1.BackgroundDiscriminationLowLevel != nil {
		return false
	}
	if this.BackgroundDiscriminationHighLevel != nil && that1.BackgroundDiscriminationHighLevel != nil {
		if *this.BackgroundDiscriminationHighLevel != *that1.BackgroundDiscriminationHighLevel {
			return false
		}
	} else if this.BackgroundDiscriminationHighLevel != nil {
		return false
	} else if that1.BackgroundDiscriminationHighLevel != nil {
		return false
	}
	if this.InlierCenterRelativeDistance != nil && that1.InlierCenterRelativeDistance != nil {
		if *this.InlierCenterRelativeDistance != *that1.InlierCenterRelativeDistance {
			return false
		}
	} else if this.InlierCenterRelativeDistance != nil {
		return false
	} else if that1.InlierCenterRelativeDistance != nil {
		return false
	}
	if this.InlierSpringForce != nil && that1.InlierSpringForce != nil {
		if *this.InlierSpringForce != *that1.InlierSpringForce {
			return false
		}
	} else if this.InlierSpringForce != nil {
		return false
	} else if that1.InlierSpringForce != nil {
		return false
	}
	if this.KineticCenterRelativeDistance != nil && that1.KineticCenterRelativeDistance != nil {
		if *this.KineticCenterRelativeDistance != *that1.KineticCenterRelativeDistance {
			return false
		}
	} else if this.KineticCenterRelativeDistance != nil {
		return false
	} else if that1.KineticCenterRelativeDistance != nil {
		return false
	}
	if this.KineticSpringForce != nil && that1.KineticSpringForce != nil {
		if *this.KineticSpringForce != *that1.KineticSpringForce {
			return false
		}
	} else if this.KineticSpringForce != nil {
		return false
	} else if that1.KineticSpringForce != nil {
		return false
	}
	if this.KineticSpringForceMinKineticEnergy != nil && that1.KineticSpringForceMinKineticEnergy != nil {
		if *this.KineticSpringForceMinKineticEnergy != *that1.KineticSpringForceMinKineticEnergy {
			return false
		}
	} else if this.KineticSpringForceMinKineticEnergy != nil {
		return false
	} else if that1.KineticSpringForceMinKineticEnergy != nil {
		return false
	}
	if this.VelocityUpdateWeight != nil && that1.VelocityUpdateWeight != nil {
		if *this.VelocityUpdateWeight != *that1.VelocityUpdateWeight {
			return false
		}
	} else if this.VelocityUpdateWeight != nil {
		return false
	} else if that1.VelocityUpdateWeight != nil {
		return false
	}
	if this.MaxTrackFailures != nil && that1.MaxTrackFailures != nil {
		if *this.MaxTrackFailures != *that1.MaxTrackFailures {
			return false
		}
	} else if this.MaxTrackFailures != nil {
		return false
	} else if that1.MaxTrackFailures != nil {
		return false
	}
	if this.ExpansionSize != nil && that1.ExpansionSize != nil {
		if *this.ExpansionSize != *that1.ExpansionSize {
			return false
		}
	} else if this.ExpansionSize != nil {
		return false
	} else if that1.ExpansionSize != nil {
		return false
	}
	if this.InlierLowWeight != nil && that1.InlierLowWeight != nil {
		if *this.InlierLowWeight != *that1.InlierLowWeight {
			return false
		}
	} else if this.InlierLowWeight != nil {
		return false
	} else if that1.InlierLowWeight != nil {
		return false
	}
	if this.InlierHighWeight != nil && that1.InlierHighWeight != nil {
		if *this.InlierHighWeight != *that1.InlierHighWeight {
			return false
		}
	} else if this.InlierHighWeight != nil {
		return false
	} else if that1.InlierHighWeight != nil {
		return false
	}
	if this.KineticEnergyDecay != nil && that1.KineticEnergyDecay != nil {
		if *this.KineticEnergyDecay != *that1.KineticEnergyDecay {
			return false
		}
	} else if this.KineticEnergyDecay != nil {
		return false
	} else if that1.KineticEnergyDecay != nil {
		return false
	}
	if this.PriorWeightIncrease != nil && that1.PriorWeightIncrease != nil {
		if *this.PriorWeightIncrease != *that1.PriorWeightIncrease {
			return false
		}
	} else if this.PriorWeightIncrease != nil {
		return false
	} else if that1.PriorWeightIncrease != nil {
		return false
	}
	if this.LowKineticEnergy != nil && that1.LowKineticEnergy != nil {
		if *this.LowKineticEnergy != *that1.LowKineticEnergy {
			return false
		}
	} else if this.LowKineticEnergy != nil {
		return false
	} else if that1.LowKineticEnergy != nil {
		return false
	}
	if this.HighKineticEnergy != nil && that1.HighKineticEnergy != nil {
		if *this.HighKineticEnergy != *that1.HighKineticEnergy {
			return false
		}
	} else if this.HighKineticEnergy != nil {
		return false
	} else if that1.HighKineticEnergy != nil {
		return false
	}
	if this.ReturnInternalState != nil && that1.ReturnInternalState != nil {
		if *this.ReturnInternalState != *that1.ReturnInternalState {
			return false
		}
	} else if this.ReturnInternalState != nil {
		return false
	} else if that1.ReturnInternalState != nil {
		return false
	}
	if this.UsePostEstimationWeightsForState != nil && that1.UsePostEstimationWeightsForState != nil {
		if *this.UsePostEstimationWeightsForState != *that1.UsePostEstimationWeightsForState {
			return false
		}
	} else if this.UsePostEstimationWeightsForState != nil {
		return false
	} else if that1.UsePostEstimationWeightsForState != nil {
		return false
	}
	if this.ComputeSpatialPrior != nil && that1.ComputeSpatialPrior != nil {
		if *this.ComputeSpatialPrior != *that1.ComputeSpatialPrior {
			return false
		}
	} else if this.ComputeSpatialPrior != nil {
		return false
	} else if that1.ComputeSpatialPrior != nil {
		return false
	}
	if !this.IrlsInitialization.Equal(that1.IrlsInitialization) {
		return false
	}
	if this.StaticMotionTemporalRatio != nil && that1.StaticMotionTemporalRatio != nil {
		if *this.StaticMotionTemporalRatio != *that1.StaticMotionTemporalRatio {
			return false
		}
	} else if this.StaticMotionTemporalRatio != nil {
		return false
	} else if that1.StaticMotionTemporalRatio != nil {
		return false
	}
	if !this.CancelTrackingWithOcclusionOptions.Equal(that1.CancelTrackingWithOcclusionOptions) {
		return false
	}
	if this.ObjectSimilarityMinContdInliers != nil && that1.ObjectSimilarityMinContdInliers != nil {
		if *this.ObjectSimilarityMinContdInliers != *that1.ObjectSimilarityMinContdInliers {
			return false
		}
	} else if this.ObjectSimilarityMinContdInliers != nil {
		return false
	} else if that1.ObjectSimilarityMinContdInliers != nil {
		return false
	}
	if this.BoxSimilarityMaxScale != nil && that1.BoxSimilarityMaxScale != nil {
		if *this.BoxSimilarityMaxScale != *that1.BoxSimilarityMaxScale {
			return false
		}
	} else if this.BoxSimilarityMaxScale != nil {
		return false
	} else if that1.BoxSimilarityMaxScale != nil {
		return false
	}
	if this.BoxSimilarityMaxRotation != nil && that1.BoxSimilarityMaxRotation != nil {
		if *this.BoxSimilarityMaxRotation != *that1.BoxSimilarityMaxRotation {
			return false
		}
	} else if this.BoxSimilarityMaxRotation != nil {
		return false
	} else if that1.BoxSimilarityMaxRotation != nil {
		return false
	}
	if this.QuadHomographyMaxScale != nil && that1.QuadHomographyMaxScale != nil {
		if *this.QuadHomographyMaxScale != *that1.QuadHomographyMaxScale {
			return false
		}
	} else if this.QuadHomographyMaxScale != nil {
		return false
	} else if that1.QuadHomographyMaxScale != nil {
		return false
	}
	if this.QuadHomographyMaxRotation != nil && that1.QuadHomographyMaxRotation != nil {
		if *this.QuadHomographyMaxRotation != *that1.QuadHomographyMaxRotation {
			return false
		}
	} else if this.QuadHomographyMaxRotation != nil {
		return false
	} else if that1.QuadHomographyMaxRotation != nil {
		return false
	}
	if !this.CameraIntrinsics.Equal(that1.CameraIntrinsics) {
		return false
	}
	if this.ForcedPnpTracking != nil && that1.ForcedPnpTracking != nil {
		if *this.ForcedPnpTracking != *that1.ForcedPnpTracking {
			return false
		}
	} else if this.ForcedPnpTracking != nil {
		return false
	} else if that1.ForcedPnpTracking != nil {
		return false
	}
	return true
}
func (this *TrackStepOptions_IrlsInitialization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackStepOptions_IrlsInitialization)
	if !ok {
		that2, ok := that.(TrackStepOptions_IrlsInitialization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Activated != nil && that1.Activated != nil {
		if *this.Activated != *that1.Activated {
			return false
		}
	} else if this.Activated != nil {
		return false
	} else if that1.Activated != nil {
		return false
	}
	if this.Rounds != nil && that1.Rounds != nil {
		if *this.Rounds != *that1.Rounds {
			return false
		}
	} else if this.Rounds != nil {
		return false
	} else if that1.Rounds != nil {
		return false
	}
	if this.Cutoff != nil && that1.Cutoff != nil {
		if *this.Cutoff != *that1.Cutoff {
			return false
		}
	} else if this.Cutoff != nil {
		return false
	} else if that1.Cutoff != nil {
		return false
	}
	return true
}
func (this *TrackStepOptions_CancelTrackingWithOcclusionOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackStepOptions_CancelTrackingWithOcclusionOptions)
	if !ok {
		that2, ok := that.(TrackStepOptions_CancelTrackingWithOcclusionOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Activated != nil && that1.Activated != nil {
		if *this.Activated != *that1.Activated {
			return false
		}
	} else if this.Activated != nil {
		return false
	} else if that1.Activated != nil {
		return false
	}
	if this.MinMotionContinuity != nil && that1.MinMotionContinuity != nil {
		if *this.MinMotionContinuity != *that1.MinMotionContinuity {
			return false
		}
	} else if this.MinMotionContinuity != nil {
		return false
	} else if that1.MinMotionContinuity != nil {
		return false
	}
	if this.MinInlierRatio != nil && that1.MinInlierRatio != nil {
		if *this.MinInlierRatio != *that1.MinInlierRatio {
			return false
		}
	} else if this.MinInlierRatio != nil {
		return false
	} else if that1.MinInlierRatio != nil {
		return false
	}
	return true
}
func (this *TrackStepOptions_CameraIntrinsics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrackStepOptions_CameraIntrinsics)
	if !ok {
		that2, ok := that.(TrackStepOptions_CameraIntrinsics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Fx != that1.Fx {
		return false
	}
	if this.Fy != that1.Fy {
		return false
	}
	if this.Cx != that1.Cx {
		return false
	}
	if this.Cy != that1.Cy {
		return false
	}
	if this.K0 != that1.K0 {
		return false
	}
	if this.K1 != that1.K1 {
		return false
	}
	if this.K2 != that1.K2 {
		return false
	}
	if this.W != that1.W {
		return false
	}
	if this.H != that1.H {
		return false
	}
	return true
}
func (this *MotionBoxState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 38)
	s = append(s, "&tracking.MotionBoxState{")
	s = append(s, "PosX: "+fmt.Sprintf("%#v", this.PosX)+",\n")
	s = append(s, "PosY: "+fmt.Sprintf("%#v", this.PosY)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	if this.Scale != nil {
		s = append(s, "Scale: "+valueToGoStringTracking(this.Scale, "float32")+",\n")
	}
	if this.Rotation != nil {
		s = append(s, "Rotation: "+valueToGoStringTracking(this.Rotation, "float32")+",\n")
	}
	if this.Quad != nil {
		s = append(s, "Quad: "+fmt.Sprintf("%#v", this.Quad)+",\n")
	}
	s = append(s, "AspectRatio: "+fmt.Sprintf("%#v", this.AspectRatio)+",\n")
	if this.RequestGrouping != nil {
		s = append(s, "RequestGrouping: "+valueToGoStringTracking(this.RequestGrouping, "bool")+",\n")
	}
	if this.PnpHomography != nil {
		s = append(s, "PnpHomography: "+fmt.Sprintf("%#v", this.PnpHomography)+",\n")
	}
	s = append(s, "Dx: "+fmt.Sprintf("%#v", this.Dx)+",\n")
	s = append(s, "Dy: "+fmt.Sprintf("%#v", this.Dy)+",\n")
	s = append(s, "KineticEnergy: "+fmt.Sprintf("%#v", this.KineticEnergy)+",\n")
	s = append(s, "PriorWeight: "+fmt.Sprintf("%#v", this.PriorWeight)+",\n")
	if this.TrackStatus != nil {
		s = append(s, "TrackStatus: "+valueToGoStringTracking(this.TrackStatus, "MotionBoxState_TrackStatus")+",\n")
	}
	if this.SpatialPriorGridSize != nil {
		s = append(s, "SpatialPriorGridSize: "+valueToGoStringTracking(this.SpatialPriorGridSize, "int32")+",\n")
	}
	if this.SpatialPrior != nil {
		s = append(s, "SpatialPrior: "+fmt.Sprintf("%#v", this.SpatialPrior)+",\n")
	}
	if this.SpatialConfidence != nil {
		s = append(s, "SpatialConfidence: "+fmt.Sprintf("%#v", this.SpatialConfidence)+",\n")
	}
	s = append(s, "PriorDiff: "+fmt.Sprintf("%#v", this.PriorDiff)+",\n")
	s = append(s, "MotionDisparity: "+fmt.Sprintf("%#v", this.MotionDisparity)+",\n")
	s = append(s, "BackgroundDiscrimination: "+fmt.Sprintf("%#v", this.BackgroundDiscrimination)+",\n")
	s = append(s, "InlierCenterX: "+fmt.Sprintf("%#v", this.InlierCenterX)+",\n")
	s = append(s, "InlierCenterY: "+fmt.Sprintf("%#v", this.InlierCenterY)+",\n")
	s = append(s, "InlierSum: "+fmt.Sprintf("%#v", this.InlierSum)+",\n")
	s = append(s, "InlierRatio: "+fmt.Sprintf("%#v", this.InlierRatio)+",\n")
	s = append(s, "InlierWidth: "+fmt.Sprintf("%#v", this.InlierWidth)+",\n")
	s = append(s, "InlierHeight: "+fmt.Sprintf("%#v", this.InlierHeight)+",\n")
	if this.InlierIds != nil {
		s = append(s, "InlierIds: "+fmt.Sprintf("%#v", this.InlierIds)+",\n")
	}
	if this.InlierIdMatchPos != nil {
		s = append(s, "InlierIdMatchPos: "+fmt.Sprintf("%#v", this.InlierIdMatchPos)+",\n")
	}
	if this.InlierLength != nil {
		s = append(s, "InlierLength: "+fmt.Sprintf("%#v", this.InlierLength)+",\n")
	}
	if this.OutlierIds != nil {
		s = append(s, "OutlierIds: "+fmt.Sprintf("%#v", this.OutlierIds)+",\n")
	}
	if this.OutlierIdMatchPos != nil {
		s = append(s, "OutlierIdMatchPos: "+fmt.Sprintf("%#v", this.OutlierIdMatchPos)+",\n")
	}
	s = append(s, "TrackingConfidence: "+fmt.Sprintf("%#v", this.TrackingConfidence)+",\n")
	if this.Internal != nil {
		s = append(s, "Internal: "+fmt.Sprintf("%#v", this.Internal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionBoxState_Quad) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tracking.MotionBoxState_Quad{")
	if this.Vertices != nil {
		s = append(s, "Vertices: "+fmt.Sprintf("%#v", this.Vertices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MotionBoxInternalState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tracking.MotionBoxInternalState{")
	if this.PosX != nil {
		s = append(s, "PosX: "+fmt.Sprintf("%#v", this.PosX)+",\n")
	}
	if this.PosY != nil {
		s = append(s, "PosY: "+fmt.Sprintf("%#v", this.PosY)+",\n")
	}
	if this.Dx != nil {
		s = append(s, "Dx: "+fmt.Sprintf("%#v", this.Dx)+",\n")
	}
	if this.Dy != nil {
		s = append(s, "Dy: "+fmt.Sprintf("%#v", this.Dy)+",\n")
	}
	if this.CameraDx != nil {
		s = append(s, "CameraDx: "+fmt.Sprintf("%#v", this.CameraDx)+",\n")
	}
	if this.CameraDy != nil {
		s = append(s, "CameraDy: "+fmt.Sprintf("%#v", this.CameraDy)+",\n")
	}
	if this.TrackId != nil {
		s = append(s, "TrackId: "+fmt.Sprintf("%#v", this.TrackId)+",\n")
	}
	if this.InlierScore != nil {
		s = append(s, "InlierScore: "+fmt.Sprintf("%#v", this.InlierScore)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackStepOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 43)
	s = append(s, "&tracking.TrackStepOptions{")
	if this.TrackingDegrees != nil {
		s = append(s, "TrackingDegrees: "+valueToGoStringTracking(this.TrackingDegrees, "TrackStepOptions_TrackingDegrees")+",\n")
	}
	if this.TrackObjectAndCamera != nil {
		s = append(s, "TrackObjectAndCamera: "+valueToGoStringTracking(this.TrackObjectAndCamera, "bool")+",\n")
	}
	if this.IrlsIterations != nil {
		s = append(s, "IrlsIterations: "+valueToGoStringTracking(this.IrlsIterations, "int32")+",\n")
	}
	if this.SpatialSigma != nil {
		s = append(s, "SpatialSigma: "+valueToGoStringTracking(this.SpatialSigma, "float32")+",\n")
	}
	if this.MinMotionSigma != nil {
		s = append(s, "MinMotionSigma: "+valueToGoStringTracking(this.MinMotionSigma, "float32")+",\n")
	}
	if this.RelativeMotionSigma != nil {
		s = append(s, "RelativeMotionSigma: "+valueToGoStringTracking(this.RelativeMotionSigma, "float32")+",\n")
	}
	if this.MotionDisparityLowLevel != nil {
		s = append(s, "MotionDisparityLowLevel: "+valueToGoStringTracking(this.MotionDisparityLowLevel, "float32")+",\n")
	}
	if this.MotionDisparityHighLevel != nil {
		s = append(s, "MotionDisparityHighLevel: "+valueToGoStringTracking(this.MotionDisparityHighLevel, "float32")+",\n")
	}
	if this.DisparityDecay != nil {
		s = append(s, "DisparityDecay: "+valueToGoStringTracking(this.DisparityDecay, "float32")+",\n")
	}
	if this.MotionPriorWeight != nil {
		s = append(s, "MotionPriorWeight: "+valueToGoStringTracking(this.MotionPriorWeight, "float32")+",\n")
	}
	if this.BackgroundDiscriminationLowLevel != nil {
		s = append(s, "BackgroundDiscriminationLowLevel: "+valueToGoStringTracking(this.BackgroundDiscriminationLowLevel, "float32")+",\n")
	}
	if this.BackgroundDiscriminationHighLevel != nil {
		s = append(s, "BackgroundDiscriminationHighLevel: "+valueToGoStringTracking(this.BackgroundDiscriminationHighLevel, "float32")+",\n")
	}
	if this.InlierCenterRelativeDistance != nil {
		s = append(s, "InlierCenterRelativeDistance: "+valueToGoStringTracking(this.InlierCenterRelativeDistance, "float32")+",\n")
	}
	if this.InlierSpringForce != nil {
		s = append(s, "InlierSpringForce: "+valueToGoStringTracking(this.InlierSpringForce, "float32")+",\n")
	}
	if this.KineticCenterRelativeDistance != nil {
		s = append(s, "KineticCenterRelativeDistance: "+valueToGoStringTracking(this.KineticCenterRelativeDistance, "float32")+",\n")
	}
	if this.KineticSpringForce != nil {
		s = append(s, "KineticSpringForce: "+valueToGoStringTracking(this.KineticSpringForce, "float32")+",\n")
	}
	if this.KineticSpringForceMinKineticEnergy != nil {
		s = append(s, "KineticSpringForceMinKineticEnergy: "+valueToGoStringTracking(this.KineticSpringForceMinKineticEnergy, "float32")+",\n")
	}
	if this.VelocityUpdateWeight != nil {
		s = append(s, "VelocityUpdateWeight: "+valueToGoStringTracking(this.VelocityUpdateWeight, "float32")+",\n")
	}
	if this.MaxTrackFailures != nil {
		s = append(s, "MaxTrackFailures: "+valueToGoStringTracking(this.MaxTrackFailures, "int32")+",\n")
	}
	if this.ExpansionSize != nil {
		s = append(s, "ExpansionSize: "+valueToGoStringTracking(this.ExpansionSize, "float32")+",\n")
	}
	if this.InlierLowWeight != nil {
		s = append(s, "InlierLowWeight: "+valueToGoStringTracking(this.InlierLowWeight, "float32")+",\n")
	}
	if this.InlierHighWeight != nil {
		s = append(s, "InlierHighWeight: "+valueToGoStringTracking(this.InlierHighWeight, "float32")+",\n")
	}
	if this.KineticEnergyDecay != nil {
		s = append(s, "KineticEnergyDecay: "+valueToGoStringTracking(this.KineticEnergyDecay, "float32")+",\n")
	}
	if this.PriorWeightIncrease != nil {
		s = append(s, "PriorWeightIncrease: "+valueToGoStringTracking(this.PriorWeightIncrease, "float32")+",\n")
	}
	if this.LowKineticEnergy != nil {
		s = append(s, "LowKineticEnergy: "+valueToGoStringTracking(this.LowKineticEnergy, "float32")+",\n")
	}
	if this.HighKineticEnergy != nil {
		s = append(s, "HighKineticEnergy: "+valueToGoStringTracking(this.HighKineticEnergy, "float32")+",\n")
	}
	if this.ReturnInternalState != nil {
		s = append(s, "ReturnInternalState: "+valueToGoStringTracking(this.ReturnInternalState, "bool")+",\n")
	}
	if this.UsePostEstimationWeightsForState != nil {
		s = append(s, "UsePostEstimationWeightsForState: "+valueToGoStringTracking(this.UsePostEstimationWeightsForState, "bool")+",\n")
	}
	if this.ComputeSpatialPrior != nil {
		s = append(s, "ComputeSpatialPrior: "+valueToGoStringTracking(this.ComputeSpatialPrior, "bool")+",\n")
	}
	if this.IrlsInitialization != nil {
		s = append(s, "IrlsInitialization: "+fmt.Sprintf("%#v", this.IrlsInitialization)+",\n")
	}
	if this.StaticMotionTemporalRatio != nil {
		s = append(s, "StaticMotionTemporalRatio: "+valueToGoStringTracking(this.StaticMotionTemporalRatio, "float32")+",\n")
	}
	if this.CancelTrackingWithOcclusionOptions != nil {
		s = append(s, "CancelTrackingWithOcclusionOptions: "+fmt.Sprintf("%#v", this.CancelTrackingWithOcclusionOptions)+",\n")
	}
	if this.ObjectSimilarityMinContdInliers != nil {
		s = append(s, "ObjectSimilarityMinContdInliers: "+valueToGoStringTracking(this.ObjectSimilarityMinContdInliers, "int32")+",\n")
	}
	if this.BoxSimilarityMaxScale != nil {
		s = append(s, "BoxSimilarityMaxScale: "+valueToGoStringTracking(this.BoxSimilarityMaxScale, "float32")+",\n")
	}
	if this.BoxSimilarityMaxRotation != nil {
		s = append(s, "BoxSimilarityMaxRotation: "+valueToGoStringTracking(this.BoxSimilarityMaxRotation, "float32")+",\n")
	}
	if this.QuadHomographyMaxScale != nil {
		s = append(s, "QuadHomographyMaxScale: "+valueToGoStringTracking(this.QuadHomographyMaxScale, "float32")+",\n")
	}
	if this.QuadHomographyMaxRotation != nil {
		s = append(s, "QuadHomographyMaxRotation: "+valueToGoStringTracking(this.QuadHomographyMaxRotation, "float32")+",\n")
	}
	if this.CameraIntrinsics != nil {
		s = append(s, "CameraIntrinsics: "+fmt.Sprintf("%#v", this.CameraIntrinsics)+",\n")
	}
	if this.ForcedPnpTracking != nil {
		s = append(s, "ForcedPnpTracking: "+valueToGoStringTracking(this.ForcedPnpTracking, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackStepOptions_IrlsInitialization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.TrackStepOptions_IrlsInitialization{")
	if this.Activated != nil {
		s = append(s, "Activated: "+valueToGoStringTracking(this.Activated, "bool")+",\n")
	}
	if this.Rounds != nil {
		s = append(s, "Rounds: "+valueToGoStringTracking(this.Rounds, "int32")+",\n")
	}
	if this.Cutoff != nil {
		s = append(s, "Cutoff: "+valueToGoStringTracking(this.Cutoff, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackStepOptions_CancelTrackingWithOcclusionOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tracking.TrackStepOptions_CancelTrackingWithOcclusionOptions{")
	if this.Activated != nil {
		s = append(s, "Activated: "+valueToGoStringTracking(this.Activated, "bool")+",\n")
	}
	if this.MinMotionContinuity != nil {
		s = append(s, "MinMotionContinuity: "+valueToGoStringTracking(this.MinMotionContinuity, "float32")+",\n")
	}
	if this.MinInlierRatio != nil {
		s = append(s, "MinInlierRatio: "+valueToGoStringTracking(this.MinInlierRatio, "float32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrackStepOptions_CameraIntrinsics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&tracking.TrackStepOptions_CameraIntrinsics{")
	s = append(s, "Fx: "+fmt.Sprintf("%#v", this.Fx)+",\n")
	s = append(s, "Fy: "+fmt.Sprintf("%#v", this.Fy)+",\n")
	s = append(s, "Cx: "+fmt.Sprintf("%#v", this.Cx)+",\n")
	s = append(s, "Cy: "+fmt.Sprintf("%#v", this.Cy)+",\n")
	s = append(s, "K0: "+fmt.Sprintf("%#v", this.K0)+",\n")
	s = append(s, "K1: "+fmt.Sprintf("%#v", this.K1)+",\n")
	s = append(s, "K2: "+fmt.Sprintf("%#v", this.K2)+",\n")
	s = append(s, "W: "+fmt.Sprintf("%#v", this.W)+",\n")
	s = append(s, "H: "+fmt.Sprintf("%#v", this.H)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTracking(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MotionBoxState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionBoxState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionBoxState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestGrouping != nil {
		i--
		if *m.RequestGrouping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.PnpHomography != nil {
		{
			size, err := m.PnpHomography.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AspectRatio))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9d
	if m.Quad != nil {
		{
			size, err := m.Quad.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TrackingConfidence))))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x8d
	if len(m.OutlierIdMatchPos) > 0 {
		dAtA4 := make([]byte, len(m.OutlierIdMatchPos)*10)
		var j3 int
		for _, num := range m.OutlierIdMatchPos {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTracking(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.InlierIdMatchPos) > 0 {
		dAtA6 := make([]byte, len(m.InlierIdMatchPos)*10)
		var j5 int
		for _, num := range m.InlierIdMatchPos {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTracking(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.Rotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Rotation))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.Internal != nil {
		{
			size, err := m.Internal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.OutlierIds) > 0 {
		dAtA9 := make([]byte, len(m.OutlierIds)*10)
		var j8 int
		for _, num := range m.OutlierIds {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTracking(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InlierLength) > 0 {
		dAtA11 := make([]byte, len(m.InlierLength)*10)
		var j10 int
		for _, num := range m.InlierLength {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTracking(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.InlierIds) > 0 {
		dAtA13 := make([]byte, len(m.InlierIds)*10)
		var j12 int
		for _, num := range m.InlierIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTracking(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierRatio))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xcd
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierSum))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc5
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierHeight))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xbd
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierWidth))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb5
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierCenterY))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.InlierCenterX))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x95
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.KineticEnergy))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BackgroundDiscrimination))))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x85
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MotionDisparity))))
	i--
	dAtA[i] = 0x7d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PriorDiff))))
	i--
	dAtA[i] = 0x75
	if len(m.SpatialConfidence) > 0 {
		for iNdEx := len(m.SpatialConfidence) - 1; iNdEx >= 0; iNdEx-- {
			f14 := math.Float32bits(float32(m.SpatialConfidence[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f14))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.SpatialConfidence)*4))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SpatialPrior) > 0 {
		for iNdEx := len(m.SpatialPrior) - 1; iNdEx >= 0; iNdEx-- {
			f15 := math.Float32bits(float32(m.SpatialPrior[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f15))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.SpatialPrior)*4))
		i--
		dAtA[i] = 0x62
	}
	if m.SpatialPriorGridSize != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.SpatialPriorGridSize))
		i--
		dAtA[i] = 0x58
	}
	if m.TrackStatus != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.TrackStatus))
		i--
		dAtA[i] = 0x50
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PriorWeight))))
	i--
	dAtA[i] = 0x4d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Dy))))
	i--
	dAtA[i] = 0x45
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Dx))))
	i--
	dAtA[i] = 0x3d
	if m.Scale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Scale))))
		i--
		dAtA[i] = 0x2d
	}
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Height))))
	i--
	dAtA[i] = 0x25
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Width))))
	i--
	dAtA[i] = 0x1d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosY))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosX))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func (m *MotionBoxState_Quad) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionBoxState_Quad) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionBoxState_Quad) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vertices) > 0 {
		for iNdEx := len(m.Vertices) - 1; iNdEx >= 0; iNdEx-- {
			f16 := math.Float32bits(float32(m.Vertices[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
			i--
			dAtA[i] = 0xd
		}
	}
	return len(dAtA) - i, nil
}

func (m *MotionBoxInternalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MotionBoxInternalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MotionBoxInternalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InlierScore) > 0 {
		for iNdEx := len(m.InlierScore) - 1; iNdEx >= 0; iNdEx-- {
			f17 := math.Float32bits(float32(m.InlierScore[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f17))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.InlierScore)*4))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TrackId) > 0 {
		dAtA19 := make([]byte, len(m.TrackId)*10)
		var j18 int
		for _, num1 := range m.TrackId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintTracking(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CameraDy) > 0 {
		for iNdEx := len(m.CameraDy) - 1; iNdEx >= 0; iNdEx-- {
			f20 := math.Float32bits(float32(m.CameraDy[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f20))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.CameraDy)*4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CameraDx) > 0 {
		for iNdEx := len(m.CameraDx) - 1; iNdEx >= 0; iNdEx-- {
			f21 := math.Float32bits(float32(m.CameraDx[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f21))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.CameraDx)*4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Dy) > 0 {
		for iNdEx := len(m.Dy) - 1; iNdEx >= 0; iNdEx-- {
			f22 := math.Float32bits(float32(m.Dy[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f22))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.Dy)*4))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Dx) > 0 {
		for iNdEx := len(m.Dx) - 1; iNdEx >= 0; iNdEx-- {
			f23 := math.Float32bits(float32(m.Dx[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f23))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.Dx)*4))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PosY) > 0 {
		for iNdEx := len(m.PosY) - 1; iNdEx >= 0; iNdEx-- {
			f24 := math.Float32bits(float32(m.PosY[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.PosY)*4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PosX) > 0 {
		for iNdEx := len(m.PosX) - 1; iNdEx >= 0; iNdEx-- {
			f25 := math.Float32bits(float32(m.PosX[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f25))
		}
		i = encodeVarintTracking(dAtA, i, uint64(len(m.PosX)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrackStepOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackStepOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackStepOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForcedPnpTracking != nil {
		i--
		if *m.ForcedPnpTracking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.CameraIntrinsics != nil {
		{
			size, err := m.CameraIntrinsics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.QuadHomographyMaxRotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.QuadHomographyMaxRotation))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xbd
	}
	if m.QuadHomographyMaxScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.QuadHomographyMaxScale))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb5
	}
	if m.BoxSimilarityMaxRotation != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BoxSimilarityMaxRotation))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.BoxSimilarityMaxScale != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BoxSimilarityMaxScale))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa5
	}
	if m.ObjectSimilarityMinContdInliers != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.ObjectSimilarityMinContdInliers))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.CancelTrackingWithOcclusionOptions != nil {
		{
			size, err := m.CancelTrackingWithOcclusionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.StaticMotionTemporalRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.StaticMotionTemporalRatio))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8d
	}
	if m.TrackObjectAndCamera != nil {
		i--
		if *m.TrackObjectAndCamera {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.IrlsInitialization != nil {
		{
			size, err := m.IrlsInitialization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTracking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.UsePostEstimationWeightsForState != nil {
		i--
		if *m.UsePostEstimationWeightsForState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.TrackingDegrees != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.TrackingDegrees))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ComputeSpatialPrior != nil {
		i--
		if *m.ComputeSpatialPrior {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.ReturnInternalState != nil {
		i--
		if *m.ReturnInternalState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.HighKineticEnergy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.HighKineticEnergy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.LowKineticEnergy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.LowKineticEnergy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if m.PriorWeightIncrease != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.PriorWeightIncrease))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.KineticEnergyDecay != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.KineticEnergyDecay))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.KineticSpringForceMinKineticEnergy != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.KineticSpringForceMinKineticEnergy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.InlierHighWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierHighWeight))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.InlierLowWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierLowWeight))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9d
	}
	if m.ExpansionSize != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.ExpansionSize))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.MaxTrackFailures != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.MaxTrackFailures))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.VelocityUpdateWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.VelocityUpdateWeight))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.KineticSpringForce != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.KineticSpringForce))))
		i--
		dAtA[i] = 0x7d
	}
	if m.KineticCenterRelativeDistance != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.KineticCenterRelativeDistance))))
		i--
		dAtA[i] = 0x75
	}
	if m.InlierSpringForce != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierSpringForce))))
		i--
		dAtA[i] = 0x6d
	}
	if m.InlierCenterRelativeDistance != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.InlierCenterRelativeDistance))))
		i--
		dAtA[i] = 0x65
	}
	if m.BackgroundDiscriminationHighLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BackgroundDiscriminationHighLevel))))
		i--
		dAtA[i] = 0x5d
	}
	if m.BackgroundDiscriminationLowLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.BackgroundDiscriminationLowLevel))))
		i--
		dAtA[i] = 0x55
	}
	if m.MotionPriorWeight != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MotionPriorWeight))))
		i--
		dAtA[i] = 0x4d
	}
	if m.DisparityDecay != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DisparityDecay))))
		i--
		dAtA[i] = 0x45
	}
	if m.MotionDisparityHighLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MotionDisparityHighLevel))))
		i--
		dAtA[i] = 0x3d
	}
	if m.MotionDisparityLowLevel != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MotionDisparityLowLevel))))
		i--
		dAtA[i] = 0x35
	}
	if m.RelativeMotionSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.RelativeMotionSigma))))
		i--
		dAtA[i] = 0x25
	}
	if m.MinMotionSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinMotionSigma))))
		i--
		dAtA[i] = 0x1d
	}
	if m.SpatialSigma != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.SpatialSigma))))
		i--
		dAtA[i] = 0x15
	}
	if m.IrlsIterations != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.IrlsIterations))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrackStepOptions_IrlsInitialization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackStepOptions_IrlsInitialization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackStepOptions_IrlsInitialization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cutoff != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Cutoff))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Rounds != nil {
		i = encodeVarintTracking(dAtA, i, uint64(*m.Rounds))
		i--
		dAtA[i] = 0x10
	}
	if m.Activated != nil {
		i--
		if *m.Activated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinInlierRatio != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinInlierRatio))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MinMotionContinuity != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.MinMotionContinuity))))
		i--
		dAtA[i] = 0x15
	}
	if m.Activated != nil {
		i--
		if *m.Activated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrackStepOptions_CameraIntrinsics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackStepOptions_CameraIntrinsics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrackStepOptions_CameraIntrinsics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintTracking(dAtA, i, uint64(m.H))
	i--
	dAtA[i] = 0x48
	i = encodeVarintTracking(dAtA, i, uint64(m.W))
	i--
	dAtA[i] = 0x40
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.K2))))
	i--
	dAtA[i] = 0x3d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.K1))))
	i--
	dAtA[i] = 0x35
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.K0))))
	i--
	dAtA[i] = 0x2d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cy))))
	i--
	dAtA[i] = 0x25
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cx))))
	i--
	dAtA[i] = 0x1d
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fy))))
	i--
	dAtA[i] = 0x15
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fx))))
	i--
	dAtA[i] = 0xd
	return len(dAtA) - i, nil
}

func encodeVarintTracking(dAtA []byte, offset int, v uint64) int {
	offset -= sovTracking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MotionBoxState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	n += 5
	if m.Scale != nil {
		n += 5
	}
	n += 5
	n += 5
	n += 5
	if m.TrackStatus != nil {
		n += 1 + sovTracking(uint64(*m.TrackStatus))
	}
	if m.SpatialPriorGridSize != nil {
		n += 1 + sovTracking(uint64(*m.SpatialPriorGridSize))
	}
	if len(m.SpatialPrior) > 0 {
		n += 1 + sovTracking(uint64(len(m.SpatialPrior)*4)) + len(m.SpatialPrior)*4
	}
	if len(m.SpatialConfidence) > 0 {
		n += 1 + sovTracking(uint64(len(m.SpatialConfidence)*4)) + len(m.SpatialConfidence)*4
	}
	n += 5
	n += 5
	n += 6
	n += 6
	n += 6
	n += 6
	n += 6
	n += 6
	n += 6
	n += 6
	if len(m.InlierIds) > 0 {
		l = 0
		for _, e := range m.InlierIds {
			l += sovTracking(uint64(e))
		}
		n += 2 + sovTracking(uint64(l)) + l
	}
	if len(m.InlierLength) > 0 {
		l = 0
		for _, e := range m.InlierLength {
			l += sovTracking(uint64(e))
		}
		n += 2 + sovTracking(uint64(l)) + l
	}
	if len(m.OutlierIds) > 0 {
		l = 0
		for _, e := range m.OutlierIds {
			l += sovTracking(uint64(e))
		}
		n += 2 + sovTracking(uint64(l)) + l
	}
	if m.Internal != nil {
		l = m.Internal.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	if m.Rotation != nil {
		n += 6
	}
	if len(m.InlierIdMatchPos) > 0 {
		l = 0
		for _, e := range m.InlierIdMatchPos {
			l += sovTracking(uint64(e))
		}
		n += 2 + sovTracking(uint64(l)) + l
	}
	if len(m.OutlierIdMatchPos) > 0 {
		l = 0
		for _, e := range m.OutlierIdMatchPos {
			l += sovTracking(uint64(e))
		}
		n += 2 + sovTracking(uint64(l)) + l
	}
	n += 6
	if m.Quad != nil {
		l = m.Quad.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	n += 6
	if m.PnpHomography != nil {
		l = m.PnpHomography.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	if m.RequestGrouping != nil {
		n += 3
	}
	return n
}

func (m *MotionBoxState_Quad) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vertices) > 0 {
		n += 5 * len(m.Vertices)
	}
	return n
}

func (m *MotionBoxInternalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PosX) > 0 {
		n += 1 + sovTracking(uint64(len(m.PosX)*4)) + len(m.PosX)*4
	}
	if len(m.PosY) > 0 {
		n += 1 + sovTracking(uint64(len(m.PosY)*4)) + len(m.PosY)*4
	}
	if len(m.Dx) > 0 {
		n += 1 + sovTracking(uint64(len(m.Dx)*4)) + len(m.Dx)*4
	}
	if len(m.Dy) > 0 {
		n += 1 + sovTracking(uint64(len(m.Dy)*4)) + len(m.Dy)*4
	}
	if len(m.CameraDx) > 0 {
		n += 1 + sovTracking(uint64(len(m.CameraDx)*4)) + len(m.CameraDx)*4
	}
	if len(m.CameraDy) > 0 {
		n += 1 + sovTracking(uint64(len(m.CameraDy)*4)) + len(m.CameraDy)*4
	}
	if len(m.TrackId) > 0 {
		l = 0
		for _, e := range m.TrackId {
			l += sovTracking(uint64(e))
		}
		n += 1 + sovTracking(uint64(l)) + l
	}
	if len(m.InlierScore) > 0 {
		n += 1 + sovTracking(uint64(len(m.InlierScore)*4)) + len(m.InlierScore)*4
	}
	return n
}

func (m *TrackStepOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IrlsIterations != nil {
		n += 1 + sovTracking(uint64(*m.IrlsIterations))
	}
	if m.SpatialSigma != nil {
		n += 5
	}
	if m.MinMotionSigma != nil {
		n += 5
	}
	if m.RelativeMotionSigma != nil {
		n += 5
	}
	if m.MotionDisparityLowLevel != nil {
		n += 5
	}
	if m.MotionDisparityHighLevel != nil {
		n += 5
	}
	if m.DisparityDecay != nil {
		n += 5
	}
	if m.MotionPriorWeight != nil {
		n += 5
	}
	if m.BackgroundDiscriminationLowLevel != nil {
		n += 5
	}
	if m.BackgroundDiscriminationHighLevel != nil {
		n += 5
	}
	if m.InlierCenterRelativeDistance != nil {
		n += 5
	}
	if m.InlierSpringForce != nil {
		n += 5
	}
	if m.KineticCenterRelativeDistance != nil {
		n += 5
	}
	if m.KineticSpringForce != nil {
		n += 5
	}
	if m.VelocityUpdateWeight != nil {
		n += 6
	}
	if m.MaxTrackFailures != nil {
		n += 2 + sovTracking(uint64(*m.MaxTrackFailures))
	}
	if m.ExpansionSize != nil {
		n += 6
	}
	if m.InlierLowWeight != nil {
		n += 6
	}
	if m.InlierHighWeight != nil {
		n += 6
	}
	if m.KineticSpringForceMinKineticEnergy != nil {
		n += 6
	}
	if m.KineticEnergyDecay != nil {
		n += 6
	}
	if m.PriorWeightIncrease != nil {
		n += 6
	}
	if m.LowKineticEnergy != nil {
		n += 6
	}
	if m.HighKineticEnergy != nil {
		n += 6
	}
	if m.ReturnInternalState != nil {
		n += 3
	}
	if m.ComputeSpatialPrior != nil {
		n += 3
	}
	if m.TrackingDegrees != nil {
		n += 2 + sovTracking(uint64(*m.TrackingDegrees))
	}
	if m.UsePostEstimationWeightsForState != nil {
		n += 3
	}
	if m.IrlsInitialization != nil {
		l = m.IrlsInitialization.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	if m.TrackObjectAndCamera != nil {
		n += 3
	}
	if m.StaticMotionTemporalRatio != nil {
		n += 6
	}
	if m.CancelTrackingWithOcclusionOptions != nil {
		l = m.CancelTrackingWithOcclusionOptions.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	if m.ObjectSimilarityMinContdInliers != nil {
		n += 2 + sovTracking(uint64(*m.ObjectSimilarityMinContdInliers))
	}
	if m.BoxSimilarityMaxScale != nil {
		n += 6
	}
	if m.BoxSimilarityMaxRotation != nil {
		n += 6
	}
	if m.QuadHomographyMaxScale != nil {
		n += 6
	}
	if m.QuadHomographyMaxRotation != nil {
		n += 6
	}
	if m.CameraIntrinsics != nil {
		l = m.CameraIntrinsics.Size()
		n += 2 + l + sovTracking(uint64(l))
	}
	if m.ForcedPnpTracking != nil {
		n += 3
	}
	return n
}

func (m *TrackStepOptions_IrlsInitialization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Activated != nil {
		n += 2
	}
	if m.Rounds != nil {
		n += 1 + sovTracking(uint64(*m.Rounds))
	}
	if m.Cutoff != nil {
		n += 5
	}
	return n
}

func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Activated != nil {
		n += 2
	}
	if m.MinMotionContinuity != nil {
		n += 5
	}
	if m.MinInlierRatio != nil {
		n += 5
	}
	return n
}

func (m *TrackStepOptions_CameraIntrinsics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	n += 5
	n += 5
	n += 5
	n += 5
	n += 5
	n += 5
	n += 1 + sovTracking(uint64(m.W))
	n += 1 + sovTracking(uint64(m.H))
	return n
}

func sovTracking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTracking(x uint64) (n int) {
	return sovTracking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MotionBoxState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionBoxState{`,
		`PosX:` + fmt.Sprintf("%v", this.PosX) + `,`,
		`PosY:` + fmt.Sprintf("%v", this.PosY) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`Scale:` + valueToStringTracking(this.Scale) + `,`,
		`Dx:` + fmt.Sprintf("%v", this.Dx) + `,`,
		`Dy:` + fmt.Sprintf("%v", this.Dy) + `,`,
		`PriorWeight:` + fmt.Sprintf("%v", this.PriorWeight) + `,`,
		`TrackStatus:` + valueToStringTracking(this.TrackStatus) + `,`,
		`SpatialPriorGridSize:` + valueToStringTracking(this.SpatialPriorGridSize) + `,`,
		`SpatialPrior:` + fmt.Sprintf("%v", this.SpatialPrior) + `,`,
		`SpatialConfidence:` + fmt.Sprintf("%v", this.SpatialConfidence) + `,`,
		`PriorDiff:` + fmt.Sprintf("%v", this.PriorDiff) + `,`,
		`MotionDisparity:` + fmt.Sprintf("%v", this.MotionDisparity) + `,`,
		`BackgroundDiscrimination:` + fmt.Sprintf("%v", this.BackgroundDiscrimination) + `,`,
		`KineticEnergy:` + fmt.Sprintf("%v", this.KineticEnergy) + `,`,
		`InlierCenterX:` + fmt.Sprintf("%v", this.InlierCenterX) + `,`,
		`InlierCenterY:` + fmt.Sprintf("%v", this.InlierCenterY) + `,`,
		`InlierWidth:` + fmt.Sprintf("%v", this.InlierWidth) + `,`,
		`InlierHeight:` + fmt.Sprintf("%v", this.InlierHeight) + `,`,
		`InlierSum:` + fmt.Sprintf("%v", this.InlierSum) + `,`,
		`InlierRatio:` + fmt.Sprintf("%v", this.InlierRatio) + `,`,
		`InlierIds:` + fmt.Sprintf("%v", this.InlierIds) + `,`,
		`InlierLength:` + fmt.Sprintf("%v", this.InlierLength) + `,`,
		`OutlierIds:` + fmt.Sprintf("%v", this.OutlierIds) + `,`,
		`Internal:` + strings.Replace(this.Internal.String(), "MotionBoxInternalState", "MotionBoxInternalState", 1) + `,`,
		`Rotation:` + valueToStringTracking(this.Rotation) + `,`,
		`InlierIdMatchPos:` + fmt.Sprintf("%v", this.InlierIdMatchPos) + `,`,
		`OutlierIdMatchPos:` + fmt.Sprintf("%v", this.OutlierIdMatchPos) + `,`,
		`TrackingConfidence:` + fmt.Sprintf("%v", this.TrackingConfidence) + `,`,
		`Quad:` + strings.Replace(fmt.Sprintf("%v", this.Quad), "MotionBoxState_Quad", "MotionBoxState_Quad", 1) + `,`,
		`AspectRatio:` + fmt.Sprintf("%v", this.AspectRatio) + `,`,
		`PnpHomography:` + strings.Replace(fmt.Sprintf("%v", this.PnpHomography), "Homography", "Homography", 1) + `,`,
		`RequestGrouping:` + valueToStringTracking(this.RequestGrouping) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionBoxState_Quad) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionBoxState_Quad{`,
		`Vertices:` + fmt.Sprintf("%v", this.Vertices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MotionBoxInternalState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MotionBoxInternalState{`,
		`PosX:` + fmt.Sprintf("%v", this.PosX) + `,`,
		`PosY:` + fmt.Sprintf("%v", this.PosY) + `,`,
		`Dx:` + fmt.Sprintf("%v", this.Dx) + `,`,
		`Dy:` + fmt.Sprintf("%v", this.Dy) + `,`,
		`CameraDx:` + fmt.Sprintf("%v", this.CameraDx) + `,`,
		`CameraDy:` + fmt.Sprintf("%v", this.CameraDy) + `,`,
		`TrackId:` + fmt.Sprintf("%v", this.TrackId) + `,`,
		`InlierScore:` + fmt.Sprintf("%v", this.InlierScore) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackStepOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackStepOptions{`,
		`IrlsIterations:` + valueToStringTracking(this.IrlsIterations) + `,`,
		`SpatialSigma:` + valueToStringTracking(this.SpatialSigma) + `,`,
		`MinMotionSigma:` + valueToStringTracking(this.MinMotionSigma) + `,`,
		`RelativeMotionSigma:` + valueToStringTracking(this.RelativeMotionSigma) + `,`,
		`MotionDisparityLowLevel:` + valueToStringTracking(this.MotionDisparityLowLevel) + `,`,
		`MotionDisparityHighLevel:` + valueToStringTracking(this.MotionDisparityHighLevel) + `,`,
		`DisparityDecay:` + valueToStringTracking(this.DisparityDecay) + `,`,
		`MotionPriorWeight:` + valueToStringTracking(this.MotionPriorWeight) + `,`,
		`BackgroundDiscriminationLowLevel:` + valueToStringTracking(this.BackgroundDiscriminationLowLevel) + `,`,
		`BackgroundDiscriminationHighLevel:` + valueToStringTracking(this.BackgroundDiscriminationHighLevel) + `,`,
		`InlierCenterRelativeDistance:` + valueToStringTracking(this.InlierCenterRelativeDistance) + `,`,
		`InlierSpringForce:` + valueToStringTracking(this.InlierSpringForce) + `,`,
		`KineticCenterRelativeDistance:` + valueToStringTracking(this.KineticCenterRelativeDistance) + `,`,
		`KineticSpringForce:` + valueToStringTracking(this.KineticSpringForce) + `,`,
		`VelocityUpdateWeight:` + valueToStringTracking(this.VelocityUpdateWeight) + `,`,
		`MaxTrackFailures:` + valueToStringTracking(this.MaxTrackFailures) + `,`,
		`ExpansionSize:` + valueToStringTracking(this.ExpansionSize) + `,`,
		`InlierLowWeight:` + valueToStringTracking(this.InlierLowWeight) + `,`,
		`InlierHighWeight:` + valueToStringTracking(this.InlierHighWeight) + `,`,
		`KineticSpringForceMinKineticEnergy:` + valueToStringTracking(this.KineticSpringForceMinKineticEnergy) + `,`,
		`KineticEnergyDecay:` + valueToStringTracking(this.KineticEnergyDecay) + `,`,
		`PriorWeightIncrease:` + valueToStringTracking(this.PriorWeightIncrease) + `,`,
		`LowKineticEnergy:` + valueToStringTracking(this.LowKineticEnergy) + `,`,
		`HighKineticEnergy:` + valueToStringTracking(this.HighKineticEnergy) + `,`,
		`ReturnInternalState:` + valueToStringTracking(this.ReturnInternalState) + `,`,
		`ComputeSpatialPrior:` + valueToStringTracking(this.ComputeSpatialPrior) + `,`,
		`TrackingDegrees:` + valueToStringTracking(this.TrackingDegrees) + `,`,
		`UsePostEstimationWeightsForState:` + valueToStringTracking(this.UsePostEstimationWeightsForState) + `,`,
		`IrlsInitialization:` + strings.Replace(fmt.Sprintf("%v", this.IrlsInitialization), "TrackStepOptions_IrlsInitialization", "TrackStepOptions_IrlsInitialization", 1) + `,`,
		`TrackObjectAndCamera:` + valueToStringTracking(this.TrackObjectAndCamera) + `,`,
		`StaticMotionTemporalRatio:` + valueToStringTracking(this.StaticMotionTemporalRatio) + `,`,
		`CancelTrackingWithOcclusionOptions:` + strings.Replace(fmt.Sprintf("%v", this.CancelTrackingWithOcclusionOptions), "TrackStepOptions_CancelTrackingWithOcclusionOptions", "TrackStepOptions_CancelTrackingWithOcclusionOptions", 1) + `,`,
		`ObjectSimilarityMinContdInliers:` + valueToStringTracking(this.ObjectSimilarityMinContdInliers) + `,`,
		`BoxSimilarityMaxScale:` + valueToStringTracking(this.BoxSimilarityMaxScale) + `,`,
		`BoxSimilarityMaxRotation:` + valueToStringTracking(this.BoxSimilarityMaxRotation) + `,`,
		`QuadHomographyMaxScale:` + valueToStringTracking(this.QuadHomographyMaxScale) + `,`,
		`QuadHomographyMaxRotation:` + valueToStringTracking(this.QuadHomographyMaxRotation) + `,`,
		`CameraIntrinsics:` + strings.Replace(fmt.Sprintf("%v", this.CameraIntrinsics), "TrackStepOptions_CameraIntrinsics", "TrackStepOptions_CameraIntrinsics", 1) + `,`,
		`ForcedPnpTracking:` + valueToStringTracking(this.ForcedPnpTracking) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackStepOptions_IrlsInitialization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackStepOptions_IrlsInitialization{`,
		`Activated:` + valueToStringTracking(this.Activated) + `,`,
		`Rounds:` + valueToStringTracking(this.Rounds) + `,`,
		`Cutoff:` + valueToStringTracking(this.Cutoff) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackStepOptions_CancelTrackingWithOcclusionOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackStepOptions_CancelTrackingWithOcclusionOptions{`,
		`Activated:` + valueToStringTracking(this.Activated) + `,`,
		`MinMotionContinuity:` + valueToStringTracking(this.MinMotionContinuity) + `,`,
		`MinInlierRatio:` + valueToStringTracking(this.MinInlierRatio) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrackStepOptions_CameraIntrinsics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrackStepOptions_CameraIntrinsics{`,
		`Fx:` + fmt.Sprintf("%v", this.Fx) + `,`,
		`Fy:` + fmt.Sprintf("%v", this.Fy) + `,`,
		`Cx:` + fmt.Sprintf("%v", this.Cx) + `,`,
		`Cy:` + fmt.Sprintf("%v", this.Cy) + `,`,
		`K0:` + fmt.Sprintf("%v", this.K0) + `,`,
		`K1:` + fmt.Sprintf("%v", this.K1) + `,`,
		`K2:` + fmt.Sprintf("%v", this.K2) + `,`,
		`W:` + fmt.Sprintf("%v", this.W) + `,`,
		`H:` + fmt.Sprintf("%v", this.H) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTracking(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MotionBoxState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MotionBoxState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MotionBoxState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosX = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosY = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Width = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Height = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Scale = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Dx = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Dy = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PriorWeight = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackStatus", wireType)
			}
			var v MotionBoxState_TrackStatus
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MotionBoxState_TrackStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackStatus = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialPriorGridSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpatialPriorGridSize = &v
		case 12:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SpatialPrior = append(m.SpatialPrior, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.SpatialPrior) == 0 {
					m.SpatialPrior = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SpatialPrior = append(m.SpatialPrior, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialPrior", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SpatialConfidence = append(m.SpatialConfidence, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.SpatialConfidence) == 0 {
					m.SpatialConfidence = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SpatialConfidence = append(m.SpatialConfidence, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialConfidence", wireType)
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorDiff", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PriorDiff = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionDisparity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MotionDisparity = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundDiscrimination", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BackgroundDiscrimination = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KineticEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.KineticEnergy = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierCenterX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierCenterX = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierCenterY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierCenterY = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierWidth", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierWidth = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierHeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierHeight = float32(math.Float32frombits(v))
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierSum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierSum = float32(math.Float32frombits(v))
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.InlierRatio = float32(math.Float32frombits(v))
		case 26:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InlierIds = append(m.InlierIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InlierIds) == 0 {
					m.InlierIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InlierIds = append(m.InlierIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierIds", wireType)
			}
		case 27:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InlierLength = append(m.InlierLength, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InlierLength) == 0 {
					m.InlierLength = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InlierLength = append(m.InlierLength, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierLength", wireType)
			}
		case 28:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutlierIds = append(m.OutlierIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutlierIds) == 0 {
					m.OutlierIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutlierIds = append(m.OutlierIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierIds", wireType)
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Internal == nil {
				m.Internal = &MotionBoxInternalState{}
			}
			if err := m.Internal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Rotation = &v2
		case 31:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InlierIdMatchPos = append(m.InlierIdMatchPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InlierIdMatchPos) == 0 {
					m.InlierIdMatchPos = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InlierIdMatchPos = append(m.InlierIdMatchPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierIdMatchPos", wireType)
			}
		case 32:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutlierIdMatchPos = append(m.OutlierIdMatchPos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutlierIdMatchPos) == 0 {
					m.OutlierIdMatchPos = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutlierIdMatchPos = append(m.OutlierIdMatchPos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierIdMatchPos", wireType)
			}
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingConfidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TrackingConfidence = float32(math.Float32frombits(v))
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quad", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quad == nil {
				m.Quad = &MotionBoxState_Quad{}
			}
			if err := m.Quad.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AspectRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AspectRatio = float32(math.Float32frombits(v))
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PnpHomography", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PnpHomography == nil {
				m.PnpHomography = &Homography{}
			}
			if err := m.PnpHomography.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestGrouping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RequestGrouping = &b
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionBoxState_Quad) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Quad: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Quad: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Vertices = append(m.Vertices, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Vertices) == 0 {
					m.Vertices = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Vertices = append(m.Vertices, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MotionBoxInternalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MotionBoxInternalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MotionBoxInternalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PosX = append(m.PosX, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PosX) == 0 {
					m.PosX = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PosX = append(m.PosX, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosX", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PosY = append(m.PosY, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.PosY) == 0 {
					m.PosY = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PosY = append(m.PosY, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosY", wireType)
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Dx = append(m.Dx, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Dx) == 0 {
					m.Dx = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Dx = append(m.Dx, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dx", wireType)
			}
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Dy = append(m.Dy, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Dy) == 0 {
					m.Dy = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Dy = append(m.Dy, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dy", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.CameraDx = append(m.CameraDx, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.CameraDx) == 0 {
					m.CameraDx = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.CameraDx = append(m.CameraDx, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraDx", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.CameraDy = append(m.CameraDy, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.CameraDy) == 0 {
					m.CameraDy = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.CameraDy = append(m.CameraDy, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraDy", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TrackId = append(m.TrackId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TrackId) == 0 {
					m.TrackId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTracking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TrackId = append(m.TrackId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.InlierScore = append(m.InlierScore, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTracking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTracking
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTracking
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.InlierScore) == 0 {
					m.InlierScore = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.InlierScore = append(m.InlierScore, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierScore", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackStepOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackStepOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackStepOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsIterations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IrlsIterations = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpatialSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.SpatialSigma = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMotionSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinMotionSigma = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeMotionSigma", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.RelativeMotionSigma = &v2
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionDisparityLowLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MotionDisparityLowLevel = &v2
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionDisparityHighLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MotionDisparityHighLevel = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisparityDecay", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DisparityDecay = &v2
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MotionPriorWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MotionPriorWeight = &v2
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundDiscriminationLowLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BackgroundDiscriminationLowLevel = &v2
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundDiscriminationHighLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BackgroundDiscriminationHighLevel = &v2
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierCenterRelativeDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierCenterRelativeDistance = &v2
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierSpringForce", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierSpringForce = &v2
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KineticCenterRelativeDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.KineticCenterRelativeDistance = &v2
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KineticSpringForce", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.KineticSpringForce = &v2
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VelocityUpdateWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.VelocityUpdateWeight = &v2
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrackFailures", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxTrackFailures = &v
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpansionSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.ExpansionSize = &v2
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierLowWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierLowWeight = &v2
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlierHighWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.InlierHighWeight = &v2
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KineticSpringForceMinKineticEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.KineticSpringForceMinKineticEnergy = &v2
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KineticEnergyDecay", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.KineticEnergyDecay = &v2
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorWeightIncrease", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.PriorWeightIncrease = &v2
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowKineticEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.LowKineticEnergy = &v2
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighKineticEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.HighKineticEnergy = &v2
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnInternalState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnInternalState = &b
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeSpatialPrior", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ComputeSpatialPrior = &b
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingDegrees", wireType)
			}
			var v TrackStepOptions_TrackingDegrees
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TrackStepOptions_TrackingDegrees(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrackingDegrees = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePostEstimationWeightsForState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UsePostEstimationWeightsForState = &b
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrlsInitialization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IrlsInitialization == nil {
				m.IrlsInitialization = &TrackStepOptions_IrlsInitialization{}
			}
			if err := m.IrlsInitialization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackObjectAndCamera", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TrackObjectAndCamera = &b
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticMotionTemporalRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.StaticMotionTemporalRatio = &v2
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelTrackingWithOcclusionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CancelTrackingWithOcclusionOptions == nil {
				m.CancelTrackingWithOcclusionOptions = &TrackStepOptions_CancelTrackingWithOcclusionOptions{}
			}
			if err := m.CancelTrackingWithOcclusionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSimilarityMinContdInliers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ObjectSimilarityMinContdInliers = &v
		case 36:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxSimilarityMaxScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BoxSimilarityMaxScale = &v2
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxSimilarityMaxRotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.BoxSimilarityMaxRotation = &v2
		case 38:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuadHomographyMaxScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.QuadHomographyMaxScale = &v2
		case 39:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuadHomographyMaxRotation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.QuadHomographyMaxRotation = &v2
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraIntrinsics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTracking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTracking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CameraIntrinsics == nil {
				m.CameraIntrinsics = &TrackStepOptions_CameraIntrinsics{}
			}
			if err := m.CameraIntrinsics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcedPnpTracking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForcedPnpTracking = &b
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackStepOptions_IrlsInitialization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IrlsInitialization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IrlsInitialization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Activated = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rounds", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rounds = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cutoff", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Cutoff = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackStepOptions_CancelTrackingWithOcclusionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTrackingWithOcclusionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTrackingWithOcclusionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Activated = &b
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMotionContinuity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinMotionContinuity = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInlierRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.MinInlierRatio = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackStepOptions_CameraIntrinsics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CameraIntrinsics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CameraIntrinsics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Fx = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Fy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cx = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cy = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field K0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.K0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field K1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.K1 = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field K2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.K2 = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			m.W = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.W |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTracking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTracking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTracking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTracking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTracking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTracking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTracking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTracking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTracking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTracking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTracking = fmt.Errorf("proto: unexpected end of group")
)
