// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qdrant/collections.proto

package qdrant

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Datatype int32

const (
	Default Datatype = 0
	Float32 Datatype = 1
	Uint8   Datatype = 2
	Float16 Datatype = 3
)

var Datatype_name = map[int32]string{
	0: "Default",
	1: "Float32",
	2: "Uint8",
	3: "Float16",
}

var Datatype_value = map[string]int32{
	"Default": 0,
	"Float32": 1,
	"Uint8":   2,
	"Float16": 3,
}

func (Datatype) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{0}
}

type Modifier int32

const (
	None Modifier = 0
	Idf  Modifier = 1
)

var Modifier_name = map[int32]string{
	0: "None",
	1: "Idf",
}

var Modifier_value = map[string]int32{
	"None": 0,
	"Idf":  1,
}

func (Modifier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{1}
}

type MultiVectorComparator int32

const (
	MaxSim MultiVectorComparator = 0
)

var MultiVectorComparator_name = map[int32]string{
	0: "MaxSim",
}

var MultiVectorComparator_value = map[string]int32{
	"MaxSim": 0,
}

func (MultiVectorComparator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{2}
}

type Distance int32

const (
	UnknownDistance Distance = 0
	Cosine          Distance = 1
	Euclid          Distance = 2
	Dot             Distance = 3
	Manhattan       Distance = 4
)

var Distance_name = map[int32]string{
	0: "UnknownDistance",
	1: "Cosine",
	2: "Euclid",
	3: "Dot",
	4: "Manhattan",
}

var Distance_value = map[string]int32{
	"UnknownDistance": 0,
	"Cosine":          1,
	"Euclid":          2,
	"Dot":             3,
	"Manhattan":       4,
}

func (Distance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{3}
}

type CollectionStatus int32

const (
	UnknownCollectionStatus CollectionStatus = 0
	Green                   CollectionStatus = 1
	Yellow                  CollectionStatus = 2
	Red                     CollectionStatus = 3
	Grey                    CollectionStatus = 4
)

var CollectionStatus_name = map[int32]string{
	0: "UnknownCollectionStatus",
	1: "Green",
	2: "Yellow",
	3: "Red",
	4: "Grey",
}

var CollectionStatus_value = map[string]int32{
	"UnknownCollectionStatus": 0,
	"Green":                   1,
	"Yellow":                  2,
	"Red":                     3,
	"Grey":                    4,
}

func (CollectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{4}
}

type PayloadSchemaType int32

const (
	UnknownType PayloadSchemaType = 0
	Keyword     PayloadSchemaType = 1
	Integer     PayloadSchemaType = 2
	Float       PayloadSchemaType = 3
	Geo         PayloadSchemaType = 4
	Text        PayloadSchemaType = 5
	Bool        PayloadSchemaType = 6
	Datetime    PayloadSchemaType = 7
)

var PayloadSchemaType_name = map[int32]string{
	0: "UnknownType",
	1: "Keyword",
	2: "Integer",
	3: "Float",
	4: "Geo",
	5: "Text",
	6: "Bool",
	7: "Datetime",
}

var PayloadSchemaType_value = map[string]int32{
	"UnknownType": 0,
	"Keyword":     1,
	"Integer":     2,
	"Float":       3,
	"Geo":         4,
	"Text":        5,
	"Bool":        6,
	"Datetime":    7,
}

func (PayloadSchemaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{5}
}

type QuantizationType int32

const (
	UnknownQuantization QuantizationType = 0
	Int8                QuantizationType = 1
)

var QuantizationType_name = map[int32]string{
	0: "UnknownQuantization",
	1: "Int8",
}

var QuantizationType_value = map[string]int32{
	"UnknownQuantization": 0,
	"Int8":                1,
}

func (QuantizationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{6}
}

type CompressionRatio int32

const (
	x4  CompressionRatio = 0
	x8  CompressionRatio = 1
	x16 CompressionRatio = 2
	x32 CompressionRatio = 3
	x64 CompressionRatio = 4
)

var CompressionRatio_name = map[int32]string{
	0: "x4",
	1: "x8",
	2: "x16",
	3: "x32",
	4: "x64",
}

var CompressionRatio_value = map[string]int32{
	"x4":  0,
	"x8":  1,
	"x16": 2,
	"x32": 3,
	"x64": 4,
}

func (CompressionRatio) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{7}
}

type ShardingMethod int32

const (
	Auto   ShardingMethod = 0
	Custom ShardingMethod = 1
)

var ShardingMethod_name = map[int32]string{
	0: "Auto",
	1: "Custom",
}

var ShardingMethod_value = map[string]int32{
	"Auto":   0,
	"Custom": 1,
}

func (ShardingMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{8}
}

type TokenizerType int32

const (
	Unknown      TokenizerType = 0
	Prefix       TokenizerType = 1
	Whitespace   TokenizerType = 2
	Word         TokenizerType = 3
	Multilingual TokenizerType = 4
)

var TokenizerType_name = map[int32]string{
	0: "Unknown",
	1: "Prefix",
	2: "Whitespace",
	3: "Word",
	4: "Multilingual",
}

var TokenizerType_value = map[string]int32{
	"Unknown":      0,
	"Prefix":       1,
	"Whitespace":   2,
	"Word":         3,
	"Multilingual": 4,
}

func (TokenizerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{9}
}

type ReplicaState int32

const (
	Active          ReplicaState = 0
	Dead            ReplicaState = 1
	Partial         ReplicaState = 2
	Initializing    ReplicaState = 3
	Listener        ReplicaState = 4
	PartialSnapshot ReplicaState = 5
	Recovery        ReplicaState = 6
	Resharding      ReplicaState = 7
)

var ReplicaState_name = map[int32]string{
	0: "Active",
	1: "Dead",
	2: "Partial",
	3: "Initializing",
	4: "Listener",
	5: "PartialSnapshot",
	6: "Recovery",
	7: "Resharding",
}

var ReplicaState_value = map[string]int32{
	"Active":          0,
	"Dead":            1,
	"Partial":         2,
	"Initializing":    3,
	"Listener":        4,
	"PartialSnapshot": 5,
	"Recovery":        6,
	"Resharding":      7,
}

func (ReplicaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{10}
}

type ShardTransferMethod int32

const (
	StreamRecords           ShardTransferMethod = 0
	Snapshot                ShardTransferMethod = 1
	WalDelta                ShardTransferMethod = 2
	ReshardingStreamRecords ShardTransferMethod = 3
)

var ShardTransferMethod_name = map[int32]string{
	0: "StreamRecords",
	1: "Snapshot",
	2: "WalDelta",
	3: "ReshardingStreamRecords",
}

var ShardTransferMethod_value = map[string]int32{
	"StreamRecords":           0,
	"Snapshot":                1,
	"WalDelta":                2,
	"ReshardingStreamRecords": 3,
}

func (ShardTransferMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{11}
}

type VectorParams struct {
	Size_              uint64              `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Distance           Distance            `protobuf:"varint,2,opt,name=distance,proto3,enum=qdrant.Distance" json:"distance,omitempty"`
	HnswConfig         *HnswConfigDiff     `protobuf:"bytes,3,opt,name=hnsw_config,json=hnswConfig,proto3" json:"hnsw_config,omitempty"`
	QuantizationConfig *QuantizationConfig `protobuf:"bytes,4,opt,name=quantization_config,json=quantizationConfig,proto3" json:"quantization_config,omitempty"`
	OnDisk             bool                `protobuf:"varint,5,opt,name=on_disk,json=onDisk,proto3" json:"on_disk,omitempty"`
	Datatype           Datatype            `protobuf:"varint,6,opt,name=datatype,proto3,enum=qdrant.Datatype" json:"datatype,omitempty"`
	MultivectorConfig  *MultiVectorConfig  `protobuf:"bytes,7,opt,name=multivector_config,json=multivectorConfig,proto3" json:"multivector_config,omitempty"`
}

func (m *VectorParams) Reset()      { *m = VectorParams{} }
func (*VectorParams) ProtoMessage() {}
func (*VectorParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{0}
}
func (m *VectorParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorParams.Merge(m, src)
}
func (m *VectorParams) XXX_Size() int {
	return m.Size()
}
func (m *VectorParams) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorParams.DiscardUnknown(m)
}

var xxx_messageInfo_VectorParams proto.InternalMessageInfo

func (m *VectorParams) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *VectorParams) GetDistance() Distance {
	if m != nil {
		return m.Distance
	}
	return UnknownDistance
}

func (m *VectorParams) GetHnswConfig() *HnswConfigDiff {
	if m != nil {
		return m.HnswConfig
	}
	return nil
}

func (m *VectorParams) GetQuantizationConfig() *QuantizationConfig {
	if m != nil {
		return m.QuantizationConfig
	}
	return nil
}

func (m *VectorParams) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func (m *VectorParams) GetDatatype() Datatype {
	if m != nil {
		return m.Datatype
	}
	return Default
}

func (m *VectorParams) GetMultivectorConfig() *MultiVectorConfig {
	if m != nil {
		return m.MultivectorConfig
	}
	return nil
}

type VectorParamsDiff struct {
	HnswConfig         *HnswConfigDiff         `protobuf:"bytes,1,opt,name=hnsw_config,json=hnswConfig,proto3" json:"hnsw_config,omitempty"`
	QuantizationConfig *QuantizationConfigDiff `protobuf:"bytes,2,opt,name=quantization_config,json=quantizationConfig,proto3" json:"quantization_config,omitempty"`
	OnDisk             bool                    `protobuf:"varint,3,opt,name=on_disk,json=onDisk,proto3" json:"on_disk,omitempty"`
}

func (m *VectorParamsDiff) Reset()      { *m = VectorParamsDiff{} }
func (*VectorParamsDiff) ProtoMessage() {}
func (*VectorParamsDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{1}
}
func (m *VectorParamsDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorParamsDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorParamsDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorParamsDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorParamsDiff.Merge(m, src)
}
func (m *VectorParamsDiff) XXX_Size() int {
	return m.Size()
}
func (m *VectorParamsDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorParamsDiff.DiscardUnknown(m)
}

var xxx_messageInfo_VectorParamsDiff proto.InternalMessageInfo

func (m *VectorParamsDiff) GetHnswConfig() *HnswConfigDiff {
	if m != nil {
		return m.HnswConfig
	}
	return nil
}

func (m *VectorParamsDiff) GetQuantizationConfig() *QuantizationConfigDiff {
	if m != nil {
		return m.QuantizationConfig
	}
	return nil
}

func (m *VectorParamsDiff) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

type VectorParamsMap struct {
	Map map[string]*VectorParams `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VectorParamsMap) Reset()      { *m = VectorParamsMap{} }
func (*VectorParamsMap) ProtoMessage() {}
func (*VectorParamsMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{2}
}
func (m *VectorParamsMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorParamsMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorParamsMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorParamsMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorParamsMap.Merge(m, src)
}
func (m *VectorParamsMap) XXX_Size() int {
	return m.Size()
}
func (m *VectorParamsMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorParamsMap.DiscardUnknown(m)
}

var xxx_messageInfo_VectorParamsMap proto.InternalMessageInfo

func (m *VectorParamsMap) GetMap() map[string]*VectorParams {
	if m != nil {
		return m.Map
	}
	return nil
}

type VectorParamsDiffMap struct {
	Map map[string]*VectorParamsDiff `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VectorParamsDiffMap) Reset()      { *m = VectorParamsDiffMap{} }
func (*VectorParamsDiffMap) ProtoMessage() {}
func (*VectorParamsDiffMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{3}
}
func (m *VectorParamsDiffMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorParamsDiffMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorParamsDiffMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorParamsDiffMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorParamsDiffMap.Merge(m, src)
}
func (m *VectorParamsDiffMap) XXX_Size() int {
	return m.Size()
}
func (m *VectorParamsDiffMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorParamsDiffMap.DiscardUnknown(m)
}

var xxx_messageInfo_VectorParamsDiffMap proto.InternalMessageInfo

func (m *VectorParamsDiffMap) GetMap() map[string]*VectorParamsDiff {
	if m != nil {
		return m.Map
	}
	return nil
}

type VectorsConfig struct {
	// Types that are valid to be assigned to Config:
	//
	//	*VectorsConfig_Params
	//	*VectorsConfig_ParamsMap
	Config isVectorsConfig_Config `protobuf_oneof:"config"`
}

func (m *VectorsConfig) Reset()      { *m = VectorsConfig{} }
func (*VectorsConfig) ProtoMessage() {}
func (*VectorsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{4}
}
func (m *VectorsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorsConfig.Merge(m, src)
}
func (m *VectorsConfig) XXX_Size() int {
	return m.Size()
}
func (m *VectorsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VectorsConfig proto.InternalMessageInfo

type isVectorsConfig_Config interface {
	isVectorsConfig_Config()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VectorsConfig_Params struct {
	Params *VectorParams `protobuf:"bytes,1,opt,name=params,proto3,oneof" json:"params,omitempty"`
}
type VectorsConfig_ParamsMap struct {
	ParamsMap *VectorParamsMap `protobuf:"bytes,2,opt,name=params_map,json=paramsMap,proto3,oneof" json:"params_map,omitempty"`
}

func (*VectorsConfig_Params) isVectorsConfig_Config()    {}
func (*VectorsConfig_ParamsMap) isVectorsConfig_Config() {}

func (m *VectorsConfig) GetConfig() isVectorsConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *VectorsConfig) GetParams() *VectorParams {
	if x, ok := m.GetConfig().(*VectorsConfig_Params); ok {
		return x.Params
	}
	return nil
}

func (m *VectorsConfig) GetParamsMap() *VectorParamsMap {
	if x, ok := m.GetConfig().(*VectorsConfig_ParamsMap); ok {
		return x.ParamsMap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VectorsConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VectorsConfig_Params)(nil),
		(*VectorsConfig_ParamsMap)(nil),
	}
}

type VectorsConfigDiff struct {
	// Types that are valid to be assigned to Config:
	//
	//	*VectorsConfigDiff_Params
	//	*VectorsConfigDiff_ParamsMap
	Config isVectorsConfigDiff_Config `protobuf_oneof:"config"`
}

func (m *VectorsConfigDiff) Reset()      { *m = VectorsConfigDiff{} }
func (*VectorsConfigDiff) ProtoMessage() {}
func (*VectorsConfigDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{5}
}
func (m *VectorsConfigDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorsConfigDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorsConfigDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorsConfigDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorsConfigDiff.Merge(m, src)
}
func (m *VectorsConfigDiff) XXX_Size() int {
	return m.Size()
}
func (m *VectorsConfigDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorsConfigDiff.DiscardUnknown(m)
}

var xxx_messageInfo_VectorsConfigDiff proto.InternalMessageInfo

type isVectorsConfigDiff_Config interface {
	isVectorsConfigDiff_Config()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VectorsConfigDiff_Params struct {
	Params *VectorParamsDiff `protobuf:"bytes,1,opt,name=params,proto3,oneof" json:"params,omitempty"`
}
type VectorsConfigDiff_ParamsMap struct {
	ParamsMap *VectorParamsDiffMap `protobuf:"bytes,2,opt,name=params_map,json=paramsMap,proto3,oneof" json:"params_map,omitempty"`
}

func (*VectorsConfigDiff_Params) isVectorsConfigDiff_Config()    {}
func (*VectorsConfigDiff_ParamsMap) isVectorsConfigDiff_Config() {}

func (m *VectorsConfigDiff) GetConfig() isVectorsConfigDiff_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *VectorsConfigDiff) GetParams() *VectorParamsDiff {
	if x, ok := m.GetConfig().(*VectorsConfigDiff_Params); ok {
		return x.Params
	}
	return nil
}

func (m *VectorsConfigDiff) GetParamsMap() *VectorParamsDiffMap {
	if x, ok := m.GetConfig().(*VectorsConfigDiff_ParamsMap); ok {
		return x.ParamsMap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VectorsConfigDiff) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VectorsConfigDiff_Params)(nil),
		(*VectorsConfigDiff_ParamsMap)(nil),
	}
}

type SparseVectorParams struct {
	Index    *SparseIndexConfig `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Modifier Modifier           `protobuf:"varint,2,opt,name=modifier,proto3,enum=qdrant.Modifier" json:"modifier,omitempty"`
}

func (m *SparseVectorParams) Reset()      { *m = SparseVectorParams{} }
func (*SparseVectorParams) ProtoMessage() {}
func (*SparseVectorParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{6}
}
func (m *SparseVectorParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseVectorParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseVectorParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseVectorParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseVectorParams.Merge(m, src)
}
func (m *SparseVectorParams) XXX_Size() int {
	return m.Size()
}
func (m *SparseVectorParams) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseVectorParams.DiscardUnknown(m)
}

var xxx_messageInfo_SparseVectorParams proto.InternalMessageInfo

func (m *SparseVectorParams) GetIndex() *SparseIndexConfig {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *SparseVectorParams) GetModifier() Modifier {
	if m != nil {
		return m.Modifier
	}
	return None
}

type SparseVectorConfig struct {
	Map map[string]*SparseVectorParams `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SparseVectorConfig) Reset()      { *m = SparseVectorConfig{} }
func (*SparseVectorConfig) ProtoMessage() {}
func (*SparseVectorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{7}
}
func (m *SparseVectorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseVectorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseVectorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseVectorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseVectorConfig.Merge(m, src)
}
func (m *SparseVectorConfig) XXX_Size() int {
	return m.Size()
}
func (m *SparseVectorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseVectorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SparseVectorConfig proto.InternalMessageInfo

func (m *SparseVectorConfig) GetMap() map[string]*SparseVectorParams {
	if m != nil {
		return m.Map
	}
	return nil
}

type MultiVectorConfig struct {
	Comparator MultiVectorComparator `protobuf:"varint,1,opt,name=comparator,proto3,enum=qdrant.MultiVectorComparator" json:"comparator,omitempty"`
}

func (m *MultiVectorConfig) Reset()      { *m = MultiVectorConfig{} }
func (*MultiVectorConfig) ProtoMessage() {}
func (*MultiVectorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{8}
}
func (m *MultiVectorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiVectorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiVectorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiVectorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiVectorConfig.Merge(m, src)
}
func (m *MultiVectorConfig) XXX_Size() int {
	return m.Size()
}
func (m *MultiVectorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiVectorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MultiVectorConfig proto.InternalMessageInfo

func (m *MultiVectorConfig) GetComparator() MultiVectorComparator {
	if m != nil {
		return m.Comparator
	}
	return MaxSim
}

type GetCollectionInfoRequest struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
}

func (m *GetCollectionInfoRequest) Reset()      { *m = GetCollectionInfoRequest{} }
func (*GetCollectionInfoRequest) ProtoMessage() {}
func (*GetCollectionInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{9}
}
func (m *GetCollectionInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCollectionInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionInfoRequest.Merge(m, src)
}
func (m *GetCollectionInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionInfoRequest proto.InternalMessageInfo

func (m *GetCollectionInfoRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

type CollectionExistsRequest struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
}

func (m *CollectionExistsRequest) Reset()      { *m = CollectionExistsRequest{} }
func (*CollectionExistsRequest) ProtoMessage() {}
func (*CollectionExistsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{10}
}
func (m *CollectionExistsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionExistsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionExistsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionExistsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionExistsRequest.Merge(m, src)
}
func (m *CollectionExistsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CollectionExistsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionExistsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionExistsRequest proto.InternalMessageInfo

func (m *CollectionExistsRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

type CollectionExists struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
}

func (m *CollectionExists) Reset()      { *m = CollectionExists{} }
func (*CollectionExists) ProtoMessage() {}
func (*CollectionExists) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{11}
}
func (m *CollectionExists) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionExists) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionExists.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionExists) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionExists.Merge(m, src)
}
func (m *CollectionExists) XXX_Size() int {
	return m.Size()
}
func (m *CollectionExists) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionExists.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionExists proto.InternalMessageInfo

func (m *CollectionExists) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type CollectionExistsResponse struct {
	Result *CollectionExists `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64           `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *CollectionExistsResponse) Reset()      { *m = CollectionExistsResponse{} }
func (*CollectionExistsResponse) ProtoMessage() {}
func (*CollectionExistsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{12}
}
func (m *CollectionExistsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionExistsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionExistsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionExistsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionExistsResponse.Merge(m, src)
}
func (m *CollectionExistsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CollectionExistsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionExistsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionExistsResponse proto.InternalMessageInfo

func (m *CollectionExistsResponse) GetResult() *CollectionExists {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CollectionExistsResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type ListCollectionsRequest struct {
}

func (m *ListCollectionsRequest) Reset()      { *m = ListCollectionsRequest{} }
func (*ListCollectionsRequest) ProtoMessage() {}
func (*ListCollectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{13}
}
func (m *ListCollectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCollectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCollectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCollectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCollectionsRequest.Merge(m, src)
}
func (m *ListCollectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCollectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCollectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCollectionsRequest proto.InternalMessageInfo

type CollectionDescription struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CollectionDescription) Reset()      { *m = CollectionDescription{} }
func (*CollectionDescription) ProtoMessage() {}
func (*CollectionDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{14}
}
func (m *CollectionDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionDescription.Merge(m, src)
}
func (m *CollectionDescription) XXX_Size() int {
	return m.Size()
}
func (m *CollectionDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionDescription.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionDescription proto.InternalMessageInfo

func (m *CollectionDescription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetCollectionInfoResponse struct {
	Result *CollectionInfo `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64         `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *GetCollectionInfoResponse) Reset()      { *m = GetCollectionInfoResponse{} }
func (*GetCollectionInfoResponse) ProtoMessage() {}
func (*GetCollectionInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{15}
}
func (m *GetCollectionInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCollectionInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionInfoResponse.Merge(m, src)
}
func (m *GetCollectionInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionInfoResponse proto.InternalMessageInfo

func (m *GetCollectionInfoResponse) GetResult() *CollectionInfo {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetCollectionInfoResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type ListCollectionsResponse struct {
	Collections []*CollectionDescription `protobuf:"bytes,1,rep,name=collections,proto3" json:"collections,omitempty"`
	Time        float64                  `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *ListCollectionsResponse) Reset()      { *m = ListCollectionsResponse{} }
func (*ListCollectionsResponse) ProtoMessage() {}
func (*ListCollectionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{16}
}
func (m *ListCollectionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCollectionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCollectionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCollectionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCollectionsResponse.Merge(m, src)
}
func (m *ListCollectionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListCollectionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCollectionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListCollectionsResponse proto.InternalMessageInfo

func (m *ListCollectionsResponse) GetCollections() []*CollectionDescription {
	if m != nil {
		return m.Collections
	}
	return nil
}

func (m *ListCollectionsResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type OptimizerStatus struct {
	Ok    bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *OptimizerStatus) Reset()      { *m = OptimizerStatus{} }
func (*OptimizerStatus) ProtoMessage() {}
func (*OptimizerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{17}
}
func (m *OptimizerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptimizerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptimizerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptimizerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptimizerStatus.Merge(m, src)
}
func (m *OptimizerStatus) XXX_Size() int {
	return m.Size()
}
func (m *OptimizerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OptimizerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OptimizerStatus proto.InternalMessageInfo

func (m *OptimizerStatus) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *OptimizerStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type HnswConfigDiff struct {
	M                  uint64 `protobuf:"varint,1,opt,name=m,proto3" json:"m,omitempty"`
	EfConstruct        uint64 `protobuf:"varint,2,opt,name=ef_construct,json=efConstruct,proto3" json:"ef_construct,omitempty"`
	FullScanThreshold  uint64 `protobuf:"varint,3,opt,name=full_scan_threshold,json=fullScanThreshold,proto3" json:"full_scan_threshold,omitempty"`
	MaxIndexingThreads uint64 `protobuf:"varint,4,opt,name=max_indexing_threads,json=maxIndexingThreads,proto3" json:"max_indexing_threads,omitempty"`
	OnDisk             bool   `protobuf:"varint,5,opt,name=on_disk,json=onDisk,proto3" json:"on_disk,omitempty"`
	PayloadM           uint64 `protobuf:"varint,6,opt,name=payload_m,json=payloadM,proto3" json:"payload_m,omitempty"`
}

func (m *HnswConfigDiff) Reset()      { *m = HnswConfigDiff{} }
func (*HnswConfigDiff) ProtoMessage() {}
func (*HnswConfigDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{18}
}
func (m *HnswConfigDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HnswConfigDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HnswConfigDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HnswConfigDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HnswConfigDiff.Merge(m, src)
}
func (m *HnswConfigDiff) XXX_Size() int {
	return m.Size()
}
func (m *HnswConfigDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_HnswConfigDiff.DiscardUnknown(m)
}

var xxx_messageInfo_HnswConfigDiff proto.InternalMessageInfo

func (m *HnswConfigDiff) GetM() uint64 {
	if m != nil {
		return m.M
	}
	return 0
}

func (m *HnswConfigDiff) GetEfConstruct() uint64 {
	if m != nil {
		return m.EfConstruct
	}
	return 0
}

func (m *HnswConfigDiff) GetFullScanThreshold() uint64 {
	if m != nil {
		return m.FullScanThreshold
	}
	return 0
}

func (m *HnswConfigDiff) GetMaxIndexingThreads() uint64 {
	if m != nil {
		return m.MaxIndexingThreads
	}
	return 0
}

func (m *HnswConfigDiff) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func (m *HnswConfigDiff) GetPayloadM() uint64 {
	if m != nil {
		return m.PayloadM
	}
	return 0
}

type SparseIndexConfig struct {
	FullScanThreshold uint64   `protobuf:"varint,1,opt,name=full_scan_threshold,json=fullScanThreshold,proto3" json:"full_scan_threshold,omitempty"`
	OnDisk            bool     `protobuf:"varint,2,opt,name=on_disk,json=onDisk,proto3" json:"on_disk,omitempty"`
	Datatype          Datatype `protobuf:"varint,3,opt,name=datatype,proto3,enum=qdrant.Datatype" json:"datatype,omitempty"`
}

func (m *SparseIndexConfig) Reset()      { *m = SparseIndexConfig{} }
func (*SparseIndexConfig) ProtoMessage() {}
func (*SparseIndexConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{19}
}
func (m *SparseIndexConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseIndexConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseIndexConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseIndexConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseIndexConfig.Merge(m, src)
}
func (m *SparseIndexConfig) XXX_Size() int {
	return m.Size()
}
func (m *SparseIndexConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseIndexConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SparseIndexConfig proto.InternalMessageInfo

func (m *SparseIndexConfig) GetFullScanThreshold() uint64 {
	if m != nil {
		return m.FullScanThreshold
	}
	return 0
}

func (m *SparseIndexConfig) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func (m *SparseIndexConfig) GetDatatype() Datatype {
	if m != nil {
		return m.Datatype
	}
	return Default
}

type WalConfigDiff struct {
	WalCapacityMb    uint64 `protobuf:"varint,1,opt,name=wal_capacity_mb,json=walCapacityMb,proto3" json:"wal_capacity_mb,omitempty"`
	WalSegmentsAhead uint64 `protobuf:"varint,2,opt,name=wal_segments_ahead,json=walSegmentsAhead,proto3" json:"wal_segments_ahead,omitempty"`
}

func (m *WalConfigDiff) Reset()      { *m = WalConfigDiff{} }
func (*WalConfigDiff) ProtoMessage() {}
func (*WalConfigDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{20}
}
func (m *WalConfigDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalConfigDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalConfigDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalConfigDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalConfigDiff.Merge(m, src)
}
func (m *WalConfigDiff) XXX_Size() int {
	return m.Size()
}
func (m *WalConfigDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_WalConfigDiff.DiscardUnknown(m)
}

var xxx_messageInfo_WalConfigDiff proto.InternalMessageInfo

func (m *WalConfigDiff) GetWalCapacityMb() uint64 {
	if m != nil {
		return m.WalCapacityMb
	}
	return 0
}

func (m *WalConfigDiff) GetWalSegmentsAhead() uint64 {
	if m != nil {
		return m.WalSegmentsAhead
	}
	return 0
}

type OptimizersConfigDiff struct {
	DeletedThreshold       float64 `protobuf:"fixed64,1,opt,name=deleted_threshold,json=deletedThreshold,proto3" json:"deleted_threshold,omitempty"`
	VacuumMinVectorNumber  uint64  `protobuf:"varint,2,opt,name=vacuum_min_vector_number,json=vacuumMinVectorNumber,proto3" json:"vacuum_min_vector_number,omitempty"`
	DefaultSegmentNumber   uint64  `protobuf:"varint,3,opt,name=default_segment_number,json=defaultSegmentNumber,proto3" json:"default_segment_number,omitempty"`
	MaxSegmentSize         uint64  `protobuf:"varint,4,opt,name=max_segment_size,json=maxSegmentSize,proto3" json:"max_segment_size,omitempty"`
	MemmapThreshold        uint64  `protobuf:"varint,5,opt,name=memmap_threshold,json=memmapThreshold,proto3" json:"memmap_threshold,omitempty"`
	IndexingThreshold      uint64  `protobuf:"varint,6,opt,name=indexing_threshold,json=indexingThreshold,proto3" json:"indexing_threshold,omitempty"`
	FlushIntervalSec       uint64  `protobuf:"varint,7,opt,name=flush_interval_sec,json=flushIntervalSec,proto3" json:"flush_interval_sec,omitempty"`
	MaxOptimizationThreads uint64  `protobuf:"varint,8,opt,name=max_optimization_threads,json=maxOptimizationThreads,proto3" json:"max_optimization_threads,omitempty"`
}

func (m *OptimizersConfigDiff) Reset()      { *m = OptimizersConfigDiff{} }
func (*OptimizersConfigDiff) ProtoMessage() {}
func (*OptimizersConfigDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{21}
}
func (m *OptimizersConfigDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptimizersConfigDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptimizersConfigDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptimizersConfigDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptimizersConfigDiff.Merge(m, src)
}
func (m *OptimizersConfigDiff) XXX_Size() int {
	return m.Size()
}
func (m *OptimizersConfigDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_OptimizersConfigDiff.DiscardUnknown(m)
}

var xxx_messageInfo_OptimizersConfigDiff proto.InternalMessageInfo

func (m *OptimizersConfigDiff) GetDeletedThreshold() float64 {
	if m != nil {
		return m.DeletedThreshold
	}
	return 0
}

func (m *OptimizersConfigDiff) GetVacuumMinVectorNumber() uint64 {
	if m != nil {
		return m.VacuumMinVectorNumber
	}
	return 0
}

func (m *OptimizersConfigDiff) GetDefaultSegmentNumber() uint64 {
	if m != nil {
		return m.DefaultSegmentNumber
	}
	return 0
}

func (m *OptimizersConfigDiff) GetMaxSegmentSize() uint64 {
	if m != nil {
		return m.MaxSegmentSize
	}
	return 0
}

func (m *OptimizersConfigDiff) GetMemmapThreshold() uint64 {
	if m != nil {
		return m.MemmapThreshold
	}
	return 0
}

func (m *OptimizersConfigDiff) GetIndexingThreshold() uint64 {
	if m != nil {
		return m.IndexingThreshold
	}
	return 0
}

func (m *OptimizersConfigDiff) GetFlushIntervalSec() uint64 {
	if m != nil {
		return m.FlushIntervalSec
	}
	return 0
}

func (m *OptimizersConfigDiff) GetMaxOptimizationThreads() uint64 {
	if m != nil {
		return m.MaxOptimizationThreads
	}
	return 0
}

type ScalarQuantization struct {
	Type      QuantizationType `protobuf:"varint,1,opt,name=type,proto3,enum=qdrant.QuantizationType" json:"type,omitempty"`
	Quantile  float32          `protobuf:"fixed32,2,opt,name=quantile,proto3" json:"quantile,omitempty"`
	AlwaysRam bool             `protobuf:"varint,3,opt,name=always_ram,json=alwaysRam,proto3" json:"always_ram,omitempty"`
}

func (m *ScalarQuantization) Reset()      { *m = ScalarQuantization{} }
func (*ScalarQuantization) ProtoMessage() {}
func (*ScalarQuantization) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{22}
}
func (m *ScalarQuantization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalarQuantization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalarQuantization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalarQuantization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalarQuantization.Merge(m, src)
}
func (m *ScalarQuantization) XXX_Size() int {
	return m.Size()
}
func (m *ScalarQuantization) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalarQuantization.DiscardUnknown(m)
}

var xxx_messageInfo_ScalarQuantization proto.InternalMessageInfo

func (m *ScalarQuantization) GetType() QuantizationType {
	if m != nil {
		return m.Type
	}
	return UnknownQuantization
}

func (m *ScalarQuantization) GetQuantile() float32 {
	if m != nil {
		return m.Quantile
	}
	return 0
}

func (m *ScalarQuantization) GetAlwaysRam() bool {
	if m != nil {
		return m.AlwaysRam
	}
	return false
}

type ProductQuantization struct {
	Compression CompressionRatio `protobuf:"varint,1,opt,name=compression,proto3,enum=qdrant.CompressionRatio" json:"compression,omitempty"`
	AlwaysRam   bool             `protobuf:"varint,2,opt,name=always_ram,json=alwaysRam,proto3" json:"always_ram,omitempty"`
}

func (m *ProductQuantization) Reset()      { *m = ProductQuantization{} }
func (*ProductQuantization) ProtoMessage() {}
func (*ProductQuantization) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{23}
}
func (m *ProductQuantization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductQuantization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductQuantization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductQuantization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductQuantization.Merge(m, src)
}
func (m *ProductQuantization) XXX_Size() int {
	return m.Size()
}
func (m *ProductQuantization) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductQuantization.DiscardUnknown(m)
}

var xxx_messageInfo_ProductQuantization proto.InternalMessageInfo

func (m *ProductQuantization) GetCompression() CompressionRatio {
	if m != nil {
		return m.Compression
	}
	return x4
}

func (m *ProductQuantization) GetAlwaysRam() bool {
	if m != nil {
		return m.AlwaysRam
	}
	return false
}

type BinaryQuantization struct {
	AlwaysRam bool `protobuf:"varint,1,opt,name=always_ram,json=alwaysRam,proto3" json:"always_ram,omitempty"`
}

func (m *BinaryQuantization) Reset()      { *m = BinaryQuantization{} }
func (*BinaryQuantization) ProtoMessage() {}
func (*BinaryQuantization) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{24}
}
func (m *BinaryQuantization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryQuantization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryQuantization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryQuantization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryQuantization.Merge(m, src)
}
func (m *BinaryQuantization) XXX_Size() int {
	return m.Size()
}
func (m *BinaryQuantization) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryQuantization.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryQuantization proto.InternalMessageInfo

func (m *BinaryQuantization) GetAlwaysRam() bool {
	if m != nil {
		return m.AlwaysRam
	}
	return false
}

type QuantizationConfig struct {
	// Types that are valid to be assigned to Quantization:
	//
	//	*QuantizationConfig_Scalar
	//	*QuantizationConfig_Product
	//	*QuantizationConfig_Binary
	Quantization isQuantizationConfig_Quantization `protobuf_oneof:"quantization"`
}

func (m *QuantizationConfig) Reset()      { *m = QuantizationConfig{} }
func (*QuantizationConfig) ProtoMessage() {}
func (*QuantizationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{25}
}
func (m *QuantizationConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuantizationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuantizationConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuantizationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuantizationConfig.Merge(m, src)
}
func (m *QuantizationConfig) XXX_Size() int {
	return m.Size()
}
func (m *QuantizationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_QuantizationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_QuantizationConfig proto.InternalMessageInfo

type isQuantizationConfig_Quantization interface {
	isQuantizationConfig_Quantization()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QuantizationConfig_Scalar struct {
	Scalar *ScalarQuantization `protobuf:"bytes,1,opt,name=scalar,proto3,oneof" json:"scalar,omitempty"`
}
type QuantizationConfig_Product struct {
	Product *ProductQuantization `protobuf:"bytes,2,opt,name=product,proto3,oneof" json:"product,omitempty"`
}
type QuantizationConfig_Binary struct {
	Binary *BinaryQuantization `protobuf:"bytes,3,opt,name=binary,proto3,oneof" json:"binary,omitempty"`
}

func (*QuantizationConfig_Scalar) isQuantizationConfig_Quantization()  {}
func (*QuantizationConfig_Product) isQuantizationConfig_Quantization() {}
func (*QuantizationConfig_Binary) isQuantizationConfig_Quantization()  {}

func (m *QuantizationConfig) GetQuantization() isQuantizationConfig_Quantization {
	if m != nil {
		return m.Quantization
	}
	return nil
}

func (m *QuantizationConfig) GetScalar() *ScalarQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfig_Scalar); ok {
		return x.Scalar
	}
	return nil
}

func (m *QuantizationConfig) GetProduct() *ProductQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfig_Product); ok {
		return x.Product
	}
	return nil
}

func (m *QuantizationConfig) GetBinary() *BinaryQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfig_Binary); ok {
		return x.Binary
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QuantizationConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QuantizationConfig_Scalar)(nil),
		(*QuantizationConfig_Product)(nil),
		(*QuantizationConfig_Binary)(nil),
	}
}

type Disabled struct {
}

func (m *Disabled) Reset()      { *m = Disabled{} }
func (*Disabled) ProtoMessage() {}
func (*Disabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{26}
}
func (m *Disabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Disabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Disabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Disabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disabled.Merge(m, src)
}
func (m *Disabled) XXX_Size() int {
	return m.Size()
}
func (m *Disabled) XXX_DiscardUnknown() {
	xxx_messageInfo_Disabled.DiscardUnknown(m)
}

var xxx_messageInfo_Disabled proto.InternalMessageInfo

type QuantizationConfigDiff struct {
	// Types that are valid to be assigned to Quantization:
	//
	//	*QuantizationConfigDiff_Scalar
	//	*QuantizationConfigDiff_Product
	//	*QuantizationConfigDiff_Disabled
	//	*QuantizationConfigDiff_Binary
	Quantization isQuantizationConfigDiff_Quantization `protobuf_oneof:"quantization"`
}

func (m *QuantizationConfigDiff) Reset()      { *m = QuantizationConfigDiff{} }
func (*QuantizationConfigDiff) ProtoMessage() {}
func (*QuantizationConfigDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{27}
}
func (m *QuantizationConfigDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuantizationConfigDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuantizationConfigDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuantizationConfigDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuantizationConfigDiff.Merge(m, src)
}
func (m *QuantizationConfigDiff) XXX_Size() int {
	return m.Size()
}
func (m *QuantizationConfigDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_QuantizationConfigDiff.DiscardUnknown(m)
}

var xxx_messageInfo_QuantizationConfigDiff proto.InternalMessageInfo

type isQuantizationConfigDiff_Quantization interface {
	isQuantizationConfigDiff_Quantization()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QuantizationConfigDiff_Scalar struct {
	Scalar *ScalarQuantization `protobuf:"bytes,1,opt,name=scalar,proto3,oneof" json:"scalar,omitempty"`
}
type QuantizationConfigDiff_Product struct {
	Product *ProductQuantization `protobuf:"bytes,2,opt,name=product,proto3,oneof" json:"product,omitempty"`
}
type QuantizationConfigDiff_Disabled struct {
	Disabled *Disabled `protobuf:"bytes,3,opt,name=disabled,proto3,oneof" json:"disabled,omitempty"`
}
type QuantizationConfigDiff_Binary struct {
	Binary *BinaryQuantization `protobuf:"bytes,4,opt,name=binary,proto3,oneof" json:"binary,omitempty"`
}

func (*QuantizationConfigDiff_Scalar) isQuantizationConfigDiff_Quantization()   {}
func (*QuantizationConfigDiff_Product) isQuantizationConfigDiff_Quantization()  {}
func (*QuantizationConfigDiff_Disabled) isQuantizationConfigDiff_Quantization() {}
func (*QuantizationConfigDiff_Binary) isQuantizationConfigDiff_Quantization()   {}

func (m *QuantizationConfigDiff) GetQuantization() isQuantizationConfigDiff_Quantization {
	if m != nil {
		return m.Quantization
	}
	return nil
}

func (m *QuantizationConfigDiff) GetScalar() *ScalarQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfigDiff_Scalar); ok {
		return x.Scalar
	}
	return nil
}

func (m *QuantizationConfigDiff) GetProduct() *ProductQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfigDiff_Product); ok {
		return x.Product
	}
	return nil
}

func (m *QuantizationConfigDiff) GetDisabled() *Disabled {
	if x, ok := m.GetQuantization().(*QuantizationConfigDiff_Disabled); ok {
		return x.Disabled
	}
	return nil
}

func (m *QuantizationConfigDiff) GetBinary() *BinaryQuantization {
	if x, ok := m.GetQuantization().(*QuantizationConfigDiff_Binary); ok {
		return x.Binary
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QuantizationConfigDiff) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QuantizationConfigDiff_Scalar)(nil),
		(*QuantizationConfigDiff_Product)(nil),
		(*QuantizationConfigDiff_Disabled)(nil),
		(*QuantizationConfigDiff_Binary)(nil),
	}
}

type CreateCollection struct {
	CollectionName         string                `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	HnswConfig             *HnswConfigDiff       `protobuf:"bytes,4,opt,name=hnsw_config,json=hnswConfig,proto3" json:"hnsw_config,omitempty"`
	WalConfig              *WalConfigDiff        `protobuf:"bytes,5,opt,name=wal_config,json=walConfig,proto3" json:"wal_config,omitempty"`
	OptimizersConfig       *OptimizersConfigDiff `protobuf:"bytes,6,opt,name=optimizers_config,json=optimizersConfig,proto3" json:"optimizers_config,omitempty"`
	ShardNumber            uint32                `protobuf:"varint,7,opt,name=shard_number,json=shardNumber,proto3" json:"shard_number,omitempty"`
	OnDiskPayload          bool                  `protobuf:"varint,8,opt,name=on_disk_payload,json=onDiskPayload,proto3" json:"on_disk_payload,omitempty"`
	Timeout                uint64                `protobuf:"varint,9,opt,name=timeout,proto3" json:"timeout,omitempty"`
	VectorsConfig          *VectorsConfig        `protobuf:"bytes,10,opt,name=vectors_config,json=vectorsConfig,proto3" json:"vectors_config,omitempty"`
	ReplicationFactor      uint32                `protobuf:"varint,11,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	WriteConsistencyFactor uint32                `protobuf:"varint,12,opt,name=write_consistency_factor,json=writeConsistencyFactor,proto3" json:"write_consistency_factor,omitempty"`
	InitFromCollection     string                `protobuf:"bytes,13,opt,name=init_from_collection,json=initFromCollection,proto3" json:"init_from_collection,omitempty"`
	QuantizationConfig     *QuantizationConfig   `protobuf:"bytes,14,opt,name=quantization_config,json=quantizationConfig,proto3" json:"quantization_config,omitempty"`
	ShardingMethod         ShardingMethod        `protobuf:"varint,15,opt,name=sharding_method,json=shardingMethod,proto3,enum=qdrant.ShardingMethod" json:"sharding_method,omitempty"`
	SparseVectorsConfig    *SparseVectorConfig   `protobuf:"bytes,16,opt,name=sparse_vectors_config,json=sparseVectorsConfig,proto3" json:"sparse_vectors_config,omitempty"`
}

func (m *CreateCollection) Reset()      { *m = CreateCollection{} }
func (*CreateCollection) ProtoMessage() {}
func (*CreateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{28}
}
func (m *CreateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCollection.Merge(m, src)
}
func (m *CreateCollection) XXX_Size() int {
	return m.Size()
}
func (m *CreateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCollection proto.InternalMessageInfo

func (m *CreateCollection) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CreateCollection) GetHnswConfig() *HnswConfigDiff {
	if m != nil {
		return m.HnswConfig
	}
	return nil
}

func (m *CreateCollection) GetWalConfig() *WalConfigDiff {
	if m != nil {
		return m.WalConfig
	}
	return nil
}

func (m *CreateCollection) GetOptimizersConfig() *OptimizersConfigDiff {
	if m != nil {
		return m.OptimizersConfig
	}
	return nil
}

func (m *CreateCollection) GetShardNumber() uint32 {
	if m != nil {
		return m.ShardNumber
	}
	return 0
}

func (m *CreateCollection) GetOnDiskPayload() bool {
	if m != nil {
		return m.OnDiskPayload
	}
	return false
}

func (m *CreateCollection) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *CreateCollection) GetVectorsConfig() *VectorsConfig {
	if m != nil {
		return m.VectorsConfig
	}
	return nil
}

func (m *CreateCollection) GetReplicationFactor() uint32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CreateCollection) GetWriteConsistencyFactor() uint32 {
	if m != nil {
		return m.WriteConsistencyFactor
	}
	return 0
}

func (m *CreateCollection) GetInitFromCollection() string {
	if m != nil {
		return m.InitFromCollection
	}
	return ""
}

func (m *CreateCollection) GetQuantizationConfig() *QuantizationConfig {
	if m != nil {
		return m.QuantizationConfig
	}
	return nil
}

func (m *CreateCollection) GetShardingMethod() ShardingMethod {
	if m != nil {
		return m.ShardingMethod
	}
	return Auto
}

func (m *CreateCollection) GetSparseVectorsConfig() *SparseVectorConfig {
	if m != nil {
		return m.SparseVectorsConfig
	}
	return nil
}

type UpdateCollection struct {
	CollectionName      string                  `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	OptimizersConfig    *OptimizersConfigDiff   `protobuf:"bytes,2,opt,name=optimizers_config,json=optimizersConfig,proto3" json:"optimizers_config,omitempty"`
	Timeout             uint64                  `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Params              *CollectionParamsDiff   `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	HnswConfig          *HnswConfigDiff         `protobuf:"bytes,5,opt,name=hnsw_config,json=hnswConfig,proto3" json:"hnsw_config,omitempty"`
	VectorsConfig       *VectorsConfigDiff      `protobuf:"bytes,6,opt,name=vectors_config,json=vectorsConfig,proto3" json:"vectors_config,omitempty"`
	QuantizationConfig  *QuantizationConfigDiff `protobuf:"bytes,7,opt,name=quantization_config,json=quantizationConfig,proto3" json:"quantization_config,omitempty"`
	SparseVectorsConfig *SparseVectorConfig     `protobuf:"bytes,8,opt,name=sparse_vectors_config,json=sparseVectorsConfig,proto3" json:"sparse_vectors_config,omitempty"`
}

func (m *UpdateCollection) Reset()      { *m = UpdateCollection{} }
func (*UpdateCollection) ProtoMessage() {}
func (*UpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{29}
}
func (m *UpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCollection.Merge(m, src)
}
func (m *UpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCollection proto.InternalMessageInfo

func (m *UpdateCollection) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *UpdateCollection) GetOptimizersConfig() *OptimizersConfigDiff {
	if m != nil {
		return m.OptimizersConfig
	}
	return nil
}

func (m *UpdateCollection) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *UpdateCollection) GetParams() *CollectionParamsDiff {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *UpdateCollection) GetHnswConfig() *HnswConfigDiff {
	if m != nil {
		return m.HnswConfig
	}
	return nil
}

func (m *UpdateCollection) GetVectorsConfig() *VectorsConfigDiff {
	if m != nil {
		return m.VectorsConfig
	}
	return nil
}

func (m *UpdateCollection) GetQuantizationConfig() *QuantizationConfigDiff {
	if m != nil {
		return m.QuantizationConfig
	}
	return nil
}

func (m *UpdateCollection) GetSparseVectorsConfig() *SparseVectorConfig {
	if m != nil {
		return m.SparseVectorsConfig
	}
	return nil
}

type DeleteCollection struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Timeout        uint64 `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *DeleteCollection) Reset()      { *m = DeleteCollection{} }
func (*DeleteCollection) ProtoMessage() {}
func (*DeleteCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{30}
}
func (m *DeleteCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCollection.Merge(m, src)
}
func (m *DeleteCollection) XXX_Size() int {
	return m.Size()
}
func (m *DeleteCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCollection.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCollection proto.InternalMessageInfo

func (m *DeleteCollection) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeleteCollection) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type CollectionOperationResponse struct {
	Result bool    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64 `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *CollectionOperationResponse) Reset()      { *m = CollectionOperationResponse{} }
func (*CollectionOperationResponse) ProtoMessage() {}
func (*CollectionOperationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{31}
}
func (m *CollectionOperationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionOperationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionOperationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionOperationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionOperationResponse.Merge(m, src)
}
func (m *CollectionOperationResponse) XXX_Size() int {
	return m.Size()
}
func (m *CollectionOperationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionOperationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionOperationResponse proto.InternalMessageInfo

func (m *CollectionOperationResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *CollectionOperationResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type CollectionParams struct {
	ShardNumber            uint32              `protobuf:"varint,3,opt,name=shard_number,json=shardNumber,proto3" json:"shard_number,omitempty"`
	OnDiskPayload          bool                `protobuf:"varint,4,opt,name=on_disk_payload,json=onDiskPayload,proto3" json:"on_disk_payload,omitempty"`
	VectorsConfig          *VectorsConfig      `protobuf:"bytes,5,opt,name=vectors_config,json=vectorsConfig,proto3" json:"vectors_config,omitempty"`
	ReplicationFactor      uint32              `protobuf:"varint,6,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	WriteConsistencyFactor uint32              `protobuf:"varint,7,opt,name=write_consistency_factor,json=writeConsistencyFactor,proto3" json:"write_consistency_factor,omitempty"`
	ReadFanOutFactor       uint32              `protobuf:"varint,8,opt,name=read_fan_out_factor,json=readFanOutFactor,proto3" json:"read_fan_out_factor,omitempty"`
	ShardingMethod         ShardingMethod      `protobuf:"varint,9,opt,name=sharding_method,json=shardingMethod,proto3,enum=qdrant.ShardingMethod" json:"sharding_method,omitempty"`
	SparseVectorsConfig    *SparseVectorConfig `protobuf:"bytes,10,opt,name=sparse_vectors_config,json=sparseVectorsConfig,proto3" json:"sparse_vectors_config,omitempty"`
}

func (m *CollectionParams) Reset()      { *m = CollectionParams{} }
func (*CollectionParams) ProtoMessage() {}
func (*CollectionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{32}
}
func (m *CollectionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionParams.Merge(m, src)
}
func (m *CollectionParams) XXX_Size() int {
	return m.Size()
}
func (m *CollectionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionParams proto.InternalMessageInfo

func (m *CollectionParams) GetShardNumber() uint32 {
	if m != nil {
		return m.ShardNumber
	}
	return 0
}

func (m *CollectionParams) GetOnDiskPayload() bool {
	if m != nil {
		return m.OnDiskPayload
	}
	return false
}

func (m *CollectionParams) GetVectorsConfig() *VectorsConfig {
	if m != nil {
		return m.VectorsConfig
	}
	return nil
}

func (m *CollectionParams) GetReplicationFactor() uint32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CollectionParams) GetWriteConsistencyFactor() uint32 {
	if m != nil {
		return m.WriteConsistencyFactor
	}
	return 0
}

func (m *CollectionParams) GetReadFanOutFactor() uint32 {
	if m != nil {
		return m.ReadFanOutFactor
	}
	return 0
}

func (m *CollectionParams) GetShardingMethod() ShardingMethod {
	if m != nil {
		return m.ShardingMethod
	}
	return Auto
}

func (m *CollectionParams) GetSparseVectorsConfig() *SparseVectorConfig {
	if m != nil {
		return m.SparseVectorsConfig
	}
	return nil
}

type CollectionParamsDiff struct {
	ReplicationFactor      uint32 `protobuf:"varint,1,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	WriteConsistencyFactor uint32 `protobuf:"varint,2,opt,name=write_consistency_factor,json=writeConsistencyFactor,proto3" json:"write_consistency_factor,omitempty"`
	OnDiskPayload          bool   `protobuf:"varint,3,opt,name=on_disk_payload,json=onDiskPayload,proto3" json:"on_disk_payload,omitempty"`
	ReadFanOutFactor       uint32 `protobuf:"varint,4,opt,name=read_fan_out_factor,json=readFanOutFactor,proto3" json:"read_fan_out_factor,omitempty"`
}

func (m *CollectionParamsDiff) Reset()      { *m = CollectionParamsDiff{} }
func (*CollectionParamsDiff) ProtoMessage() {}
func (*CollectionParamsDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{33}
}
func (m *CollectionParamsDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionParamsDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionParamsDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionParamsDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionParamsDiff.Merge(m, src)
}
func (m *CollectionParamsDiff) XXX_Size() int {
	return m.Size()
}
func (m *CollectionParamsDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionParamsDiff.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionParamsDiff proto.InternalMessageInfo

func (m *CollectionParamsDiff) GetReplicationFactor() uint32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CollectionParamsDiff) GetWriteConsistencyFactor() uint32 {
	if m != nil {
		return m.WriteConsistencyFactor
	}
	return 0
}

func (m *CollectionParamsDiff) GetOnDiskPayload() bool {
	if m != nil {
		return m.OnDiskPayload
	}
	return false
}

func (m *CollectionParamsDiff) GetReadFanOutFactor() uint32 {
	if m != nil {
		return m.ReadFanOutFactor
	}
	return 0
}

type CollectionConfig struct {
	Params             *CollectionParams     `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
	HnswConfig         *HnswConfigDiff       `protobuf:"bytes,2,opt,name=hnsw_config,json=hnswConfig,proto3" json:"hnsw_config,omitempty"`
	OptimizerConfig    *OptimizersConfigDiff `protobuf:"bytes,3,opt,name=optimizer_config,json=optimizerConfig,proto3" json:"optimizer_config,omitempty"`
	WalConfig          *WalConfigDiff        `protobuf:"bytes,4,opt,name=wal_config,json=walConfig,proto3" json:"wal_config,omitempty"`
	QuantizationConfig *QuantizationConfig   `protobuf:"bytes,5,opt,name=quantization_config,json=quantizationConfig,proto3" json:"quantization_config,omitempty"`
}

func (m *CollectionConfig) Reset()      { *m = CollectionConfig{} }
func (*CollectionConfig) ProtoMessage() {}
func (*CollectionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{34}
}
func (m *CollectionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionConfig.Merge(m, src)
}
func (m *CollectionConfig) XXX_Size() int {
	return m.Size()
}
func (m *CollectionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionConfig proto.InternalMessageInfo

func (m *CollectionConfig) GetParams() *CollectionParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *CollectionConfig) GetHnswConfig() *HnswConfigDiff {
	if m != nil {
		return m.HnswConfig
	}
	return nil
}

func (m *CollectionConfig) GetOptimizerConfig() *OptimizersConfigDiff {
	if m != nil {
		return m.OptimizerConfig
	}
	return nil
}

func (m *CollectionConfig) GetWalConfig() *WalConfigDiff {
	if m != nil {
		return m.WalConfig
	}
	return nil
}

func (m *CollectionConfig) GetQuantizationConfig() *QuantizationConfig {
	if m != nil {
		return m.QuantizationConfig
	}
	return nil
}

type TextIndexParams struct {
	Tokenizer   TokenizerType `protobuf:"varint,1,opt,name=tokenizer,proto3,enum=qdrant.TokenizerType" json:"tokenizer,omitempty"`
	Lowercase   bool          `protobuf:"varint,2,opt,name=lowercase,proto3" json:"lowercase,omitempty"`
	MinTokenLen uint64        `protobuf:"varint,3,opt,name=min_token_len,json=minTokenLen,proto3" json:"min_token_len,omitempty"`
	MaxTokenLen uint64        `protobuf:"varint,4,opt,name=max_token_len,json=maxTokenLen,proto3" json:"max_token_len,omitempty"`
}

func (m *TextIndexParams) Reset()      { *m = TextIndexParams{} }
func (*TextIndexParams) ProtoMessage() {}
func (*TextIndexParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{35}
}
func (m *TextIndexParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextIndexParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextIndexParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextIndexParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextIndexParams.Merge(m, src)
}
func (m *TextIndexParams) XXX_Size() int {
	return m.Size()
}
func (m *TextIndexParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TextIndexParams.DiscardUnknown(m)
}

var xxx_messageInfo_TextIndexParams proto.InternalMessageInfo

func (m *TextIndexParams) GetTokenizer() TokenizerType {
	if m != nil {
		return m.Tokenizer
	}
	return Unknown
}

func (m *TextIndexParams) GetLowercase() bool {
	if m != nil {
		return m.Lowercase
	}
	return false
}

func (m *TextIndexParams) GetMinTokenLen() uint64 {
	if m != nil {
		return m.MinTokenLen
	}
	return 0
}

func (m *TextIndexParams) GetMaxTokenLen() uint64 {
	if m != nil {
		return m.MaxTokenLen
	}
	return 0
}

type IntegerIndexParams struct {
	Lookup bool `protobuf:"varint,1,opt,name=lookup,proto3" json:"lookup,omitempty"`
	Range  bool `protobuf:"varint,2,opt,name=range,proto3" json:"range,omitempty"`
}

func (m *IntegerIndexParams) Reset()      { *m = IntegerIndexParams{} }
func (*IntegerIndexParams) ProtoMessage() {}
func (*IntegerIndexParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{36}
}
func (m *IntegerIndexParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegerIndexParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntegerIndexParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntegerIndexParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegerIndexParams.Merge(m, src)
}
func (m *IntegerIndexParams) XXX_Size() int {
	return m.Size()
}
func (m *IntegerIndexParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegerIndexParams.DiscardUnknown(m)
}

var xxx_messageInfo_IntegerIndexParams proto.InternalMessageInfo

func (m *IntegerIndexParams) GetLookup() bool {
	if m != nil {
		return m.Lookup
	}
	return false
}

func (m *IntegerIndexParams) GetRange() bool {
	if m != nil {
		return m.Range
	}
	return false
}

type PayloadIndexParams struct {
	// Types that are valid to be assigned to IndexParams:
	//
	//	*PayloadIndexParams_TextIndexParams
	//	*PayloadIndexParams_IntegerIndexParams
	IndexParams isPayloadIndexParams_IndexParams `protobuf_oneof:"index_params"`
}

func (m *PayloadIndexParams) Reset()      { *m = PayloadIndexParams{} }
func (*PayloadIndexParams) ProtoMessage() {}
func (*PayloadIndexParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{37}
}
func (m *PayloadIndexParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadIndexParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadIndexParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadIndexParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadIndexParams.Merge(m, src)
}
func (m *PayloadIndexParams) XXX_Size() int {
	return m.Size()
}
func (m *PayloadIndexParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadIndexParams.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadIndexParams proto.InternalMessageInfo

type isPayloadIndexParams_IndexParams interface {
	isPayloadIndexParams_IndexParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PayloadIndexParams_TextIndexParams struct {
	TextIndexParams *TextIndexParams `protobuf:"bytes,1,opt,name=text_index_params,json=textIndexParams,proto3,oneof" json:"text_index_params,omitempty"`
}
type PayloadIndexParams_IntegerIndexParams struct {
	IntegerIndexParams *IntegerIndexParams `protobuf:"bytes,2,opt,name=integer_index_params,json=integerIndexParams,proto3,oneof" json:"integer_index_params,omitempty"`
}

func (*PayloadIndexParams_TextIndexParams) isPayloadIndexParams_IndexParams()    {}
func (*PayloadIndexParams_IntegerIndexParams) isPayloadIndexParams_IndexParams() {}

func (m *PayloadIndexParams) GetIndexParams() isPayloadIndexParams_IndexParams {
	if m != nil {
		return m.IndexParams
	}
	return nil
}

func (m *PayloadIndexParams) GetTextIndexParams() *TextIndexParams {
	if x, ok := m.GetIndexParams().(*PayloadIndexParams_TextIndexParams); ok {
		return x.TextIndexParams
	}
	return nil
}

func (m *PayloadIndexParams) GetIntegerIndexParams() *IntegerIndexParams {
	if x, ok := m.GetIndexParams().(*PayloadIndexParams_IntegerIndexParams); ok {
		return x.IntegerIndexParams
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PayloadIndexParams) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PayloadIndexParams_TextIndexParams)(nil),
		(*PayloadIndexParams_IntegerIndexParams)(nil),
	}
}

type PayloadSchemaInfo struct {
	DataType PayloadSchemaType   `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3,enum=qdrant.PayloadSchemaType" json:"data_type,omitempty"`
	Params   *PayloadIndexParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
	Points   uint64              `protobuf:"varint,3,opt,name=points,proto3" json:"points,omitempty"`
}

func (m *PayloadSchemaInfo) Reset()      { *m = PayloadSchemaInfo{} }
func (*PayloadSchemaInfo) ProtoMessage() {}
func (*PayloadSchemaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{38}
}
func (m *PayloadSchemaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadSchemaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadSchemaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadSchemaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadSchemaInfo.Merge(m, src)
}
func (m *PayloadSchemaInfo) XXX_Size() int {
	return m.Size()
}
func (m *PayloadSchemaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadSchemaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadSchemaInfo proto.InternalMessageInfo

func (m *PayloadSchemaInfo) GetDataType() PayloadSchemaType {
	if m != nil {
		return m.DataType
	}
	return UnknownType
}

func (m *PayloadSchemaInfo) GetParams() *PayloadIndexParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *PayloadSchemaInfo) GetPoints() uint64 {
	if m != nil {
		return m.Points
	}
	return 0
}

type CollectionInfo struct {
	Status              CollectionStatus              `protobuf:"varint,1,opt,name=status,proto3,enum=qdrant.CollectionStatus" json:"status,omitempty"`
	OptimizerStatus     *OptimizerStatus              `protobuf:"bytes,2,opt,name=optimizer_status,json=optimizerStatus,proto3" json:"optimizer_status,omitempty"`
	VectorsCount        uint64                        `protobuf:"varint,3,opt,name=vectors_count,json=vectorsCount,proto3" json:"vectors_count,omitempty"`
	SegmentsCount       uint64                        `protobuf:"varint,4,opt,name=segments_count,json=segmentsCount,proto3" json:"segments_count,omitempty"`
	Config              *CollectionConfig             `protobuf:"bytes,7,opt,name=config,proto3" json:"config,omitempty"`
	PayloadSchema       map[string]*PayloadSchemaInfo `protobuf:"bytes,8,rep,name=payload_schema,json=payloadSchema,proto3" json:"payload_schema,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PointsCount         uint64                        `protobuf:"varint,9,opt,name=points_count,json=pointsCount,proto3" json:"points_count,omitempty"`
	IndexedVectorsCount uint64                        `protobuf:"varint,10,opt,name=indexed_vectors_count,json=indexedVectorsCount,proto3" json:"indexed_vectors_count,omitempty"`
}

func (m *CollectionInfo) Reset()      { *m = CollectionInfo{} }
func (*CollectionInfo) ProtoMessage() {}
func (*CollectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{39}
}
func (m *CollectionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInfo.Merge(m, src)
}
func (m *CollectionInfo) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInfo proto.InternalMessageInfo

func (m *CollectionInfo) GetStatus() CollectionStatus {
	if m != nil {
		return m.Status
	}
	return UnknownCollectionStatus
}

func (m *CollectionInfo) GetOptimizerStatus() *OptimizerStatus {
	if m != nil {
		return m.OptimizerStatus
	}
	return nil
}

func (m *CollectionInfo) GetVectorsCount() uint64 {
	if m != nil {
		return m.VectorsCount
	}
	return 0
}

func (m *CollectionInfo) GetSegmentsCount() uint64 {
	if m != nil {
		return m.SegmentsCount
	}
	return 0
}

func (m *CollectionInfo) GetConfig() *CollectionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *CollectionInfo) GetPayloadSchema() map[string]*PayloadSchemaInfo {
	if m != nil {
		return m.PayloadSchema
	}
	return nil
}

func (m *CollectionInfo) GetPointsCount() uint64 {
	if m != nil {
		return m.PointsCount
	}
	return 0
}

func (m *CollectionInfo) GetIndexedVectorsCount() uint64 {
	if m != nil {
		return m.IndexedVectorsCount
	}
	return 0
}

type ChangeAliases struct {
	Actions []*AliasOperations `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	Timeout uint64             `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *ChangeAliases) Reset()      { *m = ChangeAliases{} }
func (*ChangeAliases) ProtoMessage() {}
func (*ChangeAliases) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{40}
}
func (m *ChangeAliases) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeAliases) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeAliases.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeAliases) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeAliases.Merge(m, src)
}
func (m *ChangeAliases) XXX_Size() int {
	return m.Size()
}
func (m *ChangeAliases) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeAliases.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeAliases proto.InternalMessageInfo

func (m *ChangeAliases) GetActions() []*AliasOperations {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *ChangeAliases) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type AliasOperations struct {
	// Types that are valid to be assigned to Action:
	//
	//	*AliasOperations_CreateAlias
	//	*AliasOperations_RenameAlias
	//	*AliasOperations_DeleteAlias
	Action isAliasOperations_Action `protobuf_oneof:"action"`
}

func (m *AliasOperations) Reset()      { *m = AliasOperations{} }
func (*AliasOperations) ProtoMessage() {}
func (*AliasOperations) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{41}
}
func (m *AliasOperations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasOperations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AliasOperations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AliasOperations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasOperations.Merge(m, src)
}
func (m *AliasOperations) XXX_Size() int {
	return m.Size()
}
func (m *AliasOperations) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasOperations.DiscardUnknown(m)
}

var xxx_messageInfo_AliasOperations proto.InternalMessageInfo

type isAliasOperations_Action interface {
	isAliasOperations_Action()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AliasOperations_CreateAlias struct {
	CreateAlias *CreateAlias `protobuf:"bytes,1,opt,name=create_alias,json=createAlias,proto3,oneof" json:"create_alias,omitempty"`
}
type AliasOperations_RenameAlias struct {
	RenameAlias *RenameAlias `protobuf:"bytes,2,opt,name=rename_alias,json=renameAlias,proto3,oneof" json:"rename_alias,omitempty"`
}
type AliasOperations_DeleteAlias struct {
	DeleteAlias *DeleteAlias `protobuf:"bytes,3,opt,name=delete_alias,json=deleteAlias,proto3,oneof" json:"delete_alias,omitempty"`
}

func (*AliasOperations_CreateAlias) isAliasOperations_Action() {}
func (*AliasOperations_RenameAlias) isAliasOperations_Action() {}
func (*AliasOperations_DeleteAlias) isAliasOperations_Action() {}

func (m *AliasOperations) GetAction() isAliasOperations_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *AliasOperations) GetCreateAlias() *CreateAlias {
	if x, ok := m.GetAction().(*AliasOperations_CreateAlias); ok {
		return x.CreateAlias
	}
	return nil
}

func (m *AliasOperations) GetRenameAlias() *RenameAlias {
	if x, ok := m.GetAction().(*AliasOperations_RenameAlias); ok {
		return x.RenameAlias
	}
	return nil
}

func (m *AliasOperations) GetDeleteAlias() *DeleteAlias {
	if x, ok := m.GetAction().(*AliasOperations_DeleteAlias); ok {
		return x.DeleteAlias
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AliasOperations) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AliasOperations_CreateAlias)(nil),
		(*AliasOperations_RenameAlias)(nil),
		(*AliasOperations_DeleteAlias)(nil),
	}
}

type CreateAlias struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	AliasName      string `protobuf:"bytes,2,opt,name=alias_name,json=aliasName,proto3" json:"alias_name,omitempty"`
}

func (m *CreateAlias) Reset()      { *m = CreateAlias{} }
func (*CreateAlias) ProtoMessage() {}
func (*CreateAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{42}
}
func (m *CreateAlias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAlias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAlias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAlias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAlias.Merge(m, src)
}
func (m *CreateAlias) XXX_Size() int {
	return m.Size()
}
func (m *CreateAlias) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAlias.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAlias proto.InternalMessageInfo

func (m *CreateAlias) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CreateAlias) GetAliasName() string {
	if m != nil {
		return m.AliasName
	}
	return ""
}

type RenameAlias struct {
	OldAliasName string `protobuf:"bytes,1,opt,name=old_alias_name,json=oldAliasName,proto3" json:"old_alias_name,omitempty"`
	NewAliasName string `protobuf:"bytes,2,opt,name=new_alias_name,json=newAliasName,proto3" json:"new_alias_name,omitempty"`
}

func (m *RenameAlias) Reset()      { *m = RenameAlias{} }
func (*RenameAlias) ProtoMessage() {}
func (*RenameAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{43}
}
func (m *RenameAlias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenameAlias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenameAlias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenameAlias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameAlias.Merge(m, src)
}
func (m *RenameAlias) XXX_Size() int {
	return m.Size()
}
func (m *RenameAlias) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameAlias.DiscardUnknown(m)
}

var xxx_messageInfo_RenameAlias proto.InternalMessageInfo

func (m *RenameAlias) GetOldAliasName() string {
	if m != nil {
		return m.OldAliasName
	}
	return ""
}

func (m *RenameAlias) GetNewAliasName() string {
	if m != nil {
		return m.NewAliasName
	}
	return ""
}

type DeleteAlias struct {
	AliasName string `protobuf:"bytes,1,opt,name=alias_name,json=aliasName,proto3" json:"alias_name,omitempty"`
}

func (m *DeleteAlias) Reset()      { *m = DeleteAlias{} }
func (*DeleteAlias) ProtoMessage() {}
func (*DeleteAlias) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{44}
}
func (m *DeleteAlias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAlias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAlias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAlias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAlias.Merge(m, src)
}
func (m *DeleteAlias) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAlias) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAlias.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAlias proto.InternalMessageInfo

func (m *DeleteAlias) GetAliasName() string {
	if m != nil {
		return m.AliasName
	}
	return ""
}

type ListAliasesRequest struct {
}

func (m *ListAliasesRequest) Reset()      { *m = ListAliasesRequest{} }
func (*ListAliasesRequest) ProtoMessage() {}
func (*ListAliasesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{45}
}
func (m *ListAliasesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAliasesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAliasesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAliasesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAliasesRequest.Merge(m, src)
}
func (m *ListAliasesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAliasesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAliasesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAliasesRequest proto.InternalMessageInfo

type ListCollectionAliasesRequest struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
}

func (m *ListCollectionAliasesRequest) Reset()      { *m = ListCollectionAliasesRequest{} }
func (*ListCollectionAliasesRequest) ProtoMessage() {}
func (*ListCollectionAliasesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{46}
}
func (m *ListCollectionAliasesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCollectionAliasesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCollectionAliasesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCollectionAliasesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCollectionAliasesRequest.Merge(m, src)
}
func (m *ListCollectionAliasesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCollectionAliasesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCollectionAliasesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCollectionAliasesRequest proto.InternalMessageInfo

func (m *ListCollectionAliasesRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

type AliasDescription struct {
	AliasName      string `protobuf:"bytes,1,opt,name=alias_name,json=aliasName,proto3" json:"alias_name,omitempty"`
	CollectionName string `protobuf:"bytes,2,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
}

func (m *AliasDescription) Reset()      { *m = AliasDescription{} }
func (*AliasDescription) ProtoMessage() {}
func (*AliasDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{47}
}
func (m *AliasDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AliasDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AliasDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasDescription.Merge(m, src)
}
func (m *AliasDescription) XXX_Size() int {
	return m.Size()
}
func (m *AliasDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasDescription.DiscardUnknown(m)
}

var xxx_messageInfo_AliasDescription proto.InternalMessageInfo

func (m *AliasDescription) GetAliasName() string {
	if m != nil {
		return m.AliasName
	}
	return ""
}

func (m *AliasDescription) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

type ListAliasesResponse struct {
	Aliases []*AliasDescription `protobuf:"bytes,1,rep,name=aliases,proto3" json:"aliases,omitempty"`
	Time    float64             `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *ListAliasesResponse) Reset()      { *m = ListAliasesResponse{} }
func (*ListAliasesResponse) ProtoMessage() {}
func (*ListAliasesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{48}
}
func (m *ListAliasesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAliasesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAliasesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAliasesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAliasesResponse.Merge(m, src)
}
func (m *ListAliasesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAliasesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAliasesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAliasesResponse proto.InternalMessageInfo

func (m *ListAliasesResponse) GetAliases() []*AliasDescription {
	if m != nil {
		return m.Aliases
	}
	return nil
}

func (m *ListAliasesResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type CollectionClusterInfoRequest struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
}

func (m *CollectionClusterInfoRequest) Reset()      { *m = CollectionClusterInfoRequest{} }
func (*CollectionClusterInfoRequest) ProtoMessage() {}
func (*CollectionClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{49}
}
func (m *CollectionClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionClusterInfoRequest.Merge(m, src)
}
func (m *CollectionClusterInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CollectionClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionClusterInfoRequest proto.InternalMessageInfo

func (m *CollectionClusterInfoRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

type ShardKey struct {
	// Types that are valid to be assigned to Key:
	//
	//	*ShardKey_Keyword
	//	*ShardKey_Number
	Key isShardKey_Key `protobuf_oneof:"key"`
}

func (m *ShardKey) Reset()      { *m = ShardKey{} }
func (*ShardKey) ProtoMessage() {}
func (*ShardKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{50}
}
func (m *ShardKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardKey.Merge(m, src)
}
func (m *ShardKey) XXX_Size() int {
	return m.Size()
}
func (m *ShardKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardKey.DiscardUnknown(m)
}

var xxx_messageInfo_ShardKey proto.InternalMessageInfo

type isShardKey_Key interface {
	isShardKey_Key()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ShardKey_Keyword struct {
	Keyword string `protobuf:"bytes,1,opt,name=keyword,proto3,oneof" json:"keyword,omitempty"`
}
type ShardKey_Number struct {
	Number uint64 `protobuf:"varint,2,opt,name=number,proto3,oneof" json:"number,omitempty"`
}

func (*ShardKey_Keyword) isShardKey_Key() {}
func (*ShardKey_Number) isShardKey_Key()  {}

func (m *ShardKey) GetKey() isShardKey_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ShardKey) GetKeyword() string {
	if x, ok := m.GetKey().(*ShardKey_Keyword); ok {
		return x.Keyword
	}
	return ""
}

func (m *ShardKey) GetNumber() uint64 {
	if x, ok := m.GetKey().(*ShardKey_Number); ok {
		return x.Number
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ShardKey) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ShardKey_Keyword)(nil),
		(*ShardKey_Number)(nil),
	}
}

type LocalShardInfo struct {
	ShardId     uint32       `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	PointsCount uint64       `protobuf:"varint,2,opt,name=points_count,json=pointsCount,proto3" json:"points_count,omitempty"`
	State       ReplicaState `protobuf:"varint,3,opt,name=state,proto3,enum=qdrant.ReplicaState" json:"state,omitempty"`
	ShardKey    *ShardKey    `protobuf:"bytes,4,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
}

func (m *LocalShardInfo) Reset()      { *m = LocalShardInfo{} }
func (*LocalShardInfo) ProtoMessage() {}
func (*LocalShardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{51}
}
func (m *LocalShardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalShardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalShardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalShardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalShardInfo.Merge(m, src)
}
func (m *LocalShardInfo) XXX_Size() int {
	return m.Size()
}
func (m *LocalShardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalShardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LocalShardInfo proto.InternalMessageInfo

func (m *LocalShardInfo) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *LocalShardInfo) GetPointsCount() uint64 {
	if m != nil {
		return m.PointsCount
	}
	return 0
}

func (m *LocalShardInfo) GetState() ReplicaState {
	if m != nil {
		return m.State
	}
	return Active
}

func (m *LocalShardInfo) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

type RemoteShardInfo struct {
	ShardId  uint32       `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	PeerId   uint64       `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	State    ReplicaState `protobuf:"varint,3,opt,name=state,proto3,enum=qdrant.ReplicaState" json:"state,omitempty"`
	ShardKey *ShardKey    `protobuf:"bytes,4,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
}

func (m *RemoteShardInfo) Reset()      { *m = RemoteShardInfo{} }
func (*RemoteShardInfo) ProtoMessage() {}
func (*RemoteShardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{52}
}
func (m *RemoteShardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteShardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteShardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteShardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteShardInfo.Merge(m, src)
}
func (m *RemoteShardInfo) XXX_Size() int {
	return m.Size()
}
func (m *RemoteShardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteShardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteShardInfo proto.InternalMessageInfo

func (m *RemoteShardInfo) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *RemoteShardInfo) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *RemoteShardInfo) GetState() ReplicaState {
	if m != nil {
		return m.State
	}
	return Active
}

func (m *RemoteShardInfo) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

type ShardTransferInfo struct {
	ShardId   uint32 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	ToShardId uint32 `protobuf:"varint,5,opt,name=to_shard_id,json=toShardId,proto3" json:"to_shard_id,omitempty"`
	From      uint64 `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To        uint64 `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Sync      bool   `protobuf:"varint,4,opt,name=sync,proto3" json:"sync,omitempty"`
}

func (m *ShardTransferInfo) Reset()      { *m = ShardTransferInfo{} }
func (*ShardTransferInfo) ProtoMessage() {}
func (*ShardTransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{53}
}
func (m *ShardTransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardTransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardTransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardTransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardTransferInfo.Merge(m, src)
}
func (m *ShardTransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShardTransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardTransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardTransferInfo proto.InternalMessageInfo

func (m *ShardTransferInfo) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *ShardTransferInfo) GetToShardId() uint32 {
	if m != nil {
		return m.ToShardId
	}
	return 0
}

func (m *ShardTransferInfo) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ShardTransferInfo) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ShardTransferInfo) GetSync() bool {
	if m != nil {
		return m.Sync
	}
	return false
}

type CollectionClusterInfoResponse struct {
	PeerId         uint64               `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	ShardCount     uint64               `protobuf:"varint,2,opt,name=shard_count,json=shardCount,proto3" json:"shard_count,omitempty"`
	LocalShards    []*LocalShardInfo    `protobuf:"bytes,3,rep,name=local_shards,json=localShards,proto3" json:"local_shards,omitempty"`
	RemoteShards   []*RemoteShardInfo   `protobuf:"bytes,4,rep,name=remote_shards,json=remoteShards,proto3" json:"remote_shards,omitempty"`
	ShardTransfers []*ShardTransferInfo `protobuf:"bytes,5,rep,name=shard_transfers,json=shardTransfers,proto3" json:"shard_transfers,omitempty"`
}

func (m *CollectionClusterInfoResponse) Reset()      { *m = CollectionClusterInfoResponse{} }
func (*CollectionClusterInfoResponse) ProtoMessage() {}
func (*CollectionClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{54}
}
func (m *CollectionClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionClusterInfoResponse.Merge(m, src)
}
func (m *CollectionClusterInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CollectionClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionClusterInfoResponse proto.InternalMessageInfo

func (m *CollectionClusterInfoResponse) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *CollectionClusterInfoResponse) GetShardCount() uint64 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *CollectionClusterInfoResponse) GetLocalShards() []*LocalShardInfo {
	if m != nil {
		return m.LocalShards
	}
	return nil
}

func (m *CollectionClusterInfoResponse) GetRemoteShards() []*RemoteShardInfo {
	if m != nil {
		return m.RemoteShards
	}
	return nil
}

func (m *CollectionClusterInfoResponse) GetShardTransfers() []*ShardTransferInfo {
	if m != nil {
		return m.ShardTransfers
	}
	return nil
}

type MoveShard struct {
	ShardId    uint32              `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	ToShardId  uint32              `protobuf:"varint,5,opt,name=to_shard_id,json=toShardId,proto3" json:"to_shard_id,omitempty"`
	FromPeerId uint64              `protobuf:"varint,2,opt,name=from_peer_id,json=fromPeerId,proto3" json:"from_peer_id,omitempty"`
	ToPeerId   uint64              `protobuf:"varint,3,opt,name=to_peer_id,json=toPeerId,proto3" json:"to_peer_id,omitempty"`
	Method     ShardTransferMethod `protobuf:"varint,4,opt,name=method,proto3,enum=qdrant.ShardTransferMethod" json:"method,omitempty"`
}

func (m *MoveShard) Reset()      { *m = MoveShard{} }
func (*MoveShard) ProtoMessage() {}
func (*MoveShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{55}
}
func (m *MoveShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveShard.Merge(m, src)
}
func (m *MoveShard) XXX_Size() int {
	return m.Size()
}
func (m *MoveShard) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveShard.DiscardUnknown(m)
}

var xxx_messageInfo_MoveShard proto.InternalMessageInfo

func (m *MoveShard) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *MoveShard) GetToShardId() uint32 {
	if m != nil {
		return m.ToShardId
	}
	return 0
}

func (m *MoveShard) GetFromPeerId() uint64 {
	if m != nil {
		return m.FromPeerId
	}
	return 0
}

func (m *MoveShard) GetToPeerId() uint64 {
	if m != nil {
		return m.ToPeerId
	}
	return 0
}

func (m *MoveShard) GetMethod() ShardTransferMethod {
	if m != nil {
		return m.Method
	}
	return StreamRecords
}

type ReplicateShard struct {
	ShardId    uint32              `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	ToShardId  uint32              `protobuf:"varint,5,opt,name=to_shard_id,json=toShardId,proto3" json:"to_shard_id,omitempty"`
	FromPeerId uint64              `protobuf:"varint,2,opt,name=from_peer_id,json=fromPeerId,proto3" json:"from_peer_id,omitempty"`
	ToPeerId   uint64              `protobuf:"varint,3,opt,name=to_peer_id,json=toPeerId,proto3" json:"to_peer_id,omitempty"`
	Method     ShardTransferMethod `protobuf:"varint,4,opt,name=method,proto3,enum=qdrant.ShardTransferMethod" json:"method,omitempty"`
}

func (m *ReplicateShard) Reset()      { *m = ReplicateShard{} }
func (*ReplicateShard) ProtoMessage() {}
func (*ReplicateShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{56}
}
func (m *ReplicateShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicateShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicateShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicateShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicateShard.Merge(m, src)
}
func (m *ReplicateShard) XXX_Size() int {
	return m.Size()
}
func (m *ReplicateShard) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicateShard.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicateShard proto.InternalMessageInfo

func (m *ReplicateShard) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *ReplicateShard) GetToShardId() uint32 {
	if m != nil {
		return m.ToShardId
	}
	return 0
}

func (m *ReplicateShard) GetFromPeerId() uint64 {
	if m != nil {
		return m.FromPeerId
	}
	return 0
}

func (m *ReplicateShard) GetToPeerId() uint64 {
	if m != nil {
		return m.ToPeerId
	}
	return 0
}

func (m *ReplicateShard) GetMethod() ShardTransferMethod {
	if m != nil {
		return m.Method
	}
	return StreamRecords
}

type AbortShardTransfer struct {
	ShardId    uint32 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	ToShardId  uint32 `protobuf:"varint,4,opt,name=to_shard_id,json=toShardId,proto3" json:"to_shard_id,omitempty"`
	FromPeerId uint64 `protobuf:"varint,2,opt,name=from_peer_id,json=fromPeerId,proto3" json:"from_peer_id,omitempty"`
	ToPeerId   uint64 `protobuf:"varint,3,opt,name=to_peer_id,json=toPeerId,proto3" json:"to_peer_id,omitempty"`
}

func (m *AbortShardTransfer) Reset()      { *m = AbortShardTransfer{} }
func (*AbortShardTransfer) ProtoMessage() {}
func (*AbortShardTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{57}
}
func (m *AbortShardTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AbortShardTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AbortShardTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AbortShardTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AbortShardTransfer.Merge(m, src)
}
func (m *AbortShardTransfer) XXX_Size() int {
	return m.Size()
}
func (m *AbortShardTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_AbortShardTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_AbortShardTransfer proto.InternalMessageInfo

func (m *AbortShardTransfer) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *AbortShardTransfer) GetToShardId() uint32 {
	if m != nil {
		return m.ToShardId
	}
	return 0
}

func (m *AbortShardTransfer) GetFromPeerId() uint64 {
	if m != nil {
		return m.FromPeerId
	}
	return 0
}

func (m *AbortShardTransfer) GetToPeerId() uint64 {
	if m != nil {
		return m.ToPeerId
	}
	return 0
}

type RestartTransfer struct {
	ShardId    uint32              `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	ToShardId  uint32              `protobuf:"varint,5,opt,name=to_shard_id,json=toShardId,proto3" json:"to_shard_id,omitempty"`
	FromPeerId uint64              `protobuf:"varint,2,opt,name=from_peer_id,json=fromPeerId,proto3" json:"from_peer_id,omitempty"`
	ToPeerId   uint64              `protobuf:"varint,3,opt,name=to_peer_id,json=toPeerId,proto3" json:"to_peer_id,omitempty"`
	Method     ShardTransferMethod `protobuf:"varint,4,opt,name=method,proto3,enum=qdrant.ShardTransferMethod" json:"method,omitempty"`
}

func (m *RestartTransfer) Reset()      { *m = RestartTransfer{} }
func (*RestartTransfer) ProtoMessage() {}
func (*RestartTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{58}
}
func (m *RestartTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestartTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestartTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestartTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestartTransfer.Merge(m, src)
}
func (m *RestartTransfer) XXX_Size() int {
	return m.Size()
}
func (m *RestartTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_RestartTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_RestartTransfer proto.InternalMessageInfo

func (m *RestartTransfer) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *RestartTransfer) GetToShardId() uint32 {
	if m != nil {
		return m.ToShardId
	}
	return 0
}

func (m *RestartTransfer) GetFromPeerId() uint64 {
	if m != nil {
		return m.FromPeerId
	}
	return 0
}

func (m *RestartTransfer) GetToPeerId() uint64 {
	if m != nil {
		return m.ToPeerId
	}
	return 0
}

func (m *RestartTransfer) GetMethod() ShardTransferMethod {
	if m != nil {
		return m.Method
	}
	return StreamRecords
}

type Replica struct {
	ShardId uint32 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	PeerId  uint64 `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
}

func (m *Replica) Reset()      { *m = Replica{} }
func (*Replica) ProtoMessage() {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{59}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetShardId() uint32 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *Replica) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

type CreateShardKey struct {
	ShardKey          *ShardKey `protobuf:"bytes,1,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
	ShardsNumber      uint32    `protobuf:"varint,2,opt,name=shards_number,json=shardsNumber,proto3" json:"shards_number,omitempty"`
	ReplicationFactor uint32    `protobuf:"varint,3,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	Placement         []uint64  `protobuf:"varint,4,rep,packed,name=placement,proto3" json:"placement,omitempty"`
}

func (m *CreateShardKey) Reset()      { *m = CreateShardKey{} }
func (*CreateShardKey) ProtoMessage() {}
func (*CreateShardKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{60}
}
func (m *CreateShardKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardKey.Merge(m, src)
}
func (m *CreateShardKey) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardKey.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardKey proto.InternalMessageInfo

func (m *CreateShardKey) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

func (m *CreateShardKey) GetShardsNumber() uint32 {
	if m != nil {
		return m.ShardsNumber
	}
	return 0
}

func (m *CreateShardKey) GetReplicationFactor() uint32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CreateShardKey) GetPlacement() []uint64 {
	if m != nil {
		return m.Placement
	}
	return nil
}

type DeleteShardKey struct {
	ShardKey *ShardKey `protobuf:"bytes,1,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
}

func (m *DeleteShardKey) Reset()      { *m = DeleteShardKey{} }
func (*DeleteShardKey) ProtoMessage() {}
func (*DeleteShardKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{61}
}
func (m *DeleteShardKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardKey.Merge(m, src)
}
func (m *DeleteShardKey) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardKey.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardKey proto.InternalMessageInfo

func (m *DeleteShardKey) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

type UpdateCollectionClusterSetupRequest struct {
	CollectionName string `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	// Types that are valid to be assigned to Operation:
	//
	//	*UpdateCollectionClusterSetupRequest_MoveShard
	//	*UpdateCollectionClusterSetupRequest_ReplicateShard
	//	*UpdateCollectionClusterSetupRequest_AbortTransfer
	//	*UpdateCollectionClusterSetupRequest_DropReplica
	//	*UpdateCollectionClusterSetupRequest_CreateShardKey
	//	*UpdateCollectionClusterSetupRequest_DeleteShardKey
	//	*UpdateCollectionClusterSetupRequest_RestartTransfer
	Operation isUpdateCollectionClusterSetupRequest_Operation `protobuf_oneof:"operation"`
	Timeout   uint64                                          `protobuf:"varint,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *UpdateCollectionClusterSetupRequest) Reset()      { *m = UpdateCollectionClusterSetupRequest{} }
func (*UpdateCollectionClusterSetupRequest) ProtoMessage() {}
func (*UpdateCollectionClusterSetupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{62}
}
func (m *UpdateCollectionClusterSetupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCollectionClusterSetupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCollectionClusterSetupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCollectionClusterSetupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCollectionClusterSetupRequest.Merge(m, src)
}
func (m *UpdateCollectionClusterSetupRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCollectionClusterSetupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCollectionClusterSetupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCollectionClusterSetupRequest proto.InternalMessageInfo

type isUpdateCollectionClusterSetupRequest_Operation interface {
	isUpdateCollectionClusterSetupRequest_Operation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpdateCollectionClusterSetupRequest_MoveShard struct {
	MoveShard *MoveShard `protobuf:"bytes,2,opt,name=move_shard,json=moveShard,proto3,oneof" json:"move_shard,omitempty"`
}
type UpdateCollectionClusterSetupRequest_ReplicateShard struct {
	ReplicateShard *ReplicateShard `protobuf:"bytes,3,opt,name=replicate_shard,json=replicateShard,proto3,oneof" json:"replicate_shard,omitempty"`
}
type UpdateCollectionClusterSetupRequest_AbortTransfer struct {
	AbortTransfer *AbortShardTransfer `protobuf:"bytes,4,opt,name=abort_transfer,json=abortTransfer,proto3,oneof" json:"abort_transfer,omitempty"`
}
type UpdateCollectionClusterSetupRequest_DropReplica struct {
	DropReplica *Replica `protobuf:"bytes,5,opt,name=drop_replica,json=dropReplica,proto3,oneof" json:"drop_replica,omitempty"`
}
type UpdateCollectionClusterSetupRequest_CreateShardKey struct {
	CreateShardKey *CreateShardKey `protobuf:"bytes,7,opt,name=create_shard_key,json=createShardKey,proto3,oneof" json:"create_shard_key,omitempty"`
}
type UpdateCollectionClusterSetupRequest_DeleteShardKey struct {
	DeleteShardKey *DeleteShardKey `protobuf:"bytes,8,opt,name=delete_shard_key,json=deleteShardKey,proto3,oneof" json:"delete_shard_key,omitempty"`
}
type UpdateCollectionClusterSetupRequest_RestartTransfer struct {
	RestartTransfer *RestartTransfer `protobuf:"bytes,9,opt,name=restart_transfer,json=restartTransfer,proto3,oneof" json:"restart_transfer,omitempty"`
}

func (*UpdateCollectionClusterSetupRequest_MoveShard) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_ReplicateShard) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_AbortTransfer) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_DropReplica) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_CreateShardKey) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_DeleteShardKey) isUpdateCollectionClusterSetupRequest_Operation() {
}
func (*UpdateCollectionClusterSetupRequest_RestartTransfer) isUpdateCollectionClusterSetupRequest_Operation() {
}

func (m *UpdateCollectionClusterSetupRequest) GetOperation() isUpdateCollectionClusterSetupRequest_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *UpdateCollectionClusterSetupRequest) GetMoveShard() *MoveShard {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_MoveShard); ok {
		return x.MoveShard
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetReplicateShard() *ReplicateShard {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_ReplicateShard); ok {
		return x.ReplicateShard
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetAbortTransfer() *AbortShardTransfer {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_AbortTransfer); ok {
		return x.AbortTransfer
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetDropReplica() *Replica {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_DropReplica); ok {
		return x.DropReplica
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetCreateShardKey() *CreateShardKey {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_CreateShardKey); ok {
		return x.CreateShardKey
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetDeleteShardKey() *DeleteShardKey {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_DeleteShardKey); ok {
		return x.DeleteShardKey
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetRestartTransfer() *RestartTransfer {
	if x, ok := m.GetOperation().(*UpdateCollectionClusterSetupRequest_RestartTransfer); ok {
		return x.RestartTransfer
	}
	return nil
}

func (m *UpdateCollectionClusterSetupRequest) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UpdateCollectionClusterSetupRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UpdateCollectionClusterSetupRequest_MoveShard)(nil),
		(*UpdateCollectionClusterSetupRequest_ReplicateShard)(nil),
		(*UpdateCollectionClusterSetupRequest_AbortTransfer)(nil),
		(*UpdateCollectionClusterSetupRequest_DropReplica)(nil),
		(*UpdateCollectionClusterSetupRequest_CreateShardKey)(nil),
		(*UpdateCollectionClusterSetupRequest_DeleteShardKey)(nil),
		(*UpdateCollectionClusterSetupRequest_RestartTransfer)(nil),
	}
}

type UpdateCollectionClusterSetupResponse struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *UpdateCollectionClusterSetupResponse) Reset()      { *m = UpdateCollectionClusterSetupResponse{} }
func (*UpdateCollectionClusterSetupResponse) ProtoMessage() {}
func (*UpdateCollectionClusterSetupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{63}
}
func (m *UpdateCollectionClusterSetupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCollectionClusterSetupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCollectionClusterSetupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCollectionClusterSetupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCollectionClusterSetupResponse.Merge(m, src)
}
func (m *UpdateCollectionClusterSetupResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCollectionClusterSetupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCollectionClusterSetupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCollectionClusterSetupResponse proto.InternalMessageInfo

func (m *UpdateCollectionClusterSetupResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type CreateShardKeyRequest struct {
	CollectionName string          `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Request        *CreateShardKey `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	Timeout        uint64          `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *CreateShardKeyRequest) Reset()      { *m = CreateShardKeyRequest{} }
func (*CreateShardKeyRequest) ProtoMessage() {}
func (*CreateShardKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{64}
}
func (m *CreateShardKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardKeyRequest.Merge(m, src)
}
func (m *CreateShardKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardKeyRequest proto.InternalMessageInfo

func (m *CreateShardKeyRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CreateShardKeyRequest) GetRequest() *CreateShardKey {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CreateShardKeyRequest) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type DeleteShardKeyRequest struct {
	CollectionName string          `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Request        *DeleteShardKey `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	Timeout        uint64          `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *DeleteShardKeyRequest) Reset()      { *m = DeleteShardKeyRequest{} }
func (*DeleteShardKeyRequest) ProtoMessage() {}
func (*DeleteShardKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{65}
}
func (m *DeleteShardKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardKeyRequest.Merge(m, src)
}
func (m *DeleteShardKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardKeyRequest proto.InternalMessageInfo

func (m *DeleteShardKeyRequest) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeleteShardKeyRequest) GetRequest() *DeleteShardKey {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DeleteShardKeyRequest) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type CreateShardKeyResponse struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CreateShardKeyResponse) Reset()      { *m = CreateShardKeyResponse{} }
func (*CreateShardKeyResponse) ProtoMessage() {}
func (*CreateShardKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{66}
}
func (m *CreateShardKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardKeyResponse.Merge(m, src)
}
func (m *CreateShardKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardKeyResponse proto.InternalMessageInfo

func (m *CreateShardKeyResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type DeleteShardKeyResponse struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *DeleteShardKeyResponse) Reset()      { *m = DeleteShardKeyResponse{} }
func (*DeleteShardKeyResponse) ProtoMessage() {}
func (*DeleteShardKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67a6b7c8927fc88e, []int{67}
}
func (m *DeleteShardKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardKeyResponse.Merge(m, src)
}
func (m *DeleteShardKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardKeyResponse proto.InternalMessageInfo

func (m *DeleteShardKeyResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func init() {
	proto.RegisterEnum("qdrant.Datatype", Datatype_name, Datatype_value)
	proto.RegisterEnum("qdrant.Modifier", Modifier_name, Modifier_value)
	proto.RegisterEnum("qdrant.MultiVectorComparator", MultiVectorComparator_name, MultiVectorComparator_value)
	proto.RegisterEnum("qdrant.Distance", Distance_name, Distance_value)
	proto.RegisterEnum("qdrant.CollectionStatus", CollectionStatus_name, CollectionStatus_value)
	proto.RegisterEnum("qdrant.PayloadSchemaType", PayloadSchemaType_name, PayloadSchemaType_value)
	proto.RegisterEnum("qdrant.QuantizationType", QuantizationType_name, QuantizationType_value)
	proto.RegisterEnum("qdrant.CompressionRatio", CompressionRatio_name, CompressionRatio_value)
	proto.RegisterEnum("qdrant.ShardingMethod", ShardingMethod_name, ShardingMethod_value)
	proto.RegisterEnum("qdrant.TokenizerType", TokenizerType_name, TokenizerType_value)
	proto.RegisterEnum("qdrant.ReplicaState", ReplicaState_name, ReplicaState_value)
	proto.RegisterEnum("qdrant.ShardTransferMethod", ShardTransferMethod_name, ShardTransferMethod_value)
	proto.RegisterType((*VectorParams)(nil), "qdrant.VectorParams")
	proto.RegisterType((*VectorParamsDiff)(nil), "qdrant.VectorParamsDiff")
	proto.RegisterType((*VectorParamsMap)(nil), "qdrant.VectorParamsMap")
	proto.RegisterMapType((map[string]*VectorParams)(nil), "qdrant.VectorParamsMap.MapEntry")
	proto.RegisterType((*VectorParamsDiffMap)(nil), "qdrant.VectorParamsDiffMap")
	proto.RegisterMapType((map[string]*VectorParamsDiff)(nil), "qdrant.VectorParamsDiffMap.MapEntry")
	proto.RegisterType((*VectorsConfig)(nil), "qdrant.VectorsConfig")
	proto.RegisterType((*VectorsConfigDiff)(nil), "qdrant.VectorsConfigDiff")
	proto.RegisterType((*SparseVectorParams)(nil), "qdrant.SparseVectorParams")
	proto.RegisterType((*SparseVectorConfig)(nil), "qdrant.SparseVectorConfig")
	proto.RegisterMapType((map[string]*SparseVectorParams)(nil), "qdrant.SparseVectorConfig.MapEntry")
	proto.RegisterType((*MultiVectorConfig)(nil), "qdrant.MultiVectorConfig")
	proto.RegisterType((*GetCollectionInfoRequest)(nil), "qdrant.GetCollectionInfoRequest")
	proto.RegisterType((*CollectionExistsRequest)(nil), "qdrant.CollectionExistsRequest")
	proto.RegisterType((*CollectionExists)(nil), "qdrant.CollectionExists")
	proto.RegisterType((*CollectionExistsResponse)(nil), "qdrant.CollectionExistsResponse")
	proto.RegisterType((*ListCollectionsRequest)(nil), "qdrant.ListCollectionsRequest")
	proto.RegisterType((*CollectionDescription)(nil), "qdrant.CollectionDescription")
	proto.RegisterType((*GetCollectionInfoResponse)(nil), "qdrant.GetCollectionInfoResponse")
	proto.RegisterType((*ListCollectionsResponse)(nil), "qdrant.ListCollectionsResponse")
	proto.RegisterType((*OptimizerStatus)(nil), "qdrant.OptimizerStatus")
	proto.RegisterType((*HnswConfigDiff)(nil), "qdrant.HnswConfigDiff")
	proto.RegisterType((*SparseIndexConfig)(nil), "qdrant.SparseIndexConfig")
	proto.RegisterType((*WalConfigDiff)(nil), "qdrant.WalConfigDiff")
	proto.RegisterType((*OptimizersConfigDiff)(nil), "qdrant.OptimizersConfigDiff")
	proto.RegisterType((*ScalarQuantization)(nil), "qdrant.ScalarQuantization")
	proto.RegisterType((*ProductQuantization)(nil), "qdrant.ProductQuantization")
	proto.RegisterType((*BinaryQuantization)(nil), "qdrant.BinaryQuantization")
	proto.RegisterType((*QuantizationConfig)(nil), "qdrant.QuantizationConfig")
	proto.RegisterType((*Disabled)(nil), "qdrant.Disabled")
	proto.RegisterType((*QuantizationConfigDiff)(nil), "qdrant.QuantizationConfigDiff")
	proto.RegisterType((*CreateCollection)(nil), "qdrant.CreateCollection")
	proto.RegisterType((*UpdateCollection)(nil), "qdrant.UpdateCollection")
	proto.RegisterType((*DeleteCollection)(nil), "qdrant.DeleteCollection")
	proto.RegisterType((*CollectionOperationResponse)(nil), "qdrant.CollectionOperationResponse")
	proto.RegisterType((*CollectionParams)(nil), "qdrant.CollectionParams")
	proto.RegisterType((*CollectionParamsDiff)(nil), "qdrant.CollectionParamsDiff")
	proto.RegisterType((*CollectionConfig)(nil), "qdrant.CollectionConfig")
	proto.RegisterType((*TextIndexParams)(nil), "qdrant.TextIndexParams")
	proto.RegisterType((*IntegerIndexParams)(nil), "qdrant.IntegerIndexParams")
	proto.RegisterType((*PayloadIndexParams)(nil), "qdrant.PayloadIndexParams")
	proto.RegisterType((*PayloadSchemaInfo)(nil), "qdrant.PayloadSchemaInfo")
	proto.RegisterType((*CollectionInfo)(nil), "qdrant.CollectionInfo")
	proto.RegisterMapType((map[string]*PayloadSchemaInfo)(nil), "qdrant.CollectionInfo.PayloadSchemaEntry")
	proto.RegisterType((*ChangeAliases)(nil), "qdrant.ChangeAliases")
	proto.RegisterType((*AliasOperations)(nil), "qdrant.AliasOperations")
	proto.RegisterType((*CreateAlias)(nil), "qdrant.CreateAlias")
	proto.RegisterType((*RenameAlias)(nil), "qdrant.RenameAlias")
	proto.RegisterType((*DeleteAlias)(nil), "qdrant.DeleteAlias")
	proto.RegisterType((*ListAliasesRequest)(nil), "qdrant.ListAliasesRequest")
	proto.RegisterType((*ListCollectionAliasesRequest)(nil), "qdrant.ListCollectionAliasesRequest")
	proto.RegisterType((*AliasDescription)(nil), "qdrant.AliasDescription")
	proto.RegisterType((*ListAliasesResponse)(nil), "qdrant.ListAliasesResponse")
	proto.RegisterType((*CollectionClusterInfoRequest)(nil), "qdrant.CollectionClusterInfoRequest")
	proto.RegisterType((*ShardKey)(nil), "qdrant.ShardKey")
	proto.RegisterType((*LocalShardInfo)(nil), "qdrant.LocalShardInfo")
	proto.RegisterType((*RemoteShardInfo)(nil), "qdrant.RemoteShardInfo")
	proto.RegisterType((*ShardTransferInfo)(nil), "qdrant.ShardTransferInfo")
	proto.RegisterType((*CollectionClusterInfoResponse)(nil), "qdrant.CollectionClusterInfoResponse")
	proto.RegisterType((*MoveShard)(nil), "qdrant.MoveShard")
	proto.RegisterType((*ReplicateShard)(nil), "qdrant.ReplicateShard")
	proto.RegisterType((*AbortShardTransfer)(nil), "qdrant.AbortShardTransfer")
	proto.RegisterType((*RestartTransfer)(nil), "qdrant.RestartTransfer")
	proto.RegisterType((*Replica)(nil), "qdrant.Replica")
	proto.RegisterType((*CreateShardKey)(nil), "qdrant.CreateShardKey")
	proto.RegisterType((*DeleteShardKey)(nil), "qdrant.DeleteShardKey")
	proto.RegisterType((*UpdateCollectionClusterSetupRequest)(nil), "qdrant.UpdateCollectionClusterSetupRequest")
	proto.RegisterType((*UpdateCollectionClusterSetupResponse)(nil), "qdrant.UpdateCollectionClusterSetupResponse")
	proto.RegisterType((*CreateShardKeyRequest)(nil), "qdrant.CreateShardKeyRequest")
	proto.RegisterType((*DeleteShardKeyRequest)(nil), "qdrant.DeleteShardKeyRequest")
	proto.RegisterType((*CreateShardKeyResponse)(nil), "qdrant.CreateShardKeyResponse")
	proto.RegisterType((*DeleteShardKeyResponse)(nil), "qdrant.DeleteShardKeyResponse")
}

func init() { proto.RegisterFile("qdrant/collections.proto", fileDescriptor_67a6b7c8927fc88e) }

var fileDescriptor_67a6b7c8927fc88e = []byte{
	// 3753 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3a, 0x4b, 0x6c, 0x24, 0xd7,
	0x56, 0x5d, 0xdd, 0xd5, 0xbf, 0xd3, 0xbf, 0xf2, 0xb5, 0xc7, 0xd3, 0x99, 0x8f, 0x19, 0x2a, 0x21,
	0xcc, 0xf3, 0x9b, 0x71, 0x1c, 0xcf, 0xbc, 0xc9, 0xf0, 0x94, 0x10, 0xc6, 0x76, 0x62, 0x3b, 0x19,
	0xcf, 0x98, 0xb2, 0xe7, 0x85, 0x3c, 0x40, 0xcd, 0x75, 0xf5, 0x6d, 0xbb, 0xe4, 0xaa, 0xba, 0x9d,
	0xaa, 0xdb, 0x76, 0x3b, 0x12, 0x12, 0x12, 0x88, 0x05, 0x42, 0x7a, 0x48, 0x48, 0x8f, 0x15, 0x9f,
	0x25, 0x48, 0x6c, 0x58, 0xbc, 0x15, 0x1b, 0xd8, 0x91, 0x5d, 0x56, 0xe8, 0xb1, 0x23, 0x93, 0x05,
	0x2c, 0x23, 0xf6, 0x48, 0xe8, 0x7e, 0xaa, 0xba, 0xaa, 0xba, 0xda, 0x71, 0x9c, 0x80, 0x78, 0xab,
	0xae, 0x7b, 0x7e, 0x75, 0xce, 0xb9, 0xe7, 0x9e, 0x7b, 0xce, 0xe9, 0x82, 0xee, 0x27, 0xfd, 0x00,
	0xfb, 0xec, 0x0d, 0x9b, 0xba, 0x2e, 0xb1, 0x99, 0x43, 0xfd, 0x70, 0x65, 0x18, 0x50, 0x46, 0x51,
	0x45, 0x62, 0xcc, 0xff, 0x28, 0x42, 0xf3, 0x47, 0xc4, 0x66, 0x34, 0xd8, 0xc3, 0x01, 0xf6, 0x42,
	0x84, 0x40, 0x0f, 0x9d, 0x4f, 0x49, 0x57, 0xbb, 0xa3, 0xdd, 0xd5, 0x2d, 0xf1, 0x8c, 0xee, 0x41,
	0xad, 0xef, 0x84, 0x0c, 0xfb, 0x36, 0xe9, 0x16, 0xef, 0x68, 0x77, 0xdb, 0x6b, 0xc6, 0x8a, 0xe4,
	0x5f, 0xd9, 0x54, 0x70, 0x2b, 0xa6, 0x40, 0x6f, 0x41, 0xe3, 0xd8, 0x0f, 0xcf, 0x7a, 0x36, 0xf5,
	0x07, 0xce, 0x51, 0xb7, 0x74, 0x47, 0xbb, 0xdb, 0x58, 0x5b, 0x8c, 0x18, 0xb6, 0xfd, 0xf0, 0x6c,
	0x43, 0x60, 0x36, 0x9d, 0xc1, 0xc0, 0x82, 0xe3, 0x78, 0x8d, 0x3e, 0x84, 0xf9, 0x4f, 0x46, 0xd8,
	0x67, 0xce, 0xa7, 0x98, 0xab, 0x1a, 0x09, 0xd0, 0x85, 0x80, 0x1b, 0x91, 0x80, 0xdf, 0x4c, 0x90,
	0x48, 0x46, 0x0b, 0x7d, 0x32, 0x05, 0x43, 0xd7, 0xa1, 0x4a, 0xfd, 0x5e, 0xdf, 0x09, 0x4f, 0xba,
	0xe5, 0x3b, 0xda, 0xdd, 0x9a, 0x55, 0xa1, 0xfe, 0xa6, 0x13, 0x9e, 0x08, 0x63, 0x30, 0xc3, 0xec,
	0x7c, 0x48, 0xba, 0x95, 0x8c, 0x31, 0x0a, 0x6e, 0xc5, 0x14, 0x68, 0x1b, 0x90, 0x37, 0x72, 0x99,
	0x73, 0x2a, 0x7c, 0x14, 0xa9, 0x54, 0x15, 0x2a, 0xbd, 0x12, 0xf1, 0xed, 0x72, 0x0a, 0xe9, 0x45,
	0xa5, 0xd1, 0x5c, 0x82, 0x49, 0x82, 0xcc, 0x9f, 0x69, 0x60, 0x24, 0x3d, 0xcd, 0xcd, 0xcf, 0xfa,
	0x4a, 0xbb, 0xb4, 0xaf, 0x9e, 0xe7, 0xfb, 0xaa, 0x28, 0x04, 0x2c, 0xcd, 0xf6, 0x95, 0x10, 0xf4,
	0x35, 0xfe, 0x2a, 0x25, 0xfd, 0x65, 0xfe, 0xb9, 0x06, 0x9d, 0xa4, 0xde, 0xbb, 0x78, 0x88, 0xd6,
	0xa0, 0xe4, 0xe1, 0x61, 0x57, 0xbb, 0x53, 0xba, 0xdb, 0x58, 0xbb, 0x13, 0xbd, 0x2d, 0x43, 0xb5,
	0xb2, 0x8b, 0x87, 0xef, 0xf9, 0x2c, 0x38, 0xb7, 0x38, 0xf1, 0x8d, 0xa7, 0x50, 0x8b, 0x00, 0xc8,
	0x80, 0xd2, 0x09, 0x39, 0x17, 0xe6, 0xd6, 0x2d, 0xfe, 0x88, 0x96, 0xa1, 0x7c, 0x8a, 0xdd, 0x11,
	0x51, 0x16, 0x2c, 0xe4, 0xc9, 0xb4, 0x24, 0xc9, 0x0f, 0x8b, 0x8f, 0x35, 0xf3, 0xaf, 0x35, 0x98,
	0xcf, 0x7a, 0x93, 0x6b, 0xf6, 0x28, 0xa9, 0xd9, 0x6b, 0x79, 0x52, 0x14, 0x65, 0x46, 0xbb, 0xbd,
	0x0b, 0xb5, 0x5b, 0x49, 0x6b, 0xd7, 0x9d, 0x25, 0x37, 0xa9, 0xe1, 0x1f, 0x6a, 0xd0, 0x92, 0xf8,
	0x50, 0xb9, 0x78, 0x05, 0x2a, 0x43, 0x41, 0xaa, 0xf6, 0x39, 0xd7, 0xc8, 0xed, 0x82, 0xa5, 0xa8,
	0xd0, 0x63, 0x00, 0xf9, 0xd4, 0xe3, 0x26, 0xc9, 0x57, 0x5f, 0x9f, 0xe1, 0xec, 0xed, 0x82, 0x55,
	0x1f, 0x46, 0x8b, 0xf5, 0x1a, 0x54, 0x64, 0x40, 0x98, 0x3f, 0xd1, 0x60, 0x2e, 0xa5, 0x85, 0x08,
	0xbb, 0xb5, 0x8c, 0x26, 0x33, 0x0d, 0x4a, 0x68, 0xf3, 0x76, 0x8e, 0x36, 0x37, 0x2f, 0x70, 0xf0,
	0x2c, 0x8d, 0x42, 0x40, 0xfb, 0x43, 0x1c, 0x84, 0x24, 0x95, 0x76, 0xde, 0x80, 0xb2, 0xe3, 0xf7,
	0xc9, 0x58, 0x29, 0x14, 0x1f, 0x2d, 0x49, 0xba, 0xc3, 0x51, 0xea, 0x68, 0x49, 0x3a, 0x7e, 0x8c,
	0x3d, 0xda, 0x77, 0x06, 0x0e, 0x09, 0xb2, 0x39, 0x69, 0x57, 0xc1, 0xad, 0x98, 0x82, 0x87, 0x4b,
	0xea, 0xad, 0x6a, 0x47, 0x7e, 0x90, 0x8c, 0x96, 0x57, 0xd3, 0xef, 0x4c, 0x12, 0x66, 0x82, 0xc5,
	0xba, 0x30, 0x58, 0x56, 0xd3, 0xc1, 0x72, 0x23, 0x4f, 0xec, 0x74, 0x40, 0x5b, 0x30, 0x37, 0x95,
	0x46, 0xd0, 0x3b, 0x00, 0x36, 0xf5, 0xb8, 0x17, 0x19, 0x0d, 0xc4, 0x3b, 0xda, 0x6b, 0xb7, 0x73,
	0xb3, 0x4e, 0x44, 0x64, 0x25, 0x18, 0xcc, 0x0d, 0xe8, 0x6e, 0x11, 0xb6, 0x11, 0x27, 0xff, 0x1d,
	0x7f, 0x40, 0x2d, 0xf2, 0xc9, 0x88, 0x84, 0x0c, 0xfd, 0x2a, 0x74, 0x26, 0xb7, 0x42, 0xcf, 0xc7,
	0x1e, 0x51, 0x36, 0xb4, 0x27, 0xe0, 0x67, 0xd8, 0x23, 0xe6, 0x3a, 0x5c, 0x9f, 0x48, 0x78, 0x6f,
	0xec, 0x84, 0x2c, 0xfc, 0xc6, 0x32, 0x96, 0xc1, 0xc8, 0xca, 0x40, 0x8b, 0x50, 0x21, 0xe2, 0x49,
	0xf0, 0xd4, 0x2c, 0xb5, 0x32, 0x7f, 0x0f, 0xba, 0xd3, 0xef, 0x0b, 0x87, 0xd4, 0x0f, 0x09, 0x5a,
	0x85, 0x4a, 0x40, 0xc2, 0x91, 0xcb, 0xb2, 0x71, 0x3b, 0xc5, 0xa1, 0xe8, 0xf8, 0x75, 0xc6, 0x1c,
	0x4f, 0xee, 0x85, 0x66, 0x89, 0x67, 0xb3, 0x0b, 0x8b, 0x4f, 0x9d, 0x30, 0xe1, 0x97, 0xc8, 0x20,
	0xf3, 0xfb, 0x70, 0x6d, 0x02, 0xdd, 0x24, 0xa1, 0x1d, 0x38, 0x43, 0xfe, 0xc8, 0xc5, 0x24, 0xcc,
	0x13, 0xcf, 0x66, 0x0f, 0x5e, 0xc9, 0xf1, 0xae, 0xd2, 0x74, 0x25, 0xa3, 0xe9, 0xe2, 0xb4, 0xa6,
	0x82, 0xfe, 0x22, 0x3d, 0x7d, 0xb8, 0x3e, 0xa5, 0xa7, 0x12, 0xff, 0x2e, 0x34, 0x12, 0x77, 0xba,
	0x0a, 0xe0, 0xdb, 0xd3, 0xef, 0x48, 0xd8, 0x60, 0x25, 0x39, 0x72, 0xdf, 0xf7, 0x16, 0x74, 0x9e,
	0x0f, 0x99, 0xe3, 0x39, 0x9f, 0x92, 0x60, 0x9f, 0x61, 0x36, 0x0a, 0x51, 0x1b, 0x8a, 0xf4, 0x44,
	0x6d, 0x50, 0x91, 0x9e, 0xa0, 0x05, 0x28, 0x93, 0x20, 0xa0, 0xf2, 0xc8, 0xd5, 0x2d, 0xb9, 0x30,
	0xff, 0x4d, 0x83, 0x76, 0xfa, 0xae, 0x42, 0x4d, 0xd0, 0x3c, 0x55, 0x43, 0x68, 0x1e, 0xfa, 0x65,
	0x68, 0x92, 0x01, 0xbf, 0xa3, 0x42, 0x16, 0x8c, 0x6c, 0x26, 0xb8, 0x75, 0xab, 0x41, 0x06, 0x1b,
	0x11, 0x08, 0xad, 0xc0, 0xfc, 0x60, 0xe4, 0xba, 0xbd, 0xd0, 0xc6, 0x7e, 0x8f, 0x1d, 0x07, 0x24,
	0x3c, 0xa6, 0x6e, 0x5f, 0xdc, 0x45, 0xba, 0x35, 0xc7, 0x51, 0xfb, 0x36, 0xf6, 0x0f, 0x22, 0x04,
	0x5a, 0x85, 0x05, 0x0f, 0x8f, 0x7b, 0x22, 0x19, 0x38, 0xfe, 0x91, 0x60, 0xc1, 0xfd, 0x50, 0x54,
	0x0b, 0xba, 0x85, 0x3c, 0x3c, 0xde, 0x51, 0xa8, 0x03, 0x89, 0x99, 0x5d, 0x11, 0xdc, 0x84, 0xfa,
	0x10, 0x9f, 0xbb, 0x14, 0xf7, 0x7b, 0x9e, 0x28, 0x09, 0x74, 0xab, 0xa6, 0x00, 0xbb, 0xe6, 0x9f,
	0x68, 0x30, 0x37, 0x95, 0x84, 0x66, 0x69, 0xab, 0xcd, 0xd2, 0x36, 0xf1, 0xee, 0xe2, 0xcc, 0x6a,
	0xa4, 0xf4, 0x75, 0xd5, 0x88, 0x49, 0xa0, 0xf5, 0x11, 0x76, 0x13, 0x6e, 0x7e, 0x1d, 0x3a, 0x67,
	0xd8, 0xed, 0xd9, 0x78, 0x88, 0x6d, 0x87, 0x9d, 0xf7, 0xbc, 0x43, 0xa5, 0x43, 0xeb, 0x0c, 0xbb,
	0x1b, 0x0a, 0xba, 0x7b, 0x88, 0xee, 0x01, 0xe2, 0x74, 0x21, 0x39, 0xf2, 0x88, 0xcf, 0xc2, 0x1e,
	0x3e, 0x26, 0xb8, 0xaf, 0xb6, 0xc1, 0x38, 0xc3, 0xee, 0xbe, 0x42, 0x3c, 0xe1, 0x70, 0xf3, 0xaf,
	0x4a, 0xb0, 0x10, 0x47, 0x42, 0xf2, 0xde, 0xf8, 0x3e, 0xcc, 0xf5, 0x89, 0x4b, 0x18, 0xe9, 0x67,
	0x8c, 0xd6, 0x2c, 0x43, 0x21, 0x26, 0x36, 0xbf, 0x05, 0xdd, 0x53, 0x6c, 0x8f, 0x46, 0x5e, 0xcf,
	0x73, 0xfc, 0x9e, 0x2a, 0xa0, 0xfc, 0x91, 0x77, 0xa8, 0x32, 0xb6, 0x6e, 0x5d, 0x93, 0xf8, 0x5d,
	0xc7, 0x97, 0x69, 0xec, 0x99, 0x40, 0xa2, 0x87, 0xb0, 0xd8, 0x27, 0x03, 0x3c, 0x72, 0x59, 0xa4,
	0x70, 0xc4, 0x26, 0xa3, 0x61, 0x41, 0x61, 0x95, 0xd2, 0x8a, 0xeb, 0x2e, 0x18, 0x3c, 0x20, 0x22,
	0x0e, 0x51, 0xc4, 0xca, 0x60, 0x68, 0x7b, 0x78, 0xac, 0x68, 0xf7, 0x79, 0x39, 0xfb, 0x3d, 0x30,
	0x3c, 0xe2, 0x79, 0x78, 0x98, 0x30, 0xa2, 0x2c, 0x28, 0x3b, 0x12, 0x3e, 0xb1, 0xe1, 0x3e, 0xa0,
	0x54, 0x84, 0x49, 0x62, 0x19, 0x23, 0x73, 0x4e, 0x22, 0xc0, 0x24, 0xf9, 0x3d, 0x40, 0x03, 0x77,
	0x14, 0x1e, 0xf7, 0x1c, 0x9f, 0x91, 0xe0, 0x54, 0x78, 0xdc, 0x16, 0xd5, 0xa2, 0x6e, 0x19, 0x02,
	0xb3, 0xa3, 0x10, 0xfb, 0xc4, 0x46, 0x8f, 0xa1, 0xcb, 0x35, 0xa6, 0xd2, 0xd3, 0xb2, 0x8e, 0x8b,
	0xc2, 0xb8, 0x26, 0x78, 0x16, 0x3d, 0x3c, 0x7e, 0x9e, 0x40, 0xab, 0x50, 0x36, 0x7f, 0x1f, 0xd0,
	0xbe, 0x8d, 0x5d, 0x1c, 0x24, 0x0b, 0x3c, 0x74, 0x0f, 0x74, 0x11, 0x47, 0xf2, 0x9e, 0xe8, 0xe6,
	0x15, 0x81, 0x07, 0x3c, 0x9e, 0x04, 0x15, 0xba, 0x01, 0x35, 0x59, 0x06, 0xba, 0x32, 0x0b, 0x14,
	0xad, 0x78, 0x8d, 0x6e, 0x03, 0x60, 0xf7, 0x0c, 0x9f, 0x87, 0xbd, 0x00, 0x7b, 0xaa, 0x1e, 0xac,
	0x4b, 0x88, 0x85, 0x3d, 0x73, 0x08, 0xf3, 0x7b, 0x01, 0xed, 0x8f, 0x6c, 0x96, 0x7a, 0xff, 0x0f,
	0x79, 0x52, 0xf2, 0x86, 0x01, 0x09, 0x43, 0x87, 0xfa, 0x59, 0x35, 0x36, 0x26, 0x28, 0x8b, 0xd3,
	0x5b, 0x49, 0xe2, 0xcc, 0x1b, 0x8b, 0xd9, 0x37, 0x3e, 0x00, 0xb4, 0xee, 0xf8, 0x38, 0x38, 0x4f,
	0xbd, 0x30, 0xcd, 0xa4, 0x65, 0x99, 0x3e, 0xd3, 0x00, 0x4d, 0x57, 0xc0, 0xe8, 0x21, 0x54, 0x42,
	0xe1, 0x3c, 0x95, 0x9a, 0x27, 0x17, 0xf4, 0x94, 0x4b, 0x79, 0xf9, 0x23, 0x69, 0xd1, 0x5b, 0x50,
	0x1d, 0x4a, 0x9b, 0xb3, 0xb5, 0x4f, 0x8e, 0x2b, 0xb6, 0x0b, 0x56, 0x44, 0xcd, 0x5f, 0x77, 0x28,
	0x54, 0x57, 0x9d, 0x50, 0xfc, 0xba, 0x69, 0x83, 0xf8, 0xeb, 0x24, 0xed, 0x7a, 0x1b, 0x9a, 0xc9,
	0x22, 0xdd, 0x04, 0xa8, 0x6d, 0x3a, 0x21, 0x3e, 0x74, 0x49, 0xdf, 0xfc, 0x6f, 0x0d, 0x16, 0xf3,
	0x2b, 0xfb, 0xff, 0x6b, 0xdb, 0x56, 0x44, 0x63, 0x28, 0xb4, 0x52, 0xd6, 0x25, 0x1b, 0x43, 0x01,
	0xdf, 0x2e, 0x58, 0x31, 0x4d, 0xc2, 0x17, 0xfa, 0xb7, 0xf0, 0xc5, 0x5f, 0x56, 0xc0, 0xd8, 0x08,
	0x08, 0x66, 0x64, 0x72, 0xd1, 0x5d, 0xba, 0x16, 0xc9, 0xb6, 0x5c, 0xfa, 0xa5, 0x5b, 0xae, 0x87,
	0x00, 0x22, 0xd7, 0x4a, 0xbe, 0xb2, 0xe0, 0xbb, 0x16, 0xf1, 0xa5, 0xd2, 0xb2, 0x55, 0x3f, 0x8b,
	0x96, 0x68, 0x07, 0xe6, 0x68, 0x9c, 0x4a, 0x23, 0xe6, 0x8a, 0x60, 0xbe, 0x15, 0x31, 0xe7, 0xe5,
	0x5a, 0xcb, 0xa0, 0x19, 0x28, 0xbf, 0x45, 0xc3, 0x63, 0x1c, 0xf4, 0xa3, 0x6c, 0xc8, 0xf3, 0x4a,
	0xcb, 0x6a, 0x08, 0x98, 0x4a, 0x82, 0xaf, 0x43, 0x47, 0xdd, 0x33, 0x3d, 0x75, 0x83, 0x89, 0x4c,
	0x52, 0xb3, 0x5a, 0xf2, 0xbe, 0xd9, 0x93, 0x40, 0xd4, 0x85, 0x2a, 0xbf, 0xf2, 0xe9, 0x88, 0x75,
	0xeb, 0x22, 0xd3, 0x44, 0x4b, 0xf4, 0x36, 0xb4, 0x65, 0xaa, 0x8e, 0x95, 0x85, 0xb4, 0xa5, 0xa9,
	0x6e, 0xc2, 0x6a, 0x9d, 0xa6, 0x5a, 0x9c, 0xfb, 0x80, 0x02, 0x32, 0x74, 0x1d, 0x5b, 0x66, 0xb3,
	0x01, 0xe6, 0xc8, 0x6e, 0x43, 0x28, 0x3a, 0x97, 0xc0, 0xbc, 0x2f, 0x10, 0x3c, 0x03, 0x9e, 0x05,
	0x0e, 0x23, 0xa2, 0x34, 0x70, 0x42, 0x46, 0x7c, 0xfb, 0x3c, 0x62, 0x6a, 0x0a, 0xa6, 0x45, 0x81,
	0xdf, 0x98, 0xa0, 0x15, 0xe7, 0x2a, 0x2c, 0x38, 0xbe, 0xc3, 0x7a, 0x83, 0x80, 0x7a, 0xbd, 0xc9,
	0x0e, 0x77, 0x5b, 0x62, 0xcf, 0x11, 0xc7, 0xbd, 0x1f, 0x50, 0x2f, 0x11, 0x20, 0x33, 0xa6, 0x0b,
	0xed, 0x2b, 0x4d, 0x17, 0xde, 0x85, 0x8e, 0x70, 0x3b, 0xbf, 0x17, 0x3c, 0xc2, 0x8e, 0x69, 0xbf,
	0xdb, 0x11, 0xe9, 0x2e, 0x0e, 0xa4, 0x7d, 0x85, 0xde, 0x15, 0x58, 0xab, 0x1d, 0xa6, 0xd6, 0xe8,
	0x19, 0x5c, 0x0b, 0x45, 0x55, 0xd1, 0xcb, 0x78, 0xdb, 0x98, 0xdd, 0x34, 0x28, 0x7d, 0xe6, 0xc3,
	0x04, 0x4c, 0x39, 0xfe, 0x03, 0xbd, 0x56, 0x34, 0x4a, 0x1f, 0xe8, 0xb5, 0x92, 0xa1, 0x9b, 0xff,
	0x55, 0x02, 0xe3, 0xc5, 0xb0, 0x7f, 0xc5, 0xf3, 0x91, 0x1b, 0xb0, 0xc5, 0x2b, 0x05, 0x6c, 0x22,
	0xca, 0x4a, 0xe9, 0x28, 0x7b, 0x18, 0x37, 0xa0, 0x7a, 0x5a, 0xf2, 0x44, 0xe3, 0x44, 0x57, 0x1d,
	0xb5, 0xa0, 0x99, 0xa3, 0x5b, 0xbe, 0xf4, 0xd1, 0xfd, 0x8d, 0xa9, 0xa0, 0xae, 0xa4, 0xdb, 0xcc,
	0xa9, 0x16, 0x39, 0x1b, 0xd8, 0x33, 0xe6, 0x2d, 0xd5, 0x2b, 0xcf, 0x5b, 0x66, 0x06, 0x40, 0xed,
	0x4a, 0x01, 0x60, 0xbe, 0x00, 0x63, 0x53, 0x54, 0x60, 0x57, 0xd9, 0xf3, 0xc4, 0x46, 0x15, 0x53,
	0x1b, 0x65, 0xee, 0xc0, 0xcd, 0x89, 0xc0, 0xe7, 0x43, 0x12, 0x08, 0x1b, 0xe2, 0x3e, 0x64, 0x31,
	0xd5, 0xe6, 0xd4, 0x2e, 0x6c, 0x67, 0x3e, 0x2f, 0x25, 0xbb, 0x40, 0xd5, 0xf7, 0x67, 0x73, 0x5a,
	0xe9, 0x52, 0x39, 0x4d, 0xcf, 0xcb, 0x69, 0xd3, 0x99, 0xab, 0xfc, 0xad, 0x33, 0x57, 0xe5, 0x2a,
	0x99, 0xab, 0x7a, 0x61, 0xe6, 0xba, 0x0f, 0xf3, 0xbc, 0x88, 0xeb, 0x0d, 0xb0, 0xdf, 0xa3, 0x23,
	0x16, 0x31, 0xd5, 0x04, 0x93, 0xc1, 0x51, 0xef, 0x63, 0xff, 0xf9, 0x88, 0x29, 0xf2, 0x9c, 0x4c,
	0x53, 0xff, 0x6e, 0x32, 0x0d, 0x5c, 0x35, 0xd3, 0x68, 0x46, 0x51, 0xe6, 0x1b, 0xf3, 0x5f, 0x35,
	0x58, 0xc8, 0x3b, 0xb1, 0x33, 0xbc, 0xa9, 0x5d, 0xc5, 0x9b, 0xc5, 0x0b, 0xbd, 0x99, 0x13, 0x1c,
	0xa5, 0xbc, 0xe0, 0x98, 0xe1, 0x75, 0x3d, 0xdf, 0xeb, 0xe6, 0x67, 0xc5, 0x64, 0xac, 0xaa, 0x10,
	0x59, 0x9d, 0x35, 0x35, 0xcb, 0xba, 0x60, 0x56, 0xc2, 0x2a, 0x5e, 0x3a, 0x61, 0x6d, 0xc1, 0x24,
	0x9b, 0xa6, 0x07, 0xe9, 0x17, 0xe7, 0xe0, 0x4e, 0xcc, 0x95, 0x5b, 0xb4, 0xe8, 0x97, 0x2c, 0x5a,
	0x66, 0xdc, 0x95, 0xe5, 0xab, 0xdc, 0x95, 0xe6, 0xdf, 0x6b, 0xd0, 0x39, 0x20, 0x63, 0x26, 0xfa,
	0x67, 0x75, 0xec, 0x1f, 0x40, 0x9d, 0xd1, 0x13, 0xe2, 0x73, 0x4d, 0x55, 0xa3, 0x10, 0x6b, 0x75,
	0x10, 0x21, 0x44, 0xb3, 0x32, 0xa1, 0x43, 0xb7, 0xa0, 0xee, 0xd2, 0x33, 0x12, 0xd8, 0x38, 0x24,
	0x51, 0x8b, 0x10, 0x03, 0x90, 0x09, 0x2d, 0xde, 0x67, 0x0a, 0xf2, 0x9e, 0x4b, 0x7c, 0x75, 0xe5,
	0x34, 0x3c, 0xc7, 0x17, 0x12, 0x9f, 0x12, 0x5f, 0xd0, 0xe0, 0x71, 0x82, 0x46, 0x57, 0x34, 0x78,
	0x1c, 0xd1, 0x98, 0xeb, 0x80, 0x78, 0x93, 0x76, 0x44, 0x82, 0xa4, 0xc2, 0x8b, 0x50, 0x71, 0x29,
	0x3d, 0x19, 0x0d, 0xa3, 0x44, 0x27, 0x57, 0x68, 0x01, 0xca, 0x01, 0xf6, 0x8f, 0x22, 0x7d, 0xe4,
	0xc2, 0xfc, 0x47, 0x0d, 0x90, 0x8a, 0xbc, 0xa4, 0x90, 0xf7, 0x60, 0x8e, 0x91, 0x31, 0x93, 0x43,
	0x8b, 0x5e, 0x2a, 0x96, 0xe2, 0xb9, 0x6e, 0xc6, 0x53, 0xdb, 0x05, 0xab, 0xc3, 0x32, 0xce, 0x7b,
	0xc6, 0x6b, 0x1f, 0xa1, 0x61, 0x5a, 0x52, 0x66, 0xde, 0x38, 0x6d, 0xc5, 0x76, 0x81, 0x57, 0x46,
	0x59, 0x28, 0xaf, 0xaf, 0x93, 0x72, 0xcc, 0xbf, 0xd0, 0x60, 0x4e, 0x69, 0xbf, 0x6f, 0x1f, 0x13,
	0x0f, 0xef, 0xf8, 0x03, 0x8a, 0x1e, 0x41, 0xbd, 0x8f, 0x19, 0xee, 0x25, 0x5a, 0xcc, 0xf8, 0xfa,
	0x4c, 0x51, 0x1f, 0xc4, 0x33, 0x0b, 0xfe, 0x94, 0x98, 0x35, 0x67, 0xf4, 0x9b, 0x76, 0x50, 0x7c,
	0x6e, 0x16, 0xa1, 0x32, 0xa4, 0x8e, 0xcf, 0x42, 0xb5, 0x89, 0x6a, 0x65, 0xfe, 0x54, 0x87, 0x76,
	0x7a, 0x80, 0xc6, 0x0f, 0x65, 0x28, 0x66, 0x55, 0xd3, 0xfd, 0x66, 0x44, 0x27, 0x67, 0x59, 0x96,
	0xa2, 0x43, 0xeb, 0xc9, 0xb3, 0xa5, 0x78, 0x33, 0xc3, 0xf5, 0xcc, 0x18, 0x2c, 0x71, 0xac, 0xd4,
	0x5c, 0xec, 0x55, 0x68, 0x4d, 0xb2, 0xe9, 0xc8, 0x8f, 0xea, 0x9b, 0x66, 0x7c, 0xa7, 0x8c, 0x7c,
	0x86, 0x7e, 0x05, 0xda, 0xf1, 0xc0, 0x45, 0x52, 0xc9, 0x70, 0x6b, 0x45, 0x50, 0x49, 0xb6, 0x1a,
	0x8d, 0xc6, 0x55, 0x35, 0x91, 0x63, 0x81, 0x3a, 0x5d, 0x8a, 0x0e, 0xed, 0x41, 0x3b, 0x1a, 0x58,
	0x85, 0xc2, 0xe5, 0xdd, 0x9a, 0x18, 0x00, 0x7e, 0x2f, 0x7f, 0xc8, 0x98, 0xde, 0x1e, 0x39, 0xc7,
	0x6e, 0x0d, 0x93, 0x30, 0x7e, 0x0d, 0x4b, 0x17, 0x2b, 0x45, 0x65, 0x53, 0xd0, 0x90, 0x30, 0xa9,
	0xe6, 0x1a, 0x5c, 0x13, 0x51, 0x42, 0xfa, 0xbd, 0xb4, 0xe9, 0x20, 0x68, 0xe7, 0x15, 0xf2, 0x47,
	0x09, 0x0f, 0xdc, 0xf8, 0xed, 0xf8, 0x18, 0x24, 0xde, 0x9d, 0x33, 0x32, 0x7f, 0x23, 0x3d, 0x32,
	0xcf, 0x8f, 0x2b, 0x31, 0x2f, 0x9d, 0x4c, 0xcc, 0x3f, 0xd0, 0x6b, 0x65, 0xa3, 0xf2, 0x81, 0x5e,
	0xab, 0x18, 0x55, 0xf3, 0x77, 0xa0, 0xb5, 0x71, 0xcc, 0x8f, 0xde, 0x13, 0xd7, 0xc1, 0x21, 0x09,
	0xd1, 0x9b, 0x50, 0xc5, 0xa9, 0xe1, 0x68, 0xbc, 0xb7, 0x82, 0x22, 0xae, 0x64, 0x42, 0x2b, 0xa2,
	0xbb, 0xa0, 0x08, 0xfa, 0x4c, 0x83, 0x4e, 0x86, 0x0d, 0x3d, 0x86, 0xa6, 0x2d, 0x7a, 0xd0, 0x1e,
	0xe6, 0x18, 0x75, 0x8c, 0xe7, 0xe3, 0x1d, 0x10, 0x38, 0xc1, 0xb4, 0x5d, 0xb0, 0x1a, 0xf6, 0x64,
	0xc9, 0x39, 0x03, 0xc2, 0x8b, 0x31, 0xc5, 0x59, 0x4c, 0x73, 0x5a, 0x02, 0x17, 0x73, 0x06, 0x93,
	0x25, 0xe7, 0x94, 0x53, 0x36, 0xc5, 0x59, 0x4a, 0x73, 0xca, 0xfa, 0x2f, 0xe6, 0xec, 0x4f, 0x96,
	0xeb, 0x35, 0xa8, 0x48, 0x33, 0xcd, 0x17, 0xd0, 0x48, 0xe8, 0x76, 0xf9, 0x12, 0x51, 0xcc, 0x5a,
	0x1c, 0x1c, 0x4a, 0x1a, 0x39, 0xfe, 0xad, 0x0b, 0x88, 0x98, 0xf0, 0x7f, 0x0c, 0x8d, 0x84, 0xe2,
	0xe8, 0x35, 0x68, 0x53, 0xb7, 0xdf, 0x4b, 0x70, 0x48, 0xa9, 0x4d, 0xea, 0xf6, 0x9f, 0x44, 0x4c,
	0x9c, 0xca, 0x27, 0x67, 0xbd, 0x29, 0xb9, 0x4d, 0x9f, 0x9c, 0xc5, 0x54, 0xe6, 0x3d, 0x68, 0x24,
	0x2c, 0xcb, 0x28, 0xa2, 0x65, 0x15, 0x59, 0x00, 0xf4, 0xd4, 0x09, 0x99, 0x8a, 0x83, 0x68, 0xb0,
	0xbf, 0x05, 0xb7, 0xd2, 0xa3, 0xf4, 0x34, 0xfe, 0xf2, 0xff, 0x64, 0xfc, 0x18, 0x0c, 0xc1, 0x9a,
	0xfc, 0x73, 0xe0, 0x62, 0x8d, 0xf2, 0x64, 0x17, 0x73, 0x65, 0xff, 0x2e, 0xcc, 0xa7, 0x54, 0x57,
	0x35, 0xf6, 0x1a, 0x54, 0xb1, 0x04, 0xa9, 0x50, 0xee, 0xa6, 0x42, 0x39, 0x39, 0xe2, 0x8f, 0x08,
	0x73, 0xeb, 0xef, 0x2d, 0xb8, 0x95, 0xc8, 0x28, 0xee, 0x28, 0x64, 0xfc, 0x1a, 0xb8, 0xc2, 0x3f,
	0x42, 0x5b, 0x50, 0x13, 0x35, 0xe7, 0x87, 0xe4, 0x1c, 0xdd, 0x80, 0xea, 0x09, 0x39, 0x3f, 0xa3,
	0x81, 0x9c, 0x03, 0xd7, 0xb7, 0x0b, 0x56, 0x04, 0x40, 0x5d, 0xa8, 0x24, 0xc7, 0xbd, 0xdb, 0x05,
	0x4b, 0xad, 0xd7, 0xcb, 0x22, 0x03, 0x98, 0x7f, 0xa7, 0x41, 0xfb, 0x29, 0xb5, 0xb1, 0x2b, 0xc4,
	0x89, 0x74, 0xfe, 0x0a, 0xd4, 0x64, 0x3f, 0xe0, 0xf4, 0x55, 0xb9, 0x58, 0x15, 0xeb, 0x9d, 0xfe,
	0x54, 0x8e, 0x2a, 0x4e, 0xe7, 0xa8, 0x65, 0x28, 0xf3, 0x84, 0x1e, 0x8d, 0xd2, 0x17, 0x26, 0x67,
	0x4a, 0x54, 0x9c, 0x3c, 0x79, 0x13, 0x4b, 0x92, 0xa0, 0xfb, 0x50, 0x97, 0x6f, 0xe2, 0xb9, 0x48,
	0x4f, 0x0f, 0xaf, 0x22, 0xf3, 0x2c, 0xa9, 0xcc, 0x87, 0xe4, 0xdc, 0xfc, 0x1b, 0x0d, 0x3a, 0x16,
	0xf1, 0x28, 0x23, 0x97, 0x52, 0xf6, 0x3a, 0x54, 0x87, 0x84, 0x5f, 0xd0, 0xd1, 0x94, 0xbd, 0xc2,
	0x97, 0x3b, 0xfd, 0xff, 0x4d, 0x15, 0xff, 0x58, 0x83, 0x39, 0x01, 0x3e, 0x08, 0xb0, 0x1f, 0x0e,
	0xe4, 0xee, 0x5e, 0xa4, 0xe4, 0x12, 0x34, 0x18, 0xed, 0xc5, 0xd8, 0xb2, 0xc0, 0xd6, 0x19, 0xdd,
	0x57, 0x78, 0x04, 0xfa, 0x20, 0xa0, 0x9e, 0xb2, 0x40, 0x3c, 0xa3, 0x36, 0x14, 0x19, 0x55, 0xd7,
	0x5d, 0x91, 0x51, 0xf1, 0xbd, 0xc8, 0xb9, 0x6f, 0xab, 0x96, 0x4c, 0x3c, 0x9b, 0x3f, 0x2d, 0xc2,
	0xed, 0x19, 0xa1, 0xa6, 0x62, 0x3a, 0xe1, 0x1e, 0x2d, 0xe5, 0x9e, 0x5f, 0x02, 0xd9, 0xfb, 0xa5,
	0xf6, 0x18, 0x04, 0x48, 0x6e, 0xf1, 0xaf, 0x41, 0xd3, 0xe5, 0x21, 0x23, 0xd5, 0xe6, 0x39, 0xb0,
	0x94, 0xac, 0xa9, 0xd3, 0xe1, 0x64, 0x35, 0xdc, 0x78, 0x1d, 0xa2, 0xb7, 0xa1, 0x15, 0x88, 0x1d,
	0x8c, 0x78, 0xf5, 0xf4, 0xcd, 0x90, 0xd9, 0x5e, 0xab, 0x19, 0x4c, 0x00, 0xbc, 0x6c, 0x90, 0x8d,
	0x58, 0x8f, 0x29, 0xef, 0x86, 0xdd, 0xb2, 0xe0, 0x7f, 0x25, 0xb5, 0x25, 0x49, 0xdf, 0xab, 0x5e,
	0x2c, 0x02, 0x85, 0xbc, 0x2e, 0xac, 0xef, 0xd2, 0x53, 0x29, 0xf2, 0xdb, 0xec, 0xcc, 0x1d, 0x68,
	0x8a, 0xc9, 0x57, 0x3a, 0xc6, 0x80, 0xc3, 0xf6, 0xa4, 0x23, 0x6f, 0x01, 0x30, 0x1a, 0xe3, 0xe5,
	0x7e, 0xd5, 0x18, 0x55, 0xd8, 0x07, 0x50, 0x51, 0xcd, 0xa4, 0x2e, 0xc2, 0xf0, 0x66, 0xae, 0x0d,
	0xaa, 0xa3, 0x54, 0xa4, 0xe6, 0x3f, 0x69, 0xd0, 0x56, 0x61, 0xca, 0x7e, 0x41, 0x4d, 0xf8, 0x89,
	0x06, 0xe8, 0xc9, 0x21, 0x0d, 0x58, 0x8a, 0xe8, 0x1b, 0x98, 0xa1, 0x7f, 0xc7, 0x66, 0x98, 0xff,
	0x2c, 0xf2, 0x4a, 0xc8, 0x70, 0xc0, 0xae, 0xa0, 0xce, 0xff, 0x0f, 0xaf, 0xbe, 0x03, 0x55, 0x15,
	0x17, 0x57, 0x49, 0x89, 0xe6, 0x3f, 0x68, 0xd0, 0x96, 0x35, 0x49, 0x7c, 0xad, 0xa4, 0x32, 0x9f,
	0xf6, 0x75, 0x99, 0x8f, 0x97, 0xe3, 0xf2, 0x48, 0x27, 0xff, 0x5f, 0x6c, 0x59, 0x72, 0xb4, 0x14,
	0xaa, 0x39, 0x52, 0xfe, 0x4c, 0xa2, 0x34, 0x6b, 0x26, 0x71, 0x0b, 0xea, 0x43, 0x17, 0xdb, 0x84,
	0x57, 0xea, 0x22, 0x53, 0xe8, 0xd6, 0x04, 0x60, 0xbe, 0x0b, 0x6d, 0x59, 0x94, 0x5c, 0x51, 0x65,
	0xf3, 0x67, 0x3a, 0xbc, 0x9a, 0x1d, 0xd2, 0xaa, 0x4c, 0xb9, 0x4f, 0xd8, 0x68, 0xf8, 0x4d, 0x6f,
	0x65, 0xb4, 0x06, 0xe0, 0xd1, 0x53, 0x95, 0xdb, 0x54, 0x51, 0x39, 0x37, 0xf9, 0x24, 0x46, 0x25,
	0x9d, 0xed, 0x82, 0x55, 0xf7, 0xe2, 0x0c, 0xf4, 0x04, 0x3a, 0x91, 0xe1, 0x11, 0x63, 0xe6, 0x73,
	0xbd, 0xf4, 0x79, 0xdf, 0x2e, 0x58, 0xed, 0x20, 0x9d, 0x01, 0x36, 0xa0, 0x8d, 0xf9, 0x81, 0x8a,
	0xd3, 0x62, 0xf6, 0xaf, 0x9d, 0xe9, 0xe3, 0xb6, 0x5d, 0xb0, 0x5a, 0x82, 0x27, 0x0e, 0xf8, 0x87,
	0xd0, 0xec, 0x07, 0x74, 0xd8, 0x53, 0xb2, 0xd5, 0xa0, 0xa1, 0x93, 0x51, 0x42, 0x14, 0xb5, 0x01,
	0x1d, 0x46, 0xb1, 0xb6, 0x0e, 0x86, 0x2a, 0xc1, 0x27, 0x8e, 0xaf, 0x66, 0xbe, 0xb6, 0x48, 0x85,
	0x15, 0x57, 0xdf, 0x4e, 0x07, 0xda, 0x3a, 0xa8, 0x3f, 0xae, 0x13, 0x32, 0x6a, 0x69, 0x19, 0xe9,
	0x7d, 0xe6, 0x32, 0xfa, 0xe9, 0x9d, 0xdf, 0x04, 0x23, 0x90, 0x27, 0x78, 0xe2, 0x84, 0x7a, 0xba,
	0xa1, 0xcc, 0x9c, 0x70, 0xde, 0xd5, 0x07, 0x99, 0x43, 0x9f, 0x68, 0x3f, 0x2a, 0xa9, 0xf6, 0x63,
	0xbd, 0x01, 0x75, 0x1a, 0x35, 0x1e, 0xe6, 0xaf, 0xc3, 0x6b, 0x17, 0x87, 0xcd, 0xc5, 0x93, 0x59,
	0xf3, 0x4f, 0x35, 0xb8, 0x96, 0xf6, 0xca, 0x37, 0x8e, 0xb4, 0x55, 0xa8, 0x06, 0x92, 0x27, 0x3b,
	0xd1, 0xca, 0x08, 0x8e, 0xc8, 0x66, 0xff, 0x11, 0x20, 0xd4, 0x49, 0x3b, 0xf8, 0x3b, 0x54, 0x27,
	0x23, 0xf8, 0x12, 0xea, 0xac, 0xc2, 0x62, 0xd6, 0x39, 0x5f, 0xe3, 0xcf, 0x55, 0x58, 0xcc, 0xea,
	0x7f, 0x31, 0xc7, 0xf2, 0xdb, 0x50, 0x8b, 0x3e, 0xed, 0x40, 0x0d, 0xa8, 0x6e, 0xca, 0x8f, 0x19,
	0x8c, 0x02, 0x5f, 0xbc, 0xef, 0x52, 0xcc, 0x1e, 0xac, 0x19, 0x1a, 0xaa, 0x43, 0xf9, 0x85, 0xe3,
	0xb3, 0xc7, 0x46, 0x31, 0x86, 0xbf, 0xf9, 0xc8, 0x28, 0x2d, 0xdf, 0x86, 0x5a, 0xf4, 0x7d, 0x1b,
	0xaa, 0x81, 0xfe, 0x8c, 0xfa, 0xc4, 0x28, 0xa0, 0x2a, 0x94, 0x76, 0xfa, 0x03, 0x43, 0x5b, 0x7e,
	0x15, 0xae, 0xe5, 0x7e, 0x17, 0x86, 0x00, 0x2a, 0xbb, 0x78, 0xbc, 0xef, 0x78, 0x46, 0x61, 0xf9,
	0xb9, 0xf8, 0x33, 0x59, 0x7e, 0xad, 0x3b, 0x0f, 0x9d, 0x17, 0xfe, 0x89, 0x4f, 0xcf, 0xfc, 0x08,
	0x64, 0x14, 0x38, 0xf1, 0x06, 0x0d, 0x1d, 0x9f, 0x18, 0x1a, 0x7f, 0x7e, 0x6f, 0x64, 0xbb, 0x4e,
	0xdf, 0x28, 0xf2, 0xd7, 0x6c, 0x52, 0x66, 0x94, 0x50, 0x0b, 0xea, 0xbb, 0xd8, 0x3f, 0xc6, 0x8c,
	0x61, 0xdf, 0xd0, 0x97, 0x3f, 0x4e, 0x4e, 0x4b, 0xd5, 0x88, 0xe4, 0x26, 0x5c, 0x57, 0x82, 0xb3,
	0x28, 0xa3, 0xc0, 0xad, 0xdb, 0x0a, 0x08, 0xf1, 0xa5, 0xfc, 0x8f, 0x89, 0xeb, 0xd2, 0x33, 0x29,
	0xdf, 0x22, 0x7d, 0xa3, 0xc4, 0x2d, 0xdb, 0x0a, 0xc8, 0xb9, 0xa1, 0x2f, 0xb3, 0xcc, 0x2c, 0x4a,
	0xcc, 0x94, 0x3a, 0xd0, 0x50, 0xb2, 0xf9, 0x52, 0xba, 0xee, 0x43, 0xd9, 0x75, 0x18, 0x1a, 0x5f,
	0xa8, 0xd9, 0x97, 0x51, 0xe4, 0x6f, 0x12, 0xce, 0x33, 0x4a, 0x5c, 0xfa, 0x16, 0xa1, 0x86, 0xce,
	0xa5, 0x1f, 0x90, 0x31, 0x33, 0xca, 0xfc, 0x69, 0x9d, 0x52, 0xd7, 0xa8, 0xa0, 0xa6, 0xd8, 0x15,
	0xc2, 0x03, 0xc1, 0xa8, 0x2e, 0xff, 0x00, 0x8c, 0xec, 0x67, 0x13, 0xe8, 0x3a, 0xcc, 0xab, 0x97,
	0x26, 0x51, 0x46, 0x81, 0x0b, 0xd9, 0xe1, 0x3b, 0xa5, 0x2d, 0xbf, 0xc3, 0xfd, 0x90, 0xfe, 0xcc,
	0x01, 0x55, 0xa0, 0x38, 0x7e, 0x68, 0x14, 0xc4, 0xef, 0x63, 0x43, 0xe3, 0x5a, 0x8c, 0xdf, 0x7c,
	0x24, 0x8d, 0x1d, 0x3f, 0x58, 0x93, 0x7a, 0x8d, 0x1f, 0x3d, 0x34, 0xf4, 0xe5, 0xd7, 0xa1, 0x9d,
	0x1e, 0xe6, 0x73, 0xd1, 0x4f, 0x46, 0x8c, 0xaa, 0x2d, 0x19, 0x85, 0x8c, 0x7a, 0x86, 0xb6, 0x7c,
	0x00, 0xad, 0xd4, 0x90, 0x94, 0x5b, 0xac, 0x54, 0x93, 0x94, 0x7b, 0x01, 0x19, 0x38, 0x63, 0x43,
	0x43, 0x6d, 0x80, 0x8f, 0x8e, 0x1d, 0x46, 0xc2, 0x21, 0xb6, 0x89, 0x51, 0xe4, 0xf2, 0x3e, 0xe2,
	0x4e, 0x2a, 0x21, 0x03, 0x9a, 0x22, 0x50, 0x5c, 0xc7, 0x3f, 0x1a, 0x61, 0xd7, 0xd0, 0x97, 0xff,
	0x48, 0x83, 0x66, 0xb2, 0x0b, 0xe1, 0x82, 0x9e, 0xd8, 0xcc, 0x39, 0x25, 0xd2, 0xc6, 0x4d, 0x82,
	0x95, 0x77, 0xf7, 0x70, 0xc0, 0x1c, 0xec, 0x1a, 0x45, 0x2e, 0x65, 0xc7, 0x77, 0xf8, 0xc2, 0xf9,
	0xd4, 0xf1, 0x8f, 0x8c, 0x12, 0xf7, 0xe3, 0x53, 0x31, 0xa2, 0x27, 0x81, 0xa1, 0xf3, 0xe8, 0x52,
	0xc4, 0xfb, 0x3e, 0x1e, 0x86, 0xc7, 0x94, 0x3b, 0xbd, 0x09, 0x35, 0x8b, 0xd8, 0xf4, 0x94, 0x04,
	0xe7, 0x46, 0x85, 0xab, 0x68, 0x91, 0xe8, 0x3f, 0x0b, 0xa3, 0xba, 0x8c, 0x61, 0x3e, 0xa7, 0xd6,
	0x40, 0x73, 0xd0, 0xda, 0x67, 0x01, 0xc1, 0x1e, 0x67, 0x0d, 0xfa, 0x3c, 0x88, 0x9a, 0x50, 0x8b,
	0xa5, 0x6a, 0x7c, 0xf5, 0x11, 0x76, 0x37, 0x89, 0xcb, 0xb0, 0x51, 0xe4, 0xd1, 0x37, 0x91, 0x9a,
	0x66, 0x2c, 0xad, 0xff, 0xd6, 0xe7, 0x5f, 0x2c, 0x15, 0x7e, 0xfe, 0xc5, 0x52, 0xe1, 0xab, 0x2f,
	0x96, 0xb4, 0x3f, 0x78, 0xb9, 0xa4, 0xfd, 0xed, 0xcb, 0x25, 0xed, 0x5f, 0x5e, 0x2e, 0x69, 0x9f,
	0xbf, 0x5c, 0xd2, 0xfe, 0xfd, 0xe5, 0x92, 0xf6, 0x9f, 0x2f, 0x97, 0x0a, 0x5f, 0xbd, 0x5c, 0xd2,
	0xfe, 0xec, 0xcb, 0xa5, 0xc2, 0xe7, 0x5f, 0x2e, 0x15, 0x7e, 0xfe, 0xe5, 0x52, 0xe1, 0xc7, 0xe6,
	0x91, 0xc3, 0x8e, 0x47, 0x87, 0x2b, 0x36, 0xf5, 0xde, 0x50, 0xdf, 0xd5, 0x1f, 0xd1, 0xfb, 0xb6,
	0xeb, 0x10, 0x9f, 0x29, 0xc0, 0x61, 0x45, 0x7c, 0x5d, 0xff, 0xe0, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x8c, 0x34, 0x36, 0xd7, 0x79, 0x2f, 0x00, 0x00,
}

func (x Datatype) String() string {
	s, ok := Datatype_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Modifier) String() string {
	s, ok := Modifier_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MultiVectorComparator) String() string {
	s, ok := MultiVectorComparator_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Distance) String() string {
	s, ok := Distance_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CollectionStatus) String() string {
	s, ok := CollectionStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PayloadSchemaType) String() string {
	s, ok := PayloadSchemaType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x QuantizationType) String() string {
	s, ok := QuantizationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CompressionRatio) String() string {
	s, ok := CompressionRatio_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ShardingMethod) String() string {
	s, ok := ShardingMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TokenizerType) String() string {
	s, ok := TokenizerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ReplicaState) String() string {
	s, ok := ReplicaState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ShardTransferMethod) String() string {
	s, ok := ShardTransferMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VectorParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorParams)
	if !ok {
		that2, ok := that.(VectorParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Distance != that1.Distance {
		return false
	}
	if !this.HnswConfig.Equal(that1.HnswConfig) {
		return false
	}
	if !this.QuantizationConfig.Equal(that1.QuantizationConfig) {
		return false
	}
	if this.OnDisk != that1.OnDisk {
		return false
	}
	if this.Datatype != that1.Datatype {
		return false
	}
	if !this.MultivectorConfig.Equal(that1.MultivectorConfig) {
		return false
	}
	return true
}
func (this *VectorParamsDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorParamsDiff)
	if !ok {
		that2, ok := that.(VectorParamsDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HnswConfig.Equal(that1.HnswConfig) {
		return false
	}
	if !this.QuantizationConfig.Equal(that1.QuantizationConfig) {
		return false
	}
	if this.OnDisk != that1.OnDisk {
		return false
	}
	return true
}
func (this *VectorParamsMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorParamsMap)
	if !ok {
		that2, ok := that.(VectorParamsMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Map) != len(that1.Map) {
		return false
	}
	for i := range this.Map {
		if !this.Map[i].Equal(that1.Map[i]) {
			return false
		}
	}
	return true
}
func (this *VectorParamsDiffMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorParamsDiffMap)
	if !ok {
		that2, ok := that.(VectorParamsDiffMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Map) != len(that1.Map) {
		return false
	}
	for i := range this.Map {
		if !this.Map[i].Equal(that1.Map[i]) {
			return false
		}
	}
	return true
}
func (this *VectorsConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfig)
	if !ok {
		that2, ok := that.(VectorsConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Config == nil {
		if this.Config != nil {
			return false
		}
	} else if this.Config == nil {
		return false
	} else if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *VectorsConfig_Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfig_Params)
	if !ok {
		that2, ok := that.(VectorsConfig_Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *VectorsConfig_ParamsMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfig_ParamsMap)
	if !ok {
		that2, ok := that.(VectorsConfig_ParamsMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamsMap.Equal(that1.ParamsMap) {
		return false
	}
	return true
}
func (this *VectorsConfigDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfigDiff)
	if !ok {
		that2, ok := that.(VectorsConfigDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Config == nil {
		if this.Config != nil {
			return false
		}
	} else if this.Config == nil {
		return false
	} else if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *VectorsConfigDiff_Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfigDiff_Params)
	if !ok {
		that2, ok := that.(VectorsConfigDiff_Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *VectorsConfigDiff_ParamsMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsConfigDiff_ParamsMap)
	if !ok {
		that2, ok := that.(VectorsConfigDiff_ParamsMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ParamsMap.Equal(that1.ParamsMap) {
		return false
	}
	return true
}
func (this *SparseVectorParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseVectorParams)
	if !ok {
		that2, ok := that.(SparseVectorParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(that1.Index) {
		return false
	}
	if this.Modifier != that1.Modifier {
		return false
	}
	return true
}
func (this *SparseVectorConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseVectorConfig)
	if !ok {
		that2, ok := that.(SparseVectorConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Map) != len(that1.Map) {
		return false
	}
	for i := range this.Map {
		if !this.Map[i].Equal(that1.Map[i]) {
			return false
		}
	}
	return true
}
func (this *MultiVectorConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiVectorConfig)
	if !ok {
		that2, ok := that.(MultiVectorConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Comparator != that1.Comparator {
		return false
	}
	return true
}
func (this *GetCollectionInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCollectionInfoRequest)
	if !ok {
		that2, ok := that.(GetCollectionInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	return true
}
func (this *CollectionExistsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionExistsRequest)
	if !ok {
		that2, ok := that.(CollectionExistsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	return true
}
func (this *CollectionExists) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionExists)
	if !ok {
		that2, ok := that.(CollectionExists)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exists != that1.Exists {
		return false
	}
	return true
}
func (this *CollectionExistsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionExistsResponse)
	if !ok {
		that2, ok := that.(CollectionExistsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *ListCollectionsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListCollectionsRequest)
	if !ok {
		that2, ok := that.(ListCollectionsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CollectionDescription) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionDescription)
	if !ok {
		that2, ok := that.(CollectionDescription)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GetCollectionInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetCollectionInfoResponse)
	if !ok {
		that2, ok := that.(GetCollectionInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *ListCollectionsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListCollectionsResponse)
	if !ok {
		that2, ok := that.(ListCollectionsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Collections) != len(that1.Collections) {
		return false
	}
	for i := range this.Collections {
		if !this.Collections[i].Equal(that1.Collections[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *OptimizerStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OptimizerStatus)
	if !ok {
		that2, ok := that.(OptimizerStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ok != that1.Ok {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *HnswConfigDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HnswConfigDiff)
	if !ok {
		that2, ok := that.(HnswConfigDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.M != that1.M {
		return false
	}
	if this.EfConstruct != that1.EfConstruct {
		return false
	}
	if this.FullScanThreshold != that1.FullScanThreshold {
		return false
	}
	if this.MaxIndexingThreads != that1.MaxIndexingThreads {
		return false
	}
	if this.OnDisk != that1.OnDisk {
		return false
	}
	if this.PayloadM != that1.PayloadM {
		return false
	}
	return true
}
func (this *SparseIndexConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseIndexConfig)
	if !ok {
		that2, ok := that.(SparseIndexConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FullScanThreshold != that1.FullScanThreshold {
		return false
	}
	if this.OnDisk != that1.OnDisk {
		return false
	}
	if this.Datatype != that1.Datatype {
		return false
	}
	return true
}
func (this *WalConfigDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WalConfigDiff)
	if !ok {
		that2, ok := that.(WalConfigDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WalCapacityMb != that1.WalCapacityMb {
		return false
	}
	if this.WalSegmentsAhead != that1.WalSegmentsAhead {
		return false
	}
	return true
}
func (this *OptimizersConfigDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OptimizersConfigDiff)
	if !ok {
		that2, ok := that.(OptimizersConfigDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeletedThreshold != that1.DeletedThreshold {
		return false
	}
	if this.VacuumMinVectorNumber != that1.VacuumMinVectorNumber {
		return false
	}
	if this.DefaultSegmentNumber != that1.DefaultSegmentNumber {
		return false
	}
	if this.MaxSegmentSize != that1.MaxSegmentSize {
		return false
	}
	if this.MemmapThreshold != that1.MemmapThreshold {
		return false
	}
	if this.IndexingThreshold != that1.IndexingThreshold {
		return false
	}
	if this.FlushIntervalSec != that1.FlushIntervalSec {
		return false
	}
	if this.MaxOptimizationThreads != that1.MaxOptimizationThreads {
		return false
	}
	return true
}
func (this *ScalarQuantization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalarQuantization)
	if !ok {
		that2, ok := that.(ScalarQuantization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Quantile != that1.Quantile {
		return false
	}
	if this.AlwaysRam != that1.AlwaysRam {
		return false
	}
	return true
}
func (this *ProductQuantization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProductQuantization)
	if !ok {
		that2, ok := that.(ProductQuantization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Compression != that1.Compression {
		return false
	}
	if this.AlwaysRam != that1.AlwaysRam {
		return false
	}
	return true
}
func (this *BinaryQuantization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinaryQuantization)
	if !ok {
		that2, ok := that.(BinaryQuantization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AlwaysRam != that1.AlwaysRam {
		return false
	}
	return true
}
func (this *QuantizationConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfig)
	if !ok {
		that2, ok := that.(QuantizationConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Quantization == nil {
		if this.Quantization != nil {
			return false
		}
	} else if this.Quantization == nil {
		return false
	} else if !this.Quantization.Equal(that1.Quantization) {
		return false
	}
	return true
}
func (this *QuantizationConfig_Scalar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfig_Scalar)
	if !ok {
		that2, ok := that.(QuantizationConfig_Scalar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return false
	}
	return true
}
func (this *QuantizationConfig_Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfig_Product)
	if !ok {
		that2, ok := that.(QuantizationConfig_Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	return true
}
func (this *QuantizationConfig_Binary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfig_Binary)
	if !ok {
		that2, ok := that.(QuantizationConfig_Binary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Binary.Equal(that1.Binary) {
		return false
	}
	return true
}
func (this *Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Disabled)
	if !ok {
		that2, ok := that.(Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *QuantizationConfigDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfigDiff)
	if !ok {
		that2, ok := that.(QuantizationConfigDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Quantization == nil {
		if this.Quantization != nil {
			return false
		}
	} else if this.Quantization == nil {
		return false
	} else if !this.Quantization.Equal(that1.Quantization) {
		return false
	}
	return true
}
func (this *QuantizationConfigDiff_Scalar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfigDiff_Scalar)
	if !ok {
		that2, ok := that.(QuantizationConfigDiff_Scalar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return false
	}
	return true
}
func (this *QuantizationConfigDiff_Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfigDiff_Product)
	if !ok {
		that2, ok := that.(QuantizationConfigDiff_Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	return true
}
func (this *QuantizationConfigDiff_Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfigDiff_Disabled)
	if !ok {
		that2, ok := that.(QuantizationConfigDiff_Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disabled.Equal(that1.Disabled) {
		return false
	}
	return true
}
func (this *QuantizationConfigDiff_Binary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationConfigDiff_Binary)
	if !ok {
		that2, ok := that.(QuantizationConfigDiff_Binary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Binary.Equal(that1.Binary) {
		return false
	}
	return true
}
func (this *CreateCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateCollection)
	if !ok {
		that2, ok := that.(CreateCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.HnswConfig.Equal(that1.HnswConfig) {
		return false
	}
	if !this.WalConfig.Equal(that1.WalConfig) {
		return false
	}
	if !this.OptimizersConfig.Equal(that1.OptimizersConfig) {
		return false
	}
	if this.ShardNumber != that1.ShardNumber {
		return false
	}
	if this.OnDiskPayload != that1.OnDiskPayload {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.VectorsConfig.Equal(that1.VectorsConfig) {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.WriteConsistencyFactor != that1.WriteConsistencyFactor {
		return false
	}
	if this.InitFromCollection != that1.InitFromCollection {
		return false
	}
	if !this.QuantizationConfig.Equal(that1.QuantizationConfig) {
		return false
	}
	if this.ShardingMethod != that1.ShardingMethod {
		return false
	}
	if !this.SparseVectorsConfig.Equal(that1.SparseVectorsConfig) {
		return false
	}
	return true
}
func (this *UpdateCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollection)
	if !ok {
		that2, ok := that.(UpdateCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.OptimizersConfig.Equal(that1.OptimizersConfig) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if !this.HnswConfig.Equal(that1.HnswConfig) {
		return false
	}
	if !this.VectorsConfig.Equal(that1.VectorsConfig) {
		return false
	}
	if !this.QuantizationConfig.Equal(that1.QuantizationConfig) {
		return false
	}
	if !this.SparseVectorsConfig.Equal(that1.SparseVectorsConfig) {
		return false
	}
	return true
}
func (this *DeleteCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteCollection)
	if !ok {
		that2, ok := that.(DeleteCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *CollectionOperationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionOperationResponse)
	if !ok {
		that2, ok := that.(CollectionOperationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *CollectionParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionParams)
	if !ok {
		that2, ok := that.(CollectionParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardNumber != that1.ShardNumber {
		return false
	}
	if this.OnDiskPayload != that1.OnDiskPayload {
		return false
	}
	if !this.VectorsConfig.Equal(that1.VectorsConfig) {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.WriteConsistencyFactor != that1.WriteConsistencyFactor {
		return false
	}
	if this.ReadFanOutFactor != that1.ReadFanOutFactor {
		return false
	}
	if this.ShardingMethod != that1.ShardingMethod {
		return false
	}
	if !this.SparseVectorsConfig.Equal(that1.SparseVectorsConfig) {
		return false
	}
	return true
}
func (this *CollectionParamsDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionParamsDiff)
	if !ok {
		that2, ok := that.(CollectionParamsDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.WriteConsistencyFactor != that1.WriteConsistencyFactor {
		return false
	}
	if this.OnDiskPayload != that1.OnDiskPayload {
		return false
	}
	if this.ReadFanOutFactor != that1.ReadFanOutFactor {
		return false
	}
	return true
}
func (this *CollectionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionConfig)
	if !ok {
		that2, ok := that.(CollectionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if !this.HnswConfig.Equal(that1.HnswConfig) {
		return false
	}
	if !this.OptimizerConfig.Equal(that1.OptimizerConfig) {
		return false
	}
	if !this.WalConfig.Equal(that1.WalConfig) {
		return false
	}
	if !this.QuantizationConfig.Equal(that1.QuantizationConfig) {
		return false
	}
	return true
}
func (this *TextIndexParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TextIndexParams)
	if !ok {
		that2, ok := that.(TextIndexParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tokenizer != that1.Tokenizer {
		return false
	}
	if this.Lowercase != that1.Lowercase {
		return false
	}
	if this.MinTokenLen != that1.MinTokenLen {
		return false
	}
	if this.MaxTokenLen != that1.MaxTokenLen {
		return false
	}
	return true
}
func (this *IntegerIndexParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntegerIndexParams)
	if !ok {
		that2, ok := that.(IntegerIndexParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lookup != that1.Lookup {
		return false
	}
	if this.Range != that1.Range {
		return false
	}
	return true
}
func (this *PayloadIndexParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadIndexParams)
	if !ok {
		that2, ok := that.(PayloadIndexParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.IndexParams == nil {
		if this.IndexParams != nil {
			return false
		}
	} else if this.IndexParams == nil {
		return false
	} else if !this.IndexParams.Equal(that1.IndexParams) {
		return false
	}
	return true
}
func (this *PayloadIndexParams_TextIndexParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadIndexParams_TextIndexParams)
	if !ok {
		that2, ok := that.(PayloadIndexParams_TextIndexParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TextIndexParams.Equal(that1.TextIndexParams) {
		return false
	}
	return true
}
func (this *PayloadIndexParams_IntegerIndexParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadIndexParams_IntegerIndexParams)
	if !ok {
		that2, ok := that.(PayloadIndexParams_IntegerIndexParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IntegerIndexParams.Equal(that1.IntegerIndexParams) {
		return false
	}
	return true
}
func (this *PayloadSchemaInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadSchemaInfo)
	if !ok {
		that2, ok := that.(PayloadSchemaInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.Points != that1.Points {
		return false
	}
	return true
}
func (this *CollectionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionInfo)
	if !ok {
		that2, ok := that.(CollectionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.OptimizerStatus.Equal(that1.OptimizerStatus) {
		return false
	}
	if this.VectorsCount != that1.VectorsCount {
		return false
	}
	if this.SegmentsCount != that1.SegmentsCount {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if len(this.PayloadSchema) != len(that1.PayloadSchema) {
		return false
	}
	for i := range this.PayloadSchema {
		if !this.PayloadSchema[i].Equal(that1.PayloadSchema[i]) {
			return false
		}
	}
	if this.PointsCount != that1.PointsCount {
		return false
	}
	if this.IndexedVectorsCount != that1.IndexedVectorsCount {
		return false
	}
	return true
}
func (this *ChangeAliases) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChangeAliases)
	if !ok {
		that2, ok := that.(ChangeAliases)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *AliasOperations) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasOperations)
	if !ok {
		that2, ok := that.(AliasOperations)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	return true
}
func (this *AliasOperations_CreateAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasOperations_CreateAlias)
	if !ok {
		that2, ok := that.(AliasOperations_CreateAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateAlias.Equal(that1.CreateAlias) {
		return false
	}
	return true
}
func (this *AliasOperations_RenameAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasOperations_RenameAlias)
	if !ok {
		that2, ok := that.(AliasOperations_RenameAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RenameAlias.Equal(that1.RenameAlias) {
		return false
	}
	return true
}
func (this *AliasOperations_DeleteAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasOperations_DeleteAlias)
	if !ok {
		that2, ok := that.(AliasOperations_DeleteAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteAlias.Equal(that1.DeleteAlias) {
		return false
	}
	return true
}
func (this *CreateAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateAlias)
	if !ok {
		that2, ok := that.(CreateAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.AliasName != that1.AliasName {
		return false
	}
	return true
}
func (this *RenameAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RenameAlias)
	if !ok {
		that2, ok := that.(RenameAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OldAliasName != that1.OldAliasName {
		return false
	}
	if this.NewAliasName != that1.NewAliasName {
		return false
	}
	return true
}
func (this *DeleteAlias) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteAlias)
	if !ok {
		that2, ok := that.(DeleteAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AliasName != that1.AliasName {
		return false
	}
	return true
}
func (this *ListAliasesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListAliasesRequest)
	if !ok {
		that2, ok := that.(ListAliasesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ListCollectionAliasesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListCollectionAliasesRequest)
	if !ok {
		that2, ok := that.(ListCollectionAliasesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	return true
}
func (this *AliasDescription) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasDescription)
	if !ok {
		that2, ok := that.(AliasDescription)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AliasName != that1.AliasName {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	return true
}
func (this *ListAliasesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListAliasesResponse)
	if !ok {
		that2, ok := that.(ListAliasesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Aliases) != len(that1.Aliases) {
		return false
	}
	for i := range this.Aliases {
		if !this.Aliases[i].Equal(that1.Aliases[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *CollectionClusterInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionClusterInfoRequest)
	if !ok {
		that2, ok := that.(CollectionClusterInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	return true
}
func (this *ShardKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardKey)
	if !ok {
		that2, ok := that.(ShardKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Key == nil {
		if this.Key != nil {
			return false
		}
	} else if this.Key == nil {
		return false
	} else if !this.Key.Equal(that1.Key) {
		return false
	}
	return true
}
func (this *ShardKey_Keyword) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardKey_Keyword)
	if !ok {
		that2, ok := that.(ShardKey_Keyword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Keyword != that1.Keyword {
		return false
	}
	return true
}
func (this *ShardKey_Number) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardKey_Number)
	if !ok {
		that2, ok := that.(ShardKey_Number)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *LocalShardInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalShardInfo)
	if !ok {
		that2, ok := that.(LocalShardInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.PointsCount != that1.PointsCount {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	return true
}
func (this *RemoteShardInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteShardInfo)
	if !ok {
		that2, ok := that.(RemoteShardInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.PeerId != that1.PeerId {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	return true
}
func (this *ShardTransferInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardTransferInfo)
	if !ok {
		that2, ok := that.(ShardTransferInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.ToShardId != that1.ToShardId {
		return false
	}
	if this.From != that1.From {
		return false
	}
	if this.To != that1.To {
		return false
	}
	if this.Sync != that1.Sync {
		return false
	}
	return true
}
func (this *CollectionClusterInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CollectionClusterInfoResponse)
	if !ok {
		that2, ok := that.(CollectionClusterInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PeerId != that1.PeerId {
		return false
	}
	if this.ShardCount != that1.ShardCount {
		return false
	}
	if len(this.LocalShards) != len(that1.LocalShards) {
		return false
	}
	for i := range this.LocalShards {
		if !this.LocalShards[i].Equal(that1.LocalShards[i]) {
			return false
		}
	}
	if len(this.RemoteShards) != len(that1.RemoteShards) {
		return false
	}
	for i := range this.RemoteShards {
		if !this.RemoteShards[i].Equal(that1.RemoteShards[i]) {
			return false
		}
	}
	if len(this.ShardTransfers) != len(that1.ShardTransfers) {
		return false
	}
	for i := range this.ShardTransfers {
		if !this.ShardTransfers[i].Equal(that1.ShardTransfers[i]) {
			return false
		}
	}
	return true
}
func (this *MoveShard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MoveShard)
	if !ok {
		that2, ok := that.(MoveShard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.ToShardId != that1.ToShardId {
		return false
	}
	if this.FromPeerId != that1.FromPeerId {
		return false
	}
	if this.ToPeerId != that1.ToPeerId {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	return true
}
func (this *ReplicateShard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicateShard)
	if !ok {
		that2, ok := that.(ReplicateShard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.ToShardId != that1.ToShardId {
		return false
	}
	if this.FromPeerId != that1.FromPeerId {
		return false
	}
	if this.ToPeerId != that1.ToPeerId {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	return true
}
func (this *AbortShardTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AbortShardTransfer)
	if !ok {
		that2, ok := that.(AbortShardTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.ToShardId != that1.ToShardId {
		return false
	}
	if this.FromPeerId != that1.FromPeerId {
		return false
	}
	if this.ToPeerId != that1.ToPeerId {
		return false
	}
	return true
}
func (this *RestartTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestartTransfer)
	if !ok {
		that2, ok := that.(RestartTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.ToShardId != that1.ToShardId {
		return false
	}
	if this.FromPeerId != that1.FromPeerId {
		return false
	}
	if this.ToPeerId != that1.ToPeerId {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	return true
}
func (this *Replica) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Replica)
	if !ok {
		that2, ok := that.(Replica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShardId != that1.ShardId {
		return false
	}
	if this.PeerId != that1.PeerId {
		return false
	}
	return true
}
func (this *CreateShardKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateShardKey)
	if !ok {
		that2, ok := that.(CreateShardKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	if this.ShardsNumber != that1.ShardsNumber {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if len(this.Placement) != len(that1.Placement) {
		return false
	}
	for i := range this.Placement {
		if this.Placement[i] != that1.Placement[i] {
			return false
		}
	}
	return true
}
func (this *DeleteShardKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteShardKey)
	if !ok {
		that2, ok := that.(DeleteShardKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if that1.Operation == nil {
		if this.Operation != nil {
			return false
		}
	} else if this.Operation == nil {
		return false
	} else if !this.Operation.Equal(that1.Operation) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_MoveShard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_MoveShard)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_MoveShard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MoveShard.Equal(that1.MoveShard) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_ReplicateShard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_ReplicateShard)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_ReplicateShard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReplicateShard.Equal(that1.ReplicateShard) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_AbortTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_AbortTransfer)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_AbortTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AbortTransfer.Equal(that1.AbortTransfer) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_DropReplica) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_DropReplica)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_DropReplica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DropReplica.Equal(that1.DropReplica) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_CreateShardKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_CreateShardKey)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_CreateShardKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateShardKey.Equal(that1.CreateShardKey) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_DeleteShardKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_DeleteShardKey)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_DeleteShardKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteShardKey.Equal(that1.DeleteShardKey) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupRequest_RestartTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupRequest_RestartTransfer)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupRequest_RestartTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RestartTransfer.Equal(that1.RestartTransfer) {
		return false
	}
	return true
}
func (this *UpdateCollectionClusterSetupResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateCollectionClusterSetupResponse)
	if !ok {
		that2, ok := that.(UpdateCollectionClusterSetupResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *CreateShardKeyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateShardKeyRequest)
	if !ok {
		that2, ok := that.(CreateShardKeyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *DeleteShardKeyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteShardKeyRequest)
	if !ok {
		that2, ok := that.(DeleteShardKeyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.Request.Equal(that1.Request) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *CreateShardKeyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateShardKeyResponse)
	if !ok {
		that2, ok := that.(CreateShardKeyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *DeleteShardKeyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteShardKeyResponse)
	if !ok {
		that2, ok := that.(DeleteShardKeyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *VectorParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&qdrant.VectorParams{")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Distance: "+fmt.Sprintf("%#v", this.Distance)+",\n")
	if this.HnswConfig != nil {
		s = append(s, "HnswConfig: "+fmt.Sprintf("%#v", this.HnswConfig)+",\n")
	}
	if this.QuantizationConfig != nil {
		s = append(s, "QuantizationConfig: "+fmt.Sprintf("%#v", this.QuantizationConfig)+",\n")
	}
	s = append(s, "OnDisk: "+fmt.Sprintf("%#v", this.OnDisk)+",\n")
	s = append(s, "Datatype: "+fmt.Sprintf("%#v", this.Datatype)+",\n")
	if this.MultivectorConfig != nil {
		s = append(s, "MultivectorConfig: "+fmt.Sprintf("%#v", this.MultivectorConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorParamsDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.VectorParamsDiff{")
	if this.HnswConfig != nil {
		s = append(s, "HnswConfig: "+fmt.Sprintf("%#v", this.HnswConfig)+",\n")
	}
	if this.QuantizationConfig != nil {
		s = append(s, "QuantizationConfig: "+fmt.Sprintf("%#v", this.QuantizationConfig)+",\n")
	}
	s = append(s, "OnDisk: "+fmt.Sprintf("%#v", this.OnDisk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorParamsMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.VectorParamsMap{")
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*VectorParams{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%#v: %#v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	if this.Map != nil {
		s = append(s, "Map: "+mapStringForMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorParamsDiffMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.VectorParamsDiffMap{")
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*VectorParamsDiff{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%#v: %#v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	if this.Map != nil {
		s = append(s, "Map: "+mapStringForMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorsConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.VectorsConfig{")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorsConfig_Params) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorsConfig_Params{` +
		`Params:` + fmt.Sprintf("%#v", this.Params) + `}`}, ", ")
	return s
}
func (this *VectorsConfig_ParamsMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorsConfig_ParamsMap{` +
		`ParamsMap:` + fmt.Sprintf("%#v", this.ParamsMap) + `}`}, ", ")
	return s
}
func (this *VectorsConfigDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.VectorsConfigDiff{")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorsConfigDiff_Params) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorsConfigDiff_Params{` +
		`Params:` + fmt.Sprintf("%#v", this.Params) + `}`}, ", ")
	return s
}
func (this *VectorsConfigDiff_ParamsMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorsConfigDiff_ParamsMap{` +
		`ParamsMap:` + fmt.Sprintf("%#v", this.ParamsMap) + `}`}, ", ")
	return s
}
func (this *SparseVectorParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.SparseVectorParams{")
	if this.Index != nil {
		s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	}
	s = append(s, "Modifier: "+fmt.Sprintf("%#v", this.Modifier)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseVectorConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.SparseVectorConfig{")
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*SparseVectorParams{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%#v: %#v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	if this.Map != nil {
		s = append(s, "Map: "+mapStringForMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiVectorConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.MultiVectorConfig{")
	s = append(s, "Comparator: "+fmt.Sprintf("%#v", this.Comparator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCollectionInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.GetCollectionInfoRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionExistsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CollectionExistsRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionExists) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CollectionExists{")
	s = append(s, "Exists: "+fmt.Sprintf("%#v", this.Exists)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionExistsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.CollectionExistsResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListCollectionsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&qdrant.ListCollectionsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionDescription) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CollectionDescription{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCollectionInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GetCollectionInfoResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListCollectionsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ListCollectionsResponse{")
	if this.Collections != nil {
		s = append(s, "Collections: "+fmt.Sprintf("%#v", this.Collections)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OptimizerStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.OptimizerStatus{")
	s = append(s, "Ok: "+fmt.Sprintf("%#v", this.Ok)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HnswConfigDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.HnswConfigDiff{")
	s = append(s, "M: "+fmt.Sprintf("%#v", this.M)+",\n")
	s = append(s, "EfConstruct: "+fmt.Sprintf("%#v", this.EfConstruct)+",\n")
	s = append(s, "FullScanThreshold: "+fmt.Sprintf("%#v", this.FullScanThreshold)+",\n")
	s = append(s, "MaxIndexingThreads: "+fmt.Sprintf("%#v", this.MaxIndexingThreads)+",\n")
	s = append(s, "OnDisk: "+fmt.Sprintf("%#v", this.OnDisk)+",\n")
	s = append(s, "PayloadM: "+fmt.Sprintf("%#v", this.PayloadM)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseIndexConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.SparseIndexConfig{")
	s = append(s, "FullScanThreshold: "+fmt.Sprintf("%#v", this.FullScanThreshold)+",\n")
	s = append(s, "OnDisk: "+fmt.Sprintf("%#v", this.OnDisk)+",\n")
	s = append(s, "Datatype: "+fmt.Sprintf("%#v", this.Datatype)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WalConfigDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.WalConfigDiff{")
	s = append(s, "WalCapacityMb: "+fmt.Sprintf("%#v", this.WalCapacityMb)+",\n")
	s = append(s, "WalSegmentsAhead: "+fmt.Sprintf("%#v", this.WalSegmentsAhead)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OptimizersConfigDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.OptimizersConfigDiff{")
	s = append(s, "DeletedThreshold: "+fmt.Sprintf("%#v", this.DeletedThreshold)+",\n")
	s = append(s, "VacuumMinVectorNumber: "+fmt.Sprintf("%#v", this.VacuumMinVectorNumber)+",\n")
	s = append(s, "DefaultSegmentNumber: "+fmt.Sprintf("%#v", this.DefaultSegmentNumber)+",\n")
	s = append(s, "MaxSegmentSize: "+fmt.Sprintf("%#v", this.MaxSegmentSize)+",\n")
	s = append(s, "MemmapThreshold: "+fmt.Sprintf("%#v", this.MemmapThreshold)+",\n")
	s = append(s, "IndexingThreshold: "+fmt.Sprintf("%#v", this.IndexingThreshold)+",\n")
	s = append(s, "FlushIntervalSec: "+fmt.Sprintf("%#v", this.FlushIntervalSec)+",\n")
	s = append(s, "MaxOptimizationThreads: "+fmt.Sprintf("%#v", this.MaxOptimizationThreads)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalarQuantization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.ScalarQuantization{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Quantile: "+fmt.Sprintf("%#v", this.Quantile)+",\n")
	s = append(s, "AlwaysRam: "+fmt.Sprintf("%#v", this.AlwaysRam)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProductQuantization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ProductQuantization{")
	s = append(s, "Compression: "+fmt.Sprintf("%#v", this.Compression)+",\n")
	s = append(s, "AlwaysRam: "+fmt.Sprintf("%#v", this.AlwaysRam)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinaryQuantization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.BinaryQuantization{")
	s = append(s, "AlwaysRam: "+fmt.Sprintf("%#v", this.AlwaysRam)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QuantizationConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.QuantizationConfig{")
	if this.Quantization != nil {
		s = append(s, "Quantization: "+fmt.Sprintf("%#v", this.Quantization)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QuantizationConfig_Scalar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfig_Scalar{` +
		`Scalar:` + fmt.Sprintf("%#v", this.Scalar) + `}`}, ", ")
	return s
}
func (this *QuantizationConfig_Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfig_Product{` +
		`Product:` + fmt.Sprintf("%#v", this.Product) + `}`}, ", ")
	return s
}
func (this *QuantizationConfig_Binary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfig_Binary{` +
		`Binary:` + fmt.Sprintf("%#v", this.Binary) + `}`}, ", ")
	return s
}
func (this *Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&qdrant.Disabled{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QuantizationConfigDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.QuantizationConfigDiff{")
	if this.Quantization != nil {
		s = append(s, "Quantization: "+fmt.Sprintf("%#v", this.Quantization)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QuantizationConfigDiff_Scalar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfigDiff_Scalar{` +
		`Scalar:` + fmt.Sprintf("%#v", this.Scalar) + `}`}, ", ")
	return s
}
func (this *QuantizationConfigDiff_Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfigDiff_Product{` +
		`Product:` + fmt.Sprintf("%#v", this.Product) + `}`}, ", ")
	return s
}
func (this *QuantizationConfigDiff_Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfigDiff_Disabled{` +
		`Disabled:` + fmt.Sprintf("%#v", this.Disabled) + `}`}, ", ")
	return s
}
func (this *QuantizationConfigDiff_Binary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.QuantizationConfigDiff_Binary{` +
		`Binary:` + fmt.Sprintf("%#v", this.Binary) + `}`}, ", ")
	return s
}
func (this *CreateCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&qdrant.CreateCollection{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.HnswConfig != nil {
		s = append(s, "HnswConfig: "+fmt.Sprintf("%#v", this.HnswConfig)+",\n")
	}
	if this.WalConfig != nil {
		s = append(s, "WalConfig: "+fmt.Sprintf("%#v", this.WalConfig)+",\n")
	}
	if this.OptimizersConfig != nil {
		s = append(s, "OptimizersConfig: "+fmt.Sprintf("%#v", this.OptimizersConfig)+",\n")
	}
	s = append(s, "ShardNumber: "+fmt.Sprintf("%#v", this.ShardNumber)+",\n")
	s = append(s, "OnDiskPayload: "+fmt.Sprintf("%#v", this.OnDiskPayload)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.VectorsConfig != nil {
		s = append(s, "VectorsConfig: "+fmt.Sprintf("%#v", this.VectorsConfig)+",\n")
	}
	s = append(s, "ReplicationFactor: "+fmt.Sprintf("%#v", this.ReplicationFactor)+",\n")
	s = append(s, "WriteConsistencyFactor: "+fmt.Sprintf("%#v", this.WriteConsistencyFactor)+",\n")
	s = append(s, "InitFromCollection: "+fmt.Sprintf("%#v", this.InitFromCollection)+",\n")
	if this.QuantizationConfig != nil {
		s = append(s, "QuantizationConfig: "+fmt.Sprintf("%#v", this.QuantizationConfig)+",\n")
	}
	s = append(s, "ShardingMethod: "+fmt.Sprintf("%#v", this.ShardingMethod)+",\n")
	if this.SparseVectorsConfig != nil {
		s = append(s, "SparseVectorsConfig: "+fmt.Sprintf("%#v", this.SparseVectorsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.UpdateCollection{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.OptimizersConfig != nil {
		s = append(s, "OptimizersConfig: "+fmt.Sprintf("%#v", this.OptimizersConfig)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.HnswConfig != nil {
		s = append(s, "HnswConfig: "+fmt.Sprintf("%#v", this.HnswConfig)+",\n")
	}
	if this.VectorsConfig != nil {
		s = append(s, "VectorsConfig: "+fmt.Sprintf("%#v", this.VectorsConfig)+",\n")
	}
	if this.QuantizationConfig != nil {
		s = append(s, "QuantizationConfig: "+fmt.Sprintf("%#v", this.QuantizationConfig)+",\n")
	}
	if this.SparseVectorsConfig != nil {
		s = append(s, "SparseVectorsConfig: "+fmt.Sprintf("%#v", this.SparseVectorsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.DeleteCollection{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionOperationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.CollectionOperationResponse{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.CollectionParams{")
	s = append(s, "ShardNumber: "+fmt.Sprintf("%#v", this.ShardNumber)+",\n")
	s = append(s, "OnDiskPayload: "+fmt.Sprintf("%#v", this.OnDiskPayload)+",\n")
	if this.VectorsConfig != nil {
		s = append(s, "VectorsConfig: "+fmt.Sprintf("%#v", this.VectorsConfig)+",\n")
	}
	s = append(s, "ReplicationFactor: "+fmt.Sprintf("%#v", this.ReplicationFactor)+",\n")
	s = append(s, "WriteConsistencyFactor: "+fmt.Sprintf("%#v", this.WriteConsistencyFactor)+",\n")
	s = append(s, "ReadFanOutFactor: "+fmt.Sprintf("%#v", this.ReadFanOutFactor)+",\n")
	s = append(s, "ShardingMethod: "+fmt.Sprintf("%#v", this.ShardingMethod)+",\n")
	if this.SparseVectorsConfig != nil {
		s = append(s, "SparseVectorsConfig: "+fmt.Sprintf("%#v", this.SparseVectorsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionParamsDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.CollectionParamsDiff{")
	s = append(s, "ReplicationFactor: "+fmt.Sprintf("%#v", this.ReplicationFactor)+",\n")
	s = append(s, "WriteConsistencyFactor: "+fmt.Sprintf("%#v", this.WriteConsistencyFactor)+",\n")
	s = append(s, "OnDiskPayload: "+fmt.Sprintf("%#v", this.OnDiskPayload)+",\n")
	s = append(s, "ReadFanOutFactor: "+fmt.Sprintf("%#v", this.ReadFanOutFactor)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.CollectionConfig{")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.HnswConfig != nil {
		s = append(s, "HnswConfig: "+fmt.Sprintf("%#v", this.HnswConfig)+",\n")
	}
	if this.OptimizerConfig != nil {
		s = append(s, "OptimizerConfig: "+fmt.Sprintf("%#v", this.OptimizerConfig)+",\n")
	}
	if this.WalConfig != nil {
		s = append(s, "WalConfig: "+fmt.Sprintf("%#v", this.WalConfig)+",\n")
	}
	if this.QuantizationConfig != nil {
		s = append(s, "QuantizationConfig: "+fmt.Sprintf("%#v", this.QuantizationConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TextIndexParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.TextIndexParams{")
	s = append(s, "Tokenizer: "+fmt.Sprintf("%#v", this.Tokenizer)+",\n")
	s = append(s, "Lowercase: "+fmt.Sprintf("%#v", this.Lowercase)+",\n")
	s = append(s, "MinTokenLen: "+fmt.Sprintf("%#v", this.MinTokenLen)+",\n")
	s = append(s, "MaxTokenLen: "+fmt.Sprintf("%#v", this.MaxTokenLen)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntegerIndexParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.IntegerIndexParams{")
	s = append(s, "Lookup: "+fmt.Sprintf("%#v", this.Lookup)+",\n")
	s = append(s, "Range: "+fmt.Sprintf("%#v", this.Range)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PayloadIndexParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PayloadIndexParams{")
	if this.IndexParams != nil {
		s = append(s, "IndexParams: "+fmt.Sprintf("%#v", this.IndexParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PayloadIndexParams_TextIndexParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PayloadIndexParams_TextIndexParams{` +
		`TextIndexParams:` + fmt.Sprintf("%#v", this.TextIndexParams) + `}`}, ", ")
	return s
}
func (this *PayloadIndexParams_IntegerIndexParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PayloadIndexParams_IntegerIndexParams{` +
		`IntegerIndexParams:` + fmt.Sprintf("%#v", this.IntegerIndexParams) + `}`}, ", ")
	return s
}
func (this *PayloadSchemaInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.PayloadSchemaInfo{")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.CollectionInfo{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.OptimizerStatus != nil {
		s = append(s, "OptimizerStatus: "+fmt.Sprintf("%#v", this.OptimizerStatus)+",\n")
	}
	s = append(s, "VectorsCount: "+fmt.Sprintf("%#v", this.VectorsCount)+",\n")
	s = append(s, "SegmentsCount: "+fmt.Sprintf("%#v", this.SegmentsCount)+",\n")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	keysForPayloadSchema := make([]string, 0, len(this.PayloadSchema))
	for k, _ := range this.PayloadSchema {
		keysForPayloadSchema = append(keysForPayloadSchema, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayloadSchema)
	mapStringForPayloadSchema := "map[string]*PayloadSchemaInfo{"
	for _, k := range keysForPayloadSchema {
		mapStringForPayloadSchema += fmt.Sprintf("%#v: %#v,", k, this.PayloadSchema[k])
	}
	mapStringForPayloadSchema += "}"
	if this.PayloadSchema != nil {
		s = append(s, "PayloadSchema: "+mapStringForPayloadSchema+",\n")
	}
	s = append(s, "PointsCount: "+fmt.Sprintf("%#v", this.PointsCount)+",\n")
	s = append(s, "IndexedVectorsCount: "+fmt.Sprintf("%#v", this.IndexedVectorsCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChangeAliases) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ChangeAliases{")
	if this.Actions != nil {
		s = append(s, "Actions: "+fmt.Sprintf("%#v", this.Actions)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AliasOperations) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.AliasOperations{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AliasOperations_CreateAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.AliasOperations_CreateAlias{` +
		`CreateAlias:` + fmt.Sprintf("%#v", this.CreateAlias) + `}`}, ", ")
	return s
}
func (this *AliasOperations_RenameAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.AliasOperations_RenameAlias{` +
		`RenameAlias:` + fmt.Sprintf("%#v", this.RenameAlias) + `}`}, ", ")
	return s
}
func (this *AliasOperations_DeleteAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.AliasOperations_DeleteAlias{` +
		`DeleteAlias:` + fmt.Sprintf("%#v", this.DeleteAlias) + `}`}, ", ")
	return s
}
func (this *CreateAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.CreateAlias{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "AliasName: "+fmt.Sprintf("%#v", this.AliasName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RenameAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.RenameAlias{")
	s = append(s, "OldAliasName: "+fmt.Sprintf("%#v", this.OldAliasName)+",\n")
	s = append(s, "NewAliasName: "+fmt.Sprintf("%#v", this.NewAliasName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.DeleteAlias{")
	s = append(s, "AliasName: "+fmt.Sprintf("%#v", this.AliasName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListAliasesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&qdrant.ListAliasesRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListCollectionAliasesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.ListCollectionAliasesRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AliasDescription) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.AliasDescription{")
	s = append(s, "AliasName: "+fmt.Sprintf("%#v", this.AliasName)+",\n")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListAliasesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ListAliasesResponse{")
	if this.Aliases != nil {
		s = append(s, "Aliases: "+fmt.Sprintf("%#v", this.Aliases)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionClusterInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CollectionClusterInfoRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShardKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ShardKey{")
	if this.Key != nil {
		s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShardKey_Keyword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.ShardKey_Keyword{` +
		`Keyword:` + fmt.Sprintf("%#v", this.Keyword) + `}`}, ", ")
	return s
}
func (this *ShardKey_Number) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.ShardKey_Number{` +
		`Number:` + fmt.Sprintf("%#v", this.Number) + `}`}, ", ")
	return s
}
func (this *LocalShardInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.LocalShardInfo{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "PointsCount: "+fmt.Sprintf("%#v", this.PointsCount)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteShardInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.RemoteShardInfo{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShardTransferInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.ShardTransferInfo{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "ToShardId: "+fmt.Sprintf("%#v", this.ToShardId)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "Sync: "+fmt.Sprintf("%#v", this.Sync)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CollectionClusterInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.CollectionClusterInfoResponse{")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "ShardCount: "+fmt.Sprintf("%#v", this.ShardCount)+",\n")
	if this.LocalShards != nil {
		s = append(s, "LocalShards: "+fmt.Sprintf("%#v", this.LocalShards)+",\n")
	}
	if this.RemoteShards != nil {
		s = append(s, "RemoteShards: "+fmt.Sprintf("%#v", this.RemoteShards)+",\n")
	}
	if this.ShardTransfers != nil {
		s = append(s, "ShardTransfers: "+fmt.Sprintf("%#v", this.ShardTransfers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MoveShard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.MoveShard{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "ToShardId: "+fmt.Sprintf("%#v", this.ToShardId)+",\n")
	s = append(s, "FromPeerId: "+fmt.Sprintf("%#v", this.FromPeerId)+",\n")
	s = append(s, "ToPeerId: "+fmt.Sprintf("%#v", this.ToPeerId)+",\n")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplicateShard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.ReplicateShard{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "ToShardId: "+fmt.Sprintf("%#v", this.ToShardId)+",\n")
	s = append(s, "FromPeerId: "+fmt.Sprintf("%#v", this.FromPeerId)+",\n")
	s = append(s, "ToPeerId: "+fmt.Sprintf("%#v", this.ToPeerId)+",\n")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AbortShardTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.AbortShardTransfer{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "ToShardId: "+fmt.Sprintf("%#v", this.ToShardId)+",\n")
	s = append(s, "FromPeerId: "+fmt.Sprintf("%#v", this.FromPeerId)+",\n")
	s = append(s, "ToPeerId: "+fmt.Sprintf("%#v", this.ToPeerId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestartTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.RestartTransfer{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "ToShardId: "+fmt.Sprintf("%#v", this.ToShardId)+",\n")
	s = append(s, "FromPeerId: "+fmt.Sprintf("%#v", this.FromPeerId)+",\n")
	s = append(s, "ToPeerId: "+fmt.Sprintf("%#v", this.ToPeerId)+",\n")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Replica) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.Replica{")
	s = append(s, "ShardId: "+fmt.Sprintf("%#v", this.ShardId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateShardKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.CreateShardKey{")
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	s = append(s, "ShardsNumber: "+fmt.Sprintf("%#v", this.ShardsNumber)+",\n")
	s = append(s, "ReplicationFactor: "+fmt.Sprintf("%#v", this.ReplicationFactor)+",\n")
	s = append(s, "Placement: "+fmt.Sprintf("%#v", this.Placement)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteShardKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.DeleteShardKey{")
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateCollectionClusterSetupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&qdrant.UpdateCollectionClusterSetupRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Operation != nil {
		s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateCollectionClusterSetupRequest_MoveShard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_MoveShard{` +
		`MoveShard:` + fmt.Sprintf("%#v", this.MoveShard) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_ReplicateShard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_ReplicateShard{` +
		`ReplicateShard:` + fmt.Sprintf("%#v", this.ReplicateShard) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_AbortTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_AbortTransfer{` +
		`AbortTransfer:` + fmt.Sprintf("%#v", this.AbortTransfer) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_DropReplica) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_DropReplica{` +
		`DropReplica:` + fmt.Sprintf("%#v", this.DropReplica) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_CreateShardKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_CreateShardKey{` +
		`CreateShardKey:` + fmt.Sprintf("%#v", this.CreateShardKey) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_DeleteShardKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_DeleteShardKey{` +
		`DeleteShardKey:` + fmt.Sprintf("%#v", this.DeleteShardKey) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_RestartTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.UpdateCollectionClusterSetupRequest_RestartTransfer{` +
		`RestartTransfer:` + fmt.Sprintf("%#v", this.RestartTransfer) + `}`}, ", ")
	return s
}
func (this *UpdateCollectionClusterSetupResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.UpdateCollectionClusterSetupResponse{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateShardKeyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.CreateShardKeyRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Request != nil {
		s = append(s, "Request: "+fmt.Sprintf("%#v", this.Request)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteShardKeyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.DeleteShardKeyRequest{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Request != nil {
		s = append(s, "Request: "+fmt.Sprintf("%#v", this.Request)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateShardKeyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CreateShardKeyResponse{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteShardKeyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.DeleteShardKeyResponse{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCollections(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VectorParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MultivectorConfig != nil {
		{
			size, err := m.MultivectorConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Datatype != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Datatype))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDisk {
		i--
		if m.OnDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.QuantizationConfig != nil {
		{
			size, err := m.QuantizationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.HnswConfig != nil {
		{
			size, err := m.HnswConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Distance != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Distance))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VectorParamsDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorParamsDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorParamsDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnDisk {
		i--
		if m.OnDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.QuantizationConfig != nil {
		{
			size, err := m.QuantizationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HnswConfig != nil {
		{
			size, err := m.HnswConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VectorParamsMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorParamsMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorParamsMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCollections(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCollections(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCollections(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorParamsDiffMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorParamsDiffMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorParamsDiffMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCollections(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCollections(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCollections(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorsConfig_Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfig_Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VectorsConfig_ParamsMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfig_ParamsMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamsMap != nil {
		{
			size, err := m.ParamsMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VectorsConfigDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorsConfigDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfigDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size := m.Config.Size()
			i -= size
			if _, err := m.Config.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorsConfigDiff_Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfigDiff_Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VectorsConfigDiff_ParamsMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsConfigDiff_ParamsMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParamsMap != nil {
		{
			size, err := m.ParamsMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SparseVectorParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseVectorParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseVectorParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Modifier != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Modifier))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SparseVectorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseVectorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseVectorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCollections(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCollections(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCollections(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiVectorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiVectorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiVectorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Comparator != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Comparator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCollectionInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCollectionInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionExistsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionExistsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionExistsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionExists) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionExists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionExists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exists {
		i--
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionExistsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionExistsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionExistsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCollectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCollectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCollectionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CollectionDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCollectionInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCollectionInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCollectionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCollectionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCollectionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Collections) > 0 {
		for iNdEx := len(m.Collections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Collections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OptimizerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimizerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HnswConfigDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HnswConfigDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HnswConfigDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PayloadM != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PayloadM))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDisk {
		i--
		if m.OnDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MaxIndexingThreads != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MaxIndexingThreads))
		i--
		dAtA[i] = 0x20
	}
	if m.FullScanThreshold != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FullScanThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.EfConstruct != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.EfConstruct))
		i--
		dAtA[i] = 0x10
	}
	if m.M != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.M))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SparseIndexConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseIndexConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseIndexConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Datatype != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Datatype))
		i--
		dAtA[i] = 0x18
	}
	if m.OnDisk {
		i--
		if m.OnDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.FullScanThreshold != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FullScanThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalConfigDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalConfigDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalConfigDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WalSegmentsAhead != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.WalSegmentsAhead))
		i--
		dAtA[i] = 0x10
	}
	if m.WalCapacityMb != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.WalCapacityMb))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OptimizersConfigDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimizersConfigDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptimizersConfigDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxOptimizationThreads != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MaxOptimizationThreads))
		i--
		dAtA[i] = 0x40
	}
	if m.FlushIntervalSec != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FlushIntervalSec))
		i--
		dAtA[i] = 0x38
	}
	if m.IndexingThreshold != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.IndexingThreshold))
		i--
		dAtA[i] = 0x30
	}
	if m.MemmapThreshold != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MemmapThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxSegmentSize != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MaxSegmentSize))
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultSegmentNumber != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.DefaultSegmentNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.VacuumMinVectorNumber != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.VacuumMinVectorNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.DeletedThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeletedThreshold))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ScalarQuantization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalarQuantization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarQuantization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlwaysRam {
		i--
		if m.AlwaysRam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Quantile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Quantile))))
		i--
		dAtA[i] = 0x15
	}
	if m.Type != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProductQuantization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductQuantization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductQuantization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlwaysRam {
		i--
		if m.AlwaysRam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Compression != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Compression))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BinaryQuantization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryQuantization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryQuantization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlwaysRam {
		i--
		if m.AlwaysRam {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuantizationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuantizationConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantization != nil {
		{
			size := m.Quantization.Size()
			i -= size
			if _, err := m.Quantization.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuantizationConfig_Scalar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfig_Scalar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scalar != nil {
		{
			size, err := m.Scalar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationConfig_Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfig_Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationConfig_Binary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfig_Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Binary != nil {
		{
			size, err := m.Binary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Disabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QuantizationConfigDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuantizationConfigDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfigDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantization != nil {
		{
			size := m.Quantization.Size()
			i -= size
			if _, err := m.Quantization.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuantizationConfigDiff_Scalar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfigDiff_Scalar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scalar != nil {
		{
			size, err := m.Scalar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationConfigDiff_Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfigDiff_Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationConfigDiff_Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfigDiff_Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationConfigDiff_Binary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationConfigDiff_Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Binary != nil {
		{
			size, err := m.Binary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SparseVectorsConfig != nil {
		{
			size, err := m.SparseVectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ShardingMethod != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardingMethod))
		i--
		dAtA[i] = 0x78
	}
	if m.QuantizationConfig != nil {
		{
			size, err := m.QuantizationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.InitFromCollection) > 0 {
		i -= len(m.InitFromCollection)
		copy(dAtA[i:], m.InitFromCollection)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.InitFromCollection)))
		i--
		dAtA[i] = 0x6a
	}
	if m.WriteConsistencyFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.WriteConsistencyFactor))
		i--
		dAtA[i] = 0x60
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x58
	}
	if m.VectorsConfig != nil {
		{
			size, err := m.VectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x48
	}
	if m.OnDiskPayload {
		i--
		if m.OnDiskPayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ShardNumber != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardNumber))
		i--
		dAtA[i] = 0x38
	}
	if m.OptimizersConfig != nil {
		{
			size, err := m.OptimizersConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.WalConfig != nil {
		{
			size, err := m.WalConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.HnswConfig != nil {
		{
			size, err := m.HnswConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SparseVectorsConfig != nil {
		{
			size, err := m.SparseVectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.QuantizationConfig != nil {
		{
			size, err := m.QuantizationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.VectorsConfig != nil {
		{
			size, err := m.VectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.HnswConfig != nil {
		{
			size, err := m.HnswConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if m.OptimizersConfig != nil {
		{
			size, err := m.OptimizersConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionOperationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionOperationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionOperationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SparseVectorsConfig != nil {
		{
			size, err := m.SparseVectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ShardingMethod != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardingMethod))
		i--
		dAtA[i] = 0x48
	}
	if m.ReadFanOutFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReadFanOutFactor))
		i--
		dAtA[i] = 0x40
	}
	if m.WriteConsistencyFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.WriteConsistencyFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x30
	}
	if m.VectorsConfig != nil {
		{
			size, err := m.VectorsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.OnDiskPayload {
		i--
		if m.OnDiskPayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ShardNumber != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardNumber))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *CollectionParamsDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionParamsDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionParamsDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadFanOutFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReadFanOutFactor))
		i--
		dAtA[i] = 0x20
	}
	if m.OnDiskPayload {
		i--
		if m.OnDiskPayload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.WriteConsistencyFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.WriteConsistencyFactor))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QuantizationConfig != nil {
		{
			size, err := m.QuantizationConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.WalConfig != nil {
		{
			size, err := m.WalConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OptimizerConfig != nil {
		{
			size, err := m.OptimizerConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.HnswConfig != nil {
		{
			size, err := m.HnswConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TextIndexParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextIndexParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextIndexParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTokenLen != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MaxTokenLen))
		i--
		dAtA[i] = 0x20
	}
	if m.MinTokenLen != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.MinTokenLen))
		i--
		dAtA[i] = 0x18
	}
	if m.Lowercase {
		i--
		if m.Lowercase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Tokenizer != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Tokenizer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntegerIndexParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegerIndexParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegerIndexParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Range {
		i--
		if m.Range {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Lookup {
		i--
		if m.Lookup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PayloadIndexParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadIndexParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadIndexParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexParams != nil {
		{
			size := m.IndexParams.Size()
			i -= size
			if _, err := m.IndexParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayloadIndexParams_TextIndexParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadIndexParams_TextIndexParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TextIndexParams != nil {
		{
			size, err := m.TextIndexParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PayloadIndexParams_IntegerIndexParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadIndexParams_IntegerIndexParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IntegerIndexParams != nil {
		{
			size, err := m.IntegerIndexParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PayloadSchemaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadSchemaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadSchemaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Points != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x18
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DataType != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexedVectorsCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.IndexedVectorsCount))
		i--
		dAtA[i] = 0x50
	}
	if m.PointsCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PointsCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PayloadSchema) > 0 {
		for k := range m.PayloadSchema {
			v := m.PayloadSchema[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintCollections(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCollections(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCollections(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SegmentsCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.SegmentsCount))
		i--
		dAtA[i] = 0x20
	}
	if m.VectorsCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.VectorsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.OptimizerStatus != nil {
		{
			size, err := m.OptimizerStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangeAliases) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeAliases) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeAliases) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AliasOperations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasOperations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasOperations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AliasOperations_CreateAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasOperations_CreateAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateAlias != nil {
		{
			size, err := m.CreateAlias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AliasOperations_RenameAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasOperations_RenameAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RenameAlias != nil {
		{
			size, err := m.RenameAlias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AliasOperations_DeleteAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasOperations_DeleteAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteAlias != nil {
		{
			size, err := m.DeleteAlias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AliasName) > 0 {
		i -= len(m.AliasName)
		copy(dAtA[i:], m.AliasName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.AliasName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenameAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenameAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAliasName) > 0 {
		i -= len(m.NewAliasName)
		copy(dAtA[i:], m.NewAliasName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.NewAliasName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldAliasName) > 0 {
		i -= len(m.OldAliasName)
		copy(dAtA[i:], m.OldAliasName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.OldAliasName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAlias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAlias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AliasName) > 0 {
		i -= len(m.AliasName)
		copy(dAtA[i:], m.AliasName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.AliasName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAliasesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAliasesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAliasesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListCollectionAliasesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCollectionAliasesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCollectionAliasesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AliasDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AliasName) > 0 {
		i -= len(m.AliasName)
		copy(dAtA[i:], m.AliasName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.AliasName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAliasesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAliasesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAliasesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Aliases) > 0 {
		for iNdEx := len(m.Aliases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aliases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		{
			size := m.Key.Size()
			i -= size
			if _, err := m.Key.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardKey_Keyword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardKey_Keyword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Keyword)
	copy(dAtA[i:], m.Keyword)
	i = encodeVarintCollections(dAtA, i, uint64(len(m.Keyword)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ShardKey_Number) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardKey_Number) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCollections(dAtA, i, uint64(m.Number))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *LocalShardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalShardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalShardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.PointsCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PointsCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteShardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteShardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteShardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardTransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardTransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardTransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.Sync {
		i--
		if m.Sync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.To != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardTransfers) > 0 {
		for iNdEx := len(m.ShardTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RemoteShards) > 0 {
		for iNdEx := len(m.RemoteShards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteShards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LocalShards) > 0 {
		for iNdEx := len(m.LocalShards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalShards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ShardCount != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.Method != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x20
	}
	if m.ToPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToPeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FromPeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicateShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicateShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicateShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.Method != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x20
	}
	if m.ToPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToPeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FromPeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AbortShardTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbortShardTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AbortShardTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToShardId))
		i--
		dAtA[i] = 0x20
	}
	if m.ToPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToPeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FromPeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RestartTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestartTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ToShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.Method != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x20
	}
	if m.ToPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ToPeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromPeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.FromPeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardId != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Placement) > 0 {
		dAtA54 := make([]byte, len(m.Placement)*10)
		var j53 int
		for _, num := range m.Placement {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintCollections(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x22
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardsNumber != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.ShardsNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCollectionClusterSetupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCollectionClusterSetupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCollectionClusterSetupRequest_MoveShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_MoveShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MoveShard != nil {
		{
			size, err := m.MoveShard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_ReplicateShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_ReplicateShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReplicateShard != nil {
		{
			size, err := m.ReplicateShard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_AbortTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_AbortTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AbortTransfer != nil {
		{
			size, err := m.AbortTransfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_DropReplica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_DropReplica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropReplica != nil {
		{
			size, err := m.DropReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_CreateShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_CreateShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateShardKey != nil {
		{
			size, err := m.CreateShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_DeleteShardKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_DeleteShardKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteShardKey != nil {
		{
			size, err := m.DeleteShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupRequest_RestartTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupRequest_RestartTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RestartTransfer != nil {
		{
			size, err := m.RestartTransfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *UpdateCollectionClusterSetupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCollectionClusterSetupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCollectionClusterSetupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintCollections(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VectorParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovCollections(uint64(m.Size_))
	}
	if m.Distance != 0 {
		n += 1 + sovCollections(uint64(m.Distance))
	}
	if m.HnswConfig != nil {
		l = m.HnswConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.QuantizationConfig != nil {
		l = m.QuantizationConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Datatype != 0 {
		n += 1 + sovCollections(uint64(m.Datatype))
	}
	if m.MultivectorConfig != nil {
		l = m.MultivectorConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *VectorParamsDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HnswConfig != nil {
		l = m.HnswConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.QuantizationConfig != nil {
		l = m.QuantizationConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	return n
}

func (m *VectorParamsMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollections(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VectorParamsDiffMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollections(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VectorsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *VectorsConfig_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *VectorsConfig_ParamsMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamsMap != nil {
		l = m.ParamsMap.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *VectorsConfigDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *VectorsConfigDiff_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *VectorsConfigDiff_ParamsMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParamsMap != nil {
		l = m.ParamsMap.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *SparseVectorParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Modifier != 0 {
		n += 1 + sovCollections(uint64(m.Modifier))
	}
	return n
}

func (m *SparseVectorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollections(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MultiVectorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Comparator != 0 {
		n += 1 + sovCollections(uint64(m.Comparator))
	}
	return n
}

func (m *GetCollectionInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CollectionExistsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CollectionExists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *CollectionExistsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *ListCollectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CollectionDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *GetCollectionInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *ListCollectionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *OptimizerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *HnswConfigDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.M != 0 {
		n += 1 + sovCollections(uint64(m.M))
	}
	if m.EfConstruct != 0 {
		n += 1 + sovCollections(uint64(m.EfConstruct))
	}
	if m.FullScanThreshold != 0 {
		n += 1 + sovCollections(uint64(m.FullScanThreshold))
	}
	if m.MaxIndexingThreads != 0 {
		n += 1 + sovCollections(uint64(m.MaxIndexingThreads))
	}
	if m.OnDisk {
		n += 2
	}
	if m.PayloadM != 0 {
		n += 1 + sovCollections(uint64(m.PayloadM))
	}
	return n
}

func (m *SparseIndexConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullScanThreshold != 0 {
		n += 1 + sovCollections(uint64(m.FullScanThreshold))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Datatype != 0 {
		n += 1 + sovCollections(uint64(m.Datatype))
	}
	return n
}

func (m *WalConfigDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WalCapacityMb != 0 {
		n += 1 + sovCollections(uint64(m.WalCapacityMb))
	}
	if m.WalSegmentsAhead != 0 {
		n += 1 + sovCollections(uint64(m.WalSegmentsAhead))
	}
	return n
}

func (m *OptimizersConfigDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeletedThreshold != 0 {
		n += 9
	}
	if m.VacuumMinVectorNumber != 0 {
		n += 1 + sovCollections(uint64(m.VacuumMinVectorNumber))
	}
	if m.DefaultSegmentNumber != 0 {
		n += 1 + sovCollections(uint64(m.DefaultSegmentNumber))
	}
	if m.MaxSegmentSize != 0 {
		n += 1 + sovCollections(uint64(m.MaxSegmentSize))
	}
	if m.MemmapThreshold != 0 {
		n += 1 + sovCollections(uint64(m.MemmapThreshold))
	}
	if m.IndexingThreshold != 0 {
		n += 1 + sovCollections(uint64(m.IndexingThreshold))
	}
	if m.FlushIntervalSec != 0 {
		n += 1 + sovCollections(uint64(m.FlushIntervalSec))
	}
	if m.MaxOptimizationThreads != 0 {
		n += 1 + sovCollections(uint64(m.MaxOptimizationThreads))
	}
	return n
}

func (m *ScalarQuantization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCollections(uint64(m.Type))
	}
	if m.Quantile != 0 {
		n += 5
	}
	if m.AlwaysRam {
		n += 2
	}
	return n
}

func (m *ProductQuantization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Compression != 0 {
		n += 1 + sovCollections(uint64(m.Compression))
	}
	if m.AlwaysRam {
		n += 2
	}
	return n
}

func (m *BinaryQuantization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlwaysRam {
		n += 2
	}
	return n
}

func (m *QuantizationConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quantization != nil {
		n += m.Quantization.Size()
	}
	return n
}

func (m *QuantizationConfig_Scalar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scalar != nil {
		l = m.Scalar.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *QuantizationConfig_Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *QuantizationConfig_Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binary != nil {
		l = m.Binary.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QuantizationConfigDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Quantization != nil {
		n += m.Quantization.Size()
	}
	return n
}

func (m *QuantizationConfigDiff_Scalar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scalar != nil {
		l = m.Scalar.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *QuantizationConfigDiff_Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *QuantizationConfigDiff_Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *QuantizationConfigDiff_Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binary != nil {
		l = m.Binary.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *CreateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.HnswConfig != nil {
		l = m.HnswConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.WalConfig != nil {
		l = m.WalConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.OptimizersConfig != nil {
		l = m.OptimizersConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.ShardNumber != 0 {
		n += 1 + sovCollections(uint64(m.ShardNumber))
	}
	if m.OnDiskPayload {
		n += 2
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	if m.VectorsConfig != nil {
		l = m.VectorsConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReplicationFactor))
	}
	if m.WriteConsistencyFactor != 0 {
		n += 1 + sovCollections(uint64(m.WriteConsistencyFactor))
	}
	l = len(m.InitFromCollection)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.QuantizationConfig != nil {
		l = m.QuantizationConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.ShardingMethod != 0 {
		n += 1 + sovCollections(uint64(m.ShardingMethod))
	}
	if m.SparseVectorsConfig != nil {
		l = m.SparseVectorsConfig.Size()
		n += 2 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *UpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.OptimizersConfig != nil {
		l = m.OptimizersConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.HnswConfig != nil {
		l = m.HnswConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.VectorsConfig != nil {
		l = m.VectorsConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.QuantizationConfig != nil {
		l = m.QuantizationConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.SparseVectorsConfig != nil {
		l = m.SparseVectorsConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *DeleteCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	return n
}

func (m *CollectionOperationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *CollectionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardNumber != 0 {
		n += 1 + sovCollections(uint64(m.ShardNumber))
	}
	if m.OnDiskPayload {
		n += 2
	}
	if m.VectorsConfig != nil {
		l = m.VectorsConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReplicationFactor))
	}
	if m.WriteConsistencyFactor != 0 {
		n += 1 + sovCollections(uint64(m.WriteConsistencyFactor))
	}
	if m.ReadFanOutFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReadFanOutFactor))
	}
	if m.ShardingMethod != 0 {
		n += 1 + sovCollections(uint64(m.ShardingMethod))
	}
	if m.SparseVectorsConfig != nil {
		l = m.SparseVectorsConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CollectionParamsDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicationFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReplicationFactor))
	}
	if m.WriteConsistencyFactor != 0 {
		n += 1 + sovCollections(uint64(m.WriteConsistencyFactor))
	}
	if m.OnDiskPayload {
		n += 2
	}
	if m.ReadFanOutFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReadFanOutFactor))
	}
	return n
}

func (m *CollectionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.HnswConfig != nil {
		l = m.HnswConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.OptimizerConfig != nil {
		l = m.OptimizerConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.WalConfig != nil {
		l = m.WalConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.QuantizationConfig != nil {
		l = m.QuantizationConfig.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *TextIndexParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tokenizer != 0 {
		n += 1 + sovCollections(uint64(m.Tokenizer))
	}
	if m.Lowercase {
		n += 2
	}
	if m.MinTokenLen != 0 {
		n += 1 + sovCollections(uint64(m.MinTokenLen))
	}
	if m.MaxTokenLen != 0 {
		n += 1 + sovCollections(uint64(m.MaxTokenLen))
	}
	return n
}

func (m *IntegerIndexParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lookup {
		n += 2
	}
	if m.Range {
		n += 2
	}
	return n
}

func (m *PayloadIndexParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexParams != nil {
		n += m.IndexParams.Size()
	}
	return n
}

func (m *PayloadIndexParams_TextIndexParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TextIndexParams != nil {
		l = m.TextIndexParams.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *PayloadIndexParams_IntegerIndexParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntegerIndexParams != nil {
		l = m.IntegerIndexParams.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *PayloadSchemaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovCollections(uint64(m.DataType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Points != 0 {
		n += 1 + sovCollections(uint64(m.Points))
	}
	return n
}

func (m *CollectionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCollections(uint64(m.Status))
	}
	if m.OptimizerStatus != nil {
		l = m.OptimizerStatus.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.VectorsCount != 0 {
		n += 1 + sovCollections(uint64(m.VectorsCount))
	}
	if m.SegmentsCount != 0 {
		n += 1 + sovCollections(uint64(m.SegmentsCount))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.PayloadSchema) > 0 {
		for k, v := range m.PayloadSchema {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollections(uint64(mapEntrySize))
		}
	}
	if m.PointsCount != 0 {
		n += 1 + sovCollections(uint64(m.PointsCount))
	}
	if m.IndexedVectorsCount != 0 {
		n += 1 + sovCollections(uint64(m.IndexedVectorsCount))
	}
	return n
}

func (m *ChangeAliases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	return n
}

func (m *AliasOperations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *AliasOperations_CreateAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAlias != nil {
		l = m.CreateAlias.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *AliasOperations_RenameAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RenameAlias != nil {
		l = m.RenameAlias.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *AliasOperations_DeleteAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteAlias != nil {
		l = m.DeleteAlias.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *CreateAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.AliasName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *RenameAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldAliasName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.NewAliasName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *DeleteAlias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AliasName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *ListAliasesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListCollectionAliasesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *AliasDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AliasName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *ListAliasesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Aliases) > 0 {
		for _, e := range m.Aliases {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *CollectionClusterInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *ShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		n += m.Key.Size()
	}
	return n
}

func (m *ShardKey_Keyword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyword)
	n += 1 + l + sovCollections(uint64(l))
	return n
}
func (m *ShardKey_Number) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCollections(uint64(m.Number))
	return n
}
func (m *LocalShardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.PointsCount != 0 {
		n += 1 + sovCollections(uint64(m.PointsCount))
	}
	if m.State != 0 {
		n += 1 + sovCollections(uint64(m.State))
	}
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *RemoteShardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.PeerId != 0 {
		n += 1 + sovCollections(uint64(m.PeerId))
	}
	if m.State != 0 {
		n += 1 + sovCollections(uint64(m.State))
	}
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *ShardTransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.From != 0 {
		n += 1 + sovCollections(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovCollections(uint64(m.To))
	}
	if m.Sync {
		n += 2
	}
	if m.ToShardId != 0 {
		n += 1 + sovCollections(uint64(m.ToShardId))
	}
	return n
}

func (m *CollectionClusterInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovCollections(uint64(m.PeerId))
	}
	if m.ShardCount != 0 {
		n += 1 + sovCollections(uint64(m.ShardCount))
	}
	if len(m.LocalShards) > 0 {
		for _, e := range m.LocalShards {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.RemoteShards) > 0 {
		for _, e := range m.RemoteShards {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.ShardTransfers) > 0 {
		for _, e := range m.ShardTransfers {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	return n
}

func (m *MoveShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.FromPeerId != 0 {
		n += 1 + sovCollections(uint64(m.FromPeerId))
	}
	if m.ToPeerId != 0 {
		n += 1 + sovCollections(uint64(m.ToPeerId))
	}
	if m.Method != 0 {
		n += 1 + sovCollections(uint64(m.Method))
	}
	if m.ToShardId != 0 {
		n += 1 + sovCollections(uint64(m.ToShardId))
	}
	return n
}

func (m *ReplicateShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.FromPeerId != 0 {
		n += 1 + sovCollections(uint64(m.FromPeerId))
	}
	if m.ToPeerId != 0 {
		n += 1 + sovCollections(uint64(m.ToPeerId))
	}
	if m.Method != 0 {
		n += 1 + sovCollections(uint64(m.Method))
	}
	if m.ToShardId != 0 {
		n += 1 + sovCollections(uint64(m.ToShardId))
	}
	return n
}

func (m *AbortShardTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.FromPeerId != 0 {
		n += 1 + sovCollections(uint64(m.FromPeerId))
	}
	if m.ToPeerId != 0 {
		n += 1 + sovCollections(uint64(m.ToPeerId))
	}
	if m.ToShardId != 0 {
		n += 1 + sovCollections(uint64(m.ToShardId))
	}
	return n
}

func (m *RestartTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.FromPeerId != 0 {
		n += 1 + sovCollections(uint64(m.FromPeerId))
	}
	if m.ToPeerId != 0 {
		n += 1 + sovCollections(uint64(m.ToPeerId))
	}
	if m.Method != 0 {
		n += 1 + sovCollections(uint64(m.Method))
	}
	if m.ToShardId != 0 {
		n += 1 + sovCollections(uint64(m.ToShardId))
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovCollections(uint64(m.ShardId))
	}
	if m.PeerId != 0 {
		n += 1 + sovCollections(uint64(m.PeerId))
	}
	return n
}

func (m *CreateShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.ShardsNumber != 0 {
		n += 1 + sovCollections(uint64(m.ShardsNumber))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovCollections(uint64(m.ReplicationFactor))
	}
	if len(m.Placement) > 0 {
		l = 0
		for _, e := range m.Placement {
			l += sovCollections(uint64(e))
		}
		n += 1 + sovCollections(uint64(l)) + l
	}
	return n
}

func (m *DeleteShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *UpdateCollectionClusterSetupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	return n
}

func (m *UpdateCollectionClusterSetupRequest_MoveShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MoveShard != nil {
		l = m.MoveShard.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_ReplicateShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicateShard != nil {
		l = m.ReplicateShard.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_AbortTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbortTransfer != nil {
		l = m.AbortTransfer.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_DropReplica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropReplica != nil {
		l = m.DropReplica.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_CreateShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateShardKey != nil {
		l = m.CreateShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_DeleteShardKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteShardKey != nil {
		l = m.DeleteShardKey.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupRequest_RestartTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RestartTransfer != nil {
		l = m.RestartTransfer.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}
func (m *UpdateCollectionClusterSetupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *CreateShardKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	return n
}

func (m *DeleteShardKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovCollections(uint64(m.Timeout))
	}
	return n
}

func (m *CreateShardKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *DeleteShardKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VectorParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorParams{`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Distance:` + fmt.Sprintf("%v", this.Distance) + `,`,
		`HnswConfig:` + strings.Replace(this.HnswConfig.String(), "HnswConfigDiff", "HnswConfigDiff", 1) + `,`,
		`QuantizationConfig:` + strings.Replace(this.QuantizationConfig.String(), "QuantizationConfig", "QuantizationConfig", 1) + `,`,
		`OnDisk:` + fmt.Sprintf("%v", this.OnDisk) + `,`,
		`Datatype:` + fmt.Sprintf("%v", this.Datatype) + `,`,
		`MultivectorConfig:` + strings.Replace(this.MultivectorConfig.String(), "MultiVectorConfig", "MultiVectorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorParamsDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorParamsDiff{`,
		`HnswConfig:` + strings.Replace(this.HnswConfig.String(), "HnswConfigDiff", "HnswConfigDiff", 1) + `,`,
		`QuantizationConfig:` + strings.Replace(this.QuantizationConfig.String(), "QuantizationConfigDiff", "QuantizationConfigDiff", 1) + `,`,
		`OnDisk:` + fmt.Sprintf("%v", this.OnDisk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorParamsMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*VectorParams{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%v: %v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	s := strings.Join([]string{`&VectorParamsMap{`,
		`Map:` + mapStringForMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorParamsDiffMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*VectorParamsDiff{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%v: %v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	s := strings.Join([]string{`&VectorParamsDiffMap{`,
		`Map:` + mapStringForMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfig{`,
		`Config:` + fmt.Sprintf("%v", this.Config) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfig_Params) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfig_Params{`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "VectorParams", "VectorParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfig_ParamsMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfig_ParamsMap{`,
		`ParamsMap:` + strings.Replace(fmt.Sprintf("%v", this.ParamsMap), "VectorParamsMap", "VectorParamsMap", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfigDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfigDiff{`,
		`Config:` + fmt.Sprintf("%v", this.Config) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfigDiff_Params) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfigDiff_Params{`,
		`Params:` + strings.Replace(fmt.Sprintf("%v", this.Params), "VectorParamsDiff", "VectorParamsDiff", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsConfigDiff_ParamsMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsConfigDiff_ParamsMap{`,
		`ParamsMap:` + strings.Replace(fmt.Sprintf("%v", this.ParamsMap), "VectorParamsDiffMap", "VectorParamsDiffMap", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseVectorParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseVectorParams{`,
		`Index:` + strings.Replace(this.Index.String(), "SparseIndexConfig", "SparseIndexConfig", 1) + `,`,
		`Modifier:` + fmt.Sprintf("%v", this.Modifier) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseVectorConfig) String() string {
	if this == nil {
		return "nil"
	}
	keysForMap := make([]string, 0, len(this.Map))
	for k, _ := range this.Map {
		keysForMap = append(keysForMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMap)
	mapStringForMap := "map[string]*SparseVectorParams{"
	for _, k := range keysForMap {
		mapStringForMap += fmt.Sprintf("%v: %v,", k, this.Map[k])
	}
	mapStringForMap += "}"
	s := strings.Join([]string{`&SparseVectorConfig{`,
		`Map:` + mapStringForMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiVectorConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiVectorConfig{`,
		`Comparator:` + fmt.Sprintf("%v", this.Comparator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCollectionInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCollectionInfoRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionExistsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionExistsRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionExists) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionExists{`,
		`Exists:` + fmt.Sprintf("%v", this.Exists) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionExistsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionExistsResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "CollectionExists", "CollectionExists", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListCollectionsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListCollectionsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *CollectionDescription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionDescription{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCollectionInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCollectionInfoResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "CollectionInfo", "CollectionInfo", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListCollectionsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCollections := "[]*CollectionDescription{"
	for _, f := range this.Collections {
		repeatedStringForCollections += strings.Replace(f.String(), "CollectionDescription", "CollectionDescription", 1) + ","
	}
	repeatedStringForCollections += "}"
	s := strings.Join([]string{`&ListCollectionsResponse{`,
		`Collections:` + repeatedStringForCollections + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OptimizerStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OptimizerStatus{`,
		`Ok:` + fmt.Sprintf("%v", this.Ok) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HnswConfigDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HnswConfigDiff{`,
		`M:` + fmt.Sprintf("%v", this.M) + `,`,
		`EfConstruct:` + fmt.Sprintf("%v", this.EfConstruct) + `,`,
		`FullScanThreshold:` + fmt.Sprintf("%v", this.FullScanThreshold) + `,`,
		`MaxIndexingThreads:` + fmt.Sprintf("%v", this.MaxIndexingThreads) + `,`,
		`OnDisk:` + fmt.Sprintf("%v", this.OnDisk) + `,`,
		`PayloadM:` + fmt.Sprintf("%v", this.PayloadM) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseIndexConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseIndexConfig{`,
		`FullScanThreshold:` + fmt.Sprintf("%v", this.FullScanThreshold) + `,`,
		`OnDisk:` + fmt.Sprintf("%v", this.OnDisk) + `,`,
		`Datatype:` + fmt.Sprintf("%v", this.Datatype) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WalConfigDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WalConfigDiff{`,
		`WalCapacityMb:` + fmt.Sprintf("%v", this.WalCapacityMb) + `,`,
		`WalSegmentsAhead:` + fmt.Sprintf("%v", this.WalSegmentsAhead) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OptimizersConfigDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OptimizersConfigDiff{`,
		`DeletedThreshold:` + fmt.Sprintf("%v", this.DeletedThreshold) + `,`,
		`VacuumMinVectorNumber:` + fmt.Sprintf("%v", this.VacuumMinVectorNumber) + `,`,
		`DefaultSegmentNumber:` + fmt.Sprintf("%v", this.DefaultSegmentNumber) + `,`,
		`MaxSegmentSize:` + fmt.Sprintf("%v", this.MaxSegmentSize) + `,`,
		`MemmapThreshold:` + fmt.Sprintf("%v", this.MemmapThreshold) + `,`,
		`IndexingThreshold:` + fmt.Sprintf("%v", this.IndexingThreshold) + `,`,
		`FlushIntervalSec:` + fmt.Sprintf("%v", this.FlushIntervalSec) + `,`,
		`MaxOptimizationThreads:` + fmt.Sprintf("%v", this.MaxOptimizationThreads) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalarQuantization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalarQuantization{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Quantile:` + fmt.Sprintf("%v", this.Quantile) + `,`,
		`AlwaysRam:` + fmt.Sprintf("%v", this.AlwaysRam) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProductQuantization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProductQuantization{`,
		`Compression:` + fmt.Sprintf("%v", this.Compression) + `,`,
		`AlwaysRam:` + fmt.Sprintf("%v", this.AlwaysRam) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinaryQuantization) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinaryQuantization{`,
		`AlwaysRam:` + fmt.Sprintf("%v", this.AlwaysRam) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfig{`,
		`Quantization:` + fmt.Sprintf("%v", this.Quantization) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfig_Scalar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfig_Scalar{`,
		`Scalar:` + strings.Replace(fmt.Sprintf("%v", this.Scalar), "ScalarQuantization", "ScalarQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfig_Product) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfig_Product{`,
		`Product:` + strings.Replace(fmt.Sprintf("%v", this.Product), "ProductQuantization", "ProductQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfig_Binary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfig_Binary{`,
		`Binary:` + strings.Replace(fmt.Sprintf("%v", this.Binary), "BinaryQuantization", "BinaryQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Disabled{`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfigDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfigDiff{`,
		`Quantization:` + fmt.Sprintf("%v", this.Quantization) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfigDiff_Scalar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfigDiff_Scalar{`,
		`Scalar:` + strings.Replace(fmt.Sprintf("%v", this.Scalar), "ScalarQuantization", "ScalarQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfigDiff_Product) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfigDiff_Product{`,
		`Product:` + strings.Replace(fmt.Sprintf("%v", this.Product), "ProductQuantization", "ProductQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfigDiff_Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfigDiff_Disabled{`,
		`Disabled:` + strings.Replace(fmt.Sprintf("%v", this.Disabled), "Disabled", "Disabled", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationConfigDiff_Binary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationConfigDiff_Binary{`,
		`Binary:` + strings.Replace(fmt.Sprintf("%v", this.Binary), "BinaryQuantization", "BinaryQuantization", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateCollection{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`HnswConfig:` + strings.Replace(this.HnswConfig.String(), "HnswConfigDiff", "HnswConfigDiff", 1) + `,`,
		`WalConfig:` + strings.Replace(this.WalConfig.String(), "WalConfigDiff", "WalConfigDiff", 1) + `,`,
		`OptimizersConfig:` + strings.Replace(this.OptimizersConfig.String(), "OptimizersConfigDiff", "OptimizersConfigDiff", 1) + `,`,
		`ShardNumber:` + fmt.Sprintf("%v", this.ShardNumber) + `,`,
		`OnDiskPayload:` + fmt.Sprintf("%v", this.OnDiskPayload) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`VectorsConfig:` + strings.Replace(this.VectorsConfig.String(), "VectorsConfig", "VectorsConfig", 1) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`WriteConsistencyFactor:` + fmt.Sprintf("%v", this.WriteConsistencyFactor) + `,`,
		`InitFromCollection:` + fmt.Sprintf("%v", this.InitFromCollection) + `,`,
		`QuantizationConfig:` + strings.Replace(this.QuantizationConfig.String(), "QuantizationConfig", "QuantizationConfig", 1) + `,`,
		`ShardingMethod:` + fmt.Sprintf("%v", this.ShardingMethod) + `,`,
		`SparseVectorsConfig:` + strings.Replace(this.SparseVectorsConfig.String(), "SparseVectorConfig", "SparseVectorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollection{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`OptimizersConfig:` + strings.Replace(this.OptimizersConfig.String(), "OptimizersConfigDiff", "OptimizersConfigDiff", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "CollectionParamsDiff", "CollectionParamsDiff", 1) + `,`,
		`HnswConfig:` + strings.Replace(this.HnswConfig.String(), "HnswConfigDiff", "HnswConfigDiff", 1) + `,`,
		`VectorsConfig:` + strings.Replace(this.VectorsConfig.String(), "VectorsConfigDiff", "VectorsConfigDiff", 1) + `,`,
		`QuantizationConfig:` + strings.Replace(this.QuantizationConfig.String(), "QuantizationConfigDiff", "QuantizationConfigDiff", 1) + `,`,
		`SparseVectorsConfig:` + strings.Replace(this.SparseVectorsConfig.String(), "SparseVectorConfig", "SparseVectorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteCollection{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionOperationResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionOperationResponse{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionParams{`,
		`ShardNumber:` + fmt.Sprintf("%v", this.ShardNumber) + `,`,
		`OnDiskPayload:` + fmt.Sprintf("%v", this.OnDiskPayload) + `,`,
		`VectorsConfig:` + strings.Replace(this.VectorsConfig.String(), "VectorsConfig", "VectorsConfig", 1) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`WriteConsistencyFactor:` + fmt.Sprintf("%v", this.WriteConsistencyFactor) + `,`,
		`ReadFanOutFactor:` + fmt.Sprintf("%v", this.ReadFanOutFactor) + `,`,
		`ShardingMethod:` + fmt.Sprintf("%v", this.ShardingMethod) + `,`,
		`SparseVectorsConfig:` + strings.Replace(this.SparseVectorsConfig.String(), "SparseVectorConfig", "SparseVectorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionParamsDiff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionParamsDiff{`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`WriteConsistencyFactor:` + fmt.Sprintf("%v", this.WriteConsistencyFactor) + `,`,
		`OnDiskPayload:` + fmt.Sprintf("%v", this.OnDiskPayload) + `,`,
		`ReadFanOutFactor:` + fmt.Sprintf("%v", this.ReadFanOutFactor) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionConfig{`,
		`Params:` + strings.Replace(this.Params.String(), "CollectionParams", "CollectionParams", 1) + `,`,
		`HnswConfig:` + strings.Replace(this.HnswConfig.String(), "HnswConfigDiff", "HnswConfigDiff", 1) + `,`,
		`OptimizerConfig:` + strings.Replace(this.OptimizerConfig.String(), "OptimizersConfigDiff", "OptimizersConfigDiff", 1) + `,`,
		`WalConfig:` + strings.Replace(this.WalConfig.String(), "WalConfigDiff", "WalConfigDiff", 1) + `,`,
		`QuantizationConfig:` + strings.Replace(this.QuantizationConfig.String(), "QuantizationConfig", "QuantizationConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TextIndexParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TextIndexParams{`,
		`Tokenizer:` + fmt.Sprintf("%v", this.Tokenizer) + `,`,
		`Lowercase:` + fmt.Sprintf("%v", this.Lowercase) + `,`,
		`MinTokenLen:` + fmt.Sprintf("%v", this.MinTokenLen) + `,`,
		`MaxTokenLen:` + fmt.Sprintf("%v", this.MaxTokenLen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntegerIndexParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntegerIndexParams{`,
		`Lookup:` + fmt.Sprintf("%v", this.Lookup) + `,`,
		`Range:` + fmt.Sprintf("%v", this.Range) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadIndexParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadIndexParams{`,
		`IndexParams:` + fmt.Sprintf("%v", this.IndexParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadIndexParams_TextIndexParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadIndexParams_TextIndexParams{`,
		`TextIndexParams:` + strings.Replace(fmt.Sprintf("%v", this.TextIndexParams), "TextIndexParams", "TextIndexParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadIndexParams_IntegerIndexParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadIndexParams_IntegerIndexParams{`,
		`IntegerIndexParams:` + strings.Replace(fmt.Sprintf("%v", this.IntegerIndexParams), "IntegerIndexParams", "IntegerIndexParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadSchemaInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadSchemaInfo{`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "PayloadIndexParams", "PayloadIndexParams", 1) + `,`,
		`Points:` + fmt.Sprintf("%v", this.Points) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayloadSchema := make([]string, 0, len(this.PayloadSchema))
	for k, _ := range this.PayloadSchema {
		keysForPayloadSchema = append(keysForPayloadSchema, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayloadSchema)
	mapStringForPayloadSchema := "map[string]*PayloadSchemaInfo{"
	for _, k := range keysForPayloadSchema {
		mapStringForPayloadSchema += fmt.Sprintf("%v: %v,", k, this.PayloadSchema[k])
	}
	mapStringForPayloadSchema += "}"
	s := strings.Join([]string{`&CollectionInfo{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`OptimizerStatus:` + strings.Replace(this.OptimizerStatus.String(), "OptimizerStatus", "OptimizerStatus", 1) + `,`,
		`VectorsCount:` + fmt.Sprintf("%v", this.VectorsCount) + `,`,
		`SegmentsCount:` + fmt.Sprintf("%v", this.SegmentsCount) + `,`,
		`Config:` + strings.Replace(this.Config.String(), "CollectionConfig", "CollectionConfig", 1) + `,`,
		`PayloadSchema:` + mapStringForPayloadSchema + `,`,
		`PointsCount:` + fmt.Sprintf("%v", this.PointsCount) + `,`,
		`IndexedVectorsCount:` + fmt.Sprintf("%v", this.IndexedVectorsCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChangeAliases) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForActions := "[]*AliasOperations{"
	for _, f := range this.Actions {
		repeatedStringForActions += strings.Replace(f.String(), "AliasOperations", "AliasOperations", 1) + ","
	}
	repeatedStringForActions += "}"
	s := strings.Join([]string{`&ChangeAliases{`,
		`Actions:` + repeatedStringForActions + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AliasOperations) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AliasOperations{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AliasOperations_CreateAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AliasOperations_CreateAlias{`,
		`CreateAlias:` + strings.Replace(fmt.Sprintf("%v", this.CreateAlias), "CreateAlias", "CreateAlias", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AliasOperations_RenameAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AliasOperations_RenameAlias{`,
		`RenameAlias:` + strings.Replace(fmt.Sprintf("%v", this.RenameAlias), "RenameAlias", "RenameAlias", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AliasOperations_DeleteAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AliasOperations_DeleteAlias{`,
		`DeleteAlias:` + strings.Replace(fmt.Sprintf("%v", this.DeleteAlias), "DeleteAlias", "DeleteAlias", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateAlias{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`AliasName:` + fmt.Sprintf("%v", this.AliasName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RenameAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RenameAlias{`,
		`OldAliasName:` + fmt.Sprintf("%v", this.OldAliasName) + `,`,
		`NewAliasName:` + fmt.Sprintf("%v", this.NewAliasName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteAlias{`,
		`AliasName:` + fmt.Sprintf("%v", this.AliasName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListAliasesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListAliasesRequest{`,
		`}`,
	}, "")
	return s
}
func (this *ListCollectionAliasesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListCollectionAliasesRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AliasDescription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AliasDescription{`,
		`AliasName:` + fmt.Sprintf("%v", this.AliasName) + `,`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListAliasesResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAliases := "[]*AliasDescription{"
	for _, f := range this.Aliases {
		repeatedStringForAliases += strings.Replace(f.String(), "AliasDescription", "AliasDescription", 1) + ","
	}
	repeatedStringForAliases += "}"
	s := strings.Join([]string{`&ListAliasesResponse{`,
		`Aliases:` + repeatedStringForAliases + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionClusterInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CollectionClusterInfoRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShardKey{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardKey_Keyword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShardKey_Keyword{`,
		`Keyword:` + fmt.Sprintf("%v", this.Keyword) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardKey_Number) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShardKey_Number{`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalShardInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalShardInfo{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`PointsCount:` + fmt.Sprintf("%v", this.PointsCount) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`ShardKey:` + strings.Replace(this.ShardKey.String(), "ShardKey", "ShardKey", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteShardInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteShardInfo{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`PeerId:` + fmt.Sprintf("%v", this.PeerId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`ShardKey:` + strings.Replace(this.ShardKey.String(), "ShardKey", "ShardKey", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardTransferInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShardTransferInfo{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`Sync:` + fmt.Sprintf("%v", this.Sync) + `,`,
		`ToShardId:` + fmt.Sprintf("%v", this.ToShardId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CollectionClusterInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLocalShards := "[]*LocalShardInfo{"
	for _, f := range this.LocalShards {
		repeatedStringForLocalShards += strings.Replace(f.String(), "LocalShardInfo", "LocalShardInfo", 1) + ","
	}
	repeatedStringForLocalShards += "}"
	repeatedStringForRemoteShards := "[]*RemoteShardInfo{"
	for _, f := range this.RemoteShards {
		repeatedStringForRemoteShards += strings.Replace(f.String(), "RemoteShardInfo", "RemoteShardInfo", 1) + ","
	}
	repeatedStringForRemoteShards += "}"
	repeatedStringForShardTransfers := "[]*ShardTransferInfo{"
	for _, f := range this.ShardTransfers {
		repeatedStringForShardTransfers += strings.Replace(f.String(), "ShardTransferInfo", "ShardTransferInfo", 1) + ","
	}
	repeatedStringForShardTransfers += "}"
	s := strings.Join([]string{`&CollectionClusterInfoResponse{`,
		`PeerId:` + fmt.Sprintf("%v", this.PeerId) + `,`,
		`ShardCount:` + fmt.Sprintf("%v", this.ShardCount) + `,`,
		`LocalShards:` + repeatedStringForLocalShards + `,`,
		`RemoteShards:` + repeatedStringForRemoteShards + `,`,
		`ShardTransfers:` + repeatedStringForShardTransfers + `,`,
		`}`,
	}, "")
	return s
}
func (this *MoveShard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MoveShard{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`FromPeerId:` + fmt.Sprintf("%v", this.FromPeerId) + `,`,
		`ToPeerId:` + fmt.Sprintf("%v", this.ToPeerId) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`ToShardId:` + fmt.Sprintf("%v", this.ToShardId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplicateShard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplicateShard{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`FromPeerId:` + fmt.Sprintf("%v", this.FromPeerId) + `,`,
		`ToPeerId:` + fmt.Sprintf("%v", this.ToPeerId) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`ToShardId:` + fmt.Sprintf("%v", this.ToShardId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AbortShardTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AbortShardTransfer{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`FromPeerId:` + fmt.Sprintf("%v", this.FromPeerId) + `,`,
		`ToPeerId:` + fmt.Sprintf("%v", this.ToPeerId) + `,`,
		`ToShardId:` + fmt.Sprintf("%v", this.ToShardId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestartTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestartTransfer{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`FromPeerId:` + fmt.Sprintf("%v", this.FromPeerId) + `,`,
		`ToPeerId:` + fmt.Sprintf("%v", this.ToPeerId) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`ToShardId:` + fmt.Sprintf("%v", this.ToShardId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Replica) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Replica{`,
		`ShardId:` + fmt.Sprintf("%v", this.ShardId) + `,`,
		`PeerId:` + fmt.Sprintf("%v", this.PeerId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateShardKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateShardKey{`,
		`ShardKey:` + strings.Replace(this.ShardKey.String(), "ShardKey", "ShardKey", 1) + `,`,
		`ShardsNumber:` + fmt.Sprintf("%v", this.ShardsNumber) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`Placement:` + fmt.Sprintf("%v", this.Placement) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteShardKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteShardKey{`,
		`ShardKey:` + strings.Replace(this.ShardKey.String(), "ShardKey", "ShardKey", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_MoveShard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_MoveShard{`,
		`MoveShard:` + strings.Replace(fmt.Sprintf("%v", this.MoveShard), "MoveShard", "MoveShard", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_ReplicateShard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_ReplicateShard{`,
		`ReplicateShard:` + strings.Replace(fmt.Sprintf("%v", this.ReplicateShard), "ReplicateShard", "ReplicateShard", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_AbortTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_AbortTransfer{`,
		`AbortTransfer:` + strings.Replace(fmt.Sprintf("%v", this.AbortTransfer), "AbortShardTransfer", "AbortShardTransfer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_DropReplica) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_DropReplica{`,
		`DropReplica:` + strings.Replace(fmt.Sprintf("%v", this.DropReplica), "Replica", "Replica", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_CreateShardKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_CreateShardKey{`,
		`CreateShardKey:` + strings.Replace(fmt.Sprintf("%v", this.CreateShardKey), "CreateShardKey", "CreateShardKey", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_DeleteShardKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_DeleteShardKey{`,
		`DeleteShardKey:` + strings.Replace(fmt.Sprintf("%v", this.DeleteShardKey), "DeleteShardKey", "DeleteShardKey", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupRequest_RestartTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupRequest_RestartTransfer{`,
		`RestartTransfer:` + strings.Replace(fmt.Sprintf("%v", this.RestartTransfer), "RestartTransfer", "RestartTransfer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateCollectionClusterSetupResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateCollectionClusterSetupResponse{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateShardKeyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateShardKeyRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Request:` + strings.Replace(this.Request.String(), "CreateShardKey", "CreateShardKey", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteShardKeyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteShardKeyRequest{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Request:` + strings.Replace(this.Request.String(), "DeleteShardKey", "DeleteShardKey", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateShardKeyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateShardKeyResponse{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteShardKeyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteShardKeyResponse{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCollections(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VectorParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			m.Distance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Distance |= Distance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HnswConfig == nil {
				m.HnswConfig = &HnswConfigDiff{}
			}
			if err := m.HnswConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuantizationConfig == nil {
				m.QuantizationConfig = &QuantizationConfig{}
			}
			if err := m.QuantizationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datatype", wireType)
			}
			m.Datatype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Datatype |= Datatype(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultivectorConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultivectorConfig == nil {
				m.MultivectorConfig = &MultiVectorConfig{}
			}
			if err := m.MultivectorConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorParamsDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorParamsDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorParamsDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HnswConfig == nil {
				m.HnswConfig = &HnswConfigDiff{}
			}
			if err := m.HnswConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuantizationConfig == nil {
				m.QuantizationConfig = &QuantizationConfigDiff{}
			}
			if err := m.QuantizationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorParamsMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorParamsMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorParamsMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*VectorParams)
			}
			var mapkey string
			var mapvalue *VectorParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollections
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCollections
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VectorParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollections(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCollections
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorParamsDiffMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorParamsDiffMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorParamsDiffMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*VectorParamsDiff)
			}
			var mapkey string
			var mapvalue *VectorParamsDiff
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollections
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCollections
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VectorParamsDiff{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollections(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCollections
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VectorsConfig_Params{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorParamsMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VectorsConfig_ParamsMap{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorsConfigDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorsConfigDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorsConfigDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorParamsDiff{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VectorsConfigDiff_Params{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorParamsDiffMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VectorsConfigDiff_ParamsMap{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseVectorParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseVectorParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseVectorParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &SparseIndexConfig{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modifier", wireType)
			}
			m.Modifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modifier |= Modifier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseVectorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseVectorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseVectorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*SparseVectorParams)
			}
			var mapkey string
			var mapvalue *SparseVectorParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollections
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCollections
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SparseVectorParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollections(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCollections
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiVectorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiVectorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiVectorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comparator", wireType)
			}
			m.Comparator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Comparator |= MultiVectorComparator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionExistsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionExistsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionExistsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionExists) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionExists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionExists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionExistsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionExistsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionExistsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &CollectionExists{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCollectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCollectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCollectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &CollectionInfo{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCollectionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCollectionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCollectionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, &CollectionDescription{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimizerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HnswConfigDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HnswConfigDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HnswConfigDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EfConstruct", wireType)
			}
			m.EfConstruct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EfConstruct |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScanThreshold", wireType)
			}
			m.FullScanThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullScanThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIndexingThreads", wireType)
			}
			m.MaxIndexingThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxIndexingThreads |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadM", wireType)
			}
			m.PayloadM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayloadM |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseIndexConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseIndexConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseIndexConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScanThreshold", wireType)
			}
			m.FullScanThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullScanThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datatype", wireType)
			}
			m.Datatype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Datatype |= Datatype(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalConfigDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalConfigDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalConfigDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalCapacityMb", wireType)
			}
			m.WalCapacityMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalCapacityMb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalSegmentsAhead", wireType)
			}
			m.WalSegmentsAhead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalSegmentsAhead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimizersConfigDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizersConfigDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizersConfigDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeletedThreshold = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VacuumMinVectorNumber", wireType)
			}
			m.VacuumMinVectorNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VacuumMinVectorNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSegmentNumber", wireType)
			}
			m.DefaultSegmentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultSegmentNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSegmentSize", wireType)
			}
			m.MaxSegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSegmentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemmapThreshold", wireType)
			}
			m.MemmapThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemmapThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexingThreshold", wireType)
			}
			m.IndexingThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexingThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushIntervalSec", wireType)
			}
			m.FlushIntervalSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushIntervalSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOptimizationThreads", wireType)
			}
			m.MaxOptimizationThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOptimizationThreads |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalarQuantization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalarQuantization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalarQuantization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= QuantizationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Quantile = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysRam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysRam = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductQuantization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductQuantization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductQuantization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= CompressionRatio(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysRam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysRam = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryQuantization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryQuantization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryQuantization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysRam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysRam = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuantizationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuantizationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuantizationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfig_Scalar{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProductQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfig_Product{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BinaryQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfig_Binary{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Disabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuantizationConfigDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuantizationConfigDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuantizationConfigDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfigDiff_Scalar{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProductQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfigDiff_Product{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Disabled{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfigDiff_Disabled{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BinaryQuantization{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Quantization = &QuantizationConfigDiff_Binary{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HnswConfig == nil {
				m.HnswConfig = &HnswConfigDiff{}
			}
			if err := m.HnswConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WalConfig == nil {
				m.WalConfig = &WalConfigDiff{}
			}
			if err := m.WalConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizersConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizersConfig == nil {
				m.OptimizersConfig = &OptimizersConfigDiff{}
			}
			if err := m.OptimizersConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardNumber", wireType)
			}
			m.ShardNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskPayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDiskPayload = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VectorsConfig == nil {
				m.VectorsConfig = &VectorsConfig{}
			}
			if err := m.VectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteConsistencyFactor", wireType)
			}
			m.WriteConsistencyFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteConsistencyFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitFromCollection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitFromCollection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuantizationConfig == nil {
				m.QuantizationConfig = &QuantizationConfig{}
			}
			if err := m.QuantizationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingMethod", wireType)
			}
			m.ShardingMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardingMethod |= ShardingMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseVectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparseVectorsConfig == nil {
				m.SparseVectorsConfig = &SparseVectorConfig{}
			}
			if err := m.SparseVectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizersConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizersConfig == nil {
				m.OptimizersConfig = &OptimizersConfigDiff{}
			}
			if err := m.OptimizersConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &CollectionParamsDiff{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HnswConfig == nil {
				m.HnswConfig = &HnswConfigDiff{}
			}
			if err := m.HnswConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VectorsConfig == nil {
				m.VectorsConfig = &VectorsConfigDiff{}
			}
			if err := m.VectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuantizationConfig == nil {
				m.QuantizationConfig = &QuantizationConfigDiff{}
			}
			if err := m.QuantizationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseVectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparseVectorsConfig == nil {
				m.SparseVectorsConfig = &SparseVectorConfig{}
			}
			if err := m.SparseVectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionOperationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionOperationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionOperationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardNumber", wireType)
			}
			m.ShardNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskPayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDiskPayload = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VectorsConfig == nil {
				m.VectorsConfig = &VectorsConfig{}
			}
			if err := m.VectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteConsistencyFactor", wireType)
			}
			m.WriteConsistencyFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteConsistencyFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadFanOutFactor", wireType)
			}
			m.ReadFanOutFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadFanOutFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingMethod", wireType)
			}
			m.ShardingMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardingMethod |= ShardingMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseVectorsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparseVectorsConfig == nil {
				m.SparseVectorsConfig = &SparseVectorConfig{}
			}
			if err := m.SparseVectorsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionParamsDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionParamsDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionParamsDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteConsistencyFactor", wireType)
			}
			m.WriteConsistencyFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteConsistencyFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskPayload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDiskPayload = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadFanOutFactor", wireType)
			}
			m.ReadFanOutFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadFanOutFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &CollectionParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HnswConfig == nil {
				m.HnswConfig = &HnswConfigDiff{}
			}
			if err := m.HnswConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizerConfig == nil {
				m.OptimizerConfig = &OptimizersConfigDiff{}
			}
			if err := m.OptimizerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WalConfig == nil {
				m.WalConfig = &WalConfigDiff{}
			}
			if err := m.WalConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuantizationConfig == nil {
				m.QuantizationConfig = &QuantizationConfig{}
			}
			if err := m.QuantizationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextIndexParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextIndexParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextIndexParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			m.Tokenizer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tokenizer |= TokenizerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lowercase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lowercase = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTokenLen", wireType)
			}
			m.MinTokenLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTokenLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTokenLen", wireType)
			}
			m.MaxTokenLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTokenLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegerIndexParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegerIndexParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegerIndexParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lookup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lookup = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Range = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadIndexParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadIndexParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadIndexParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextIndexParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TextIndexParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IndexParams = &PayloadIndexParams_TextIndexParams{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerIndexParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntegerIndexParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IndexParams = &PayloadIndexParams_IntegerIndexParams{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadSchemaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadSchemaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadSchemaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= PayloadSchemaType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &PayloadIndexParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CollectionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizerStatus == nil {
				m.OptimizerStatus = &OptimizerStatus{}
			}
			if err := m.OptimizerStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorsCount", wireType)
			}
			m.VectorsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentsCount", wireType)
			}
			m.SegmentsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &CollectionConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayloadSchema == nil {
				m.PayloadSchema = make(map[string]*PayloadSchemaInfo)
			}
			var mapkey string
			var mapvalue *PayloadSchemaInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCollections
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollections
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCollections
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PayloadSchemaInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollections(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCollections
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PayloadSchema[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsCount", wireType)
			}
			m.PointsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedVectorsCount", wireType)
			}
			m.IndexedVectorsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexedVectorsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeAliases) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeAliases: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeAliases: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &AliasOperations{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasOperations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasOperations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasOperations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateAlias{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AliasOperations_CreateAlias{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenameAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RenameAlias{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AliasOperations_RenameAlias{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteAlias{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AliasOperations_DeleteAlias{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldAliasName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldAliasName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAliasName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAliasName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAliasesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAliasesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAliasesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCollectionAliasesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCollectionAliasesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCollectionAliasesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAliasesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAliasesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAliasesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aliases = append(m.Aliases, &AliasDescription{})
			if err := m.Aliases[len(m.Aliases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = &ShardKey_Keyword{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Key = &ShardKey_Number{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalShardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalShardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalShardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsCount", wireType)
			}
			m.PointsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ReplicaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteShardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteShardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteShardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ReplicaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardTransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardTransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardTransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sync = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShardId", wireType)
			}
			m.ToShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalShards = append(m.LocalShards, &LocalShardInfo{})
			if err := m.LocalShards[len(m.LocalShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteShards = append(m.RemoteShards, &RemoteShardInfo{})
			if err := m.RemoteShards[len(m.RemoteShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardTransfers = append(m.ShardTransfers, &ShardTransferInfo{})
			if err := m.ShardTransfers[len(m.ShardTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPeerId", wireType)
			}
			m.FromPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPeerId", wireType)
			}
			m.ToPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ShardTransferMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShardId", wireType)
			}
			m.ToShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicateShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicateShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicateShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPeerId", wireType)
			}
			m.FromPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPeerId", wireType)
			}
			m.ToPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ShardTransferMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShardId", wireType)
			}
			m.ToShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortShardTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortShardTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortShardTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPeerId", wireType)
			}
			m.FromPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPeerId", wireType)
			}
			m.ToPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShardId", wireType)
			}
			m.ToShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPeerId", wireType)
			}
			m.FromPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPeerId", wireType)
			}
			m.ToPeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToPeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ShardTransferMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShardId", wireType)
			}
			m.ToShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsNumber", wireType)
			}
			m.ShardsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Placement = append(m.Placement, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCollections
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCollections
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Placement) == 0 {
					m.Placement = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollections
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Placement = append(m.Placement, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Placement", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCollectionClusterSetupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCollectionClusterSetupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCollectionClusterSetupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MoveShard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_MoveShard{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicateShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplicateShard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_ReplicateShard{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AbortShardTransfer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_AbortTransfer{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Replica{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_DropReplica{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateShardKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_CreateShardKey{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteShardKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_DeleteShardKey{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestartTransfer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &UpdateCollectionClusterSetupRequest_RestartTransfer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCollectionClusterSetupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCollectionClusterSetupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCollectionClusterSetupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &CreateShardKey{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeleteShardKey{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
