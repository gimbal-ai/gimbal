// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qdrant/points.proto

package qdrant

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WriteOrderingType int32

const (
	Weak   WriteOrderingType = 0
	Medium WriteOrderingType = 1
	Strong WriteOrderingType = 2
)

var WriteOrderingType_name = map[int32]string{
	0: "Weak",
	1: "Medium",
	2: "Strong",
}

var WriteOrderingType_value = map[string]int32{
	"Weak":   0,
	"Medium": 1,
	"Strong": 2,
}

func (WriteOrderingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{0}
}

type ReadConsistencyType int32

const (
	All      ReadConsistencyType = 0
	Majority ReadConsistencyType = 1
	Quorum   ReadConsistencyType = 2
)

var ReadConsistencyType_name = map[int32]string{
	0: "All",
	1: "Majority",
	2: "Quorum",
}

var ReadConsistencyType_value = map[string]int32{
	"All":      0,
	"Majority": 1,
	"Quorum":   2,
}

func (ReadConsistencyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{1}
}

type FieldType int32

const (
	FieldTypeKeyword  FieldType = 0
	FieldTypeInteger  FieldType = 1
	FieldTypeFloat    FieldType = 2
	FieldTypeGeo      FieldType = 3
	FieldTypeText     FieldType = 4
	FieldTypeBool     FieldType = 5
	FieldTypeDatetime FieldType = 6
)

var FieldType_name = map[int32]string{
	0: "FieldTypeKeyword",
	1: "FieldTypeInteger",
	2: "FieldTypeFloat",
	3: "FieldTypeGeo",
	4: "FieldTypeText",
	5: "FieldTypeBool",
	6: "FieldTypeDatetime",
}

var FieldType_value = map[string]int32{
	"FieldTypeKeyword":  0,
	"FieldTypeInteger":  1,
	"FieldTypeFloat":    2,
	"FieldTypeGeo":      3,
	"FieldTypeText":     4,
	"FieldTypeBool":     5,
	"FieldTypeDatetime": 6,
}

func (FieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{2}
}

type Direction int32

const (
	Asc  Direction = 0
	Desc Direction = 1
)

var Direction_name = map[int32]string{
	0: "Asc",
	1: "Desc",
}

var Direction_value = map[string]int32{
	"Asc":  0,
	"Desc": 1,
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{3}
}

type RecommendStrategy int32

const (
	AverageVector RecommendStrategy = 0
	BestScore     RecommendStrategy = 1
)

var RecommendStrategy_name = map[int32]string{
	0: "AverageVector",
	1: "BestScore",
}

var RecommendStrategy_value = map[string]int32{
	"AverageVector": 0,
	"BestScore":     1,
}

func (RecommendStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{4}
}

type Fusion int32

const (
	RRF Fusion = 0
)

var Fusion_name = map[int32]string{
	0: "RRF",
}

var Fusion_value = map[string]int32{
	"RRF": 0,
}

func (Fusion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{5}
}

type UpdateStatus int32

const (
	UnknownUpdateStatus UpdateStatus = 0
	Acknowledged        UpdateStatus = 1
	Completed           UpdateStatus = 2
	ClockRejected       UpdateStatus = 3
)

var UpdateStatus_name = map[int32]string{
	0: "UnknownUpdateStatus",
	1: "Acknowledged",
	2: "Completed",
	3: "ClockRejected",
}

var UpdateStatus_value = map[string]int32{
	"UnknownUpdateStatus": 0,
	"Acknowledged":        1,
	"Completed":           2,
	"ClockRejected":       3,
}

func (UpdateStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{6}
}

type WriteOrdering struct {
	Type WriteOrderingType `protobuf:"varint,1,opt,name=type,proto3,enum=qdrant.WriteOrderingType" json:"type,omitempty"`
}

func (m *WriteOrdering) Reset()      { *m = WriteOrdering{} }
func (*WriteOrdering) ProtoMessage() {}
func (*WriteOrdering) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{0}
}
func (m *WriteOrdering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteOrdering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteOrdering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteOrdering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteOrdering.Merge(m, src)
}
func (m *WriteOrdering) XXX_Size() int {
	return m.Size()
}
func (m *WriteOrdering) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteOrdering.DiscardUnknown(m)
}

var xxx_messageInfo_WriteOrdering proto.InternalMessageInfo

func (m *WriteOrdering) GetType() WriteOrderingType {
	if m != nil {
		return m.Type
	}
	return Weak
}

type ReadConsistency struct {
	// Types that are valid to be assigned to Value:
	//	*ReadConsistency_Type
	//	*ReadConsistency_Factor
	Value isReadConsistency_Value `protobuf_oneof:"value"`
}

func (m *ReadConsistency) Reset()      { *m = ReadConsistency{} }
func (*ReadConsistency) ProtoMessage() {}
func (*ReadConsistency) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{1}
}
func (m *ReadConsistency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadConsistency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadConsistency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadConsistency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadConsistency.Merge(m, src)
}
func (m *ReadConsistency) XXX_Size() int {
	return m.Size()
}
func (m *ReadConsistency) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadConsistency.DiscardUnknown(m)
}

var xxx_messageInfo_ReadConsistency proto.InternalMessageInfo

type isReadConsistency_Value interface {
	isReadConsistency_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadConsistency_Type struct {
	Type ReadConsistencyType `protobuf:"varint,1,opt,name=type,proto3,enum=qdrant.ReadConsistencyType,oneof" json:"type,omitempty"`
}
type ReadConsistency_Factor struct {
	Factor uint64 `protobuf:"varint,2,opt,name=factor,proto3,oneof" json:"factor,omitempty"`
}

func (*ReadConsistency_Type) isReadConsistency_Value()   {}
func (*ReadConsistency_Factor) isReadConsistency_Value() {}

func (m *ReadConsistency) GetValue() isReadConsistency_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ReadConsistency) GetType() ReadConsistencyType {
	if x, ok := m.GetValue().(*ReadConsistency_Type); ok {
		return x.Type
	}
	return All
}

func (m *ReadConsistency) GetFactor() uint64 {
	if x, ok := m.GetValue().(*ReadConsistency_Factor); ok {
		return x.Factor
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadConsistency) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadConsistency_Type)(nil),
		(*ReadConsistency_Factor)(nil),
	}
}

type PointId struct {
	// Types that are valid to be assigned to PointIdOptions:
	//	*PointId_Num
	//	*PointId_Uuid
	PointIdOptions isPointId_PointIdOptions `protobuf_oneof:"point_id_options"`
}

func (m *PointId) Reset()      { *m = PointId{} }
func (*PointId) ProtoMessage() {}
func (*PointId) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{2}
}
func (m *PointId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointId.Merge(m, src)
}
func (m *PointId) XXX_Size() int {
	return m.Size()
}
func (m *PointId) XXX_DiscardUnknown() {
	xxx_messageInfo_PointId.DiscardUnknown(m)
}

var xxx_messageInfo_PointId proto.InternalMessageInfo

type isPointId_PointIdOptions interface {
	isPointId_PointIdOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PointId_Num struct {
	Num uint64 `protobuf:"varint,1,opt,name=num,proto3,oneof" json:"num,omitempty"`
}
type PointId_Uuid struct {
	Uuid string `protobuf:"bytes,2,opt,name=uuid,proto3,oneof" json:"uuid,omitempty"`
}

func (*PointId_Num) isPointId_PointIdOptions()  {}
func (*PointId_Uuid) isPointId_PointIdOptions() {}

func (m *PointId) GetPointIdOptions() isPointId_PointIdOptions {
	if m != nil {
		return m.PointIdOptions
	}
	return nil
}

func (m *PointId) GetNum() uint64 {
	if x, ok := m.GetPointIdOptions().(*PointId_Num); ok {
		return x.Num
	}
	return 0
}

func (m *PointId) GetUuid() string {
	if x, ok := m.GetPointIdOptions().(*PointId_Uuid); ok {
		return x.Uuid
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PointId) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PointId_Num)(nil),
		(*PointId_Uuid)(nil),
	}
}

type SparseIndices struct {
	Data []uint32 `protobuf:"varint,1,rep,packed,name=data,proto3" json:"data,omitempty"`
}

func (m *SparseIndices) Reset()      { *m = SparseIndices{} }
func (*SparseIndices) ProtoMessage() {}
func (*SparseIndices) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{3}
}
func (m *SparseIndices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseIndices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseIndices.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseIndices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseIndices.Merge(m, src)
}
func (m *SparseIndices) XXX_Size() int {
	return m.Size()
}
func (m *SparseIndices) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseIndices.DiscardUnknown(m)
}

var xxx_messageInfo_SparseIndices proto.InternalMessageInfo

func (m *SparseIndices) GetData() []uint32 {
	if m != nil {
		return m.Data
	}
	return nil
}

type Vector struct {
	Data         []float32      `protobuf:"fixed32,1,rep,packed,name=data,proto3" json:"data,omitempty"`
	Indices      *SparseIndices `protobuf:"bytes,2,opt,name=indices,proto3" json:"indices,omitempty"`
	VectorsCount uint32         `protobuf:"varint,3,opt,name=vectors_count,json=vectorsCount,proto3" json:"vectors_count,omitempty"`
}

func (m *Vector) Reset()      { *m = Vector{} }
func (*Vector) ProtoMessage() {}
func (*Vector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{4}
}
func (m *Vector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector.Merge(m, src)
}
func (m *Vector) XXX_Size() int {
	return m.Size()
}
func (m *Vector) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector.DiscardUnknown(m)
}

var xxx_messageInfo_Vector proto.InternalMessageInfo

func (m *Vector) GetData() []float32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Vector) GetIndices() *SparseIndices {
	if m != nil {
		return m.Indices
	}
	return nil
}

func (m *Vector) GetVectorsCount() uint32 {
	if m != nil {
		return m.VectorsCount
	}
	return 0
}

type DenseVector struct {
	Data []float32 `protobuf:"fixed32,1,rep,packed,name=data,proto3" json:"data,omitempty"`
}

func (m *DenseVector) Reset()      { *m = DenseVector{} }
func (*DenseVector) ProtoMessage() {}
func (*DenseVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{5}
}
func (m *DenseVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenseVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenseVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenseVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenseVector.Merge(m, src)
}
func (m *DenseVector) XXX_Size() int {
	return m.Size()
}
func (m *DenseVector) XXX_DiscardUnknown() {
	xxx_messageInfo_DenseVector.DiscardUnknown(m)
}

var xxx_messageInfo_DenseVector proto.InternalMessageInfo

func (m *DenseVector) GetData() []float32 {
	if m != nil {
		return m.Data
	}
	return nil
}

type SparseVector struct {
	Values  []float32 `protobuf:"fixed32,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	Indices []uint32  `protobuf:"varint,2,rep,packed,name=indices,proto3" json:"indices,omitempty"`
}

func (m *SparseVector) Reset()      { *m = SparseVector{} }
func (*SparseVector) ProtoMessage() {}
func (*SparseVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{6}
}
func (m *SparseVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseVector.Merge(m, src)
}
func (m *SparseVector) XXX_Size() int {
	return m.Size()
}
func (m *SparseVector) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseVector.DiscardUnknown(m)
}

var xxx_messageInfo_SparseVector proto.InternalMessageInfo

func (m *SparseVector) GetValues() []float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *SparseVector) GetIndices() []uint32 {
	if m != nil {
		return m.Indices
	}
	return nil
}

type MultiDenseVector struct {
	Vectors []*DenseVector `protobuf:"bytes,1,rep,name=vectors,proto3" json:"vectors,omitempty"`
}

func (m *MultiDenseVector) Reset()      { *m = MultiDenseVector{} }
func (*MultiDenseVector) ProtoMessage() {}
func (*MultiDenseVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{7}
}
func (m *MultiDenseVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiDenseVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiDenseVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiDenseVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiDenseVector.Merge(m, src)
}
func (m *MultiDenseVector) XXX_Size() int {
	return m.Size()
}
func (m *MultiDenseVector) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiDenseVector.DiscardUnknown(m)
}

var xxx_messageInfo_MultiDenseVector proto.InternalMessageInfo

func (m *MultiDenseVector) GetVectors() []*DenseVector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

type VectorInput struct {
	// Types that are valid to be assigned to Variant:
	//	*VectorInput_Id
	//	*VectorInput_Dense
	//	*VectorInput_Sparse
	//	*VectorInput_MultiDense
	Variant isVectorInput_Variant `protobuf_oneof:"variant"`
}

func (m *VectorInput) Reset()      { *m = VectorInput{} }
func (*VectorInput) ProtoMessage() {}
func (*VectorInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{8}
}
func (m *VectorInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorInput.Merge(m, src)
}
func (m *VectorInput) XXX_Size() int {
	return m.Size()
}
func (m *VectorInput) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorInput.DiscardUnknown(m)
}

var xxx_messageInfo_VectorInput proto.InternalMessageInfo

type isVectorInput_Variant interface {
	isVectorInput_Variant()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VectorInput_Id struct {
	Id *PointId `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
}
type VectorInput_Dense struct {
	Dense *DenseVector `protobuf:"bytes,2,opt,name=dense,proto3,oneof" json:"dense,omitempty"`
}
type VectorInput_Sparse struct {
	Sparse *SparseVector `protobuf:"bytes,3,opt,name=sparse,proto3,oneof" json:"sparse,omitempty"`
}
type VectorInput_MultiDense struct {
	MultiDense *MultiDenseVector `protobuf:"bytes,4,opt,name=multi_dense,json=multiDense,proto3,oneof" json:"multi_dense,omitempty"`
}

func (*VectorInput_Id) isVectorInput_Variant()         {}
func (*VectorInput_Dense) isVectorInput_Variant()      {}
func (*VectorInput_Sparse) isVectorInput_Variant()     {}
func (*VectorInput_MultiDense) isVectorInput_Variant() {}

func (m *VectorInput) GetVariant() isVectorInput_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (m *VectorInput) GetId() *PointId {
	if x, ok := m.GetVariant().(*VectorInput_Id); ok {
		return x.Id
	}
	return nil
}

func (m *VectorInput) GetDense() *DenseVector {
	if x, ok := m.GetVariant().(*VectorInput_Dense); ok {
		return x.Dense
	}
	return nil
}

func (m *VectorInput) GetSparse() *SparseVector {
	if x, ok := m.GetVariant().(*VectorInput_Sparse); ok {
		return x.Sparse
	}
	return nil
}

func (m *VectorInput) GetMultiDense() *MultiDenseVector {
	if x, ok := m.GetVariant().(*VectorInput_MultiDense); ok {
		return x.MultiDense
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VectorInput) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VectorInput_Id)(nil),
		(*VectorInput_Dense)(nil),
		(*VectorInput_Sparse)(nil),
		(*VectorInput_MultiDense)(nil),
	}
}

type ShardKeySelector struct {
	ShardKeys []*ShardKey `protobuf:"bytes,1,rep,name=shard_keys,json=shardKeys,proto3" json:"shard_keys,omitempty"`
}

func (m *ShardKeySelector) Reset()      { *m = ShardKeySelector{} }
func (*ShardKeySelector) ProtoMessage() {}
func (*ShardKeySelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{9}
}
func (m *ShardKeySelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardKeySelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardKeySelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardKeySelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardKeySelector.Merge(m, src)
}
func (m *ShardKeySelector) XXX_Size() int {
	return m.Size()
}
func (m *ShardKeySelector) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardKeySelector.DiscardUnknown(m)
}

var xxx_messageInfo_ShardKeySelector proto.InternalMessageInfo

func (m *ShardKeySelector) GetShardKeys() []*ShardKey {
	if m != nil {
		return m.ShardKeys
	}
	return nil
}

type UpsertPoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Points           []*PointStruct    `protobuf:"bytes,3,rep,name=points,proto3" json:"points,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,5,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *UpsertPoints) Reset()      { *m = UpsertPoints{} }
func (*UpsertPoints) ProtoMessage() {}
func (*UpsertPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{10}
}
func (m *UpsertPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertPoints.Merge(m, src)
}
func (m *UpsertPoints) XXX_Size() int {
	return m.Size()
}
func (m *UpsertPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertPoints.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertPoints proto.InternalMessageInfo

func (m *UpsertPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *UpsertPoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *UpsertPoints) GetPoints() []*PointStruct {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *UpsertPoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *UpsertPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type DeletePoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Points           *PointsSelector   `protobuf:"bytes,3,opt,name=points,proto3" json:"points,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,5,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *DeletePoints) Reset()      { *m = DeletePoints{} }
func (*DeletePoints) ProtoMessage() {}
func (*DeletePoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{11}
}
func (m *DeletePoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePoints.Merge(m, src)
}
func (m *DeletePoints) XXX_Size() int {
	return m.Size()
}
func (m *DeletePoints) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePoints.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePoints proto.InternalMessageInfo

func (m *DeletePoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeletePoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *DeletePoints) GetPoints() *PointsSelector {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *DeletePoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *DeletePoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type GetPoints struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Ids              []*PointId           `protobuf:"bytes,2,rep,name=ids,proto3" json:"ids,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,4,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,5,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,6,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,7,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *GetPoints) Reset()      { *m = GetPoints{} }
func (*GetPoints) ProtoMessage() {}
func (*GetPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{12}
}
func (m *GetPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPoints.Merge(m, src)
}
func (m *GetPoints) XXX_Size() int {
	return m.Size()
}
func (m *GetPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPoints.DiscardUnknown(m)
}

var xxx_messageInfo_GetPoints proto.InternalMessageInfo

func (m *GetPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *GetPoints) GetIds() []*PointId {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *GetPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *GetPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *GetPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *GetPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type UpdatePointVectors struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Points           []*PointVectors   `protobuf:"bytes,3,rep,name=points,proto3" json:"points,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,5,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *UpdatePointVectors) Reset()      { *m = UpdatePointVectors{} }
func (*UpdatePointVectors) ProtoMessage() {}
func (*UpdatePointVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{13}
}
func (m *UpdatePointVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePointVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePointVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePointVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePointVectors.Merge(m, src)
}
func (m *UpdatePointVectors) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePointVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePointVectors.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePointVectors proto.InternalMessageInfo

func (m *UpdatePointVectors) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *UpdatePointVectors) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *UpdatePointVectors) GetPoints() []*PointVectors {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *UpdatePointVectors) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *UpdatePointVectors) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointVectors struct {
	Id      *PointId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Vectors *Vectors `protobuf:"bytes,2,opt,name=vectors,proto3" json:"vectors,omitempty"`
}

func (m *PointVectors) Reset()      { *m = PointVectors{} }
func (*PointVectors) ProtoMessage() {}
func (*PointVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{14}
}
func (m *PointVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointVectors.Merge(m, src)
}
func (m *PointVectors) XXX_Size() int {
	return m.Size()
}
func (m *PointVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_PointVectors.DiscardUnknown(m)
}

var xxx_messageInfo_PointVectors proto.InternalMessageInfo

func (m *PointVectors) GetId() *PointId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PointVectors) GetVectors() *Vectors {
	if m != nil {
		return m.Vectors
	}
	return nil
}

type DeletePointVectors struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,3,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	Vectors          *VectorsSelector  `protobuf:"bytes,4,opt,name=vectors,proto3" json:"vectors,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,5,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,6,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *DeletePointVectors) Reset()      { *m = DeletePointVectors{} }
func (*DeletePointVectors) ProtoMessage() {}
func (*DeletePointVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{15}
}
func (m *DeletePointVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePointVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePointVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePointVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePointVectors.Merge(m, src)
}
func (m *DeletePointVectors) XXX_Size() int {
	return m.Size()
}
func (m *DeletePointVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePointVectors.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePointVectors proto.InternalMessageInfo

func (m *DeletePointVectors) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeletePointVectors) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *DeletePointVectors) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *DeletePointVectors) GetVectors() *VectorsSelector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

func (m *DeletePointVectors) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *DeletePointVectors) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type SetPayloadPoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Payload          map[string]*Value `protobuf:"bytes,3,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,5,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,6,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,7,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	Key              string            `protobuf:"bytes,8,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *SetPayloadPoints) Reset()      { *m = SetPayloadPoints{} }
func (*SetPayloadPoints) ProtoMessage() {}
func (*SetPayloadPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{16}
}
func (m *SetPayloadPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetPayloadPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetPayloadPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetPayloadPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetPayloadPoints.Merge(m, src)
}
func (m *SetPayloadPoints) XXX_Size() int {
	return m.Size()
}
func (m *SetPayloadPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_SetPayloadPoints.DiscardUnknown(m)
}

var xxx_messageInfo_SetPayloadPoints proto.InternalMessageInfo

func (m *SetPayloadPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *SetPayloadPoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *SetPayloadPoints) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SetPayloadPoints) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *SetPayloadPoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *SetPayloadPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *SetPayloadPoints) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeletePayloadPoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Keys             []string          `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys,omitempty"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,5,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,6,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,7,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *DeletePayloadPoints) Reset()      { *m = DeletePayloadPoints{} }
func (*DeletePayloadPoints) ProtoMessage() {}
func (*DeletePayloadPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{17}
}
func (m *DeletePayloadPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePayloadPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePayloadPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePayloadPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePayloadPoints.Merge(m, src)
}
func (m *DeletePayloadPoints) XXX_Size() int {
	return m.Size()
}
func (m *DeletePayloadPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePayloadPoints.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePayloadPoints proto.InternalMessageInfo

func (m *DeletePayloadPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeletePayloadPoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *DeletePayloadPoints) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *DeletePayloadPoints) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *DeletePayloadPoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *DeletePayloadPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type ClearPayloadPoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool              `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Points           *PointsSelector   `protobuf:"bytes,3,opt,name=points,proto3" json:"points,omitempty"`
	Ordering         *WriteOrdering    `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,5,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *ClearPayloadPoints) Reset()      { *m = ClearPayloadPoints{} }
func (*ClearPayloadPoints) ProtoMessage() {}
func (*ClearPayloadPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{18}
}
func (m *ClearPayloadPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearPayloadPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearPayloadPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearPayloadPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearPayloadPoints.Merge(m, src)
}
func (m *ClearPayloadPoints) XXX_Size() int {
	return m.Size()
}
func (m *ClearPayloadPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearPayloadPoints.DiscardUnknown(m)
}

var xxx_messageInfo_ClearPayloadPoints proto.InternalMessageInfo

func (m *ClearPayloadPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *ClearPayloadPoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *ClearPayloadPoints) GetPoints() *PointsSelector {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *ClearPayloadPoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

func (m *ClearPayloadPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type CreateFieldIndexCollection struct {
	CollectionName   string              `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait             bool                `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	FieldName        string              `protobuf:"bytes,3,opt,name=field_name,json=fieldName,proto3" json:"field_name,omitempty"`
	FieldType        FieldType           `protobuf:"varint,4,opt,name=field_type,json=fieldType,proto3,enum=qdrant.FieldType" json:"field_type,omitempty"`
	FieldIndexParams *PayloadIndexParams `protobuf:"bytes,5,opt,name=field_index_params,json=fieldIndexParams,proto3" json:"field_index_params,omitempty"`
	Ordering         *WriteOrdering      `protobuf:"bytes,6,opt,name=ordering,proto3" json:"ordering,omitempty"`
}

func (m *CreateFieldIndexCollection) Reset()      { *m = CreateFieldIndexCollection{} }
func (*CreateFieldIndexCollection) ProtoMessage() {}
func (*CreateFieldIndexCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{19}
}
func (m *CreateFieldIndexCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFieldIndexCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFieldIndexCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateFieldIndexCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFieldIndexCollection.Merge(m, src)
}
func (m *CreateFieldIndexCollection) XXX_Size() int {
	return m.Size()
}
func (m *CreateFieldIndexCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFieldIndexCollection.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFieldIndexCollection proto.InternalMessageInfo

func (m *CreateFieldIndexCollection) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CreateFieldIndexCollection) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *CreateFieldIndexCollection) GetFieldName() string {
	if m != nil {
		return m.FieldName
	}
	return ""
}

func (m *CreateFieldIndexCollection) GetFieldType() FieldType {
	if m != nil {
		return m.FieldType
	}
	return FieldTypeKeyword
}

func (m *CreateFieldIndexCollection) GetFieldIndexParams() *PayloadIndexParams {
	if m != nil {
		return m.FieldIndexParams
	}
	return nil
}

func (m *CreateFieldIndexCollection) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

type DeleteFieldIndexCollection struct {
	CollectionName string         `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait           bool           `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	FieldName      string         `protobuf:"bytes,3,opt,name=field_name,json=fieldName,proto3" json:"field_name,omitempty"`
	Ordering       *WriteOrdering `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
}

func (m *DeleteFieldIndexCollection) Reset()      { *m = DeleteFieldIndexCollection{} }
func (*DeleteFieldIndexCollection) ProtoMessage() {}
func (*DeleteFieldIndexCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{20}
}
func (m *DeleteFieldIndexCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFieldIndexCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFieldIndexCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFieldIndexCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFieldIndexCollection.Merge(m, src)
}
func (m *DeleteFieldIndexCollection) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFieldIndexCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFieldIndexCollection.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFieldIndexCollection proto.InternalMessageInfo

func (m *DeleteFieldIndexCollection) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DeleteFieldIndexCollection) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *DeleteFieldIndexCollection) GetFieldName() string {
	if m != nil {
		return m.FieldName
	}
	return ""
}

func (m *DeleteFieldIndexCollection) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

type PayloadIncludeSelector struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *PayloadIncludeSelector) Reset()      { *m = PayloadIncludeSelector{} }
func (*PayloadIncludeSelector) ProtoMessage() {}
func (*PayloadIncludeSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{21}
}
func (m *PayloadIncludeSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadIncludeSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadIncludeSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadIncludeSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadIncludeSelector.Merge(m, src)
}
func (m *PayloadIncludeSelector) XXX_Size() int {
	return m.Size()
}
func (m *PayloadIncludeSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadIncludeSelector.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadIncludeSelector proto.InternalMessageInfo

func (m *PayloadIncludeSelector) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type PayloadExcludeSelector struct {
	Fields []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *PayloadExcludeSelector) Reset()      { *m = PayloadExcludeSelector{} }
func (*PayloadExcludeSelector) ProtoMessage() {}
func (*PayloadExcludeSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{22}
}
func (m *PayloadExcludeSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadExcludeSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadExcludeSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadExcludeSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadExcludeSelector.Merge(m, src)
}
func (m *PayloadExcludeSelector) XXX_Size() int {
	return m.Size()
}
func (m *PayloadExcludeSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadExcludeSelector.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadExcludeSelector proto.InternalMessageInfo

func (m *PayloadExcludeSelector) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type WithPayloadSelector struct {
	// Types that are valid to be assigned to SelectorOptions:
	//	*WithPayloadSelector_Enable
	//	*WithPayloadSelector_Include
	//	*WithPayloadSelector_Exclude
	SelectorOptions isWithPayloadSelector_SelectorOptions `protobuf_oneof:"selector_options"`
}

func (m *WithPayloadSelector) Reset()      { *m = WithPayloadSelector{} }
func (*WithPayloadSelector) ProtoMessage() {}
func (*WithPayloadSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{23}
}
func (m *WithPayloadSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithPayloadSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithPayloadSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithPayloadSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithPayloadSelector.Merge(m, src)
}
func (m *WithPayloadSelector) XXX_Size() int {
	return m.Size()
}
func (m *WithPayloadSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_WithPayloadSelector.DiscardUnknown(m)
}

var xxx_messageInfo_WithPayloadSelector proto.InternalMessageInfo

type isWithPayloadSelector_SelectorOptions interface {
	isWithPayloadSelector_SelectorOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WithPayloadSelector_Enable struct {
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3,oneof" json:"enable,omitempty"`
}
type WithPayloadSelector_Include struct {
	Include *PayloadIncludeSelector `protobuf:"bytes,2,opt,name=include,proto3,oneof" json:"include,omitempty"`
}
type WithPayloadSelector_Exclude struct {
	Exclude *PayloadExcludeSelector `protobuf:"bytes,3,opt,name=exclude,proto3,oneof" json:"exclude,omitempty"`
}

func (*WithPayloadSelector_Enable) isWithPayloadSelector_SelectorOptions()  {}
func (*WithPayloadSelector_Include) isWithPayloadSelector_SelectorOptions() {}
func (*WithPayloadSelector_Exclude) isWithPayloadSelector_SelectorOptions() {}

func (m *WithPayloadSelector) GetSelectorOptions() isWithPayloadSelector_SelectorOptions {
	if m != nil {
		return m.SelectorOptions
	}
	return nil
}

func (m *WithPayloadSelector) GetEnable() bool {
	if x, ok := m.GetSelectorOptions().(*WithPayloadSelector_Enable); ok {
		return x.Enable
	}
	return false
}

func (m *WithPayloadSelector) GetInclude() *PayloadIncludeSelector {
	if x, ok := m.GetSelectorOptions().(*WithPayloadSelector_Include); ok {
		return x.Include
	}
	return nil
}

func (m *WithPayloadSelector) GetExclude() *PayloadExcludeSelector {
	if x, ok := m.GetSelectorOptions().(*WithPayloadSelector_Exclude); ok {
		return x.Exclude
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WithPayloadSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WithPayloadSelector_Enable)(nil),
		(*WithPayloadSelector_Include)(nil),
		(*WithPayloadSelector_Exclude)(nil),
	}
}

type NamedVectors struct {
	Vectors map[string]*Vector `protobuf:"bytes,1,rep,name=vectors,proto3" json:"vectors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamedVectors) Reset()      { *m = NamedVectors{} }
func (*NamedVectors) ProtoMessage() {}
func (*NamedVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{24}
}
func (m *NamedVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedVectors.Merge(m, src)
}
func (m *NamedVectors) XXX_Size() int {
	return m.Size()
}
func (m *NamedVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedVectors.DiscardUnknown(m)
}

var xxx_messageInfo_NamedVectors proto.InternalMessageInfo

func (m *NamedVectors) GetVectors() map[string]*Vector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

type Vectors struct {
	// Types that are valid to be assigned to VectorsOptions:
	//	*Vectors_Vector
	//	*Vectors_Vectors
	VectorsOptions isVectors_VectorsOptions `protobuf_oneof:"vectors_options"`
}

func (m *Vectors) Reset()      { *m = Vectors{} }
func (*Vectors) ProtoMessage() {}
func (*Vectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{25}
}
func (m *Vectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vectors.Merge(m, src)
}
func (m *Vectors) XXX_Size() int {
	return m.Size()
}
func (m *Vectors) XXX_DiscardUnknown() {
	xxx_messageInfo_Vectors.DiscardUnknown(m)
}

var xxx_messageInfo_Vectors proto.InternalMessageInfo

type isVectors_VectorsOptions interface {
	isVectors_VectorsOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Vectors_Vector struct {
	Vector *Vector `protobuf:"bytes,1,opt,name=vector,proto3,oneof" json:"vector,omitempty"`
}
type Vectors_Vectors struct {
	Vectors *NamedVectors `protobuf:"bytes,2,opt,name=vectors,proto3,oneof" json:"vectors,omitempty"`
}

func (*Vectors_Vector) isVectors_VectorsOptions()  {}
func (*Vectors_Vectors) isVectors_VectorsOptions() {}

func (m *Vectors) GetVectorsOptions() isVectors_VectorsOptions {
	if m != nil {
		return m.VectorsOptions
	}
	return nil
}

func (m *Vectors) GetVector() *Vector {
	if x, ok := m.GetVectorsOptions().(*Vectors_Vector); ok {
		return x.Vector
	}
	return nil
}

func (m *Vectors) GetVectors() *NamedVectors {
	if x, ok := m.GetVectorsOptions().(*Vectors_Vectors); ok {
		return x.Vectors
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Vectors) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Vectors_Vector)(nil),
		(*Vectors_Vectors)(nil),
	}
}

type VectorsSelector struct {
	Names []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
}

func (m *VectorsSelector) Reset()      { *m = VectorsSelector{} }
func (*VectorsSelector) ProtoMessage() {}
func (*VectorsSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{26}
}
func (m *VectorsSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorsSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorsSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorsSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorsSelector.Merge(m, src)
}
func (m *VectorsSelector) XXX_Size() int {
	return m.Size()
}
func (m *VectorsSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorsSelector.DiscardUnknown(m)
}

var xxx_messageInfo_VectorsSelector proto.InternalMessageInfo

func (m *VectorsSelector) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type WithVectorsSelector struct {
	// Types that are valid to be assigned to SelectorOptions:
	//	*WithVectorsSelector_Enable
	//	*WithVectorsSelector_Include
	SelectorOptions isWithVectorsSelector_SelectorOptions `protobuf_oneof:"selector_options"`
}

func (m *WithVectorsSelector) Reset()      { *m = WithVectorsSelector{} }
func (*WithVectorsSelector) ProtoMessage() {}
func (*WithVectorsSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{27}
}
func (m *WithVectorsSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithVectorsSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithVectorsSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithVectorsSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithVectorsSelector.Merge(m, src)
}
func (m *WithVectorsSelector) XXX_Size() int {
	return m.Size()
}
func (m *WithVectorsSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_WithVectorsSelector.DiscardUnknown(m)
}

var xxx_messageInfo_WithVectorsSelector proto.InternalMessageInfo

type isWithVectorsSelector_SelectorOptions interface {
	isWithVectorsSelector_SelectorOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WithVectorsSelector_Enable struct {
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3,oneof" json:"enable,omitempty"`
}
type WithVectorsSelector_Include struct {
	Include *VectorsSelector `protobuf:"bytes,2,opt,name=include,proto3,oneof" json:"include,omitempty"`
}

func (*WithVectorsSelector_Enable) isWithVectorsSelector_SelectorOptions()  {}
func (*WithVectorsSelector_Include) isWithVectorsSelector_SelectorOptions() {}

func (m *WithVectorsSelector) GetSelectorOptions() isWithVectorsSelector_SelectorOptions {
	if m != nil {
		return m.SelectorOptions
	}
	return nil
}

func (m *WithVectorsSelector) GetEnable() bool {
	if x, ok := m.GetSelectorOptions().(*WithVectorsSelector_Enable); ok {
		return x.Enable
	}
	return false
}

func (m *WithVectorsSelector) GetInclude() *VectorsSelector {
	if x, ok := m.GetSelectorOptions().(*WithVectorsSelector_Include); ok {
		return x.Include
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WithVectorsSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WithVectorsSelector_Enable)(nil),
		(*WithVectorsSelector_Include)(nil),
	}
}

type QuantizationSearchParams struct {
	Ignore       bool    `protobuf:"varint,1,opt,name=ignore,proto3" json:"ignore,omitempty"`
	Rescore      bool    `protobuf:"varint,2,opt,name=rescore,proto3" json:"rescore,omitempty"`
	Oversampling float64 `protobuf:"fixed64,3,opt,name=oversampling,proto3" json:"oversampling,omitempty"`
}

func (m *QuantizationSearchParams) Reset()      { *m = QuantizationSearchParams{} }
func (*QuantizationSearchParams) ProtoMessage() {}
func (*QuantizationSearchParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{28}
}
func (m *QuantizationSearchParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuantizationSearchParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuantizationSearchParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuantizationSearchParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuantizationSearchParams.Merge(m, src)
}
func (m *QuantizationSearchParams) XXX_Size() int {
	return m.Size()
}
func (m *QuantizationSearchParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QuantizationSearchParams.DiscardUnknown(m)
}

var xxx_messageInfo_QuantizationSearchParams proto.InternalMessageInfo

func (m *QuantizationSearchParams) GetIgnore() bool {
	if m != nil {
		return m.Ignore
	}
	return false
}

func (m *QuantizationSearchParams) GetRescore() bool {
	if m != nil {
		return m.Rescore
	}
	return false
}

func (m *QuantizationSearchParams) GetOversampling() float64 {
	if m != nil {
		return m.Oversampling
	}
	return 0
}

type SearchParams struct {
	HnswEf       uint64                    `protobuf:"varint,1,opt,name=hnsw_ef,json=hnswEf,proto3" json:"hnsw_ef,omitempty"`
	Exact        bool                      `protobuf:"varint,2,opt,name=exact,proto3" json:"exact,omitempty"`
	Quantization *QuantizationSearchParams `protobuf:"bytes,3,opt,name=quantization,proto3" json:"quantization,omitempty"`
	IndexedOnly  bool                      `protobuf:"varint,4,opt,name=indexed_only,json=indexedOnly,proto3" json:"indexed_only,omitempty"`
}

func (m *SearchParams) Reset()      { *m = SearchParams{} }
func (*SearchParams) ProtoMessage() {}
func (*SearchParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{29}
}
func (m *SearchParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchParams.Merge(m, src)
}
func (m *SearchParams) XXX_Size() int {
	return m.Size()
}
func (m *SearchParams) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchParams.DiscardUnknown(m)
}

var xxx_messageInfo_SearchParams proto.InternalMessageInfo

func (m *SearchParams) GetHnswEf() uint64 {
	if m != nil {
		return m.HnswEf
	}
	return 0
}

func (m *SearchParams) GetExact() bool {
	if m != nil {
		return m.Exact
	}
	return false
}

func (m *SearchParams) GetQuantization() *QuantizationSearchParams {
	if m != nil {
		return m.Quantization
	}
	return nil
}

func (m *SearchParams) GetIndexedOnly() bool {
	if m != nil {
		return m.IndexedOnly
	}
	return false
}

type SearchPoints struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Vector           []float32            `protobuf:"fixed32,2,rep,packed,name=vector,proto3" json:"vector,omitempty"`
	Filter           *Filter              `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit            uint64               `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,6,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	Params           *SearchParams        `protobuf:"bytes,7,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold   float32              `protobuf:"fixed32,8,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	Offset           uint64               `protobuf:"varint,9,opt,name=offset,proto3" json:"offset,omitempty"`
	VectorName       string               `protobuf:"bytes,10,opt,name=vector_name,json=vectorName,proto3" json:"vector_name,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,11,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,12,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout          uint64               `protobuf:"varint,13,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,14,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	SparseIndices    *SparseIndices       `protobuf:"bytes,15,opt,name=sparse_indices,json=sparseIndices,proto3" json:"sparse_indices,omitempty"`
}

func (m *SearchPoints) Reset()      { *m = SearchPoints{} }
func (*SearchPoints) ProtoMessage() {}
func (*SearchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{30}
}
func (m *SearchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchPoints.Merge(m, src)
}
func (m *SearchPoints) XXX_Size() int {
	return m.Size()
}
func (m *SearchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_SearchPoints proto.InternalMessageInfo

func (m *SearchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *SearchPoints) GetVector() []float32 {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *SearchPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SearchPoints) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *SearchPoints) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SearchPoints) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *SearchPoints) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchPoints) GetVectorName() string {
	if m != nil {
		return m.VectorName
	}
	return ""
}

func (m *SearchPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *SearchPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *SearchPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SearchPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *SearchPoints) GetSparseIndices() *SparseIndices {
	if m != nil {
		return m.SparseIndices
	}
	return nil
}

type SearchBatchPoints struct {
	CollectionName  string           `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	SearchPoints    []*SearchPoints  `protobuf:"bytes,2,rep,name=search_points,json=searchPoints,proto3" json:"search_points,omitempty"`
	ReadConsistency *ReadConsistency `protobuf:"bytes,3,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout         uint64           `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *SearchBatchPoints) Reset()      { *m = SearchBatchPoints{} }
func (*SearchBatchPoints) ProtoMessage() {}
func (*SearchBatchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{31}
}
func (m *SearchBatchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBatchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBatchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBatchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBatchPoints.Merge(m, src)
}
func (m *SearchBatchPoints) XXX_Size() int {
	return m.Size()
}
func (m *SearchBatchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBatchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBatchPoints proto.InternalMessageInfo

func (m *SearchBatchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *SearchBatchPoints) GetSearchPoints() []*SearchPoints {
	if m != nil {
		return m.SearchPoints
	}
	return nil
}

func (m *SearchBatchPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *SearchBatchPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type WithLookup struct {
	Collection  string               `protobuf:"bytes,1,opt,name=collection,proto3" json:"collection,omitempty"`
	WithPayload *WithPayloadSelector `protobuf:"bytes,2,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	WithVectors *WithVectorsSelector `protobuf:"bytes,3,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
}

func (m *WithLookup) Reset()      { *m = WithLookup{} }
func (*WithLookup) ProtoMessage() {}
func (*WithLookup) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{32}
}
func (m *WithLookup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithLookup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithLookup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithLookup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithLookup.Merge(m, src)
}
func (m *WithLookup) XXX_Size() int {
	return m.Size()
}
func (m *WithLookup) XXX_DiscardUnknown() {
	xxx_messageInfo_WithLookup.DiscardUnknown(m)
}

var xxx_messageInfo_WithLookup proto.InternalMessageInfo

func (m *WithLookup) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *WithLookup) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *WithLookup) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

type SearchPointGroups struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Vector           []float32            `protobuf:"fixed32,2,rep,packed,name=vector,proto3" json:"vector,omitempty"`
	Filter           *Filter              `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit            uint32               `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,5,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	Params           *SearchParams        `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold   float32              `protobuf:"fixed32,7,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	VectorName       string               `protobuf:"bytes,8,opt,name=vector_name,json=vectorName,proto3" json:"vector_name,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,9,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	GroupBy          string               `protobuf:"bytes,10,opt,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupSize        uint32               `protobuf:"varint,11,opt,name=group_size,json=groupSize,proto3" json:"group_size,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,12,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	WithLookup       *WithLookup          `protobuf:"bytes,13,opt,name=with_lookup,json=withLookup,proto3" json:"with_lookup,omitempty"`
	Timeout          uint64               `protobuf:"varint,14,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,15,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	SparseIndices    *SparseIndices       `protobuf:"bytes,16,opt,name=sparse_indices,json=sparseIndices,proto3" json:"sparse_indices,omitempty"`
}

func (m *SearchPointGroups) Reset()      { *m = SearchPointGroups{} }
func (*SearchPointGroups) ProtoMessage() {}
func (*SearchPointGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{33}
}
func (m *SearchPointGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchPointGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchPointGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchPointGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchPointGroups.Merge(m, src)
}
func (m *SearchPointGroups) XXX_Size() int {
	return m.Size()
}
func (m *SearchPointGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchPointGroups.DiscardUnknown(m)
}

var xxx_messageInfo_SearchPointGroups proto.InternalMessageInfo

func (m *SearchPointGroups) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *SearchPointGroups) GetVector() []float32 {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *SearchPointGroups) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SearchPointGroups) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchPointGroups) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *SearchPointGroups) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *SearchPointGroups) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *SearchPointGroups) GetVectorName() string {
	if m != nil {
		return m.VectorName
	}
	return ""
}

func (m *SearchPointGroups) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *SearchPointGroups) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *SearchPointGroups) GetGroupSize() uint32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *SearchPointGroups) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *SearchPointGroups) GetWithLookup() *WithLookup {
	if m != nil {
		return m.WithLookup
	}
	return nil
}

func (m *SearchPointGroups) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SearchPointGroups) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *SearchPointGroups) GetSparseIndices() *SparseIndices {
	if m != nil {
		return m.SparseIndices
	}
	return nil
}

type StartFrom struct {
	// Types that are valid to be assigned to Value:
	//	*StartFrom_Float
	//	*StartFrom_Integer
	//	*StartFrom_Timestamp
	//	*StartFrom_Datetime
	Value isStartFrom_Value `protobuf_oneof:"value"`
}

func (m *StartFrom) Reset()      { *m = StartFrom{} }
func (*StartFrom) ProtoMessage() {}
func (*StartFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{34}
}
func (m *StartFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartFrom.Merge(m, src)
}
func (m *StartFrom) XXX_Size() int {
	return m.Size()
}
func (m *StartFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_StartFrom.DiscardUnknown(m)
}

var xxx_messageInfo_StartFrom proto.InternalMessageInfo

type isStartFrom_Value interface {
	isStartFrom_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StartFrom_Float struct {
	Float float64 `protobuf:"fixed64,1,opt,name=float,proto3,oneof" json:"float,omitempty"`
}
type StartFrom_Integer struct {
	Integer int64 `protobuf:"varint,2,opt,name=integer,proto3,oneof" json:"integer,omitempty"`
}
type StartFrom_Timestamp struct {
	Timestamp *types.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3,oneof" json:"timestamp,omitempty"`
}
type StartFrom_Datetime struct {
	Datetime string `protobuf:"bytes,4,opt,name=datetime,proto3,oneof" json:"datetime,omitempty"`
}

func (*StartFrom_Float) isStartFrom_Value()     {}
func (*StartFrom_Integer) isStartFrom_Value()   {}
func (*StartFrom_Timestamp) isStartFrom_Value() {}
func (*StartFrom_Datetime) isStartFrom_Value()  {}

func (m *StartFrom) GetValue() isStartFrom_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *StartFrom) GetFloat() float64 {
	if x, ok := m.GetValue().(*StartFrom_Float); ok {
		return x.Float
	}
	return 0
}

func (m *StartFrom) GetInteger() int64 {
	if x, ok := m.GetValue().(*StartFrom_Integer); ok {
		return x.Integer
	}
	return 0
}

func (m *StartFrom) GetTimestamp() *types.Timestamp {
	if x, ok := m.GetValue().(*StartFrom_Timestamp); ok {
		return x.Timestamp
	}
	return nil
}

func (m *StartFrom) GetDatetime() string {
	if x, ok := m.GetValue().(*StartFrom_Datetime); ok {
		return x.Datetime
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StartFrom) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StartFrom_Float)(nil),
		(*StartFrom_Integer)(nil),
		(*StartFrom_Timestamp)(nil),
		(*StartFrom_Datetime)(nil),
	}
}

type OrderBy struct {
	Key       string     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Direction Direction  `protobuf:"varint,2,opt,name=direction,proto3,enum=qdrant.Direction" json:"direction,omitempty"`
	StartFrom *StartFrom `protobuf:"bytes,3,opt,name=start_from,json=startFrom,proto3" json:"start_from,omitempty"`
}

func (m *OrderBy) Reset()      { *m = OrderBy{} }
func (*OrderBy) ProtoMessage() {}
func (*OrderBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{35}
}
func (m *OrderBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBy.Merge(m, src)
}
func (m *OrderBy) XXX_Size() int {
	return m.Size()
}
func (m *OrderBy) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBy.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBy proto.InternalMessageInfo

func (m *OrderBy) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *OrderBy) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return Asc
}

func (m *OrderBy) GetStartFrom() *StartFrom {
	if m != nil {
		return m.StartFrom
	}
	return nil
}

type ScrollPoints struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Filter           *Filter              `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	Offset           *PointId             `protobuf:"bytes,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit            uint32               `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,6,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,7,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,8,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,9,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	OrderBy          *OrderBy             `protobuf:"bytes,10,opt,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
}

func (m *ScrollPoints) Reset()      { *m = ScrollPoints{} }
func (*ScrollPoints) ProtoMessage() {}
func (*ScrollPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{36}
}
func (m *ScrollPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScrollPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScrollPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScrollPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScrollPoints.Merge(m, src)
}
func (m *ScrollPoints) XXX_Size() int {
	return m.Size()
}
func (m *ScrollPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_ScrollPoints.DiscardUnknown(m)
}

var xxx_messageInfo_ScrollPoints proto.InternalMessageInfo

func (m *ScrollPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *ScrollPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ScrollPoints) GetOffset() *PointId {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *ScrollPoints) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ScrollPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *ScrollPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *ScrollPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *ScrollPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *ScrollPoints) GetOrderBy() *OrderBy {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

type LookupLocation struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	VectorName       string            `protobuf:"bytes,2,opt,name=vector_name,json=vectorName,proto3" json:"vector_name,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,3,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *LookupLocation) Reset()      { *m = LookupLocation{} }
func (*LookupLocation) ProtoMessage() {}
func (*LookupLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{37}
}
func (m *LookupLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LookupLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LookupLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LookupLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LookupLocation.Merge(m, src)
}
func (m *LookupLocation) XXX_Size() int {
	return m.Size()
}
func (m *LookupLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_LookupLocation.DiscardUnknown(m)
}

var xxx_messageInfo_LookupLocation proto.InternalMessageInfo

func (m *LookupLocation) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *LookupLocation) GetVectorName() string {
	if m != nil {
		return m.VectorName
	}
	return ""
}

func (m *LookupLocation) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type RecommendPoints struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Positive         []*PointId           `protobuf:"bytes,2,rep,name=positive,proto3" json:"positive,omitempty"`
	Negative         []*PointId           `protobuf:"bytes,3,rep,name=negative,proto3" json:"negative,omitempty"`
	Filter           *Filter              `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit            uint64               `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,7,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	Params           *SearchParams        `protobuf:"bytes,8,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold   float32              `protobuf:"fixed32,9,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	Offset           uint64               `protobuf:"varint,10,opt,name=offset,proto3" json:"offset,omitempty"`
	Using            string               `protobuf:"bytes,11,opt,name=using,proto3" json:"using,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,12,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	LookupFrom       *LookupLocation      `protobuf:"bytes,13,opt,name=lookup_from,json=lookupFrom,proto3" json:"lookup_from,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,14,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Strategy         RecommendStrategy    `protobuf:"varint,16,opt,name=strategy,proto3,enum=qdrant.RecommendStrategy" json:"strategy,omitempty"`
	PositiveVectors  []*Vector            `protobuf:"bytes,17,rep,name=positive_vectors,json=positiveVectors,proto3" json:"positive_vectors,omitempty"`
	NegativeVectors  []*Vector            `protobuf:"bytes,18,rep,name=negative_vectors,json=negativeVectors,proto3" json:"negative_vectors,omitempty"`
	Timeout          uint64               `protobuf:"varint,19,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,20,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *RecommendPoints) Reset()      { *m = RecommendPoints{} }
func (*RecommendPoints) ProtoMessage() {}
func (*RecommendPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{38}
}
func (m *RecommendPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendPoints.Merge(m, src)
}
func (m *RecommendPoints) XXX_Size() int {
	return m.Size()
}
func (m *RecommendPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendPoints.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendPoints proto.InternalMessageInfo

func (m *RecommendPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *RecommendPoints) GetPositive() []*PointId {
	if m != nil {
		return m.Positive
	}
	return nil
}

func (m *RecommendPoints) GetNegative() []*PointId {
	if m != nil {
		return m.Negative
	}
	return nil
}

func (m *RecommendPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *RecommendPoints) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RecommendPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *RecommendPoints) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RecommendPoints) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *RecommendPoints) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RecommendPoints) GetUsing() string {
	if m != nil {
		return m.Using
	}
	return ""
}

func (m *RecommendPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *RecommendPoints) GetLookupFrom() *LookupLocation {
	if m != nil {
		return m.LookupFrom
	}
	return nil
}

func (m *RecommendPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *RecommendPoints) GetStrategy() RecommendStrategy {
	if m != nil {
		return m.Strategy
	}
	return AverageVector
}

func (m *RecommendPoints) GetPositiveVectors() []*Vector {
	if m != nil {
		return m.PositiveVectors
	}
	return nil
}

func (m *RecommendPoints) GetNegativeVectors() []*Vector {
	if m != nil {
		return m.NegativeVectors
	}
	return nil
}

func (m *RecommendPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RecommendPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type RecommendBatchPoints struct {
	CollectionName  string             `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	RecommendPoints []*RecommendPoints `protobuf:"bytes,2,rep,name=recommend_points,json=recommendPoints,proto3" json:"recommend_points,omitempty"`
	ReadConsistency *ReadConsistency   `protobuf:"bytes,3,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout         uint64             `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *RecommendBatchPoints) Reset()      { *m = RecommendBatchPoints{} }
func (*RecommendBatchPoints) ProtoMessage() {}
func (*RecommendBatchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{39}
}
func (m *RecommendBatchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendBatchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendBatchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendBatchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendBatchPoints.Merge(m, src)
}
func (m *RecommendBatchPoints) XXX_Size() int {
	return m.Size()
}
func (m *RecommendBatchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendBatchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendBatchPoints proto.InternalMessageInfo

func (m *RecommendBatchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *RecommendBatchPoints) GetRecommendPoints() []*RecommendPoints {
	if m != nil {
		return m.RecommendPoints
	}
	return nil
}

func (m *RecommendBatchPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *RecommendBatchPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type RecommendPointGroups struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Positive         []*PointId           `protobuf:"bytes,2,rep,name=positive,proto3" json:"positive,omitempty"`
	Negative         []*PointId           `protobuf:"bytes,3,rep,name=negative,proto3" json:"negative,omitempty"`
	Filter           *Filter              `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit            uint32               `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,6,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	Params           *SearchParams        `protobuf:"bytes,7,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold   float32              `protobuf:"fixed32,8,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	Using            string               `protobuf:"bytes,9,opt,name=using,proto3" json:"using,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,10,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	LookupFrom       *LookupLocation      `protobuf:"bytes,11,opt,name=lookup_from,json=lookupFrom,proto3" json:"lookup_from,omitempty"`
	GroupBy          string               `protobuf:"bytes,12,opt,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupSize        uint32               `protobuf:"varint,13,opt,name=group_size,json=groupSize,proto3" json:"group_size,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,14,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	WithLookup       *WithLookup          `protobuf:"bytes,15,opt,name=with_lookup,json=withLookup,proto3" json:"with_lookup,omitempty"`
	Strategy         RecommendStrategy    `protobuf:"varint,17,opt,name=strategy,proto3,enum=qdrant.RecommendStrategy" json:"strategy,omitempty"`
	PositiveVectors  []*Vector            `protobuf:"bytes,18,rep,name=positive_vectors,json=positiveVectors,proto3" json:"positive_vectors,omitempty"`
	NegativeVectors  []*Vector            `protobuf:"bytes,19,rep,name=negative_vectors,json=negativeVectors,proto3" json:"negative_vectors,omitempty"`
	Timeout          uint64               `protobuf:"varint,20,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,21,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *RecommendPointGroups) Reset()      { *m = RecommendPointGroups{} }
func (*RecommendPointGroups) ProtoMessage() {}
func (*RecommendPointGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{40}
}
func (m *RecommendPointGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendPointGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendPointGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendPointGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendPointGroups.Merge(m, src)
}
func (m *RecommendPointGroups) XXX_Size() int {
	return m.Size()
}
func (m *RecommendPointGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendPointGroups.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendPointGroups proto.InternalMessageInfo

func (m *RecommendPointGroups) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *RecommendPointGroups) GetPositive() []*PointId {
	if m != nil {
		return m.Positive
	}
	return nil
}

func (m *RecommendPointGroups) GetNegative() []*PointId {
	if m != nil {
		return m.Negative
	}
	return nil
}

func (m *RecommendPointGroups) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *RecommendPointGroups) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RecommendPointGroups) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *RecommendPointGroups) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *RecommendPointGroups) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *RecommendPointGroups) GetUsing() string {
	if m != nil {
		return m.Using
	}
	return ""
}

func (m *RecommendPointGroups) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *RecommendPointGroups) GetLookupFrom() *LookupLocation {
	if m != nil {
		return m.LookupFrom
	}
	return nil
}

func (m *RecommendPointGroups) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *RecommendPointGroups) GetGroupSize() uint32 {
	if m != nil {
		return m.GroupSize
	}
	return 0
}

func (m *RecommendPointGroups) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *RecommendPointGroups) GetWithLookup() *WithLookup {
	if m != nil {
		return m.WithLookup
	}
	return nil
}

func (m *RecommendPointGroups) GetStrategy() RecommendStrategy {
	if m != nil {
		return m.Strategy
	}
	return AverageVector
}

func (m *RecommendPointGroups) GetPositiveVectors() []*Vector {
	if m != nil {
		return m.PositiveVectors
	}
	return nil
}

func (m *RecommendPointGroups) GetNegativeVectors() []*Vector {
	if m != nil {
		return m.NegativeVectors
	}
	return nil
}

func (m *RecommendPointGroups) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RecommendPointGroups) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type TargetVector struct {
	// Types that are valid to be assigned to Target:
	//
	//	*TargetVector_Single
	Target isTargetVector_Target `protobuf_oneof:"target"`
}

func (m *TargetVector) Reset()      { *m = TargetVector{} }
func (*TargetVector) ProtoMessage() {}
func (*TargetVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{41}
}
func (m *TargetVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetVector.Merge(m, src)
}
func (m *TargetVector) XXX_Size() int {
	return m.Size()
}
func (m *TargetVector) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetVector.DiscardUnknown(m)
}

var xxx_messageInfo_TargetVector proto.InternalMessageInfo

type isTargetVector_Target interface {
	isTargetVector_Target()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TargetVector_Single struct {
	Single *VectorExample `protobuf:"bytes,1,opt,name=single,proto3,oneof" json:"single,omitempty"`
}

func (*TargetVector_Single) isTargetVector_Target() {}

func (m *TargetVector) GetTarget() isTargetVector_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *TargetVector) GetSingle() *VectorExample {
	if x, ok := m.GetTarget().(*TargetVector_Single); ok {
		return x.Single
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TargetVector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TargetVector_Single)(nil),
	}
}

type VectorExample struct {
	// Types that are valid to be assigned to Example:
	//
	//	*VectorExample_Id
	//	*VectorExample_Vector
	Example isVectorExample_Example `protobuf_oneof:"example"`
}

func (m *VectorExample) Reset()      { *m = VectorExample{} }
func (*VectorExample) ProtoMessage() {}
func (*VectorExample) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{42}
}
func (m *VectorExample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorExample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorExample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VectorExample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorExample.Merge(m, src)
}
func (m *VectorExample) XXX_Size() int {
	return m.Size()
}
func (m *VectorExample) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorExample.DiscardUnknown(m)
}

var xxx_messageInfo_VectorExample proto.InternalMessageInfo

type isVectorExample_Example interface {
	isVectorExample_Example()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VectorExample_Id struct {
	Id *PointId `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
}
type VectorExample_Vector struct {
	Vector *Vector `protobuf:"bytes,2,opt,name=vector,proto3,oneof" json:"vector,omitempty"`
}

func (*VectorExample_Id) isVectorExample_Example()     {}
func (*VectorExample_Vector) isVectorExample_Example() {}

func (m *VectorExample) GetExample() isVectorExample_Example {
	if m != nil {
		return m.Example
	}
	return nil
}

func (m *VectorExample) GetId() *PointId {
	if x, ok := m.GetExample().(*VectorExample_Id); ok {
		return x.Id
	}
	return nil
}

func (m *VectorExample) GetVector() *Vector {
	if x, ok := m.GetExample().(*VectorExample_Vector); ok {
		return x.Vector
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VectorExample) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VectorExample_Id)(nil),
		(*VectorExample_Vector)(nil),
	}
}

type ContextExamplePair struct {
	Positive *VectorExample `protobuf:"bytes,1,opt,name=positive,proto3" json:"positive,omitempty"`
	Negative *VectorExample `protobuf:"bytes,2,opt,name=negative,proto3" json:"negative,omitempty"`
}

func (m *ContextExamplePair) Reset()      { *m = ContextExamplePair{} }
func (*ContextExamplePair) ProtoMessage() {}
func (*ContextExamplePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{43}
}
func (m *ContextExamplePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextExamplePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextExamplePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextExamplePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextExamplePair.Merge(m, src)
}
func (m *ContextExamplePair) XXX_Size() int {
	return m.Size()
}
func (m *ContextExamplePair) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextExamplePair.DiscardUnknown(m)
}

var xxx_messageInfo_ContextExamplePair proto.InternalMessageInfo

func (m *ContextExamplePair) GetPositive() *VectorExample {
	if m != nil {
		return m.Positive
	}
	return nil
}

func (m *ContextExamplePair) GetNegative() *VectorExample {
	if m != nil {
		return m.Negative
	}
	return nil
}

type DiscoverPoints struct {
	CollectionName   string                `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Target           *TargetVector         `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Context          []*ContextExamplePair `protobuf:"bytes,3,rep,name=context,proto3" json:"context,omitempty"`
	Filter           *Filter               `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit            uint64                `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	WithPayload      *WithPayloadSelector  `protobuf:"bytes,6,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	Params           *SearchParams         `protobuf:"bytes,7,opt,name=params,proto3" json:"params,omitempty"`
	Offset           uint64                `protobuf:"varint,8,opt,name=offset,proto3" json:"offset,omitempty"`
	Using            string                `protobuf:"bytes,9,opt,name=using,proto3" json:"using,omitempty"`
	WithVectors      *WithVectorsSelector  `protobuf:"bytes,10,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	LookupFrom       *LookupLocation       `protobuf:"bytes,11,opt,name=lookup_from,json=lookupFrom,proto3" json:"lookup_from,omitempty"`
	ReadConsistency  *ReadConsistency      `protobuf:"bytes,12,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout          uint64                `protobuf:"varint,13,opt,name=timeout,proto3" json:"timeout,omitempty"`
	ShardKeySelector *ShardKeySelector     `protobuf:"bytes,14,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *DiscoverPoints) Reset()      { *m = DiscoverPoints{} }
func (*DiscoverPoints) ProtoMessage() {}
func (*DiscoverPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{44}
}
func (m *DiscoverPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverPoints.Merge(m, src)
}
func (m *DiscoverPoints) XXX_Size() int {
	return m.Size()
}
func (m *DiscoverPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverPoints.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverPoints proto.InternalMessageInfo

func (m *DiscoverPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DiscoverPoints) GetTarget() *TargetVector {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *DiscoverPoints) GetContext() []*ContextExamplePair {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DiscoverPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *DiscoverPoints) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *DiscoverPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *DiscoverPoints) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *DiscoverPoints) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DiscoverPoints) GetUsing() string {
	if m != nil {
		return m.Using
	}
	return ""
}

func (m *DiscoverPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *DiscoverPoints) GetLookupFrom() *LookupLocation {
	if m != nil {
		return m.LookupFrom
	}
	return nil
}

func (m *DiscoverPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *DiscoverPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *DiscoverPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type DiscoverBatchPoints struct {
	CollectionName  string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	DiscoverPoints  []*DiscoverPoints `protobuf:"bytes,2,rep,name=discover_points,json=discoverPoints,proto3" json:"discover_points,omitempty"`
	ReadConsistency *ReadConsistency  `protobuf:"bytes,3,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout         uint64            `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *DiscoverBatchPoints) Reset()      { *m = DiscoverBatchPoints{} }
func (*DiscoverBatchPoints) ProtoMessage() {}
func (*DiscoverBatchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{45}
}
func (m *DiscoverBatchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverBatchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverBatchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverBatchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverBatchPoints.Merge(m, src)
}
func (m *DiscoverBatchPoints) XXX_Size() int {
	return m.Size()
}
func (m *DiscoverBatchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverBatchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverBatchPoints proto.InternalMessageInfo

func (m *DiscoverBatchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *DiscoverBatchPoints) GetDiscoverPoints() []*DiscoverPoints {
	if m != nil {
		return m.DiscoverPoints
	}
	return nil
}

func (m *DiscoverBatchPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *DiscoverBatchPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type CountPoints struct {
	CollectionName   string            `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Filter           *Filter           `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	Exact            bool              `protobuf:"varint,3,opt,name=exact,proto3" json:"exact,omitempty"`
	ReadConsistency  *ReadConsistency  `protobuf:"bytes,4,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,5,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *CountPoints) Reset()      { *m = CountPoints{} }
func (*CountPoints) ProtoMessage() {}
func (*CountPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{46}
}
func (m *CountPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountPoints.Merge(m, src)
}
func (m *CountPoints) XXX_Size() int {
	return m.Size()
}
func (m *CountPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_CountPoints.DiscardUnknown(m)
}

var xxx_messageInfo_CountPoints proto.InternalMessageInfo

func (m *CountPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *CountPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *CountPoints) GetExact() bool {
	if m != nil {
		return m.Exact
	}
	return false
}

func (m *CountPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *CountPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type RecommendInput struct {
	Positive []*VectorInput    `protobuf:"bytes,1,rep,name=positive,proto3" json:"positive,omitempty"`
	Negative []*VectorInput    `protobuf:"bytes,2,rep,name=negative,proto3" json:"negative,omitempty"`
	Strategy RecommendStrategy `protobuf:"varint,3,opt,name=strategy,proto3,enum=qdrant.RecommendStrategy" json:"strategy,omitempty"`
}

func (m *RecommendInput) Reset()      { *m = RecommendInput{} }
func (*RecommendInput) ProtoMessage() {}
func (*RecommendInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{47}
}
func (m *RecommendInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendInput.Merge(m, src)
}
func (m *RecommendInput) XXX_Size() int {
	return m.Size()
}
func (m *RecommendInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendInput.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendInput proto.InternalMessageInfo

func (m *RecommendInput) GetPositive() []*VectorInput {
	if m != nil {
		return m.Positive
	}
	return nil
}

func (m *RecommendInput) GetNegative() []*VectorInput {
	if m != nil {
		return m.Negative
	}
	return nil
}

func (m *RecommendInput) GetStrategy() RecommendStrategy {
	if m != nil {
		return m.Strategy
	}
	return AverageVector
}

type ContextInputPair struct {
	Positive *VectorInput `protobuf:"bytes,1,opt,name=positive,proto3" json:"positive,omitempty"`
	Negative *VectorInput `protobuf:"bytes,2,opt,name=negative,proto3" json:"negative,omitempty"`
}

func (m *ContextInputPair) Reset()      { *m = ContextInputPair{} }
func (*ContextInputPair) ProtoMessage() {}
func (*ContextInputPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{48}
}
func (m *ContextInputPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextInputPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextInputPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextInputPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextInputPair.Merge(m, src)
}
func (m *ContextInputPair) XXX_Size() int {
	return m.Size()
}
func (m *ContextInputPair) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextInputPair.DiscardUnknown(m)
}

var xxx_messageInfo_ContextInputPair proto.InternalMessageInfo

func (m *ContextInputPair) GetPositive() *VectorInput {
	if m != nil {
		return m.Positive
	}
	return nil
}

func (m *ContextInputPair) GetNegative() *VectorInput {
	if m != nil {
		return m.Negative
	}
	return nil
}

type DiscoverInput struct {
	Target  *VectorInput  `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	Context *ContextInput `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *DiscoverInput) Reset()      { *m = DiscoverInput{} }
func (*DiscoverInput) ProtoMessage() {}
func (*DiscoverInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{49}
}
func (m *DiscoverInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverInput.Merge(m, src)
}
func (m *DiscoverInput) XXX_Size() int {
	return m.Size()
}
func (m *DiscoverInput) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverInput.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverInput proto.InternalMessageInfo

func (m *DiscoverInput) GetTarget() *VectorInput {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *DiscoverInput) GetContext() *ContextInput {
	if m != nil {
		return m.Context
	}
	return nil
}

type ContextInput struct {
	Pairs []*ContextInputPair `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs,omitempty"`
}

func (m *ContextInput) Reset()      { *m = ContextInput{} }
func (*ContextInput) ProtoMessage() {}
func (*ContextInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{50}
}
func (m *ContextInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextInput.Merge(m, src)
}
func (m *ContextInput) XXX_Size() int {
	return m.Size()
}
func (m *ContextInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextInput.DiscardUnknown(m)
}

var xxx_messageInfo_ContextInput proto.InternalMessageInfo

func (m *ContextInput) GetPairs() []*ContextInputPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type Query struct {
	// Types that are valid to be assigned to Variant:
	//
	//	*Query_Nearest
	//	*Query_Recommend
	//	*Query_Discover
	//	*Query_Context
	//	*Query_OrderBy
	//	*Query_Fusion
	Variant isQuery_Variant `protobuf_oneof:"variant"`
}

func (m *Query) Reset()      { *m = Query{} }
func (*Query) ProtoMessage() {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{51}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.Size()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

type isQuery_Variant interface {
	isQuery_Variant()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Query_Nearest struct {
	Nearest *VectorInput `protobuf:"bytes,1,opt,name=nearest,proto3,oneof" json:"nearest,omitempty"`
}
type Query_Recommend struct {
	Recommend *RecommendInput `protobuf:"bytes,2,opt,name=recommend,proto3,oneof" json:"recommend,omitempty"`
}
type Query_Discover struct {
	Discover *DiscoverInput `protobuf:"bytes,3,opt,name=discover,proto3,oneof" json:"discover,omitempty"`
}
type Query_Context struct {
	Context *ContextInput `protobuf:"bytes,4,opt,name=context,proto3,oneof" json:"context,omitempty"`
}
type Query_OrderBy struct {
	OrderBy *OrderBy `protobuf:"bytes,5,opt,name=order_by,json=orderBy,proto3,oneof" json:"order_by,omitempty"`
}
type Query_Fusion struct {
	Fusion Fusion `protobuf:"varint,6,opt,name=fusion,proto3,enum=qdrant.Fusion,oneof" json:"fusion,omitempty"`
}

func (*Query_Nearest) isQuery_Variant()   {}
func (*Query_Recommend) isQuery_Variant() {}
func (*Query_Discover) isQuery_Variant()  {}
func (*Query_Context) isQuery_Variant()   {}
func (*Query_OrderBy) isQuery_Variant()   {}
func (*Query_Fusion) isQuery_Variant()    {}

func (m *Query) GetVariant() isQuery_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (m *Query) GetNearest() *VectorInput {
	if x, ok := m.GetVariant().(*Query_Nearest); ok {
		return x.Nearest
	}
	return nil
}

func (m *Query) GetRecommend() *RecommendInput {
	if x, ok := m.GetVariant().(*Query_Recommend); ok {
		return x.Recommend
	}
	return nil
}

func (m *Query) GetDiscover() *DiscoverInput {
	if x, ok := m.GetVariant().(*Query_Discover); ok {
		return x.Discover
	}
	return nil
}

func (m *Query) GetContext() *ContextInput {
	if x, ok := m.GetVariant().(*Query_Context); ok {
		return x.Context
	}
	return nil
}

func (m *Query) GetOrderBy() *OrderBy {
	if x, ok := m.GetVariant().(*Query_OrderBy); ok {
		return x.OrderBy
	}
	return nil
}

func (m *Query) GetFusion() Fusion {
	if x, ok := m.GetVariant().(*Query_Fusion); ok {
		return x.Fusion
	}
	return RRF
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Query) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Query_Nearest)(nil),
		(*Query_Recommend)(nil),
		(*Query_Discover)(nil),
		(*Query_Context)(nil),
		(*Query_OrderBy)(nil),
		(*Query_Fusion)(nil),
	}
}

type PrefetchQuery struct {
	Prefetch       []*PrefetchQuery `protobuf:"bytes,1,rep,name=prefetch,proto3" json:"prefetch,omitempty"`
	Query          *Query           `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Using          string           `protobuf:"bytes,3,opt,name=using,proto3" json:"using,omitempty"`
	Filter         *Filter          `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Params         *SearchParams    `protobuf:"bytes,5,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold float32          `protobuf:"fixed32,6,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	Limit          uint64           `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	LookupFrom     *LookupLocation  `protobuf:"bytes,8,opt,name=lookup_from,json=lookupFrom,proto3" json:"lookup_from,omitempty"`
}

func (m *PrefetchQuery) Reset()      { *m = PrefetchQuery{} }
func (*PrefetchQuery) ProtoMessage() {}
func (*PrefetchQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{52}
}
func (m *PrefetchQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrefetchQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrefetchQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrefetchQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefetchQuery.Merge(m, src)
}
func (m *PrefetchQuery) XXX_Size() int {
	return m.Size()
}
func (m *PrefetchQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefetchQuery.DiscardUnknown(m)
}

var xxx_messageInfo_PrefetchQuery proto.InternalMessageInfo

func (m *PrefetchQuery) GetPrefetch() []*PrefetchQuery {
	if m != nil {
		return m.Prefetch
	}
	return nil
}

func (m *PrefetchQuery) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *PrefetchQuery) GetUsing() string {
	if m != nil {
		return m.Using
	}
	return ""
}

func (m *PrefetchQuery) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *PrefetchQuery) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *PrefetchQuery) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *PrefetchQuery) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PrefetchQuery) GetLookupFrom() *LookupLocation {
	if m != nil {
		return m.LookupFrom
	}
	return nil
}

type QueryPoints struct {
	CollectionName   string               `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Prefetch         []*PrefetchQuery     `protobuf:"bytes,2,rep,name=prefetch,proto3" json:"prefetch,omitempty"`
	Query            *Query               `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	Using            string               `protobuf:"bytes,4,opt,name=using,proto3" json:"using,omitempty"`
	Filter           *Filter              `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
	Params           *SearchParams        `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
	ScoreThreshold   float32              `protobuf:"fixed32,7,opt,name=score_threshold,json=scoreThreshold,proto3" json:"score_threshold,omitempty"`
	Limit            uint64               `protobuf:"varint,8,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset           uint64               `protobuf:"varint,9,opt,name=offset,proto3" json:"offset,omitempty"`
	WithVectors      *WithVectorsSelector `protobuf:"bytes,10,opt,name=with_vectors,json=withVectors,proto3" json:"with_vectors,omitempty"`
	WithPayload      *WithPayloadSelector `protobuf:"bytes,11,opt,name=with_payload,json=withPayload,proto3" json:"with_payload,omitempty"`
	ReadConsistency  *ReadConsistency     `protobuf:"bytes,12,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	ShardKeySelector *ShardKeySelector    `protobuf:"bytes,13,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	LookupFrom       *LookupLocation      `protobuf:"bytes,14,opt,name=lookup_from,json=lookupFrom,proto3" json:"lookup_from,omitempty"`
	Timeout          uint64               `protobuf:"varint,15,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *QueryPoints) Reset()      { *m = QueryPoints{} }
func (*QueryPoints) ProtoMessage() {}
func (*QueryPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{53}
}
func (m *QueryPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPoints.Merge(m, src)
}
func (m *QueryPoints) XXX_Size() int {
	return m.Size()
}
func (m *QueryPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPoints.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPoints proto.InternalMessageInfo

func (m *QueryPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *QueryPoints) GetPrefetch() []*PrefetchQuery {
	if m != nil {
		return m.Prefetch
	}
	return nil
}

func (m *QueryPoints) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *QueryPoints) GetUsing() string {
	if m != nil {
		return m.Using
	}
	return ""
}

func (m *QueryPoints) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *QueryPoints) GetParams() *SearchParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *QueryPoints) GetScoreThreshold() float32 {
	if m != nil {
		return m.ScoreThreshold
	}
	return 0
}

func (m *QueryPoints) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *QueryPoints) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *QueryPoints) GetWithVectors() *WithVectorsSelector {
	if m != nil {
		return m.WithVectors
	}
	return nil
}

func (m *QueryPoints) GetWithPayload() *WithPayloadSelector {
	if m != nil {
		return m.WithPayload
	}
	return nil
}

func (m *QueryPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *QueryPoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *QueryPoints) GetLookupFrom() *LookupLocation {
	if m != nil {
		return m.LookupFrom
	}
	return nil
}

func (m *QueryPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type QueryBatchPoints struct {
	CollectionName  string           `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	QueryPoints     []*QueryPoints   `protobuf:"bytes,2,rep,name=query_points,json=queryPoints,proto3" json:"query_points,omitempty"`
	ReadConsistency *ReadConsistency `protobuf:"bytes,3,opt,name=read_consistency,json=readConsistency,proto3" json:"read_consistency,omitempty"`
	Timeout         uint64           `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *QueryBatchPoints) Reset()      { *m = QueryBatchPoints{} }
func (*QueryBatchPoints) ProtoMessage() {}
func (*QueryBatchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{54}
}
func (m *QueryBatchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBatchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBatchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBatchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBatchPoints.Merge(m, src)
}
func (m *QueryBatchPoints) XXX_Size() int {
	return m.Size()
}
func (m *QueryBatchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBatchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBatchPoints proto.InternalMessageInfo

func (m *QueryBatchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *QueryBatchPoints) GetQueryPoints() []*QueryPoints {
	if m != nil {
		return m.QueryPoints
	}
	return nil
}

func (m *QueryBatchPoints) GetReadConsistency() *ReadConsistency {
	if m != nil {
		return m.ReadConsistency
	}
	return nil
}

func (m *QueryBatchPoints) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type PointsUpdateOperation struct {
	// Types that are valid to be assigned to Operation:
	//
	//	*PointsUpdateOperation_Upsert
	//	*PointsUpdateOperation_DeleteDeprecated
	//	*PointsUpdateOperation_SetPayload_
	//	*PointsUpdateOperation_OverwritePayload_
	//	*PointsUpdateOperation_DeletePayload_
	//	*PointsUpdateOperation_ClearPayloadDeprecated
	//	*PointsUpdateOperation_UpdateVectors_
	//	*PointsUpdateOperation_DeleteVectors_
	//	*PointsUpdateOperation_DeletePoints_
	//	*PointsUpdateOperation_ClearPayload_
	Operation isPointsUpdateOperation_Operation `protobuf_oneof:"operation"`
}

func (m *PointsUpdateOperation) Reset()      { *m = PointsUpdateOperation{} }
func (*PointsUpdateOperation) ProtoMessage() {}
func (*PointsUpdateOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55}
}
func (m *PointsUpdateOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation.Merge(m, src)
}
func (m *PointsUpdateOperation) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation proto.InternalMessageInfo

type isPointsUpdateOperation_Operation interface {
	isPointsUpdateOperation_Operation()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PointsUpdateOperation_Upsert struct {
	Upsert *PointsUpdateOperation_PointStructList `protobuf:"bytes,1,opt,name=upsert,proto3,oneof" json:"upsert,omitempty"`
}
type PointsUpdateOperation_DeleteDeprecated struct {
	DeleteDeprecated *PointsSelector `protobuf:"bytes,2,opt,name=delete_deprecated,json=deleteDeprecated,proto3,oneof" json:"delete_deprecated,omitempty"`
}
type PointsUpdateOperation_SetPayload_ struct {
	SetPayload *PointsUpdateOperation_SetPayload `protobuf:"bytes,3,opt,name=set_payload,json=setPayload,proto3,oneof" json:"set_payload,omitempty"`
}
type PointsUpdateOperation_OverwritePayload_ struct {
	OverwritePayload *PointsUpdateOperation_OverwritePayload `protobuf:"bytes,4,opt,name=overwrite_payload,json=overwritePayload,proto3,oneof" json:"overwrite_payload,omitempty"`
}
type PointsUpdateOperation_DeletePayload_ struct {
	DeletePayload *PointsUpdateOperation_DeletePayload `protobuf:"bytes,5,opt,name=delete_payload,json=deletePayload,proto3,oneof" json:"delete_payload,omitempty"`
}
type PointsUpdateOperation_ClearPayloadDeprecated struct {
	ClearPayloadDeprecated *PointsSelector `protobuf:"bytes,6,opt,name=clear_payload_deprecated,json=clearPayloadDeprecated,proto3,oneof" json:"clear_payload_deprecated,omitempty"`
}
type PointsUpdateOperation_UpdateVectors_ struct {
	UpdateVectors *PointsUpdateOperation_UpdateVectors `protobuf:"bytes,7,opt,name=update_vectors,json=updateVectors,proto3,oneof" json:"update_vectors,omitempty"`
}
type PointsUpdateOperation_DeleteVectors_ struct {
	DeleteVectors *PointsUpdateOperation_DeleteVectors `protobuf:"bytes,8,opt,name=delete_vectors,json=deleteVectors,proto3,oneof" json:"delete_vectors,omitempty"`
}
type PointsUpdateOperation_DeletePoints_ struct {
	DeletePoints *PointsUpdateOperation_DeletePoints `protobuf:"bytes,9,opt,name=delete_points,json=deletePoints,proto3,oneof" json:"delete_points,omitempty"`
}
type PointsUpdateOperation_ClearPayload_ struct {
	ClearPayload *PointsUpdateOperation_ClearPayload `protobuf:"bytes,10,opt,name=clear_payload,json=clearPayload,proto3,oneof" json:"clear_payload,omitempty"`
}

func (*PointsUpdateOperation_Upsert) isPointsUpdateOperation_Operation()                 {}
func (*PointsUpdateOperation_DeleteDeprecated) isPointsUpdateOperation_Operation()       {}
func (*PointsUpdateOperation_SetPayload_) isPointsUpdateOperation_Operation()            {}
func (*PointsUpdateOperation_OverwritePayload_) isPointsUpdateOperation_Operation()      {}
func (*PointsUpdateOperation_DeletePayload_) isPointsUpdateOperation_Operation()         {}
func (*PointsUpdateOperation_ClearPayloadDeprecated) isPointsUpdateOperation_Operation() {}
func (*PointsUpdateOperation_UpdateVectors_) isPointsUpdateOperation_Operation()         {}
func (*PointsUpdateOperation_DeleteVectors_) isPointsUpdateOperation_Operation()         {}
func (*PointsUpdateOperation_DeletePoints_) isPointsUpdateOperation_Operation()          {}
func (*PointsUpdateOperation_ClearPayload_) isPointsUpdateOperation_Operation()          {}

func (m *PointsUpdateOperation) GetOperation() isPointsUpdateOperation_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *PointsUpdateOperation) GetUpsert() *PointsUpdateOperation_PointStructList {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_Upsert); ok {
		return x.Upsert
	}
	return nil
}

// Deprecated: Do not use.
func (m *PointsUpdateOperation) GetDeleteDeprecated() *PointsSelector {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_DeleteDeprecated); ok {
		return x.DeleteDeprecated
	}
	return nil
}

func (m *PointsUpdateOperation) GetSetPayload() *PointsUpdateOperation_SetPayload {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_SetPayload_); ok {
		return x.SetPayload
	}
	return nil
}

func (m *PointsUpdateOperation) GetOverwritePayload() *PointsUpdateOperation_OverwritePayload {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_OverwritePayload_); ok {
		return x.OverwritePayload
	}
	return nil
}

func (m *PointsUpdateOperation) GetDeletePayload() *PointsUpdateOperation_DeletePayload {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_DeletePayload_); ok {
		return x.DeletePayload
	}
	return nil
}

// Deprecated: Do not use.
func (m *PointsUpdateOperation) GetClearPayloadDeprecated() *PointsSelector {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_ClearPayloadDeprecated); ok {
		return x.ClearPayloadDeprecated
	}
	return nil
}

func (m *PointsUpdateOperation) GetUpdateVectors() *PointsUpdateOperation_UpdateVectors {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_UpdateVectors_); ok {
		return x.UpdateVectors
	}
	return nil
}

func (m *PointsUpdateOperation) GetDeleteVectors() *PointsUpdateOperation_DeleteVectors {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_DeleteVectors_); ok {
		return x.DeleteVectors
	}
	return nil
}

func (m *PointsUpdateOperation) GetDeletePoints() *PointsUpdateOperation_DeletePoints {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_DeletePoints_); ok {
		return x.DeletePoints
	}
	return nil
}

func (m *PointsUpdateOperation) GetClearPayload() *PointsUpdateOperation_ClearPayload {
	if x, ok := m.GetOperation().(*PointsUpdateOperation_ClearPayload_); ok {
		return x.ClearPayload
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PointsUpdateOperation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PointsUpdateOperation_Upsert)(nil),
		(*PointsUpdateOperation_DeleteDeprecated)(nil),
		(*PointsUpdateOperation_SetPayload_)(nil),
		(*PointsUpdateOperation_OverwritePayload_)(nil),
		(*PointsUpdateOperation_DeletePayload_)(nil),
		(*PointsUpdateOperation_ClearPayloadDeprecated)(nil),
		(*PointsUpdateOperation_UpdateVectors_)(nil),
		(*PointsUpdateOperation_DeleteVectors_)(nil),
		(*PointsUpdateOperation_DeletePoints_)(nil),
		(*PointsUpdateOperation_ClearPayload_)(nil),
	}
}

type PointsUpdateOperation_PointStructList struct {
	Points           []*PointStruct    `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,2,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_PointStructList) Reset()      { *m = PointsUpdateOperation_PointStructList{} }
func (*PointsUpdateOperation_PointStructList) ProtoMessage() {}
func (*PointsUpdateOperation_PointStructList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 0}
}
func (m *PointsUpdateOperation_PointStructList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_PointStructList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_PointStructList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_PointStructList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_PointStructList.Merge(m, src)
}
func (m *PointsUpdateOperation_PointStructList) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_PointStructList) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_PointStructList.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_PointStructList proto.InternalMessageInfo

func (m *PointsUpdateOperation_PointStructList) GetPoints() []*PointStruct {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *PointsUpdateOperation_PointStructList) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointsUpdateOperation_SetPayload struct {
	Payload          map[string]*Value `protobuf:"bytes,1,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,2,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,3,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	Key              string            `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PointsUpdateOperation_SetPayload) Reset()      { *m = PointsUpdateOperation_SetPayload{} }
func (*PointsUpdateOperation_SetPayload) ProtoMessage() {}
func (*PointsUpdateOperation_SetPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 1}
}
func (m *PointsUpdateOperation_SetPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_SetPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_SetPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_SetPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_SetPayload.Merge(m, src)
}
func (m *PointsUpdateOperation_SetPayload) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_SetPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_SetPayload.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_SetPayload proto.InternalMessageInfo

func (m *PointsUpdateOperation_SetPayload) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PointsUpdateOperation_SetPayload) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *PointsUpdateOperation_SetPayload) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *PointsUpdateOperation_SetPayload) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type PointsUpdateOperation_OverwritePayload struct {
	Payload          map[string]*Value `protobuf:"bytes,1,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,2,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,3,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
	Key              string            `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PointsUpdateOperation_OverwritePayload) Reset() {
	*m = PointsUpdateOperation_OverwritePayload{}
}
func (*PointsUpdateOperation_OverwritePayload) ProtoMessage() {}
func (*PointsUpdateOperation_OverwritePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 2}
}
func (m *PointsUpdateOperation_OverwritePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_OverwritePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_OverwritePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_OverwritePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_OverwritePayload.Merge(m, src)
}
func (m *PointsUpdateOperation_OverwritePayload) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_OverwritePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_OverwritePayload.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_OverwritePayload proto.InternalMessageInfo

func (m *PointsUpdateOperation_OverwritePayload) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PointsUpdateOperation_OverwritePayload) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *PointsUpdateOperation_OverwritePayload) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

func (m *PointsUpdateOperation_OverwritePayload) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type PointsUpdateOperation_DeletePayload struct {
	Keys             []string          `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	PointsSelector   *PointsSelector   `protobuf:"bytes,2,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,3,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_DeletePayload) Reset()      { *m = PointsUpdateOperation_DeletePayload{} }
func (*PointsUpdateOperation_DeletePayload) ProtoMessage() {}
func (*PointsUpdateOperation_DeletePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 3}
}
func (m *PointsUpdateOperation_DeletePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_DeletePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_DeletePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_DeletePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_DeletePayload.Merge(m, src)
}
func (m *PointsUpdateOperation_DeletePayload) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_DeletePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_DeletePayload.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_DeletePayload proto.InternalMessageInfo

func (m *PointsUpdateOperation_DeletePayload) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *PointsUpdateOperation_DeletePayload) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *PointsUpdateOperation_DeletePayload) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointsUpdateOperation_UpdateVectors struct {
	Points           []*PointVectors   `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,2,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_UpdateVectors) Reset()      { *m = PointsUpdateOperation_UpdateVectors{} }
func (*PointsUpdateOperation_UpdateVectors) ProtoMessage() {}
func (*PointsUpdateOperation_UpdateVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 4}
}
func (m *PointsUpdateOperation_UpdateVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_UpdateVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_UpdateVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_UpdateVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_UpdateVectors.Merge(m, src)
}
func (m *PointsUpdateOperation_UpdateVectors) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_UpdateVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_UpdateVectors.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_UpdateVectors proto.InternalMessageInfo

func (m *PointsUpdateOperation_UpdateVectors) GetPoints() []*PointVectors {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *PointsUpdateOperation_UpdateVectors) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointsUpdateOperation_DeleteVectors struct {
	PointsSelector   *PointsSelector   `protobuf:"bytes,1,opt,name=points_selector,json=pointsSelector,proto3" json:"points_selector,omitempty"`
	Vectors          *VectorsSelector  `protobuf:"bytes,2,opt,name=vectors,proto3" json:"vectors,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,3,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_DeleteVectors) Reset()      { *m = PointsUpdateOperation_DeleteVectors{} }
func (*PointsUpdateOperation_DeleteVectors) ProtoMessage() {}
func (*PointsUpdateOperation_DeleteVectors) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 5}
}
func (m *PointsUpdateOperation_DeleteVectors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_DeleteVectors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_DeleteVectors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_DeleteVectors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_DeleteVectors.Merge(m, src)
}
func (m *PointsUpdateOperation_DeleteVectors) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_DeleteVectors) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_DeleteVectors.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_DeleteVectors proto.InternalMessageInfo

func (m *PointsUpdateOperation_DeleteVectors) GetPointsSelector() *PointsSelector {
	if m != nil {
		return m.PointsSelector
	}
	return nil
}

func (m *PointsUpdateOperation_DeleteVectors) GetVectors() *VectorsSelector {
	if m != nil {
		return m.Vectors
	}
	return nil
}

func (m *PointsUpdateOperation_DeleteVectors) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointsUpdateOperation_DeletePoints struct {
	Points           *PointsSelector   `protobuf:"bytes,1,opt,name=points,proto3" json:"points,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,2,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_DeletePoints) Reset()      { *m = PointsUpdateOperation_DeletePoints{} }
func (*PointsUpdateOperation_DeletePoints) ProtoMessage() {}
func (*PointsUpdateOperation_DeletePoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 6}
}
func (m *PointsUpdateOperation_DeletePoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_DeletePoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_DeletePoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_DeletePoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_DeletePoints.Merge(m, src)
}
func (m *PointsUpdateOperation_DeletePoints) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_DeletePoints) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_DeletePoints.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_DeletePoints proto.InternalMessageInfo

func (m *PointsUpdateOperation_DeletePoints) GetPoints() *PointsSelector {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *PointsUpdateOperation_DeletePoints) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type PointsUpdateOperation_ClearPayload struct {
	Points           *PointsSelector   `protobuf:"bytes,1,opt,name=points,proto3" json:"points,omitempty"`
	ShardKeySelector *ShardKeySelector `protobuf:"bytes,2,opt,name=shard_key_selector,json=shardKeySelector,proto3" json:"shard_key_selector,omitempty"`
}

func (m *PointsUpdateOperation_ClearPayload) Reset()      { *m = PointsUpdateOperation_ClearPayload{} }
func (*PointsUpdateOperation_ClearPayload) ProtoMessage() {}
func (*PointsUpdateOperation_ClearPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{55, 7}
}
func (m *PointsUpdateOperation_ClearPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsUpdateOperation_ClearPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsUpdateOperation_ClearPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsUpdateOperation_ClearPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsUpdateOperation_ClearPayload.Merge(m, src)
}
func (m *PointsUpdateOperation_ClearPayload) XXX_Size() int {
	return m.Size()
}
func (m *PointsUpdateOperation_ClearPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsUpdateOperation_ClearPayload.DiscardUnknown(m)
}

var xxx_messageInfo_PointsUpdateOperation_ClearPayload proto.InternalMessageInfo

func (m *PointsUpdateOperation_ClearPayload) GetPoints() *PointsSelector {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *PointsUpdateOperation_ClearPayload) GetShardKeySelector() *ShardKeySelector {
	if m != nil {
		return m.ShardKeySelector
	}
	return nil
}

type UpdateBatchPoints struct {
	CollectionName string                   `protobuf:"bytes,1,opt,name=collection_name,json=collectionName,proto3" json:"collection_name,omitempty"`
	Wait           bool                     `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Operations     []*PointsUpdateOperation `protobuf:"bytes,3,rep,name=operations,proto3" json:"operations,omitempty"`
	Ordering       *WriteOrdering           `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`
}

func (m *UpdateBatchPoints) Reset()      { *m = UpdateBatchPoints{} }
func (*UpdateBatchPoints) ProtoMessage() {}
func (*UpdateBatchPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{56}
}
func (m *UpdateBatchPoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBatchPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBatchPoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateBatchPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBatchPoints.Merge(m, src)
}
func (m *UpdateBatchPoints) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBatchPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBatchPoints.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBatchPoints proto.InternalMessageInfo

func (m *UpdateBatchPoints) GetCollectionName() string {
	if m != nil {
		return m.CollectionName
	}
	return ""
}

func (m *UpdateBatchPoints) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *UpdateBatchPoints) GetOperations() []*PointsUpdateOperation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *UpdateBatchPoints) GetOrdering() *WriteOrdering {
	if m != nil {
		return m.Ordering
	}
	return nil
}

type PointsOperationResponse struct {
	Result *UpdateResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64       `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *PointsOperationResponse) Reset()      { *m = PointsOperationResponse{} }
func (*PointsOperationResponse) ProtoMessage() {}
func (*PointsOperationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{57}
}
func (m *PointsOperationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsOperationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsOperationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsOperationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsOperationResponse.Merge(m, src)
}
func (m *PointsOperationResponse) XXX_Size() int {
	return m.Size()
}
func (m *PointsOperationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsOperationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PointsOperationResponse proto.InternalMessageInfo

func (m *PointsOperationResponse) GetResult() *UpdateResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *PointsOperationResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type UpdateResult struct {
	OperationId uint64       `protobuf:"varint,1,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	Status      UpdateStatus `protobuf:"varint,2,opt,name=status,proto3,enum=qdrant.UpdateStatus" json:"status,omitempty"`
}

func (m *UpdateResult) Reset()      { *m = UpdateResult{} }
func (*UpdateResult) ProtoMessage() {}
func (*UpdateResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{58}
}
func (m *UpdateResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResult.Merge(m, src)
}
func (m *UpdateResult) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResult) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResult.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResult proto.InternalMessageInfo

func (m *UpdateResult) GetOperationId() uint64 {
	if m != nil {
		return m.OperationId
	}
	return 0
}

func (m *UpdateResult) GetStatus() UpdateStatus {
	if m != nil {
		return m.Status
	}
	return UnknownUpdateStatus
}

type OrderValue struct {
	// Types that are valid to be assigned to Variant:
	//
	//	*OrderValue_Int
	//	*OrderValue_Float
	Variant isOrderValue_Variant `protobuf_oneof:"variant"`
}

func (m *OrderValue) Reset()      { *m = OrderValue{} }
func (*OrderValue) ProtoMessage() {}
func (*OrderValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{59}
}
func (m *OrderValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderValue.Merge(m, src)
}
func (m *OrderValue) XXX_Size() int {
	return m.Size()
}
func (m *OrderValue) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderValue.DiscardUnknown(m)
}

var xxx_messageInfo_OrderValue proto.InternalMessageInfo

type isOrderValue_Variant interface {
	isOrderValue_Variant()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OrderValue_Int struct {
	Int int64 `protobuf:"varint,1,opt,name=int,proto3,oneof" json:"int,omitempty"`
}
type OrderValue_Float struct {
	Float float64 `protobuf:"fixed64,2,opt,name=float,proto3,oneof" json:"float,omitempty"`
}

func (*OrderValue_Int) isOrderValue_Variant()   {}
func (*OrderValue_Float) isOrderValue_Variant() {}

func (m *OrderValue) GetVariant() isOrderValue_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (m *OrderValue) GetInt() int64 {
	if x, ok := m.GetVariant().(*OrderValue_Int); ok {
		return x.Int
	}
	return 0
}

func (m *OrderValue) GetFloat() float64 {
	if x, ok := m.GetVariant().(*OrderValue_Float); ok {
		return x.Float
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderValue_Int)(nil),
		(*OrderValue_Float)(nil),
	}
}

type ScoredPoint struct {
	Id         *PointId          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Payload    map[string]*Value `protobuf:"bytes,2,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Score      float32           `protobuf:"fixed32,3,opt,name=score,proto3" json:"score,omitempty"`
	Version    uint64            `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	Vectors    *Vectors          `protobuf:"bytes,6,opt,name=vectors,proto3" json:"vectors,omitempty"`
	ShardKey   *ShardKey         `protobuf:"bytes,7,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
	OrderValue *OrderValue       `protobuf:"bytes,8,opt,name=order_value,json=orderValue,proto3" json:"order_value,omitempty"`
}

func (m *ScoredPoint) Reset()      { *m = ScoredPoint{} }
func (*ScoredPoint) ProtoMessage() {}
func (*ScoredPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{60}
}
func (m *ScoredPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScoredPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScoredPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScoredPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoredPoint.Merge(m, src)
}
func (m *ScoredPoint) XXX_Size() int {
	return m.Size()
}
func (m *ScoredPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoredPoint.DiscardUnknown(m)
}

var xxx_messageInfo_ScoredPoint proto.InternalMessageInfo

func (m *ScoredPoint) GetId() *PointId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ScoredPoint) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ScoredPoint) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ScoredPoint) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ScoredPoint) GetVectors() *Vectors {
	if m != nil {
		return m.Vectors
	}
	return nil
}

func (m *ScoredPoint) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

func (m *ScoredPoint) GetOrderValue() *OrderValue {
	if m != nil {
		return m.OrderValue
	}
	return nil
}

type GroupId struct {
	// Types that are valid to be assigned to Kind:
	//
	//	*GroupId_UnsignedValue
	//	*GroupId_IntegerValue
	//	*GroupId_StringValue
	Kind isGroupId_Kind `protobuf_oneof:"kind"`
}

func (m *GroupId) Reset()      { *m = GroupId{} }
func (*GroupId) ProtoMessage() {}
func (*GroupId) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{61}
}
func (m *GroupId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupId.Merge(m, src)
}
func (m *GroupId) XXX_Size() int {
	return m.Size()
}
func (m *GroupId) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupId.DiscardUnknown(m)
}

var xxx_messageInfo_GroupId proto.InternalMessageInfo

type isGroupId_Kind interface {
	isGroupId_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GroupId_UnsignedValue struct {
	UnsignedValue uint64 `protobuf:"varint,1,opt,name=unsigned_value,json=unsignedValue,proto3,oneof" json:"unsigned_value,omitempty"`
}
type GroupId_IntegerValue struct {
	IntegerValue int64 `protobuf:"varint,2,opt,name=integer_value,json=integerValue,proto3,oneof" json:"integer_value,omitempty"`
}
type GroupId_StringValue struct {
	StringValue string `protobuf:"bytes,3,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}

func (*GroupId_UnsignedValue) isGroupId_Kind() {}
func (*GroupId_IntegerValue) isGroupId_Kind()  {}
func (*GroupId_StringValue) isGroupId_Kind()   {}

func (m *GroupId) GetKind() isGroupId_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *GroupId) GetUnsignedValue() uint64 {
	if x, ok := m.GetKind().(*GroupId_UnsignedValue); ok {
		return x.UnsignedValue
	}
	return 0
}

func (m *GroupId) GetIntegerValue() int64 {
	if x, ok := m.GetKind().(*GroupId_IntegerValue); ok {
		return x.IntegerValue
	}
	return 0
}

func (m *GroupId) GetStringValue() string {
	if x, ok := m.GetKind().(*GroupId_StringValue); ok {
		return x.StringValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GroupId) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GroupId_UnsignedValue)(nil),
		(*GroupId_IntegerValue)(nil),
		(*GroupId_StringValue)(nil),
	}
}

type PointGroup struct {
	Id     *GroupId        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Hits   []*ScoredPoint  `protobuf:"bytes,2,rep,name=hits,proto3" json:"hits,omitempty"`
	Lookup *RetrievedPoint `protobuf:"bytes,3,opt,name=lookup,proto3" json:"lookup,omitempty"`
}

func (m *PointGroup) Reset()      { *m = PointGroup{} }
func (*PointGroup) ProtoMessage() {}
func (*PointGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{62}
}
func (m *PointGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointGroup.Merge(m, src)
}
func (m *PointGroup) XXX_Size() int {
	return m.Size()
}
func (m *PointGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_PointGroup.DiscardUnknown(m)
}

var xxx_messageInfo_PointGroup proto.InternalMessageInfo

func (m *PointGroup) GetId() *GroupId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PointGroup) GetHits() []*ScoredPoint {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *PointGroup) GetLookup() *RetrievedPoint {
	if m != nil {
		return m.Lookup
	}
	return nil
}

type GroupsResult struct {
	Groups []*PointGroup `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
}

func (m *GroupsResult) Reset()      { *m = GroupsResult{} }
func (*GroupsResult) ProtoMessage() {}
func (*GroupsResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{63}
}
func (m *GroupsResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupsResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupsResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupsResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupsResult.Merge(m, src)
}
func (m *GroupsResult) XXX_Size() int {
	return m.Size()
}
func (m *GroupsResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupsResult.DiscardUnknown(m)
}

var xxx_messageInfo_GroupsResult proto.InternalMessageInfo

func (m *GroupsResult) GetGroups() []*PointGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

type SearchResponse struct {
	Result []*ScoredPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *SearchResponse) Reset()      { *m = SearchResponse{} }
func (*SearchResponse) ProtoMessage() {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{64}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetResult() []*ScoredPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SearchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type QueryResponse struct {
	Result []*ScoredPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *QueryResponse) Reset()      { *m = QueryResponse{} }
func (*QueryResponse) ProtoMessage() {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{65}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

func (m *QueryResponse) GetResult() []*ScoredPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type QueryBatchResponse struct {
	Result []*BatchResult `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *QueryBatchResponse) Reset()      { *m = QueryBatchResponse{} }
func (*QueryBatchResponse) ProtoMessage() {}
func (*QueryBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{66}
}
func (m *QueryBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBatchResponse.Merge(m, src)
}
func (m *QueryBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBatchResponse proto.InternalMessageInfo

func (m *QueryBatchResponse) GetResult() []*BatchResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *QueryBatchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type BatchResult struct {
	Result []*ScoredPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
}

func (m *BatchResult) Reset()      { *m = BatchResult{} }
func (*BatchResult) ProtoMessage() {}
func (*BatchResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{67}
}
func (m *BatchResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResult.Merge(m, src)
}
func (m *BatchResult) XXX_Size() int {
	return m.Size()
}
func (m *BatchResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResult.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResult proto.InternalMessageInfo

func (m *BatchResult) GetResult() []*ScoredPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

type SearchBatchResponse struct {
	Result []*BatchResult `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *SearchBatchResponse) Reset()      { *m = SearchBatchResponse{} }
func (*SearchBatchResponse) ProtoMessage() {}
func (*SearchBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{68}
}
func (m *SearchBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchBatchResponse.Merge(m, src)
}
func (m *SearchBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchBatchResponse proto.InternalMessageInfo

func (m *SearchBatchResponse) GetResult() []*BatchResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SearchBatchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type SearchGroupsResponse struct {
	Result *GroupsResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64       `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *SearchGroupsResponse) Reset()      { *m = SearchGroupsResponse{} }
func (*SearchGroupsResponse) ProtoMessage() {}
func (*SearchGroupsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{69}
}
func (m *SearchGroupsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchGroupsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchGroupsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchGroupsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchGroupsResponse.Merge(m, src)
}
func (m *SearchGroupsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchGroupsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchGroupsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchGroupsResponse proto.InternalMessageInfo

func (m *SearchGroupsResponse) GetResult() *GroupsResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SearchGroupsResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type CountResponse struct {
	Result *CountResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64      `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *CountResponse) Reset()      { *m = CountResponse{} }
func (*CountResponse) ProtoMessage() {}
func (*CountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{70}
}
func (m *CountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountResponse.Merge(m, src)
}
func (m *CountResponse) XXX_Size() int {
	return m.Size()
}
func (m *CountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CountResponse proto.InternalMessageInfo

func (m *CountResponse) GetResult() *CountResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CountResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type ScrollResponse struct {
	NextPageOffset *PointId          `protobuf:"bytes,1,opt,name=next_page_offset,json=nextPageOffset,proto3" json:"next_page_offset,omitempty"`
	Result         []*RetrievedPoint `protobuf:"bytes,2,rep,name=result,proto3" json:"result,omitempty"`
	Time           float64           `protobuf:"fixed64,3,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *ScrollResponse) Reset()      { *m = ScrollResponse{} }
func (*ScrollResponse) ProtoMessage() {}
func (*ScrollResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{71}
}
func (m *ScrollResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScrollResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScrollResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScrollResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScrollResponse.Merge(m, src)
}
func (m *ScrollResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScrollResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScrollResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScrollResponse proto.InternalMessageInfo

func (m *ScrollResponse) GetNextPageOffset() *PointId {
	if m != nil {
		return m.NextPageOffset
	}
	return nil
}

func (m *ScrollResponse) GetResult() []*RetrievedPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ScrollResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type CountResult struct {
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CountResult) Reset()      { *m = CountResult{} }
func (*CountResult) ProtoMessage() {}
func (*CountResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{72}
}
func (m *CountResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountResult.Merge(m, src)
}
func (m *CountResult) XXX_Size() int {
	return m.Size()
}
func (m *CountResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CountResult.DiscardUnknown(m)
}

var xxx_messageInfo_CountResult proto.InternalMessageInfo

func (m *CountResult) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type RetrievedPoint struct {
	Id         *PointId          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Payload    map[string]*Value `protobuf:"bytes,2,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Vectors    *Vectors          `protobuf:"bytes,4,opt,name=vectors,proto3" json:"vectors,omitempty"`
	ShardKey   *ShardKey         `protobuf:"bytes,5,opt,name=shard_key,json=shardKey,proto3" json:"shard_key,omitempty"`
	OrderValue *OrderValue       `protobuf:"bytes,6,opt,name=order_value,json=orderValue,proto3" json:"order_value,omitempty"`
}

func (m *RetrievedPoint) Reset()      { *m = RetrievedPoint{} }
func (*RetrievedPoint) ProtoMessage() {}
func (*RetrievedPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{73}
}
func (m *RetrievedPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetrievedPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetrievedPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetrievedPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetrievedPoint.Merge(m, src)
}
func (m *RetrievedPoint) XXX_Size() int {
	return m.Size()
}
func (m *RetrievedPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_RetrievedPoint.DiscardUnknown(m)
}

var xxx_messageInfo_RetrievedPoint proto.InternalMessageInfo

func (m *RetrievedPoint) GetId() *PointId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RetrievedPoint) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *RetrievedPoint) GetVectors() *Vectors {
	if m != nil {
		return m.Vectors
	}
	return nil
}

func (m *RetrievedPoint) GetShardKey() *ShardKey {
	if m != nil {
		return m.ShardKey
	}
	return nil
}

func (m *RetrievedPoint) GetOrderValue() *OrderValue {
	if m != nil {
		return m.OrderValue
	}
	return nil
}

type GetResponse struct {
	Result []*RetrievedPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64           `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *GetResponse) Reset()      { *m = GetResponse{} }
func (*GetResponse) ProtoMessage() {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{74}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetResult() []*RetrievedPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type RecommendResponse struct {
	Result []*ScoredPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *RecommendResponse) Reset()      { *m = RecommendResponse{} }
func (*RecommendResponse) ProtoMessage() {}
func (*RecommendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{75}
}
func (m *RecommendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendResponse.Merge(m, src)
}
func (m *RecommendResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecommendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendResponse proto.InternalMessageInfo

func (m *RecommendResponse) GetResult() []*ScoredPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RecommendResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type RecommendBatchResponse struct {
	Result []*BatchResult `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *RecommendBatchResponse) Reset()      { *m = RecommendBatchResponse{} }
func (*RecommendBatchResponse) ProtoMessage() {}
func (*RecommendBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{76}
}
func (m *RecommendBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendBatchResponse.Merge(m, src)
}
func (m *RecommendBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecommendBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendBatchResponse proto.InternalMessageInfo

func (m *RecommendBatchResponse) GetResult() []*BatchResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RecommendBatchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type DiscoverResponse struct {
	Result []*ScoredPoint `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *DiscoverResponse) Reset()      { *m = DiscoverResponse{} }
func (*DiscoverResponse) ProtoMessage() {}
func (*DiscoverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{77}
}
func (m *DiscoverResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverResponse.Merge(m, src)
}
func (m *DiscoverResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiscoverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverResponse proto.InternalMessageInfo

func (m *DiscoverResponse) GetResult() []*ScoredPoint {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *DiscoverResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type DiscoverBatchResponse struct {
	Result []*BatchResult `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64        `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *DiscoverBatchResponse) Reset()      { *m = DiscoverBatchResponse{} }
func (*DiscoverBatchResponse) ProtoMessage() {}
func (*DiscoverBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{78}
}
func (m *DiscoverBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscoverBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscoverBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscoverBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverBatchResponse.Merge(m, src)
}
func (m *DiscoverBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiscoverBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverBatchResponse proto.InternalMessageInfo

func (m *DiscoverBatchResponse) GetResult() []*BatchResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *DiscoverBatchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type RecommendGroupsResponse struct {
	Result *GroupsResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Time   float64       `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *RecommendGroupsResponse) Reset()      { *m = RecommendGroupsResponse{} }
func (*RecommendGroupsResponse) ProtoMessage() {}
func (*RecommendGroupsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{79}
}
func (m *RecommendGroupsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecommendGroupsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecommendGroupsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecommendGroupsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecommendGroupsResponse.Merge(m, src)
}
func (m *RecommendGroupsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecommendGroupsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecommendGroupsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecommendGroupsResponse proto.InternalMessageInfo

func (m *RecommendGroupsResponse) GetResult() *GroupsResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RecommendGroupsResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type UpdateBatchResponse struct {
	Result []*UpdateResult `protobuf:"bytes,1,rep,name=result,proto3" json:"result,omitempty"`
	Time   float64         `protobuf:"fixed64,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *UpdateBatchResponse) Reset()      { *m = UpdateBatchResponse{} }
func (*UpdateBatchResponse) ProtoMessage() {}
func (*UpdateBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{80}
}
func (m *UpdateBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateBatchResponse.Merge(m, src)
}
func (m *UpdateBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateBatchResponse proto.InternalMessageInfo

func (m *UpdateBatchResponse) GetResult() []*UpdateResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *UpdateBatchResponse) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type Filter struct {
	Should    []*Condition `protobuf:"bytes,1,rep,name=should,proto3" json:"should,omitempty"`
	Must      []*Condition `protobuf:"bytes,2,rep,name=must,proto3" json:"must,omitempty"`
	MustNot   []*Condition `protobuf:"bytes,3,rep,name=must_not,json=mustNot,proto3" json:"must_not,omitempty"`
	MinShould *MinShould   `protobuf:"bytes,4,opt,name=min_should,json=minShould,proto3" json:"min_should,omitempty"`
}

func (m *Filter) Reset()      { *m = Filter{} }
func (*Filter) ProtoMessage() {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{81}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetShould() []*Condition {
	if m != nil {
		return m.Should
	}
	return nil
}

func (m *Filter) GetMust() []*Condition {
	if m != nil {
		return m.Must
	}
	return nil
}

func (m *Filter) GetMustNot() []*Condition {
	if m != nil {
		return m.MustNot
	}
	return nil
}

func (m *Filter) GetMinShould() *MinShould {
	if m != nil {
		return m.MinShould
	}
	return nil
}

type MinShould struct {
	Conditions []*Condition `protobuf:"bytes,1,rep,name=conditions,proto3" json:"conditions,omitempty"`
	MinCount   uint64       `protobuf:"varint,2,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
}

func (m *MinShould) Reset()      { *m = MinShould{} }
func (*MinShould) ProtoMessage() {}
func (*MinShould) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{82}
}
func (m *MinShould) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinShould) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinShould.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinShould) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinShould.Merge(m, src)
}
func (m *MinShould) XXX_Size() int {
	return m.Size()
}
func (m *MinShould) XXX_DiscardUnknown() {
	xxx_messageInfo_MinShould.DiscardUnknown(m)
}

var xxx_messageInfo_MinShould proto.InternalMessageInfo

func (m *MinShould) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *MinShould) GetMinCount() uint64 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

type Condition struct {
	// Types that are valid to be assigned to ConditionOneOf:
	//
	//	*Condition_Field
	//	*Condition_IsEmpty
	//	*Condition_HasId
	//	*Condition_Filter
	//	*Condition_IsNull
	//	*Condition_Nested
	ConditionOneOf isCondition_ConditionOneOf `protobuf_oneof:"condition_one_of"`
}

func (m *Condition) Reset()      { *m = Condition{} }
func (*Condition) ProtoMessage() {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{83}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

type isCondition_ConditionOneOf interface {
	isCondition_ConditionOneOf()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Condition_Field struct {
	Field *FieldCondition `protobuf:"bytes,1,opt,name=field,proto3,oneof" json:"field,omitempty"`
}
type Condition_IsEmpty struct {
	IsEmpty *IsEmptyCondition `protobuf:"bytes,2,opt,name=is_empty,json=isEmpty,proto3,oneof" json:"is_empty,omitempty"`
}
type Condition_HasId struct {
	HasId *HasIdCondition `protobuf:"bytes,3,opt,name=has_id,json=hasId,proto3,oneof" json:"has_id,omitempty"`
}
type Condition_Filter struct {
	Filter *Filter `protobuf:"bytes,4,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}
type Condition_IsNull struct {
	IsNull *IsNullCondition `protobuf:"bytes,5,opt,name=is_null,json=isNull,proto3,oneof" json:"is_null,omitempty"`
}
type Condition_Nested struct {
	Nested *NestedCondition `protobuf:"bytes,6,opt,name=nested,proto3,oneof" json:"nested,omitempty"`
}

func (*Condition_Field) isCondition_ConditionOneOf()   {}
func (*Condition_IsEmpty) isCondition_ConditionOneOf() {}
func (*Condition_HasId) isCondition_ConditionOneOf()   {}
func (*Condition_Filter) isCondition_ConditionOneOf()  {}
func (*Condition_IsNull) isCondition_ConditionOneOf()  {}
func (*Condition_Nested) isCondition_ConditionOneOf()  {}

func (m *Condition) GetConditionOneOf() isCondition_ConditionOneOf {
	if m != nil {
		return m.ConditionOneOf
	}
	return nil
}

func (m *Condition) GetField() *FieldCondition {
	if x, ok := m.GetConditionOneOf().(*Condition_Field); ok {
		return x.Field
	}
	return nil
}

func (m *Condition) GetIsEmpty() *IsEmptyCondition {
	if x, ok := m.GetConditionOneOf().(*Condition_IsEmpty); ok {
		return x.IsEmpty
	}
	return nil
}

func (m *Condition) GetHasId() *HasIdCondition {
	if x, ok := m.GetConditionOneOf().(*Condition_HasId); ok {
		return x.HasId
	}
	return nil
}

func (m *Condition) GetFilter() *Filter {
	if x, ok := m.GetConditionOneOf().(*Condition_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *Condition) GetIsNull() *IsNullCondition {
	if x, ok := m.GetConditionOneOf().(*Condition_IsNull); ok {
		return x.IsNull
	}
	return nil
}

func (m *Condition) GetNested() *NestedCondition {
	if x, ok := m.GetConditionOneOf().(*Condition_Nested); ok {
		return x.Nested
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Condition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Condition_Field)(nil),
		(*Condition_IsEmpty)(nil),
		(*Condition_HasId)(nil),
		(*Condition_Filter)(nil),
		(*Condition_IsNull)(nil),
		(*Condition_Nested)(nil),
	}
}

type IsEmptyCondition struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *IsEmptyCondition) Reset()      { *m = IsEmptyCondition{} }
func (*IsEmptyCondition) ProtoMessage() {}
func (*IsEmptyCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{84}
}
func (m *IsEmptyCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsEmptyCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsEmptyCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsEmptyCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsEmptyCondition.Merge(m, src)
}
func (m *IsEmptyCondition) XXX_Size() int {
	return m.Size()
}
func (m *IsEmptyCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_IsEmptyCondition.DiscardUnknown(m)
}

var xxx_messageInfo_IsEmptyCondition proto.InternalMessageInfo

func (m *IsEmptyCondition) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type IsNullCondition struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *IsNullCondition) Reset()      { *m = IsNullCondition{} }
func (*IsNullCondition) ProtoMessage() {}
func (*IsNullCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{85}
}
func (m *IsNullCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsNullCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsNullCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsNullCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsNullCondition.Merge(m, src)
}
func (m *IsNullCondition) XXX_Size() int {
	return m.Size()
}
func (m *IsNullCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_IsNullCondition.DiscardUnknown(m)
}

var xxx_messageInfo_IsNullCondition proto.InternalMessageInfo

func (m *IsNullCondition) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type HasIdCondition struct {
	HasId []*PointId `protobuf:"bytes,1,rep,name=has_id,json=hasId,proto3" json:"has_id,omitempty"`
}

func (m *HasIdCondition) Reset()      { *m = HasIdCondition{} }
func (*HasIdCondition) ProtoMessage() {}
func (*HasIdCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{86}
}
func (m *HasIdCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasIdCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasIdCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasIdCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasIdCondition.Merge(m, src)
}
func (m *HasIdCondition) XXX_Size() int {
	return m.Size()
}
func (m *HasIdCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_HasIdCondition.DiscardUnknown(m)
}

var xxx_messageInfo_HasIdCondition proto.InternalMessageInfo

func (m *HasIdCondition) GetHasId() []*PointId {
	if m != nil {
		return m.HasId
	}
	return nil
}

type NestedCondition struct {
	Key    string  `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Filter *Filter `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (m *NestedCondition) Reset()      { *m = NestedCondition{} }
func (*NestedCondition) ProtoMessage() {}
func (*NestedCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{87}
}
func (m *NestedCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NestedCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NestedCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NestedCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NestedCondition.Merge(m, src)
}
func (m *NestedCondition) XXX_Size() int {
	return m.Size()
}
func (m *NestedCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NestedCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NestedCondition proto.InternalMessageInfo

func (m *NestedCondition) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NestedCondition) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type FieldCondition struct {
	Key            string          `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Match          *Match          `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	Range          *Range          `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	GeoBoundingBox *GeoBoundingBox `protobuf:"bytes,4,opt,name=geo_bounding_box,json=geoBoundingBox,proto3" json:"geo_bounding_box,omitempty"`
	GeoRadius      *GeoRadius      `protobuf:"bytes,5,opt,name=geo_radius,json=geoRadius,proto3" json:"geo_radius,omitempty"`
	ValuesCount    *ValuesCount    `protobuf:"bytes,6,opt,name=values_count,json=valuesCount,proto3" json:"values_count,omitempty"`
	GeoPolygon     *GeoPolygon     `protobuf:"bytes,7,opt,name=geo_polygon,json=geoPolygon,proto3" json:"geo_polygon,omitempty"`
	DatetimeRange  *DatetimeRange  `protobuf:"bytes,8,opt,name=datetime_range,json=datetimeRange,proto3" json:"datetime_range,omitempty"`
}

func (m *FieldCondition) Reset()      { *m = FieldCondition{} }
func (*FieldCondition) ProtoMessage() {}
func (*FieldCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{88}
}
func (m *FieldCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldCondition.Merge(m, src)
}
func (m *FieldCondition) XXX_Size() int {
	return m.Size()
}
func (m *FieldCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldCondition.DiscardUnknown(m)
}

var xxx_messageInfo_FieldCondition proto.InternalMessageInfo

func (m *FieldCondition) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FieldCondition) GetMatch() *Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *FieldCondition) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *FieldCondition) GetGeoBoundingBox() *GeoBoundingBox {
	if m != nil {
		return m.GeoBoundingBox
	}
	return nil
}

func (m *FieldCondition) GetGeoRadius() *GeoRadius {
	if m != nil {
		return m.GeoRadius
	}
	return nil
}

func (m *FieldCondition) GetValuesCount() *ValuesCount {
	if m != nil {
		return m.ValuesCount
	}
	return nil
}

func (m *FieldCondition) GetGeoPolygon() *GeoPolygon {
	if m != nil {
		return m.GeoPolygon
	}
	return nil
}

func (m *FieldCondition) GetDatetimeRange() *DatetimeRange {
	if m != nil {
		return m.DatetimeRange
	}
	return nil
}

type Match struct {
	// Types that are valid to be assigned to MatchValue:
	//
	//	*Match_Keyword
	//	*Match_Integer
	//	*Match_Boolean
	//	*Match_Text
	//	*Match_Keywords
	//	*Match_Integers
	//	*Match_ExceptIntegers
	//	*Match_ExceptKeywords
	MatchValue isMatch_MatchValue `protobuf_oneof:"match_value"`
}

func (m *Match) Reset()      { *m = Match{} }
func (*Match) ProtoMessage() {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{89}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return m.Size()
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

type isMatch_MatchValue interface {
	isMatch_MatchValue()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Match_Keyword struct {
	Keyword string `protobuf:"bytes,1,opt,name=keyword,proto3,oneof" json:"keyword,omitempty"`
}
type Match_Integer struct {
	Integer int64 `protobuf:"varint,2,opt,name=integer,proto3,oneof" json:"integer,omitempty"`
}
type Match_Boolean struct {
	Boolean bool `protobuf:"varint,3,opt,name=boolean,proto3,oneof" json:"boolean,omitempty"`
}
type Match_Text struct {
	Text string `protobuf:"bytes,4,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type Match_Keywords struct {
	Keywords *RepeatedStrings `protobuf:"bytes,5,opt,name=keywords,proto3,oneof" json:"keywords,omitempty"`
}
type Match_Integers struct {
	Integers *RepeatedIntegers `protobuf:"bytes,6,opt,name=integers,proto3,oneof" json:"integers,omitempty"`
}
type Match_ExceptIntegers struct {
	ExceptIntegers *RepeatedIntegers `protobuf:"bytes,7,opt,name=except_integers,json=exceptIntegers,proto3,oneof" json:"except_integers,omitempty"`
}
type Match_ExceptKeywords struct {
	ExceptKeywords *RepeatedStrings `protobuf:"bytes,8,opt,name=except_keywords,json=exceptKeywords,proto3,oneof" json:"except_keywords,omitempty"`
}

func (*Match_Keyword) isMatch_MatchValue()        {}
func (*Match_Integer) isMatch_MatchValue()        {}
func (*Match_Boolean) isMatch_MatchValue()        {}
func (*Match_Text) isMatch_MatchValue()           {}
func (*Match_Keywords) isMatch_MatchValue()       {}
func (*Match_Integers) isMatch_MatchValue()       {}
func (*Match_ExceptIntegers) isMatch_MatchValue() {}
func (*Match_ExceptKeywords) isMatch_MatchValue() {}

func (m *Match) GetMatchValue() isMatch_MatchValue {
	if m != nil {
		return m.MatchValue
	}
	return nil
}

func (m *Match) GetKeyword() string {
	if x, ok := m.GetMatchValue().(*Match_Keyword); ok {
		return x.Keyword
	}
	return ""
}

func (m *Match) GetInteger() int64 {
	if x, ok := m.GetMatchValue().(*Match_Integer); ok {
		return x.Integer
	}
	return 0
}

func (m *Match) GetBoolean() bool {
	if x, ok := m.GetMatchValue().(*Match_Boolean); ok {
		return x.Boolean
	}
	return false
}

func (m *Match) GetText() string {
	if x, ok := m.GetMatchValue().(*Match_Text); ok {
		return x.Text
	}
	return ""
}

func (m *Match) GetKeywords() *RepeatedStrings {
	if x, ok := m.GetMatchValue().(*Match_Keywords); ok {
		return x.Keywords
	}
	return nil
}

func (m *Match) GetIntegers() *RepeatedIntegers {
	if x, ok := m.GetMatchValue().(*Match_Integers); ok {
		return x.Integers
	}
	return nil
}

func (m *Match) GetExceptIntegers() *RepeatedIntegers {
	if x, ok := m.GetMatchValue().(*Match_ExceptIntegers); ok {
		return x.ExceptIntegers
	}
	return nil
}

func (m *Match) GetExceptKeywords() *RepeatedStrings {
	if x, ok := m.GetMatchValue().(*Match_ExceptKeywords); ok {
		return x.ExceptKeywords
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Match) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Match_Keyword)(nil),
		(*Match_Integer)(nil),
		(*Match_Boolean)(nil),
		(*Match_Text)(nil),
		(*Match_Keywords)(nil),
		(*Match_Integers)(nil),
		(*Match_ExceptIntegers)(nil),
		(*Match_ExceptKeywords)(nil),
	}
}

type RepeatedStrings struct {
	Strings []string `protobuf:"bytes,1,rep,name=strings,proto3" json:"strings,omitempty"`
}

func (m *RepeatedStrings) Reset()      { *m = RepeatedStrings{} }
func (*RepeatedStrings) ProtoMessage() {}
func (*RepeatedStrings) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{90}
}
func (m *RepeatedStrings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepeatedStrings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepeatedStrings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepeatedStrings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepeatedStrings.Merge(m, src)
}
func (m *RepeatedStrings) XXX_Size() int {
	return m.Size()
}
func (m *RepeatedStrings) XXX_DiscardUnknown() {
	xxx_messageInfo_RepeatedStrings.DiscardUnknown(m)
}

var xxx_messageInfo_RepeatedStrings proto.InternalMessageInfo

func (m *RepeatedStrings) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type RepeatedIntegers struct {
	Integers []int64 `protobuf:"varint,1,rep,packed,name=integers,proto3" json:"integers,omitempty"`
}

func (m *RepeatedIntegers) Reset()      { *m = RepeatedIntegers{} }
func (*RepeatedIntegers) ProtoMessage() {}
func (*RepeatedIntegers) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{91}
}
func (m *RepeatedIntegers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepeatedIntegers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepeatedIntegers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepeatedIntegers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepeatedIntegers.Merge(m, src)
}
func (m *RepeatedIntegers) XXX_Size() int {
	return m.Size()
}
func (m *RepeatedIntegers) XXX_DiscardUnknown() {
	xxx_messageInfo_RepeatedIntegers.DiscardUnknown(m)
}

var xxx_messageInfo_RepeatedIntegers proto.InternalMessageInfo

func (m *RepeatedIntegers) GetIntegers() []int64 {
	if m != nil {
		return m.Integers
	}
	return nil
}

type Range struct {
	Lt  float64 `protobuf:"fixed64,1,opt,name=lt,proto3" json:"lt,omitempty"`
	Gt  float64 `protobuf:"fixed64,2,opt,name=gt,proto3" json:"gt,omitempty"`
	Gte float64 `protobuf:"fixed64,3,opt,name=gte,proto3" json:"gte,omitempty"`
	Lte float64 `protobuf:"fixed64,4,opt,name=lte,proto3" json:"lte,omitempty"`
}

func (m *Range) Reset()      { *m = Range{} }
func (*Range) ProtoMessage() {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{92}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetLt() float64 {
	if m != nil {
		return m.Lt
	}
	return 0
}

func (m *Range) GetGt() float64 {
	if m != nil {
		return m.Gt
	}
	return 0
}

func (m *Range) GetGte() float64 {
	if m != nil {
		return m.Gte
	}
	return 0
}

func (m *Range) GetLte() float64 {
	if m != nil {
		return m.Lte
	}
	return 0
}

type DatetimeRange struct {
	Lt  *types.Timestamp `protobuf:"bytes,1,opt,name=lt,proto3" json:"lt,omitempty"`
	Gt  *types.Timestamp `protobuf:"bytes,2,opt,name=gt,proto3" json:"gt,omitempty"`
	Gte *types.Timestamp `protobuf:"bytes,3,opt,name=gte,proto3" json:"gte,omitempty"`
	Lte *types.Timestamp `protobuf:"bytes,4,opt,name=lte,proto3" json:"lte,omitempty"`
}

func (m *DatetimeRange) Reset()      { *m = DatetimeRange{} }
func (*DatetimeRange) ProtoMessage() {}
func (*DatetimeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{93}
}
func (m *DatetimeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatetimeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatetimeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatetimeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatetimeRange.Merge(m, src)
}
func (m *DatetimeRange) XXX_Size() int {
	return m.Size()
}
func (m *DatetimeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DatetimeRange.DiscardUnknown(m)
}

var xxx_messageInfo_DatetimeRange proto.InternalMessageInfo

func (m *DatetimeRange) GetLt() *types.Timestamp {
	if m != nil {
		return m.Lt
	}
	return nil
}

func (m *DatetimeRange) GetGt() *types.Timestamp {
	if m != nil {
		return m.Gt
	}
	return nil
}

func (m *DatetimeRange) GetGte() *types.Timestamp {
	if m != nil {
		return m.Gte
	}
	return nil
}

func (m *DatetimeRange) GetLte() *types.Timestamp {
	if m != nil {
		return m.Lte
	}
	return nil
}

type GeoBoundingBox struct {
	TopLeft     *GeoPoint `protobuf:"bytes,1,opt,name=top_left,json=topLeft,proto3" json:"top_left,omitempty"`
	BottomRight *GeoPoint `protobuf:"bytes,2,opt,name=bottom_right,json=bottomRight,proto3" json:"bottom_right,omitempty"`
}

func (m *GeoBoundingBox) Reset()      { *m = GeoBoundingBox{} }
func (*GeoBoundingBox) ProtoMessage() {}
func (*GeoBoundingBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{94}
}
func (m *GeoBoundingBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoBoundingBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoBoundingBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoBoundingBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoBoundingBox.Merge(m, src)
}
func (m *GeoBoundingBox) XXX_Size() int {
	return m.Size()
}
func (m *GeoBoundingBox) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoBoundingBox.DiscardUnknown(m)
}

var xxx_messageInfo_GeoBoundingBox proto.InternalMessageInfo

func (m *GeoBoundingBox) GetTopLeft() *GeoPoint {
	if m != nil {
		return m.TopLeft
	}
	return nil
}

func (m *GeoBoundingBox) GetBottomRight() *GeoPoint {
	if m != nil {
		return m.BottomRight
	}
	return nil
}

type GeoRadius struct {
	Center *GeoPoint `protobuf:"bytes,1,opt,name=center,proto3" json:"center,omitempty"`
	Radius float32   `protobuf:"fixed32,2,opt,name=radius,proto3" json:"radius,omitempty"`
}

func (m *GeoRadius) Reset()      { *m = GeoRadius{} }
func (*GeoRadius) ProtoMessage() {}
func (*GeoRadius) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{95}
}
func (m *GeoRadius) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoRadius) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoRadius.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoRadius) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoRadius.Merge(m, src)
}
func (m *GeoRadius) XXX_Size() int {
	return m.Size()
}
func (m *GeoRadius) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoRadius.DiscardUnknown(m)
}

var xxx_messageInfo_GeoRadius proto.InternalMessageInfo

func (m *GeoRadius) GetCenter() *GeoPoint {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *GeoRadius) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

type GeoLineString struct {
	Points []*GeoPoint `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
}

func (m *GeoLineString) Reset()      { *m = GeoLineString{} }
func (*GeoLineString) ProtoMessage() {}
func (*GeoLineString) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{96}
}
func (m *GeoLineString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoLineString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoLineString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoLineString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoLineString.Merge(m, src)
}
func (m *GeoLineString) XXX_Size() int {
	return m.Size()
}
func (m *GeoLineString) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoLineString.DiscardUnknown(m)
}

var xxx_messageInfo_GeoLineString proto.InternalMessageInfo

func (m *GeoLineString) GetPoints() []*GeoPoint {
	if m != nil {
		return m.Points
	}
	return nil
}

type GeoPolygon struct {
	Exterior  *GeoLineString   `protobuf:"bytes,1,opt,name=exterior,proto3" json:"exterior,omitempty"`
	Interiors []*GeoLineString `protobuf:"bytes,2,rep,name=interiors,proto3" json:"interiors,omitempty"`
}

func (m *GeoPolygon) Reset()      { *m = GeoPolygon{} }
func (*GeoPolygon) ProtoMessage() {}
func (*GeoPolygon) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{97}
}
func (m *GeoPolygon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoPolygon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoPolygon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoPolygon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoPolygon.Merge(m, src)
}
func (m *GeoPolygon) XXX_Size() int {
	return m.Size()
}
func (m *GeoPolygon) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoPolygon.DiscardUnknown(m)
}

var xxx_messageInfo_GeoPolygon proto.InternalMessageInfo

func (m *GeoPolygon) GetExterior() *GeoLineString {
	if m != nil {
		return m.Exterior
	}
	return nil
}

func (m *GeoPolygon) GetInteriors() []*GeoLineString {
	if m != nil {
		return m.Interiors
	}
	return nil
}

type ValuesCount struct {
	Lt  uint64 `protobuf:"varint,1,opt,name=lt,proto3" json:"lt,omitempty"`
	Gt  uint64 `protobuf:"varint,2,opt,name=gt,proto3" json:"gt,omitempty"`
	Gte uint64 `protobuf:"varint,3,opt,name=gte,proto3" json:"gte,omitempty"`
	Lte uint64 `protobuf:"varint,4,opt,name=lte,proto3" json:"lte,omitempty"`
}

func (m *ValuesCount) Reset()      { *m = ValuesCount{} }
func (*ValuesCount) ProtoMessage() {}
func (*ValuesCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{98}
}
func (m *ValuesCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValuesCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValuesCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValuesCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValuesCount.Merge(m, src)
}
func (m *ValuesCount) XXX_Size() int {
	return m.Size()
}
func (m *ValuesCount) XXX_DiscardUnknown() {
	xxx_messageInfo_ValuesCount.DiscardUnknown(m)
}

var xxx_messageInfo_ValuesCount proto.InternalMessageInfo

func (m *ValuesCount) GetLt() uint64 {
	if m != nil {
		return m.Lt
	}
	return 0
}

func (m *ValuesCount) GetGt() uint64 {
	if m != nil {
		return m.Gt
	}
	return 0
}

func (m *ValuesCount) GetGte() uint64 {
	if m != nil {
		return m.Gte
	}
	return 0
}

func (m *ValuesCount) GetLte() uint64 {
	if m != nil {
		return m.Lte
	}
	return 0
}

type PointsSelector struct {
	// Types that are valid to be assigned to PointsSelectorOneOf:
	//
	//	*PointsSelector_Points
	//	*PointsSelector_Filter
	PointsSelectorOneOf isPointsSelector_PointsSelectorOneOf `protobuf_oneof:"points_selector_one_of"`
}

func (m *PointsSelector) Reset()      { *m = PointsSelector{} }
func (*PointsSelector) ProtoMessage() {}
func (*PointsSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{99}
}
func (m *PointsSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsSelector.Merge(m, src)
}
func (m *PointsSelector) XXX_Size() int {
	return m.Size()
}
func (m *PointsSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsSelector.DiscardUnknown(m)
}

var xxx_messageInfo_PointsSelector proto.InternalMessageInfo

type isPointsSelector_PointsSelectorOneOf interface {
	isPointsSelector_PointsSelectorOneOf()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PointsSelector_Points struct {
	Points *PointsIdsList `protobuf:"bytes,1,opt,name=points,proto3,oneof" json:"points,omitempty"`
}
type PointsSelector_Filter struct {
	Filter *Filter `protobuf:"bytes,2,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}

func (*PointsSelector_Points) isPointsSelector_PointsSelectorOneOf() {}
func (*PointsSelector_Filter) isPointsSelector_PointsSelectorOneOf() {}

func (m *PointsSelector) GetPointsSelectorOneOf() isPointsSelector_PointsSelectorOneOf {
	if m != nil {
		return m.PointsSelectorOneOf
	}
	return nil
}

func (m *PointsSelector) GetPoints() *PointsIdsList {
	if x, ok := m.GetPointsSelectorOneOf().(*PointsSelector_Points); ok {
		return x.Points
	}
	return nil
}

func (m *PointsSelector) GetFilter() *Filter {
	if x, ok := m.GetPointsSelectorOneOf().(*PointsSelector_Filter); ok {
		return x.Filter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PointsSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PointsSelector_Points)(nil),
		(*PointsSelector_Filter)(nil),
	}
}

type PointsIdsList struct {
	Ids []*PointId `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (m *PointsIdsList) Reset()      { *m = PointsIdsList{} }
func (*PointsIdsList) ProtoMessage() {}
func (*PointsIdsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{100}
}
func (m *PointsIdsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointsIdsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointsIdsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointsIdsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointsIdsList.Merge(m, src)
}
func (m *PointsIdsList) XXX_Size() int {
	return m.Size()
}
func (m *PointsIdsList) XXX_DiscardUnknown() {
	xxx_messageInfo_PointsIdsList.DiscardUnknown(m)
}

var xxx_messageInfo_PointsIdsList proto.InternalMessageInfo

func (m *PointsIdsList) GetIds() []*PointId {
	if m != nil {
		return m.Ids
	}
	return nil
}

type PointStruct struct {
	Id      *PointId          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Payload map[string]*Value `protobuf:"bytes,3,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Vectors *Vectors          `protobuf:"bytes,4,opt,name=vectors,proto3" json:"vectors,omitempty"`
}

func (m *PointStruct) Reset()      { *m = PointStruct{} }
func (*PointStruct) ProtoMessage() {}
func (*PointStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{101}
}
func (m *PointStruct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PointStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PointStruct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PointStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointStruct.Merge(m, src)
}
func (m *PointStruct) XXX_Size() int {
	return m.Size()
}
func (m *PointStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_PointStruct.DiscardUnknown(m)
}

var xxx_messageInfo_PointStruct proto.InternalMessageInfo

func (m *PointStruct) GetId() *PointId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PointStruct) GetPayload() map[string]*Value {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PointStruct) GetVectors() *Vectors {
	if m != nil {
		return m.Vectors
	}
	return nil
}

type GeoPoint struct {
	Lon float64 `protobuf:"fixed64,1,opt,name=lon,proto3" json:"lon,omitempty"`
	Lat float64 `protobuf:"fixed64,2,opt,name=lat,proto3" json:"lat,omitempty"`
}

func (m *GeoPoint) Reset()      { *m = GeoPoint{} }
func (*GeoPoint) ProtoMessage() {}
func (*GeoPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f0ead5c3d4d690b, []int{102}
}
func (m *GeoPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoPoint.Merge(m, src)
}
func (m *GeoPoint) XXX_Size() int {
	return m.Size()
}
func (m *GeoPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoPoint.DiscardUnknown(m)
}

var xxx_messageInfo_GeoPoint proto.InternalMessageInfo

func (m *GeoPoint) GetLon() float64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

func (m *GeoPoint) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func init() {
	proto.RegisterEnum("qdrant.WriteOrderingType", WriteOrderingType_name, WriteOrderingType_value)
	proto.RegisterEnum("qdrant.ReadConsistencyType", ReadConsistencyType_name, ReadConsistencyType_value)
	proto.RegisterEnum("qdrant.FieldType", FieldType_name, FieldType_value)
	proto.RegisterEnum("qdrant.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("qdrant.RecommendStrategy", RecommendStrategy_name, RecommendStrategy_value)
	proto.RegisterEnum("qdrant.Fusion", Fusion_name, Fusion_value)
	proto.RegisterEnum("qdrant.UpdateStatus", UpdateStatus_name, UpdateStatus_value)
	proto.RegisterType((*WriteOrdering)(nil), "qdrant.WriteOrdering")
	proto.RegisterType((*ReadConsistency)(nil), "qdrant.ReadConsistency")
	proto.RegisterType((*PointId)(nil), "qdrant.PointId")
	proto.RegisterType((*SparseIndices)(nil), "qdrant.SparseIndices")
	proto.RegisterType((*Vector)(nil), "qdrant.Vector")
	proto.RegisterType((*DenseVector)(nil), "qdrant.DenseVector")
	proto.RegisterType((*SparseVector)(nil), "qdrant.SparseVector")
	proto.RegisterType((*MultiDenseVector)(nil), "qdrant.MultiDenseVector")
	proto.RegisterType((*VectorInput)(nil), "qdrant.VectorInput")
	proto.RegisterType((*ShardKeySelector)(nil), "qdrant.ShardKeySelector")
	proto.RegisterType((*UpsertPoints)(nil), "qdrant.UpsertPoints")
	proto.RegisterType((*DeletePoints)(nil), "qdrant.DeletePoints")
	proto.RegisterType((*GetPoints)(nil), "qdrant.GetPoints")
	proto.RegisterType((*UpdatePointVectors)(nil), "qdrant.UpdatePointVectors")
	proto.RegisterType((*PointVectors)(nil), "qdrant.PointVectors")
	proto.RegisterType((*DeletePointVectors)(nil), "qdrant.DeletePointVectors")
	proto.RegisterType((*SetPayloadPoints)(nil), "qdrant.SetPayloadPoints")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.SetPayloadPoints.PayloadEntry")
	proto.RegisterType((*DeletePayloadPoints)(nil), "qdrant.DeletePayloadPoints")
	proto.RegisterType((*ClearPayloadPoints)(nil), "qdrant.ClearPayloadPoints")
	proto.RegisterType((*CreateFieldIndexCollection)(nil), "qdrant.CreateFieldIndexCollection")
	proto.RegisterType((*DeleteFieldIndexCollection)(nil), "qdrant.DeleteFieldIndexCollection")
	proto.RegisterType((*PayloadIncludeSelector)(nil), "qdrant.PayloadIncludeSelector")
	proto.RegisterType((*PayloadExcludeSelector)(nil), "qdrant.PayloadExcludeSelector")
	proto.RegisterType((*WithPayloadSelector)(nil), "qdrant.WithPayloadSelector")
	proto.RegisterType((*NamedVectors)(nil), "qdrant.NamedVectors")
	proto.RegisterMapType((map[string]*Vector)(nil), "qdrant.NamedVectors.VectorsEntry")
	proto.RegisterType((*Vectors)(nil), "qdrant.Vectors")
	proto.RegisterType((*VectorsSelector)(nil), "qdrant.VectorsSelector")
	proto.RegisterType((*WithVectorsSelector)(nil), "qdrant.WithVectorsSelector")
	proto.RegisterType((*QuantizationSearchParams)(nil), "qdrant.QuantizationSearchParams")
	proto.RegisterType((*SearchParams)(nil), "qdrant.SearchParams")
	proto.RegisterType((*SearchPoints)(nil), "qdrant.SearchPoints")
	proto.RegisterType((*SearchBatchPoints)(nil), "qdrant.SearchBatchPoints")
	proto.RegisterType((*WithLookup)(nil), "qdrant.WithLookup")
	proto.RegisterType((*SearchPointGroups)(nil), "qdrant.SearchPointGroups")
	proto.RegisterType((*StartFrom)(nil), "qdrant.StartFrom")
	proto.RegisterType((*OrderBy)(nil), "qdrant.OrderBy")
	proto.RegisterType((*ScrollPoints)(nil), "qdrant.ScrollPoints")
	proto.RegisterType((*LookupLocation)(nil), "qdrant.LookupLocation")
	proto.RegisterType((*RecommendPoints)(nil), "qdrant.RecommendPoints")
	proto.RegisterType((*RecommendBatchPoints)(nil), "qdrant.RecommendBatchPoints")
	proto.RegisterType((*RecommendPointGroups)(nil), "qdrant.RecommendPointGroups")
	proto.RegisterType((*TargetVector)(nil), "qdrant.TargetVector")
	proto.RegisterType((*VectorExample)(nil), "qdrant.VectorExample")
	proto.RegisterType((*ContextExamplePair)(nil), "qdrant.ContextExamplePair")
	proto.RegisterType((*DiscoverPoints)(nil), "qdrant.DiscoverPoints")
	proto.RegisterType((*DiscoverBatchPoints)(nil), "qdrant.DiscoverBatchPoints")
	proto.RegisterType((*CountPoints)(nil), "qdrant.CountPoints")
	proto.RegisterType((*RecommendInput)(nil), "qdrant.RecommendInput")
	proto.RegisterType((*ContextInputPair)(nil), "qdrant.ContextInputPair")
	proto.RegisterType((*DiscoverInput)(nil), "qdrant.DiscoverInput")
	proto.RegisterType((*ContextInput)(nil), "qdrant.ContextInput")
	proto.RegisterType((*Query)(nil), "qdrant.Query")
	proto.RegisterType((*PrefetchQuery)(nil), "qdrant.PrefetchQuery")
	proto.RegisterType((*QueryPoints)(nil), "qdrant.QueryPoints")
	proto.RegisterType((*QueryBatchPoints)(nil), "qdrant.QueryBatchPoints")
	proto.RegisterType((*PointsUpdateOperation)(nil), "qdrant.PointsUpdateOperation")
	proto.RegisterType((*PointsUpdateOperation_PointStructList)(nil), "qdrant.PointsUpdateOperation.PointStructList")
	proto.RegisterType((*PointsUpdateOperation_SetPayload)(nil), "qdrant.PointsUpdateOperation.SetPayload")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.PointsUpdateOperation.SetPayload.PayloadEntry")
	proto.RegisterType((*PointsUpdateOperation_OverwritePayload)(nil), "qdrant.PointsUpdateOperation.OverwritePayload")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.PointsUpdateOperation.OverwritePayload.PayloadEntry")
	proto.RegisterType((*PointsUpdateOperation_DeletePayload)(nil), "qdrant.PointsUpdateOperation.DeletePayload")
	proto.RegisterType((*PointsUpdateOperation_UpdateVectors)(nil), "qdrant.PointsUpdateOperation.UpdateVectors")
	proto.RegisterType((*PointsUpdateOperation_DeleteVectors)(nil), "qdrant.PointsUpdateOperation.DeleteVectors")
	proto.RegisterType((*PointsUpdateOperation_DeletePoints)(nil), "qdrant.PointsUpdateOperation.DeletePoints")
	proto.RegisterType((*PointsUpdateOperation_ClearPayload)(nil), "qdrant.PointsUpdateOperation.ClearPayload")
	proto.RegisterType((*UpdateBatchPoints)(nil), "qdrant.UpdateBatchPoints")
	proto.RegisterType((*PointsOperationResponse)(nil), "qdrant.PointsOperationResponse")
	proto.RegisterType((*UpdateResult)(nil), "qdrant.UpdateResult")
	proto.RegisterType((*OrderValue)(nil), "qdrant.OrderValue")
	proto.RegisterType((*ScoredPoint)(nil), "qdrant.ScoredPoint")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.ScoredPoint.PayloadEntry")
	proto.RegisterType((*GroupId)(nil), "qdrant.GroupId")
	proto.RegisterType((*PointGroup)(nil), "qdrant.PointGroup")
	proto.RegisterType((*GroupsResult)(nil), "qdrant.GroupsResult")
	proto.RegisterType((*SearchResponse)(nil), "qdrant.SearchResponse")
	proto.RegisterType((*QueryResponse)(nil), "qdrant.QueryResponse")
	proto.RegisterType((*QueryBatchResponse)(nil), "qdrant.QueryBatchResponse")
	proto.RegisterType((*BatchResult)(nil), "qdrant.BatchResult")
	proto.RegisterType((*SearchBatchResponse)(nil), "qdrant.SearchBatchResponse")
	proto.RegisterType((*SearchGroupsResponse)(nil), "qdrant.SearchGroupsResponse")
	proto.RegisterType((*CountResponse)(nil), "qdrant.CountResponse")
	proto.RegisterType((*ScrollResponse)(nil), "qdrant.ScrollResponse")
	proto.RegisterType((*CountResult)(nil), "qdrant.CountResult")
	proto.RegisterType((*RetrievedPoint)(nil), "qdrant.RetrievedPoint")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.RetrievedPoint.PayloadEntry")
	proto.RegisterType((*GetResponse)(nil), "qdrant.GetResponse")
	proto.RegisterType((*RecommendResponse)(nil), "qdrant.RecommendResponse")
	proto.RegisterType((*RecommendBatchResponse)(nil), "qdrant.RecommendBatchResponse")
	proto.RegisterType((*DiscoverResponse)(nil), "qdrant.DiscoverResponse")
	proto.RegisterType((*DiscoverBatchResponse)(nil), "qdrant.DiscoverBatchResponse")
	proto.RegisterType((*RecommendGroupsResponse)(nil), "qdrant.RecommendGroupsResponse")
	proto.RegisterType((*UpdateBatchResponse)(nil), "qdrant.UpdateBatchResponse")
	proto.RegisterType((*Filter)(nil), "qdrant.Filter")
	proto.RegisterType((*MinShould)(nil), "qdrant.MinShould")
	proto.RegisterType((*Condition)(nil), "qdrant.Condition")
	proto.RegisterType((*IsEmptyCondition)(nil), "qdrant.IsEmptyCondition")
	proto.RegisterType((*IsNullCondition)(nil), "qdrant.IsNullCondition")
	proto.RegisterType((*HasIdCondition)(nil), "qdrant.HasIdCondition")
	proto.RegisterType((*NestedCondition)(nil), "qdrant.NestedCondition")
	proto.RegisterType((*FieldCondition)(nil), "qdrant.FieldCondition")
	proto.RegisterType((*Match)(nil), "qdrant.Match")
	proto.RegisterType((*RepeatedStrings)(nil), "qdrant.RepeatedStrings")
	proto.RegisterType((*RepeatedIntegers)(nil), "qdrant.RepeatedIntegers")
	proto.RegisterType((*Range)(nil), "qdrant.Range")
	proto.RegisterType((*DatetimeRange)(nil), "qdrant.DatetimeRange")
	proto.RegisterType((*GeoBoundingBox)(nil), "qdrant.GeoBoundingBox")
	proto.RegisterType((*GeoRadius)(nil), "qdrant.GeoRadius")
	proto.RegisterType((*GeoLineString)(nil), "qdrant.GeoLineString")
	proto.RegisterType((*GeoPolygon)(nil), "qdrant.GeoPolygon")
	proto.RegisterType((*ValuesCount)(nil), "qdrant.ValuesCount")
	proto.RegisterType((*PointsSelector)(nil), "qdrant.PointsSelector")
	proto.RegisterType((*PointsIdsList)(nil), "qdrant.PointsIdsList")
	proto.RegisterType((*PointStruct)(nil), "qdrant.PointStruct")
	proto.RegisterMapType((map[string]*Value)(nil), "qdrant.PointStruct.PayloadEntry")
	proto.RegisterType((*GeoPoint)(nil), "qdrant.GeoPoint")
}

func init() { proto.RegisterFile("qdrant/points.proto", fileDescriptor_2f0ead5c3d4d690b) }

var fileDescriptor_2f0ead5c3d4d690b = []byte{
	// 5052 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x7c, 0x4d, 0x8c, 0x1c, 0xc7,
	0x75, 0xff, 0x74, 0xcf, 0xf7, 0x9b, 0x8f, 0xed, 0xad, 0x5d, 0x2e, 0xc7, 0xeb, 0xbf, 0x57, 0x62,
	0xd3, 0xb2, 0xa8, 0xa5, 0xb4, 0x2b, 0x92, 0x7f, 0x29, 0x12, 0x65, 0x4b, 0xd6, 0x2c, 0x25, 0xee,
	0x4a, 0xa2, 0x48, 0xf6, 0x52, 0x1f, 0xb1, 0x10, 0x0c, 0x9a, 0xd3, 0xb5, 0xb3, 0x2d, 0xf6, 0x74,
	0x8f, 0xba, 0x7b, 0xc8, 0x5d, 0x1d, 0x02, 0x5f, 0xac, 0x1c, 0x72, 0x48, 0x4e, 0x09, 0x10, 0xe4,
	0xe4, 0x43, 0xe2, 0x20, 0x06, 0x92, 0xb3, 0x73, 0x48, 0x10, 0x5f, 0x0c, 0xf8, 0x10, 0xe5, 0x60,
	0xc0, 0x87, 0x18, 0x88, 0x28, 0x20, 0x48, 0x6e, 0x06, 0x02, 0x04, 0x81, 0x91, 0x43, 0x50, 0x9f,
	0x5d, 0xdd, 0x3b, 0x33, 0x3b, 0xb3, 0x3b, 0xb4, 0x24, 0xe4, 0x34, 0x5d, 0xaf, 0xde, 0xab, 0x7e,
	0xf5, 0xea, 0xbd, 0x5f, 0xbd, 0xfa, 0xe8, 0x81, 0xa5, 0x8f, 0x9c, 0xd0, 0xf6, 0xe3, 0xcd, 0x41,
	0xe0, 0xfa, 0x71, 0xb4, 0x31, 0x08, 0x83, 0x38, 0x40, 0x25, 0x46, 0x5c, 0x6d, 0xf1, 0xca, 0x6e,
	0xe0, 0x79, 0xb8, 0x1b, 0xbb, 0x81, 0xcf, 0x39, 0x56, 0x1f, 0xeb, 0x05, 0x41, 0xcf, 0xc3, 0x9b,
	0xb4, 0x74, 0x77, 0xb8, 0xb7, 0x19, 0xbb, 0x7d, 0x1c, 0xc5, 0x76, 0x7f, 0xc0, 0x19, 0x56, 0xb9,
	0xe8, 0x87, 0x51, 0xe0, 0x77, 0x1e, 0xb8, 0xf1, 0x7e, 0xc7, 0xf5, 0x63, 0x56, 0x67, 0xbe, 0x0c,
	0x8d, 0xf7, 0x42, 0x37, 0xc6, 0x37, 0x43, 0x07, 0x87, 0xae, 0xdf, 0x43, 0xcf, 0x40, 0x21, 0x3e,
	0x1c, 0xe0, 0x96, 0xf6, 0xb8, 0x76, 0xa1, 0x79, 0xf9, 0x6b, 0x1b, 0x4c, 0x76, 0x23, 0xc5, 0x74,
	0xe7, 0x70, 0x80, 0x2d, 0xca, 0x66, 0xf6, 0x60, 0xc1, 0xc2, 0xb6, 0xb3, 0x15, 0xf8, 0x91, 0x1b,
	0xc5, 0xd8, 0xef, 0x1e, 0xa2, 0x4b, 0xa9, 0x16, 0xbe, 0x2e, 0x5a, 0xc8, 0xb0, 0x91, 0x36, 0xb6,
	0x73, 0xac, 0x15, 0xd4, 0x82, 0xd2, 0x9e, 0xdd, 0x8d, 0x83, 0xb0, 0xa5, 0x3f, 0xae, 0x5d, 0x28,
	0x6c, 0xe7, 0x2c, 0x5e, 0x6e, 0x97, 0xa1, 0x78, 0xdf, 0xf6, 0x86, 0xd8, 0xbc, 0x0e, 0xe5, 0x5b,
	0xc4, 0x2e, 0x3b, 0x0e, 0x42, 0x90, 0xf7, 0x87, 0x7d, 0xda, 0x3e, 0x61, 0x25, 0x05, 0xb4, 0x0c,
	0x85, 0xe1, 0xd0, 0x75, 0xa8, 0x7c, 0x95, 0xb4, 0x4b, 0x4a, 0x6d, 0x04, 0x06, 0x35, 0x66, 0xc7,
	0x75, 0x3a, 0xc1, 0x80, 0x1a, 0xcd, 0x3c, 0x0f, 0x8d, 0xdd, 0x81, 0x1d, 0x46, 0x78, 0xc7, 0x77,
	0xdc, 0x2e, 0x8e, 0x10, 0x82, 0x82, 0x63, 0xc7, 0x76, 0x4b, 0x7b, 0x3c, 0x7f, 0xa1, 0x61, 0xd1,
	0x67, 0x33, 0x84, 0xd2, 0xbb, 0x98, 0x28, 0x90, 0xaa, 0xd5, 0x59, 0x2d, 0xda, 0x84, 0xb2, 0xcb,
	0x84, 0xe9, 0xfb, 0x6a, 0x97, 0xcf, 0x88, 0x4e, 0xa6, 0x5a, 0xb6, 0x04, 0x17, 0x3a, 0x0f, 0x8d,
	0xfb, 0xb4, 0xb9, 0xa8, 0xd3, 0x0d, 0x86, 0x7e, 0xdc, 0xca, 0x3f, 0xae, 0x5d, 0x68, 0x58, 0x75,
	0x4e, 0xdc, 0x22, 0x34, 0xf3, 0x1c, 0xd4, 0xae, 0x61, 0x3f, 0xc2, 0xe3, 0x5f, 0x6c, 0x7e, 0x17,
	0xea, 0xec, 0x0d, 0x9c, 0x67, 0x05, 0x4a, 0xd4, 0x3a, 0x11, 0xe7, 0xe2, 0x25, 0xd4, 0x52, 0x15,
	0x24, 0xbd, 0x12, 0x45, 0xf3, 0x55, 0x30, 0x6e, 0x0c, 0xbd, 0xd8, 0x55, 0xdf, 0xf4, 0x0c, 0x94,
	0xb9, 0x22, 0xb4, 0x99, 0xda, 0xe5, 0x25, 0xd1, 0x1d, 0x85, 0xcb, 0x12, 0x3c, 0xe6, 0x2f, 0x34,
	0xa8, 0x31, 0xda, 0x8e, 0x3f, 0x18, 0xc6, 0xe8, 0x1c, 0xe8, 0xae, 0x43, 0x47, 0xa3, 0x76, 0x79,
	0x41, 0x48, 0xf2, 0xb1, 0xda, 0xce, 0x59, 0xba, 0xeb, 0xa0, 0x8b, 0x50, 0x74, 0x48, 0x53, 0xdc,
	0x5c, 0xa3, 0xda, 0xdf, 0xce, 0x59, 0x8c, 0x07, 0x6d, 0x40, 0x29, 0xa2, 0x9d, 0xa4, 0x56, 0xaa,
	0x5d, 0x5e, 0x4e, 0x1b, 0x57, 0xb2, 0x73, 0x2e, 0xf4, 0x12, 0xd4, 0xfa, 0xa4, 0x4b, 0x1d, 0xf6,
	0x8a, 0x02, 0x15, 0x6a, 0x09, 0xa1, 0x6c, 0x6f, 0xb7, 0x73, 0x16, 0xf4, 0x25, 0xad, 0x5d, 0x85,
	0xf2, 0x7d, 0x3b, 0x74, 0x6d, 0x3f, 0x36, 0xb7, 0xc0, 0xd8, 0xdd, 0xb7, 0x43, 0xe7, 0x4d, 0x7c,
	0xb8, 0x8b, 0x3d, 0x66, 0x9a, 0x4d, 0x80, 0x88, 0xd0, 0x3a, 0xf7, 0xf0, 0xa1, 0xb0, 0x8e, 0x21,
	0xf5, 0xe1, 0xdc, 0x56, 0x35, 0xe2, 0x4f, 0x91, 0xf9, 0x9f, 0x1a, 0xd4, 0xdf, 0x19, 0x44, 0x38,
	0x8c, 0xa9, 0x05, 0x22, 0xf4, 0x24, 0x2c, 0x24, 0x21, 0xdb, 0xf1, 0xed, 0x3e, 0x0b, 0x8c, 0xaa,
	0xd5, 0x4c, 0xc8, 0x6f, 0xdb, 0x7d, 0x4c, 0xc6, 0xfb, 0x81, 0xed, 0xc6, 0xd4, 0x44, 0x15, 0x8b,
	0x3e, 0xa3, 0x8b, 0x50, 0x62, 0x60, 0xd0, 0xca, 0xa7, 0x07, 0x86, 0x36, 0xbe, 0x1b, 0x87, 0xc3,
	0x6e, 0x6c, 0x71, 0x16, 0x74, 0x09, 0x2a, 0x01, 0x0f, 0x50, 0x6e, 0x84, 0x33, 0x23, 0xa3, 0xd7,
	0x92, 0x6c, 0xe8, 0x75, 0x40, 0xb2, 0x7b, 0x9d, 0x88, 0x77, 0xba, 0x55, 0x4c, 0x5b, 0x30, 0x6b,
	0x14, 0xcb, 0x88, 0x32, 0x14, 0xf3, 0xbf, 0x34, 0xa8, 0x5f, 0xc3, 0x1e, 0x8e, 0xf1, 0x3c, 0x7a,
	0xbd, 0xa1, 0xf4, 0x9a, 0x68, 0xb2, 0x92, 0xea, 0x75, 0x24, 0xf5, 0xf8, 0x12, 0x74, 0xfc, 0x3f,
	0x74, 0xa8, 0x5e, 0xc7, 0x33, 0x8f, 0xf5, 0x39, 0xc8, 0xbb, 0x0e, 0x8b, 0xcd, 0xa3, 0x31, 0x63,
	0x91, 0x3a, 0xf4, 0x32, 0xd4, 0x29, 0x54, 0x0f, 0xec, 0x43, 0x2f, 0xb0, 0x1d, 0xde, 0x31, 0x89,
	0xa6, 0xef, 0xb9, 0xf1, 0xfe, 0x2d, 0x56, 0x25, 0xd5, 0xab, 0x3d, 0x48, 0x88, 0x52, 0x5e, 0x44,
	0x76, 0xf1, 0xa8, 0x3c, 0x0b, 0x88, 0x28, 0x2d, 0xcf, 0x89, 0xa8, 0x0d, 0x46, 0x88, 0x6d, 0xa7,
	0xd3, 0x4d, 0x20, 0xbb, 0x55, 0xa2, 0x6d, 0x9c, 0x1d, 0x83, 0xe8, 0xd6, 0x42, 0x98, 0x99, 0x09,
	0x46, 0x5b, 0xb9, 0x3c, 0xab, 0x95, 0xdf, 0x28, 0x54, 0xf2, 0x46, 0xc1, 0xfc, 0x8d, 0x06, 0xe8,
	0x9d, 0x81, 0x63, 0x73, 0x27, 0x13, 0x8a, 0x9e, 0xca, 0xd5, 0x9e, 0xce, 0x04, 0xd8, 0x72, 0x6a,
	0x2c, 0xf8, 0x2b, 0xbe, 0x0c, 0x8e, 0xf6, 0x3d, 0xa8, 0xa7, 0x7a, 0xfd, 0xd8, 0x04, 0xd0, 0xa5,
	0x90, 0xfb, 0x54, 0x02, 0xea, 0x7a, 0x9a, 0x4b, 0xf4, 0x4a, 0x02, 0xfa, 0x3f, 0xe8, 0x80, 0x94,
	0xe8, 0x9d, 0x8b, 0x61, 0x5f, 0x81, 0x05, 0x66, 0xb4, 0xa4, 0xd3, 0x93, 0x83, 0xb9, 0x39, 0x48,
	0x95, 0xd1, 0xa5, 0x44, 0xff, 0x42, 0xda, 0xed, 0xb2, 0x6e, 0x2b, 0xf8, 0x52, 0xc3, 0x53, 0x3c,
	0xcd, 0xf0, 0x94, 0x66, 0x1e, 0x9e, 0xbf, 0xc9, 0x83, 0xb1, 0x8b, 0x63, 0x1e, 0x7c, 0xf3, 0x00,
	0xc1, 0x57, 0xa0, 0x2c, 0x42, 0x9f, 0xb9, 0xe6, 0x13, 0x52, 0x9d, 0xcc, 0x7b, 0x36, 0x78, 0xe9,
	0x35, 0x3f, 0x0e, 0x0f, 0x2d, 0x21, 0x35, 0x6a, 0x04, 0x8a, 0x33, 0x8e, 0x40, 0x62, 0xce, 0xd2,
	0x69, 0xcc, 0x39, 0x73, 0xc0, 0x23, 0x03, 0xf2, 0xf7, 0xf0, 0x61, 0xab, 0x42, 0xad, 0x45, 0x1e,
	0x57, 0x77, 0xa0, 0xae, 0x76, 0x53, 0x70, 0x68, 0x92, 0x03, 0x9d, 0xe7, 0x99, 0x22, 0x77, 0xf7,
	0x86, 0x74, 0x17, 0x42, 0xb4, 0x58, 0xdd, 0x55, 0xfd, 0x05, 0xed, 0x8d, 0x42, 0xa5, 0x60, 0x14,
	0xcd, 0x1f, 0xe9, 0xb0, 0xc4, 0x9d, 0x7e, 0x7e, 0x83, 0x86, 0xa0, 0x40, 0x13, 0x05, 0x32, 0x62,
	0x55, 0x8b, 0x3e, 0x7f, 0x95, 0xc7, 0x81, 0x9b, 0xea, 0x7f, 0x34, 0x40, 0x5b, 0x1e, 0xb6, 0xc3,
	0x39, 0x5a, 0xea, 0x2b, 0x34, 0xc7, 0xff, 0xa5, 0x0e, 0xab, 0x5b, 0x21, 0xb6, 0x63, 0xfc, 0xba,
	0x8b, 0x3d, 0x67, 0xc7, 0x77, 0xf0, 0xc1, 0x96, 0xec, 0xe1, 0xe9, 0xcc, 0xf0, 0x0d, 0x80, 0x3d,
	0xd2, 0x28, 0x93, 0xcb, 0x53, 0xb9, 0x2a, 0xa5, 0x50, 0x91, 0x67, 0x45, 0x35, 0x5d, 0x50, 0x15,
	0xe8, 0x82, 0x6a, 0x51, 0xa8, 0x4e, 0xb5, 0xa1, 0x4b, 0x31, 0x26, 0x41, 0x1e, 0xd1, 0x36, 0x20,
	0x26, 0xe1, 0x12, 0x35, 0x3b, 0x03, 0x3b, 0xb4, 0xfb, 0x62, 0xf2, 0x5f, 0x95, 0x36, 0x66, 0xe3,
	0x48, 0x7b, 0x72, 0x8b, 0x72, 0x58, 0xc6, 0x9e, 0xec, 0x1b, 0xa3, 0x9c, 0xc0, 0xed, 0xcc, 0xbf,
	0xd6, 0x60, 0x95, 0xc5, 0xd4, 0x6f, 0xdd, 0x52, 0xb3, 0xfb, 0x87, 0xf9, 0x2c, 0xac, 0x48, 0x43,
	0x74, 0xbd, 0xa1, 0x83, 0x65, 0xc4, 0xad, 0x40, 0x89, 0xb6, 0xcc, 0x32, 0xfe, 0xaa, 0xc5, 0x4b,
	0x8a, 0xc4, 0x6b, 0x07, 0xd3, 0x49, 0xfc, 0x9d, 0x06, 0x4b, 0x23, 0x52, 0x35, 0xb2, 0xe0, 0xc5,
	0xbe, 0x7d, 0xd7, 0x63, 0x16, 0xa8, 0x90, 0xd5, 0x0c, 0x2b, 0xa3, 0xab, 0x64, 0xe9, 0x46, 0x1b,
	0xe7, 0x40, 0xb6, 0x76, 0x64, 0xd4, 0x52, 0xaf, 0xde, 0xce, 0x59, 0x42, 0x80, 0xc8, 0x62, 0xa6,
	0x18, 0x8f, 0xaa, 0xac, 0x6c, 0x46, 0x6d, 0x22, 0xcb, 0x05, 0xc8, 0x52, 0x59, 0xc4, 0x88, 0x5c,
	0x2a, 0xff, 0xa9, 0x06, 0x75, 0x62, 0x5d, 0x47, 0xa4, 0x04, 0x2f, 0x65, 0x57, 0x8a, 0xe7, 0xc4,
	0x0b, 0x54, 0x36, 0x31, 0x43, 0xf3, 0x09, 0x89, 0x4b, 0xac, 0xbe, 0x01, 0x75, 0xb5, 0x62, 0x04,
	0x84, 0x7f, 0x33, 0x0d, 0xe1, 0xcd, 0xf4, 0x8c, 0xaf, 0x60, 0xb8, 0x79, 0x00, 0x65, 0xa1, 0xd3,
	0x05, 0x28, 0xb1, 0x37, 0xf0, 0x6c, 0x28, 0x23, 0x45, 0x4c, 0xcb, 0xea, 0xd1, 0xb3, 0xd9, 0x94,
	0x68, 0x79, 0x94, 0xf6, 0xc4, 0x28, 0x9c, 0xad, 0xbd, 0x08, 0x0b, 0x62, 0xdd, 0x2e, 0x6c, 0xf2,
	0x24, 0x2c, 0x64, 0x12, 0x10, 0xb4, 0x0c, 0x45, 0xe2, 0x94, 0x62, 0xec, 0x59, 0xc1, 0x3c, 0x60,
	0x23, 0x9f, 0x65, 0x1e, 0x3f, 0xf2, 0x57, 0xb2, 0x23, 0x3f, 0x2e, 0xe3, 0x51, 0x86, 0x7c, 0xe4,
	0xb0, 0x0d, 0xa0, 0x75, 0x7b, 0x68, 0xfb, 0xb1, 0xfb, 0xb1, 0x4d, 0x08, 0xbb, 0xd8, 0x0e, 0xbb,
	0xfb, 0x3c, 0xaa, 0x57, 0xa0, 0xe4, 0xf6, 0xfc, 0x20, 0xe4, 0xaf, 0xb7, 0x78, 0x09, 0xb5, 0xa0,
	0x1c, 0xe2, 0xa8, 0x4b, 0x2a, 0x58, 0xd4, 0x89, 0x22, 0x32, 0xa1, 0x1e, 0xdc, 0xc7, 0x61, 0x64,
	0xf7, 0x07, 0x1e, 0x89, 0x2e, 0xe2, 0x59, 0x9a, 0x95, 0xa2, 0x99, 0x7f, 0xa1, 0x41, 0x3d, 0xf5,
	0x9a, 0xb3, 0x50, 0xde, 0xf7, 0xa3, 0x07, 0x1d, 0xbc, 0xc7, 0xb6, 0x69, 0xac, 0x12, 0x29, 0xbe,
	0xb6, 0x47, 0x6c, 0x85, 0x0f, 0xec, 0xae, 0x88, 0x6d, 0x56, 0x40, 0xd7, 0xa0, 0xfe, 0x91, 0xa2,
	0x31, 0xf7, 0xde, 0xc7, 0x45, 0xff, 0xc7, 0xf5, 0xc6, 0x4a, 0x49, 0xa1, 0x73, 0x50, 0xa7, 0xa8,
	0x87, 0x9d, 0x4e, 0xe0, 0x7b, 0x87, 0x14, 0x07, 0x2a, 0x56, 0x8d, 0xd3, 0x6e, 0xfa, 0xde, 0xa1,
	0xf9, 0x07, 0x45, 0xa9, 0xe8, 0x8c, 0x93, 0xd8, 0x8a, 0x74, 0x33, 0x9d, 0x6f, 0xb5, 0xb0, 0xf1,
	0xfc, 0x16, 0x89, 0x7c, 0x2f, 0xc6, 0x22, 0xbf, 0x6d, 0x26, 0xf0, 0x4c, 0xa8, 0x16, 0xaf, 0x25,
	0x1d, 0xf7, 0xdc, 0xbe, 0x1b, 0x53, 0xad, 0x0a, 0x16, 0x2b, 0x1c, 0x59, 0xe5, 0x95, 0x66, 0x5c,
	0xe5, 0x91, 0xf5, 0x0b, 0x83, 0xf8, 0x72, 0x66, 0xaf, 0x44, 0x35, 0x13, 0xe7, 0x21, 0x9d, 0xa5,
	0x63, 0xda, 0x89, 0xf7, 0x43, 0x1c, 0xed, 0x07, 0x9e, 0x43, 0x53, 0x2c, 0xdd, 0x6a, 0x52, 0xf2,
	0x1d, 0x41, 0x25, 0x9d, 0x0d, 0xf6, 0xf6, 0x22, 0x1c, 0xb7, 0xaa, 0x6c, 0xf4, 0x58, 0x09, 0x3d,
	0x06, 0x35, 0xd6, 0x6d, 0x66, 0x29, 0xa0, 0x96, 0x02, 0x46, 0xa2, 0x56, 0xca, 0xae, 0x3a, 0x6b,
	0x73, 0x58, 0x75, 0xd6, 0x67, 0x5c, 0x75, 0xb6, 0xa0, 0x1c, 0xbb, 0x7d, 0x1c, 0x0c, 0xe3, 0x56,
	0x83, 0x6a, 0x2f, 0x8a, 0x63, 0x32, 0x82, 0xe6, 0xcc, 0xe9, 0xe9, 0xb7, 0xa1, 0xc9, 0xf6, 0x9e,
	0x3a, 0x62, 0x97, 0x6d, 0x61, 0xd2, 0x36, 0x60, 0x23, 0x52, 0x8b, 0x6f, 0x14, 0x2a, 0x45, 0xa3,
	0x64, 0xfe, 0x42, 0x83, 0x45, 0x36, 0x48, 0x6d, 0x3b, 0x9e, 0xdd, 0x1d, 0x5f, 0x84, 0x46, 0x44,
	0xa5, 0x3b, 0x3c, 0x8d, 0xd2, 0xd3, 0xeb, 0x57, 0xd5, 0xc9, 0xad, 0x7a, 0xa4, 0xba, 0xfc, 0x28,
	0x1b, 0xe7, 0x4f, 0x6e, 0xe3, 0x42, 0xca, 0xc6, 0xe6, 0x8f, 0x35, 0x00, 0x32, 0xcc, 0x6f, 0x05,
	0xc1, 0xbd, 0xe1, 0x00, 0xad, 0x01, 0x24, 0x9a, 0xf3, 0xbe, 0x28, 0x94, 0x23, 0x01, 0xa0, 0x9f,
	0x72, 0x9b, 0x23, 0x3f, 0x9b, 0xc3, 0x99, 0xbf, 0x2a, 0x8a, 0x61, 0xa0, 0xd6, 0xb9, 0x1e, 0x06,
	0xc3, 0xc1, 0x17, 0x85, 0x0a, 0x8d, 0x71, 0xa8, 0x50, 0x3c, 0x31, 0x2a, 0x94, 0x4e, 0x86, 0x0a,
	0xe5, 0x91, 0xa8, 0x90, 0x89, 0xfe, 0xca, 0xb1, 0xd1, 0x5f, 0x9d, 0x31, 0xfa, 0xbf, 0x06, 0x95,
	0x1e, 0x19, 0x80, 0xce, 0xdd, 0x43, 0x8e, 0x2d, 0x65, 0x5a, 0x6e, 0x1f, 0x92, 0xf4, 0x8f, 0x55,
	0x45, 0xee, 0xc7, 0x98, 0xc2, 0x4a, 0xc3, 0xaa, 0x52, 0xca, 0xae, 0xfb, 0x31, 0x9e, 0x0b, 0x6e,
	0x5c, 0x01, 0xaa, 0x4c, 0xc7, 0xa3, 0x9e, 0x4b, 0xb1, 0xa3, 0x76, 0x19, 0xa9, 0xca, 0x33, 0x9f,
	0xb6, 0xe0, 0x41, 0xe2, 0xdf, 0x4a, 0x20, 0x34, 0xa7, 0x01, 0x9b, 0x85, 0x39, 0x80, 0x8d, 0x31,
	0x3d, 0xd8, 0x98, 0x3f, 0xd4, 0xa0, 0xba, 0x1b, 0xdb, 0x61, 0xfc, 0x7a, 0x18, 0xf4, 0xd1, 0x0a,
	0x14, 0xf7, 0xbc, 0xc0, 0x8e, 0xa9, 0x37, 0x6b, 0xdb, 0x39, 0x8b, 0x15, 0xd1, 0x2a, 0x49, 0x3d,
	0x62, 0xdc, 0xc3, 0xec, 0x00, 0x26, 0xcf, 0x32, 0x0c, 0x4a, 0x40, 0x57, 0xa1, 0x2a, 0x0f, 0x94,
	0xb8, 0x37, 0xaf, 0x6e, 0xb0, 0x23, 0xa7, 0x0d, 0x71, 0xe4, 0xb4, 0x71, 0x47, 0x70, 0x6c, 0xe7,
	0xac, 0x84, 0x1d, 0xfd, 0x3f, 0xa8, 0x38, 0x76, 0x8c, 0x09, 0x81, 0x7a, 0x78, 0x75, 0x3b, 0x67,
	0x49, 0x4a, 0x72, 0xb6, 0xf3, 0xfb, 0x50, 0xa6, 0xf9, 0x79, 0x7b, 0x54, 0x52, 0xb8, 0x09, 0x55,
	0xc7, 0x0d, 0x39, 0x80, 0xe8, 0xe9, 0x25, 0xd0, 0x35, 0x51, 0x61, 0x25, 0x3c, 0x64, 0xd1, 0x14,
	0x91, 0x1e, 0x77, 0xf6, 0xc2, 0xa0, 0xcf, 0x35, 0x96, 0x12, 0xd2, 0x16, 0x56, 0x35, 0x12, 0x8f,
	0xe6, 0xbf, 0xe4, 0xa1, 0xbe, 0xdb, 0x0d, 0x03, 0xcf, 0x9b, 0x15, 0x86, 0x93, 0x38, 0xd7, 0x27,
	0xc6, 0xf9, 0x93, 0x72, 0x42, 0xcd, 0x8f, 0xde, 0xb2, 0x13, 0x33, 0xec, 0x74, 0x80, 0x50, 0x3a,
	0x25, 0x4a, 0x96, 0xe7, 0x30, 0x2d, 0x57, 0xe6, 0xb2, 0x19, 0x5c, 0x9d, 0x39, 0x1e, 0xd6, 0xf9,
	0x4a, 0x4f, 0x80, 0x84, 0x62, 0x4c, 0xee, 0x44, 0x56, 0x39, 0x60, 0x0f, 0x7c, 0xaa, 0xfd, 0xa1,
	0x06, 0x4d, 0x16, 0xae, 0x6f, 0x05, 0x5d, 0x7b, 0xb6, 0xa5, 0x68, 0x06, 0xf3, 0xf4, 0x23, 0x98,
	0x37, 0xba, 0x5b, 0xf9, 0xd9, 0x4f, 0x12, 0x4a, 0xb0, 0x60, 0xe1, 0x6e, 0xd0, 0xef, 0x63, 0x7f,
	0xe6, 0x1d, 0x96, 0x8b, 0x50, 0x19, 0x04, 0x91, 0x1b, 0xbb, 0xf7, 0xf1, 0xb8, 0x43, 0x05, 0xc9,
	0x40, 0x98, 0x7d, 0xdc, 0xb3, 0x29, 0x73, 0x7e, 0x0c, 0xb3, 0x60, 0x50, 0x1c, 0xbc, 0x30, 0xdd,
	0x44, 0x56, 0x9c, 0x94, 0xde, 0x96, 0x4f, 0x3c, 0x91, 0x55, 0x4e, 0x36, 0x91, 0x55, 0x8f, 0x49,
	0x6f, 0x21, 0x95, 0xde, 0x2e, 0x43, 0x71, 0x18, 0x91, 0x35, 0x4e, 0x8d, 0x5a, 0x99, 0x15, 0x8e,
	0x04, 0x4f, 0x7d, 0xc6, 0xe0, 0xf9, 0x1d, 0xa8, 0xb1, 0x29, 0x85, 0x01, 0x52, 0x23, 0xbd, 0xdf,
	0x95, 0x76, 0x4c, 0x0b, 0x18, 0x2b, 0x45, 0xeb, 0x51, 0x51, 0xd7, 0x9c, 0x31, 0xea, 0x9e, 0x83,
	0x4a, 0x14, 0x87, 0x76, 0x8c, 0x7b, 0x87, 0x74, 0xde, 0x50, 0x8e, 0xf4, 0xa5, 0xb7, 0xed, 0x72,
	0x06, 0x4b, 0xb2, 0xa2, 0x17, 0xc1, 0x10, 0xfe, 0x22, 0xfb, 0xbd, 0x48, 0x7d, 0x25, 0xbb, 0x28,
	0x5f, 0x10, 0x7c, 0xa2, 0xbb, 0x2f, 0x82, 0x21, 0xbc, 0x47, 0x8a, 0xa2, 0xd1, 0xa2, 0x82, 0x4f,
	0x88, 0x2a, 0x93, 0xe9, 0xd2, 0x34, 0x93, 0xe9, 0xf2, 0x09, 0x36, 0x34, 0x4b, 0x46, 0xd9, 0xfc,
	0x4c, 0x83, 0x65, 0xd9, 0xfb, 0x13, 0xa5, 0xdf, 0x74, 0x68, 0x78, 0x03, 0xe9, 0x0c, 0xfc, 0xec,
	0x11, 0xf3, 0xf2, 0x24, 0x7c, 0x21, 0xcc, 0x44, 0xf7, 0xa3, 0xcd, 0xc3, 0xff, 0xbe, 0xac, 0xf4,
	0xf1, 0x44, 0xb9, 0xed, 0x97, 0x0c, 0x54, 0x1a, 0x5f, 0xf2, 0x35, 0xb3, 0x04, 0x8f, 0xea, 0x24,
	0xf0, 0x80, 0xd3, 0x81, 0x47, 0x6d, 0x6a, 0xf0, 0x50, 0x73, 0xe9, 0xfa, 0xa4, 0x5c, 0xba, 0x31,
	0x4d, 0x2e, 0xdd, 0x3c, 0x5d, 0x2e, 0xbd, 0x30, 0x55, 0x2e, 0xad, 0x62, 0xd5, 0xe2, 0xe9, 0xb0,
	0x0a, 0x9d, 0x1c, 0xab, 0x96, 0x66, 0xc6, 0xaa, 0xe5, 0x69, 0xb0, 0xea, 0xcc, 0xcc, 0x19, 0xc1,
	0x0e, 0xd4, 0xef, 0xd8, 0x61, 0x0f, 0xf3, 0x03, 0x59, 0xb4, 0x09, 0x25, 0xe2, 0x52, 0x7c, 0xe7,
	0x50, 0x59, 0x00, 0xb0, 0xfa, 0xd7, 0x0e, 0xec, 0xfe, 0xc0, 0xc3, 0xf4, 0x62, 0x0c, 0x65, 0x6b,
	0x57, 0xa0, 0x14, 0xd3, 0x06, 0xcc, 0x1e, 0x34, 0x52, 0x4c, 0xd3, 0xdc, 0xd9, 0xb9, 0xa0, 0x2c,
	0x6d, 0x27, 0xee, 0xab, 0xb6, 0xab, 0x50, 0xc6, 0xac, 0x5d, 0xf3, 0x63, 0x40, 0x5b, 0x81, 0x1f,
	0xe3, 0x83, 0x98, 0xbf, 0xe9, 0x96, 0xed, 0xd2, 0x13, 0x2c, 0x89, 0x24, 0x93, 0x74, 0x57, 0xf0,
	0xe4, 0x92, 0x82, 0x27, 0xfa, 0x44, 0x11, 0xc1, 0x66, 0xfe, 0x49, 0x11, 0x9a, 0xd7, 0xdc, 0xa8,
	0x1b, 0xdc, 0xc7, 0xe1, 0xac, 0x78, 0xfe, 0xb4, 0x30, 0x55, 0x76, 0x67, 0x58, 0x1d, 0x01, 0x8b,
	0xf3, 0xa0, 0xff, 0x0f, 0xe5, 0x2e, 0xeb, 0x25, 0xc7, 0x3a, 0x79, 0xb2, 0x72, 0xb4, 0xf3, 0x96,
	0x60, 0x9d, 0x73, 0x2a, 0xf5, 0x68, 0x51, 0x2f, 0xc9, 0x90, 0x2a, 0xa3, 0x33, 0xa4, 0x2f, 0x07,
	0xc8, 0x7d, 0x25, 0xb6, 0x0b, 0xcd, 0x5f, 0x69, 0xb0, 0x24, 0x1c, 0xf3, 0x44, 0xd9, 0xc6, 0x2b,
	0xb0, 0xe0, 0x70, 0xf9, 0x74, 0xb2, 0xb1, 0x92, 0x2c, 0x84, 0x55, 0xbf, 0xb7, 0x9a, 0x4e, 0x3a,
	0x0e, 0x1e, 0x6d, 0xaa, 0xf1, 0x7d, 0x1d, 0x6a, 0xf4, 0x0a, 0xe3, 0xa3, 0x5a, 0x3d, 0xcb, 0x43,
	0x83, 0xbc, 0x7a, 0x68, 0x30, 0xaa, 0x53, 0x85, 0xb9, 0x2c, 0x4a, 0x67, 0x3f, 0x23, 0xfe, 0x2b,
	0x0d, 0x9a, 0x72, 0x8e, 0x62, 0xd7, 0x22, 0x37, 0x53, 0xa0, 0x97, 0xba, 0xbd, 0xa7, 0xdc, 0x9e,
	0x54, 0x20, 0x6f, 0x33, 0x05, 0x79, 0xe3, 0x05, 0x64, 0x1a, 0xa5, 0xce, 0x97, 0xf9, 0xa9, 0xe7,
	0x4b, 0x33, 0x06, 0x83, 0xc3, 0x14, 0x6d, 0x90, 0x22, 0xf4, 0xe6, 0x11, 0x84, 0x9e, 0x49, 0x59,
	0xed, 0x58, 0x65, 0x4d, 0x0f, 0x1a, 0xc2, 0x49, 0x99, 0x7d, 0x2e, 0x4a, 0xc8, 0x9d, 0xf0, 0x42,
	0x81, 0xb8, 0x1b, 0x09, 0xe2, 0x66, 0x00, 0x5a, 0xed, 0x8a, 0xc4, 0x5a, 0xf3, 0x65, 0xa8, 0xab,
	0x15, 0x68, 0x03, 0x8a, 0x03, 0xdb, 0x95, 0xc7, 0x96, 0xad, 0x51, 0xd2, 0x14, 0xad, 0x19, 0x9b,
	0xf9, 0x13, 0x1d, 0x8a, 0xb7, 0x87, 0x38, 0x3c, 0x44, 0x9b, 0x50, 0xf6, 0xb1, 0x1d, 0xe2, 0x68,
	0x92, 0x9e, 0xdb, 0x39, 0x4b, 0x70, 0xa1, 0xe7, 0xa1, 0x2a, 0x33, 0x7d, 0xae, 0xec, 0xca, 0x91,
	0x61, 0x11, 0x52, 0x09, 0x2b, 0xba, 0x02, 0x15, 0x11, 0xb5, 0x3c, 0x36, 0xcf, 0x64, 0xa3, 0x5b,
	0x48, 0x49, 0x46, 0xf4, 0x6c, 0x62, 0x97, 0xc2, 0x78, 0xbb, 0x10, 0xf5, 0xc4, 0x2c, 0xf4, 0xb4,
	0xb2, 0x7d, 0x52, 0x1c, 0xb9, 0x7d, 0x42, 0xb8, 0xf9, 0x06, 0x0a, 0x49, 0x02, 0xf6, 0x86, 0x91,
	0x1b, 0xf8, 0x74, 0xbe, 0x69, 0x2a, 0x11, 0x4a, 0xa9, 0xf4, 0xa2, 0x36, 0x7d, 0x52, 0x2f, 0xd2,
	0xfe, 0x5c, 0x87, 0xc6, 0xad, 0x10, 0xef, 0xe1, 0xb8, 0xbb, 0xcf, 0x8c, 0x48, 0x12, 0x00, 0x4e,
	0xe0, 0x23, 0x20, 0xfb, 0x96, 0x62, 0xb4, 0x24, 0x1b, 0x3a, 0x0f, 0xc5, 0x8f, 0x08, 0x29, 0x7b,
	0x9d, 0x87, 0xf1, 0xb1, 0xba, 0x64, 0x3a, 0xca, 0xab, 0xd3, 0xd1, 0xb4, 0x13, 0x6d, 0x32, 0x25,
	0x16, 0x4f, 0xb6, 0x10, 0x28, 0x8d, 0x5b, 0x08, 0xb0, 0xf9, 0xbb, 0xac, 0xce, 0xdf, 0x99, 0x39,
	0xae, 0x32, 0xed, 0x1c, 0x67, 0xfe, 0x6d, 0x11, 0x6a, 0xb4, 0xd3, 0xb3, 0xa2, 0xab, 0x6a, 0x74,
	0x7d, 0x46, 0xa3, 0xe7, 0xa7, 0x31, 0x7a, 0x61, 0xb4, 0xd1, 0x8b, 0x53, 0x1a, 0x7d, 0xae, 0x67,
	0x13, 0xd2, 0xe8, 0x15, 0xd5, 0xe8, 0xe3, 0xce, 0x31, 0x4f, 0x9b, 0xb0, 0x64, 0x93, 0xb1, 0xda,
	0x8c, 0xc9, 0xd8, 0x3c, 0xf2, 0x96, 0xd1, 0x53, 0x57, 0x63, 0xe6, 0xfd, 0xd4, 0x8c, 0x63, 0x36,
	0xa7, 0x4e, 0xbe, 0x94, 0x84, 0x60, 0x21, 0x9d, 0x10, 0xfc, 0xb3, 0x06, 0x06, 0x75, 0x99, 0x13,
	0x65, 0x3b, 0xcf, 0x43, 0x9d, 0x3a, 0x5a, 0x3a, 0xd5, 0x59, 0x4a, 0xf9, 0x22, 0xcf, 0x73, 0x6a,
	0x1f, 0x29, 0x81, 0xf1, 0x68, 0x93, 0x9c, 0x3f, 0x5f, 0x82, 0x33, 0xec, 0x45, 0xec, 0x0e, 0xf2,
	0xcd, 0x01, 0x0e, 0xd9, 0x5e, 0xf2, 0x75, 0x28, 0x0d, 0xe9, 0x8d, 0x7f, 0x3e, 0x41, 0x3c, 0x93,
	0xbe, 0xca, 0x96, 0x61, 0x57, 0xaf, 0xee, 0xbf, 0xe5, 0x46, 0x04, 0x9b, 0xb9, 0x38, 0xda, 0x81,
	0x45, 0x87, 0xde, 0x9e, 0xea, 0x38, 0x78, 0x10, 0xe2, 0xae, 0x1d, 0xe3, 0x23, 0x33, 0x48, 0xfa,
	0x7a, 0x5c, 0x5b, 0x6f, 0x69, 0xdb, 0x39, 0xcb, 0x60, 0x62, 0xd7, 0xa4, 0x14, 0x7a, 0x13, 0x6a,
	0x11, 0x8e, 0x3b, 0xc9, 0x0d, 0x52, 0xd2, 0xc8, 0x85, 0xc9, 0x8a, 0x25, 0xf7, 0x4a, 0xb7, 0x73,
	0x16, 0x44, 0xb2, 0x84, 0x7e, 0x0f, 0x16, 0xc9, 0x64, 0xf3, 0x20, 0x74, 0x63, 0x9c, 0xb9, 0x8f,
	0xbe, 0x31, 0xb9, 0xc9, 0x9b, 0x42, 0x2c, 0x69, 0xd8, 0x08, 0x32, 0x34, 0x74, 0x07, 0x9a, 0xbc,
	0xdb, 0xe9, 0xf3, 0xce, 0x8b, 0x93, 0xdb, 0x4e, 0x5d, 0xde, 0xdc, 0xce, 0x59, 0x0d, 0x47, 0x25,
	0xa0, 0x77, 0xa1, 0xd5, 0xf5, 0xb0, 0x1d, 0x8a, 0x46, 0x55, 0x9b, 0x96, 0xa6, 0xb0, 0xe9, 0x4a,
	0x57, 0xb9, 0xf1, 0xa8, 0x58, 0xf6, 0x0e, 0x34, 0x87, 0x54, 0x93, 0xcc, 0x61, 0xca, 0x31, 0xda,
	0xb2, 0x72, 0x72, 0xc5, 0xa8, 0x31, 0x54, 0x09, 0x8a, 0x0d, 0x44, 0xab, 0x95, 0xe9, 0x6d, 0xa0,
	0xb4, 0xea, 0xa8, 0x04, 0x74, 0x1b, 0x1a, 0xc2, 0xb2, 0x2c, 0x94, 0xd8, 0x69, 0xcb, 0xfa, 0x54,
	0x86, 0xa5, 0x75, 0xdb, 0x39, 0xab, 0xee, 0xa8, 0x1f, 0x76, 0xdc, 0x86, 0x46, 0xca, 0xac, 0x1c,
	0x3a, 0x8f, 0x69, 0x52, 0xbd, 0x3d, 0x4a, 0x9a, 0x54, 0x6d, 0xbb, 0xfa, 0x89, 0x06, 0x0b, 0x99,
	0xa0, 0x50, 0x3e, 0x7c, 0xd1, 0x8e, 0xff, 0xf0, 0x65, 0x34, 0x12, 0xea, 0xb3, 0x22, 0xe1, 0xea,
	0x4f, 0x75, 0x80, 0x24, 0x08, 0xd0, 0xcd, 0xe4, 0x06, 0x36, 0x53, 0xe2, 0xb9, 0x69, 0xe3, 0x67,
	0xfa, 0x1b, 0xd9, 0xfa, 0x4c, 0x37, 0x81, 0xe7, 0x74, 0xd6, 0x24, 0x0e, 0x59, 0x0b, 0x8f, 0xe2,
	0x7a, 0xf5, 0xea, 0x3f, 0xe9, 0x60, 0x64, 0xe3, 0x1e, 0xbd, 0x93, 0xb5, 0xe5, 0x4b, 0xb3, 0x01,
	0xc7, 0xff, 0x69, 0x8b, 0xfe, 0x58, 0x83, 0x46, 0x0a, 0xed, 0xe4, 0x3d, 0x73, 0x6d, 0xf2, 0x3d,
	0xf3, 0x2f, 0xc4, 0x16, 0xab, 0x3f, 0xd0, 0xa0, 0x91, 0x82, 0x3b, 0xe5, 0x2b, 0x1b, 0x6d, 0x8a,
	0xaf, 0x6c, 0xe6, 0x15, 0xce, 0x3f, 0x97, 0x66, 0x13, 0x7a, 0x8c, 0x30, 0x91, 0x76, 0xd2, 0x8f,
	0x52, 0xf4, 0x29, 0x3f, 0x4a, 0x99, 0x97, 0x55, 0x3f, 0xc9, 0x7e, 0x62, 0xb7, 0xa1, 0x18, 0x75,
	0x9a, 0x1b, 0xf4, 0xf3, 0x32, 0x2b, 0x51, 0x44, 0xc5, 0xf3, 0x2f, 0x4a, 0x91, 0x76, 0x0d, 0xaa,
	0x81, 0x00, 0x0c, 0xf3, 0x1f, 0x35, 0x58, 0x64, 0x4e, 0x77, 0xa2, 0x9c, 0x73, 0xd4, 0x8d, 0xf3,
	0xef, 0x00, 0xc8, 0xf6, 0xc5, 0xf7, 0x61, 0xdf, 0x98, 0x08, 0x5b, 0x96, 0x22, 0x70, 0x92, 0x1b,
	0xe9, 0x1f, 0xc0, 0x59, 0xd6, 0x6e, 0xd2, 0x22, 0x8e, 0x06, 0x81, 0x1f, 0xd1, 0x0d, 0xea, 0x10,
	0x47, 0x43, 0x4f, 0x24, 0x99, 0x32, 0x84, 0x98, 0x0a, 0x16, 0xad, 0xb3, 0x38, 0x0f, 0xe9, 0x0e,
	0xbd, 0x73, 0xa3, 0xd3, 0xbb, 0xba, 0xf4, 0xd9, 0xec, 0x40, 0x5d, 0xe5, 0x45, 0xe7, 0xa0, 0x2e,
	0xb5, 0xed, 0xf0, 0xc3, 0x80, 0x82, 0x55, 0x93, 0xb4, 0x1d, 0xba, 0x67, 0x1c, 0xc5, 0x76, 0x3c,
	0x8c, 0xf8, 0xbd, 0x9b, 0xcc, 0x4b, 0x77, 0x69, 0x9d, 0xc5, 0x79, 0xcc, 0x2d, 0x00, 0xda, 0x27,
	0x8a, 0x5f, 0x08, 0x41, 0xde, 0xf5, 0x99, 0xb6, 0xf9, 0xed, 0x9c, 0x45, 0x0a, 0xc9, 0xf5, 0x23,
	0x3d, 0x75, 0xfd, 0x48, 0xdd, 0x3b, 0xf8, 0x8d, 0x0e, 0xb5, 0x5d, 0xb2, 0xb4, 0x63, 0x67, 0x96,
	0xc7, 0x7f, 0xe7, 0x76, 0x35, 0x99, 0x59, 0xd8, 0x42, 0x41, 0xde, 0x1a, 0x56, 0x9a, 0x19, 0x33,
	0x7d, 0x2c, 0x43, 0x91, 0x5d, 0x79, 0xce, 0xd3, 0x35, 0x25, 0x2b, 0x90, 0x35, 0xc0, 0x7d, 0x1c,
	0xd2, 0x4d, 0x0f, 0xb6, 0x03, 0x2f, 0x8a, 0xea, 0x37, 0x75, 0xa5, 0xc9, 0xdf, 0xd4, 0xa1, 0x67,
	0xa0, 0x2a, 0x9d, 0x9c, 0x67, 0x88, 0x47, 0xbf, 0x1b, 0xae, 0x08, 0x9f, 0x46, 0x57, 0xa0, 0xc6,
	0x76, 0x65, 0xd8, 0x8c, 0x50, 0x49, 0x9f, 0x97, 0x25, 0x66, 0xb5, 0x20, 0x90, 0xcf, 0xf3, 0xff,
	0x26, 0xea, 0x13, 0x0d, 0xca, 0xf4, 0x94, 0x78, 0xc7, 0x41, 0x4f, 0x42, 0x73, 0xe8, 0x47, 0x6e,
	0xcf, 0xc7, 0x0e, 0x57, 0x4a, 0x7c, 0x6f, 0xdf, 0x10, 0x74, 0x36, 0xd0, 0x4f, 0x40, 0x83, 0x5f,
	0x15, 0xeb, 0x24, 0xef, 0x22, 0x43, 0x5e, 0xe7, 0x64, 0xc6, 0x76, 0x1e, 0xea, 0x51, 0x4c, 0xbc,
	0x9c, 0x73, 0xe5, 0xf9, 0x75, 0xb0, 0x1a, 0xa3, 0x52, 0xa6, 0x76, 0x09, 0x0a, 0xf7, 0x5c, 0xdf,
	0x21, 0x8a, 0x40, 0x72, 0x66, 0x3d, 0xda, 0x09, 0xb8, 0xa2, 0xd4, 0x09, 0x9e, 0x84, 0xc2, 0xbe,
	0x7b, 0x74, 0xa9, 0xa8, 0x78, 0x80, 0x45, 0x19, 0x08, 0x56, 0xf1, 0x23, 0xc9, 0x7c, 0x76, 0x67,
	0x2e, 0x0e, 0x5d, 0x7c, 0x5f, 0x70, 0x73, 0x2e, 0xf3, 0x2a, 0xd4, 0xd9, 0xb1, 0x39, 0x0f, 0x9a,
	0x75, 0x28, 0xd1, 0x83, 0x52, 0x31, 0x93, 0xa1, 0x94, 0x4b, 0x52, 0x56, 0x8b, 0x73, 0x98, 0xb7,
	0xa1, 0xc9, 0xf6, 0x34, 0x64, 0x10, 0x5f, 0x54, 0x82, 0x78, 0xac, 0xa2, 0x93, 0x62, 0xf8, 0x16,
	0x34, 0xd8, 0x56, 0xcc, 0xdc, 0x5a, 0x7c, 0x07, 0x50, 0xb2, 0x52, 0x3f, 0xbe, 0x59, 0xc1, 0x76,
	0x1c, 0xd8, 0x5c, 0x85, 0x9a, 0xc2, 0x3a, 0x93, 0x9a, 0xe6, 0xbb, 0xb0, 0xa4, 0x5c, 0x8c, 0x9e,
	0x9f, 0x4e, 0xef, 0xc3, 0x32, 0x6b, 0x57, 0x8e, 0xe8, 0x31, 0xd0, 0xaa, 0x8e, 0xfc, 0x71, 0xc3,
	0x42, 0xcf, 0x3f, 0x46, 0xea, 0x9a, 0xda, 0x33, 0x16, 0x6c, 0xc7, 0xb5, 0xf8, 0x47, 0x1a, 0x34,
	0xd9, 0x8d, 0x44, 0xd9, 0x26, 0x3d, 0xab, 0x3e, 0x20, 0x6b, 0xfa, 0x1e, 0xee, 0xf0, 0x5d, 0xad,
	0x31, 0xb8, 0xd8, 0x24, 0x8c, 0xb7, 0xec, 0x1e, 0xbe, 0xc9, 0xb6, 0xbb, 0x36, 0xa4, 0x3a, 0x99,
	0x63, 0xa3, 0xac, 0xd7, 0x67, 0x34, 0xca, 0x2b, 0x1a, 0x9d, 0xe7, 0x67, 0x3c, 0x7c, 0x44, 0x97,
	0xa1, 0xc8, 0xfe, 0xc9, 0x82, 0x4d, 0x1b, 0xac, 0x60, 0x7e, 0xaa, 0x43, 0x33, 0xdd, 0xe6, 0xf1,
	0x00, 0xfe, 0x9d, 0x2c, 0x80, 0x9f, 0x1f, 0xad, 0xdd, 0x18, 0x0c, 0x7f, 0x2a, 0xfb, 0x9d, 0xf0,
	0x94, 0x98, 0x5c, 0x9c, 0x15, 0x93, 0x4b, 0xbf, 0x7d, 0x4c, 0xce, 0x1b, 0x05, 0xf3, 0x36, 0xd4,
	0xae, 0xe3, 0xc4, 0xb3, 0x36, 0x32, 0x51, 0x30, 0xed, 0x50, 0xaa, 0xce, 0x75, 0x07, 0x16, 0xe5,
	0x41, 0xc4, 0xfc, 0x90, 0xe4, 0x77, 0x61, 0x25, 0x7d, 0xa7, 0x6a, 0x7e, 0x91, 0xbb, 0x0b, 0x86,
	0x38, 0x02, 0x99, 0x9f, 0xbe, 0xef, 0xc3, 0x99, 0xd4, 0xa1, 0xec, 0xfc, 0xd4, 0xfd, 0x00, 0xce,
	0x4a, 0x4b, 0xcc, 0x1d, 0x6b, 0xde, 0x83, 0x25, 0x25, 0xcf, 0x1d, 0xd9, 0x70, 0xfe, 0x44, 0xf9,
	0xe1, 0x4f, 0x34, 0x28, 0xb1, 0xbd, 0x7a, 0xf4, 0x14, 0x94, 0xa2, 0xfd, 0x60, 0xe8, 0x89, 0xc5,
	0xfa, 0xa2, 0x72, 0xa8, 0xe4, 0xb8, 0x34, 0x2f, 0xe5, 0x0c, 0xe8, 0x09, 0x28, 0xf4, 0x87, 0x91,
	0x00, 0x96, 0x11, 0x8c, 0xb4, 0x1a, 0x3d, 0x0d, 0x15, 0xf2, 0xdb, 0xf1, 0x03, 0x71, 0x65, 0x62,
	0x04, 0x6b, 0x99, 0xb0, 0xbc, 0x1d, 0xc4, 0xe8, 0x59, 0x80, 0xbe, 0xeb, 0x77, 0xb8, 0x0e, 0x85,
	0xf4, 0x0d, 0xee, 0x1b, 0xae, 0xbf, 0x4b, 0x2b, 0xac, 0x6a, 0x5f, 0x3c, 0x9a, 0x1f, 0x40, 0x55,
	0xd2, 0xd1, 0x25, 0x80, 0xae, 0x68, 0x34, 0x1a, 0xdf, 0x05, 0x85, 0x09, 0x7d, 0x1d, 0x48, 0x63,
	0xfc, 0xcf, 0x79, 0xe8, 0x7f, 0x10, 0x59, 0x95, 0xbe, 0xeb, 0xb3, 0x3f, 0xe6, 0xf9, 0x99, 0x0e,
	0x55, 0x29, 0x86, 0x36, 0xa0, 0x48, 0x3f, 0xee, 0xcc, 0xae, 0x76, 0xe8, 0x27, 0xaf, 0x92, 0x8d,
	0x26, 0xb7, 0x84, 0x82, 0x9e, 0x83, 0x8a, 0x1b, 0x75, 0x70, 0x7f, 0x10, 0x1f, 0x66, 0x17, 0x39,
	0x3b, 0xd1, 0x6b, 0x84, 0xac, 0x0a, 0x95, 0x5d, 0x46, 0x43, 0x9b, 0x50, 0xda, 0xb7, 0x23, 0x92,
	0x98, 0x67, 0x32, 0x95, 0x6d, 0x3b, 0xda, 0x49, 0xbf, 0x67, 0x9f, 0x50, 0xe8, 0x51, 0xdd, 0x84,
	0x53, 0x2f, 0x7a, 0x54, 0xc7, 0x86, 0xf7, 0x32, 0x94, 0xdd, 0xa8, 0xe3, 0x0f, 0x3d, 0x8f, 0xa3,
	0xe0, 0xd9, 0x44, 0xa1, 0xb7, 0x87, 0x9e, 0xa7, 0x36, 0x5e, 0x72, 0x29, 0x09, 0x5d, 0x82, 0x92,
	0x8f, 0xa3, 0x64, 0xf3, 0x54, 0x8a, 0xbc, 0x4d, 0xa9, 0x29, 0x11, 0xc6, 0xd8, 0x46, 0x60, 0x48,
	0x0b, 0x77, 0x02, 0x9f, 0x4c, 0x5a, 0xe6, 0x37, 0xc1, 0xc8, 0x76, 0xfa, 0x28, 0x44, 0x9a, 0xe7,
	0x61, 0x21, 0xa3, 0xc9, 0x08, 0xa6, 0x17, 0xa0, 0x99, 0x36, 0x05, 0xfa, 0x96, 0x34, 0x99, 0x36,
	0xfa, 0x06, 0x22, 0xb3, 0x94, 0xf9, 0x26, 0x2c, 0x64, 0xb4, 0x1e, 0x01, 0xd3, 0x53, 0xde, 0x4d,
	0x30, 0xff, 0x30, 0x0f, 0xcd, 0xf4, 0xd0, 0x8f, 0xc6, 0xfc, 0xbe, 0xcd, 0xce, 0xe1, 0x52, 0x98,
	0x7f, 0x83, 0xc6, 0x30, 0xab, 0x23, 0x4c, 0xa1, 0xed, 0xf7, 0x70, 0xf6, 0xf0, 0xcd, 0x22, 0x44,
	0x8b, 0xd5, 0xa1, 0xef, 0x82, 0xd1, 0xc3, 0x41, 0xe7, 0x6e, 0x30, 0xf4, 0x1d, 0x92, 0x4c, 0xdf,
	0x0d, 0x0e, 0xf8, 0x78, 0x4b, 0x07, 0xb9, 0x8e, 0x83, 0x36, 0xaf, 0x6e, 0x07, 0x07, 0x56, 0xb3,
	0x97, 0x2a, 0x93, 0xe0, 0x22, 0x2d, 0x84, 0xb6, 0xe3, 0x0e, 0xc5, 0xc9, 0xe7, 0xa2, 0x22, 0x6b,
	0xd1, 0x0a, 0xab, 0xda, 0x13, 0x8f, 0xe8, 0x79, 0xa8, 0xb3, 0xff, 0x95, 0xe2, 0xf1, 0x51, 0xca,
	0x9c, 0x83, 0xd3, 0x3a, 0x96, 0x1c, 0xd4, 0xee, 0x27, 0x05, 0x32, 0x81, 0x92, 0x37, 0x0d, 0x02,
	0xef, 0xb0, 0x17, 0xf8, 0x7c, 0x15, 0x84, 0x94, 0x57, 0xdd, 0x62, 0x35, 0x16, 0x51, 0x88, 0x3f,
	0xa3, 0x6f, 0x43, 0x53, 0x7c, 0x20, 0xd2, 0x61, 0xe6, 0xa8, 0x64, 0x0e, 0xc3, 0x79, 0x2d, 0x33,
	0x4b, 0xc3, 0x51, 0x8b, 0xe6, 0x7f, 0xeb, 0x50, 0xa4, 0x46, 0x45, 0xab, 0x50, 0xbe, 0x87, 0x0f,
	0x1f, 0x04, 0x21, 0x0b, 0x54, 0xb2, 0xd4, 0x10, 0x84, 0x89, 0x9f, 0xbb, 0xac, 0x42, 0xf9, 0x6e,
	0x10, 0x78, 0xd8, 0x66, 0x5f, 0xa1, 0x56, 0x48, 0x1d, 0x27, 0xa0, 0x65, 0x28, 0xc8, 0xa3, 0x76,
	0xfa, 0x27, 0x63, 0xf4, 0x44, 0xfd, 0x39, 0xa8, 0xf0, 0x86, 0xa3, 0x6c, 0x3c, 0x59, 0x78, 0x80,
	0xed, 0x18, 0x3b, 0xbb, 0x74, 0x8d, 0x13, 0x6d, 0xe7, 0x2c, 0xc9, 0x8a, 0x9e, 0x87, 0x0a, 0x7f,
	0x67, 0x94, 0xfd, 0xc3, 0x11, 0x21, 0xb6, 0xc3, 0xeb, 0x89, 0x9c, 0xe0, 0x45, 0x5b, 0xb0, 0x80,
	0x0f, 0xba, 0x78, 0x10, 0x77, 0xa4, 0x78, 0xf9, 0x58, 0xf1, 0x26, 0x13, 0x11, 0x14, 0xd4, 0x96,
	0x8d, 0x48, 0xd5, 0x2b, 0xc7, 0xa9, 0xce, 0xdb, 0x78, 0x93, 0x0b, 0xb4, 0x1b, 0x50, 0xa3, 0x8e,
	0xcb, 0xf2, 0x23, 0xf3, 0x22, 0x2c, 0x64, 0x64, 0xc8, 0x4a, 0x9a, 0xad, 0xee, 0xc4, 0x4e, 0xa5,
	0x28, 0x9a, 0x1b, 0x60, 0x64, 0xb5, 0x44, 0xab, 0x8a, 0x41, 0x08, 0x7b, 0x3e, 0xe9, 0xb4, 0xf9,
	0x26, 0x14, 0xe9, 0x00, 0xa3, 0x26, 0xe8, 0x7c, 0xf2, 0xd4, 0x2c, 0xdd, 0x8b, 0x49, 0xb9, 0xc7,
	0xf7, 0x13, 0x2c, 0xbd, 0x17, 0x93, 0xd8, 0xeb, 0xc5, 0x22, 0x73, 0x25, 0x8f, 0x84, 0xe2, 0xc5,
	0xec, 0xf3, 0x23, 0xcd, 0x22, 0x8f, 0xe6, 0x4f, 0x35, 0x68, 0xa4, 0xbc, 0x08, 0xad, 0xcb, 0x56,
	0x27, 0x7e, 0xdc, 0x44, 0xdf, 0xb8, 0x2e, 0xdf, 0x78, 0x0c, 0x6f, 0x8f, 0x4c, 0x7b, 0x52, 0x9b,
	0xc9, 0xcc, 0x54, 0xd3, 0xa7, 0x13, 0x4d, 0x8f, 0xe1, 0x26, 0xbd, 0x08, 0xa1, 0x99, 0x8e, 0x74,
	0x74, 0x11, 0x2a, 0x71, 0x30, 0xe8, 0x78, 0x78, 0x4f, 0xf4, 0xc5, 0x48, 0x05, 0x1b, 0xc9, 0x88,
	0xca, 0x71, 0x30, 0x78, 0x0b, 0xef, 0x91, 0xe0, 0xac, 0xdf, 0x0d, 0xe2, 0x38, 0xe8, 0x77, 0x42,
	0xb7, 0xb7, 0x2f, 0x3a, 0x74, 0x54, 0xa0, 0xc6, 0xb8, 0x2c, 0xc2, 0x64, 0xde, 0x80, 0xaa, 0x44,
	0x08, 0x32, 0xe1, 0x74, 0xb1, 0x4f, 0x10, 0x72, 0xdc, 0xcb, 0x78, 0x3d, 0x5a, 0x81, 0x12, 0x87,
	0x1b, 0x9d, 0x6e, 0xb4, 0xf0, 0x92, 0xf9, 0x22, 0x34, 0xae, 0xe3, 0xe0, 0x2d, 0xd7, 0xc7, 0xcc,
	0x63, 0x48, 0x93, 0xa9, 0x8d, 0xe2, 0x11, 0x4d, 0xb2, 0x7a, 0x33, 0x06, 0x48, 0x00, 0x04, 0x5d,
	0x82, 0x0a, 0x3e, 0x88, 0x71, 0xe8, 0xca, 0x1d, 0xdd, 0x33, 0x8a, 0x64, 0xf2, 0x02, 0x4b, 0xb2,
	0xa1, 0x2b, 0x50, 0x25, 0xde, 0x45, 0x9e, 0xa3, 0xec, 0xf5, 0x88, 0xb4, 0x4c, 0xc2, 0x47, 0x92,
	0x71, 0x05, 0xed, 0x14, 0x67, 0x2c, 0x64, 0x9c, 0xb1, 0x90, 0x75, 0xc6, 0xc2, 0x11, 0x67, 0x2c,
	0xb0, 0x61, 0xfc, 0x81, 0x06, 0xcd, 0xf4, 0x46, 0x29, 0x99, 0xfa, 0x53, 0x1b, 0xaa, 0x67, 0xd2,
	0x9b, 0x8e, 0x3b, 0x4e, 0x24, 0x0e, 0x8e, 0xf9, 0x8e, 0xea, 0x85, 0xc9, 0x73, 0x55, 0x32, 0xf5,
	0xb7, 0x5b, 0xb0, 0x92, 0xd9, 0x01, 0x17, 0x33, 0xf3, 0x65, 0x68, 0xa4, 0x9a, 0x17, 0xff, 0x51,
	0xa6, 0x8d, 0xff, 0x8f, 0x32, 0xf3, 0xdf, 0x34, 0xa8, 0x29, 0x07, 0x72, 0x33, 0x6d, 0xd6, 0xe5,
	0xd3, 0x9b, 0x75, 0x4a, 0x33, 0xa7, 0x5e, 0xe8, 0xcd, 0x77, 0x11, 0xa6, 0x1b, 0x79, 0x73, 0x03,
	0x2a, 0xc2, 0x03, 0xe9, 0x10, 0xf2, 0x4f, 0x99, 0x09, 0x9e, 0xb0, 0xf9, 0xde, 0x13, 0x9b, 0x9a,
	0x16, 0x79, 0x5c, 0x7f, 0x0e, 0x16, 0x8f, 0xfc, 0x61, 0x26, 0xaa, 0x40, 0xe1, 0x3d, 0x6c, 0xdf,
	0x33, 0x72, 0x08, 0xa0, 0x74, 0x03, 0x3b, 0xee, 0xb0, 0x6f, 0x68, 0xe4, 0x79, 0x37, 0x0e, 0x03,
	0xbf, 0x67, 0xe8, 0xeb, 0x2f, 0xc0, 0xd2, 0x88, 0x7f, 0xc9, 0x44, 0x65, 0xc8, 0xbf, 0xea, 0x79,
	0x46, 0x0e, 0xd5, 0xa1, 0x72, 0xc3, 0xfe, 0x30, 0x08, 0xdd, 0xf8, 0x90, 0x49, 0xde, 0x1e, 0x06,
	0xe1, 0xb0, 0x6f, 0xe8, 0xeb, 0x7f, 0xa6, 0x41, 0x55, 0xfe, 0x1f, 0x0c, 0x5a, 0x06, 0x43, 0x16,
	0x38, 0x5c, 0x1b, 0xb9, 0x14, 0x95, 0x83, 0xae, 0xa1, 0x21, 0xc4, 0xd3, 0x17, 0x42, 0x7d, 0xdd,
	0x0b, 0xec, 0xd8, 0xd0, 0x91, 0x01, 0x75, 0x49, 0xbb, 0x8e, 0x03, 0x23, 0x8f, 0x16, 0xa1, 0x21,
	0x29, 0x77, 0xf0, 0x41, 0x6c, 0x14, 0x52, 0xa4, 0x76, 0x10, 0x78, 0x46, 0x11, 0x9d, 0x81, 0x45,
	0x49, 0x12, 0x00, 0x6b, 0x94, 0xd6, 0xd7, 0xa0, 0x2a, 0x3f, 0xd4, 0xa4, 0x9d, 0x89, 0xba, 0x46,
	0x8e, 0x98, 0xe3, 0x1a, 0x8e, 0xba, 0x86, 0x46, 0xac, 0x75, 0xe4, 0xbe, 0x22, 0x69, 0xfe, 0xd5,
	0xfb, 0x38, 0xb4, 0x7b, 0xfc, 0xf4, 0xc6, 0xc8, 0xa1, 0x06, 0x54, 0xdb, 0x38, 0x8a, 0xe9, 0x02,
	0xcf, 0xd0, 0xd6, 0x17, 0xa1, 0xc4, 0x6e, 0xa1, 0x91, 0x36, 0x2d, 0xeb, 0x75, 0x23, 0xb7, 0xfe,
	0x81, 0xd8, 0xe3, 0x66, 0x5b, 0xd3, 0xe8, 0x2c, 0x2c, 0xbd, 0xe3, 0xdf, 0xf3, 0x83, 0x07, 0xbe,
	0x4a, 0x36, 0x72, 0xa4, 0x87, 0xaf, 0x76, 0x49, 0x85, 0x87, 0x9d, 0x1e, 0x76, 0x0c, 0x8d, 0x34,
	0xbe, 0x15, 0xf4, 0x07, 0x1e, 0x8e, 0xb1, 0x63, 0xe8, 0xe4, 0xf5, 0x5b, 0x5e, 0xd0, 0xbd, 0x67,
	0xe1, 0x0f, 0x71, 0x97, 0x90, 0xf2, 0xed, 0xf7, 0x3f, 0xfd, 0x6c, 0x2d, 0xf7, 0xcb, 0xcf, 0xd6,
	0x72, 0xbf, 0xfe, 0x6c, 0x4d, 0xfb, 0xfe, 0xc3, 0x35, 0xed, 0x47, 0x0f, 0xd7, 0xb4, 0x9f, 0x3d,
	0x5c, 0xd3, 0x3e, 0x7d, 0xb8, 0xa6, 0xfd, 0xeb, 0xc3, 0x35, 0xed, 0xdf, 0x1f, 0xae, 0xe5, 0x7e,
	0xfd, 0x70, 0x4d, 0xfb, 0xe3, 0xcf, 0xd7, 0x72, 0x9f, 0x7e, 0xbe, 0x96, 0xfb, 0xe5, 0xe7, 0x6b,
	0xb9, 0xef, 0x99, 0x3d, 0x37, 0xde, 0x1f, 0xde, 0xdd, 0xe8, 0x06, 0xfd, 0x4d, 0xfe, 0x3f, 0xac,
	0xbd, 0xe0, 0x99, 0xae, 0xe7, 0x62, 0x3f, 0xe6, 0x84, 0xbb, 0x25, 0x8a, 0xf1, 0x57, 0xfe, 0x37,
	0x00, 0x00, 0xff, 0xff, 0x8b, 0xd4, 0x3d, 0x91, 0x01, 0x56, 0x00, 0x00,
}

func (x WriteOrderingType) String() string {
	s, ok := WriteOrderingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ReadConsistencyType) String() string {
	s, ok := ReadConsistencyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FieldType) String() string {
	s, ok := FieldType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Direction) String() string {
	s, ok := Direction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RecommendStrategy) String() string {
	s, ok := RecommendStrategy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Fusion) String() string {
	s, ok := Fusion_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UpdateStatus) String() string {
	s, ok := UpdateStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WriteOrdering) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteOrdering)
	if !ok {
		that2, ok := that.(WriteOrdering)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *ReadConsistency) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadConsistency)
	if !ok {
		that2, ok := that.(ReadConsistency)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *ReadConsistency_Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadConsistency_Type)
	if !ok {
		that2, ok := that.(ReadConsistency_Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *ReadConsistency_Factor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadConsistency_Factor)
	if !ok {
		that2, ok := that.(ReadConsistency_Factor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Factor != that1.Factor {
		return false
	}
	return true
}
func (this *PointId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointId)
	if !ok {
		that2, ok := that.(PointId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PointIdOptions == nil {
		if this.PointIdOptions != nil {
			return false
		}
	} else if this.PointIdOptions == nil {
		return false
	} else if !this.PointIdOptions.Equal(that1.PointIdOptions) {
		return false
	}
	return true
}
func (this *PointId_Num) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointId_Num)
	if !ok {
		that2, ok := that.(PointId_Num)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Num != that1.Num {
		return false
	}
	return true
}
func (this *PointId_Uuid) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointId_Uuid)
	if !ok {
		that2, ok := that.(PointId_Uuid)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uuid != that1.Uuid {
		return false
	}
	return true
}
func (this *SparseIndices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseIndices)
	if !ok {
		that2, ok := that.(SparseIndices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if this.Data[i] != that1.Data[i] {
			return false
		}
	}
	return true
}
func (this *Vector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vector)
	if !ok {
		that2, ok := that.(Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if this.Data[i] != that1.Data[i] {
			return false
		}
	}
	if !this.Indices.Equal(that1.Indices) {
		return false
	}
	if this.VectorsCount != that1.VectorsCount {
		return false
	}
	return true
}
func (this *DenseVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DenseVector)
	if !ok {
		that2, ok := that.(DenseVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if this.Data[i] != that1.Data[i] {
			return false
		}
	}
	return true
}
func (this *SparseVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseVector)
	if !ok {
		that2, ok := that.(SparseVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if len(this.Indices) != len(that1.Indices) {
		return false
	}
	for i := range this.Indices {
		if this.Indices[i] != that1.Indices[i] {
			return false
		}
	}
	return true
}
func (this *MultiDenseVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiDenseVector)
	if !ok {
		that2, ok := that.(MultiDenseVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Vectors) != len(that1.Vectors) {
		return false
	}
	for i := range this.Vectors {
		if !this.Vectors[i].Equal(that1.Vectors[i]) {
			return false
		}
	}
	return true
}
func (this *VectorInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorInput)
	if !ok {
		that2, ok := that.(VectorInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Variant == nil {
		if this.Variant != nil {
			return false
		}
	} else if this.Variant == nil {
		return false
	} else if !this.Variant.Equal(that1.Variant) {
		return false
	}
	return true
}
func (this *VectorInput_Id) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorInput_Id)
	if !ok {
		that2, ok := that.(VectorInput_Id)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *VectorInput_Dense) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorInput_Dense)
	if !ok {
		that2, ok := that.(VectorInput_Dense)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dense.Equal(that1.Dense) {
		return false
	}
	return true
}
func (this *VectorInput_Sparse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorInput_Sparse)
	if !ok {
		that2, ok := that.(VectorInput_Sparse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sparse.Equal(that1.Sparse) {
		return false
	}
	return true
}
func (this *VectorInput_MultiDense) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorInput_MultiDense)
	if !ok {
		that2, ok := that.(VectorInput_MultiDense)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultiDense.Equal(that1.MultiDense) {
		return false
	}
	return true
}
func (this *ShardKeySelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardKeySelector)
	if !ok {
		that2, ok := that.(ShardKeySelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ShardKeys) != len(that1.ShardKeys) {
		return false
	}
	for i := range this.ShardKeys {
		if !this.ShardKeys[i].Equal(that1.ShardKeys[i]) {
			return false
		}
	}
	return true
}
func (this *UpsertPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpsertPoints)
	if !ok {
		that2, ok := that.(UpsertPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if len(this.Points) != len(that1.Points) {
		return false
	}
	for i := range this.Points {
		if !this.Points[i].Equal(that1.Points[i]) {
			return false
		}
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *DeletePoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeletePoints)
	if !ok {
		that2, ok := that.(DeletePoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if !this.Points.Equal(that1.Points) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *GetPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPoints)
	if !ok {
		that2, ok := that.(GetPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Ids) != len(that1.Ids) {
		return false
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(that1.Ids[i]) {
			return false
		}
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *UpdatePointVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdatePointVectors)
	if !ok {
		that2, ok := that.(UpdatePointVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if len(this.Points) != len(that1.Points) {
		return false
	}
	for i := range this.Points {
		if !this.Points[i].Equal(that1.Points[i]) {
			return false
		}
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointVectors)
	if !ok {
		that2, ok := that.(PointVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	return true
}
func (this *DeletePointVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeletePointVectors)
	if !ok {
		that2, ok := that.(DeletePointVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *SetPayloadPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetPayloadPoints)
	if !ok {
		that2, ok := that.(SetPayloadPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *DeletePayloadPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeletePayloadPoints)
	if !ok {
		that2, ok := that.(DeletePayloadPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *ClearPayloadPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClearPayloadPoints)
	if !ok {
		that2, ok := that.(ClearPayloadPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if !this.Points.Equal(that1.Points) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *CreateFieldIndexCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateFieldIndexCollection)
	if !ok {
		that2, ok := that.(CreateFieldIndexCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if this.FieldName != that1.FieldName {
		return false
	}
	if this.FieldType != that1.FieldType {
		return false
	}
	if !this.FieldIndexParams.Equal(that1.FieldIndexParams) {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	return true
}
func (this *DeleteFieldIndexCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteFieldIndexCollection)
	if !ok {
		that2, ok := that.(DeleteFieldIndexCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if this.FieldName != that1.FieldName {
		return false
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	return true
}
func (this *PayloadIncludeSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadIncludeSelector)
	if !ok {
		that2, ok := that.(PayloadIncludeSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if this.Fields[i] != that1.Fields[i] {
			return false
		}
	}
	return true
}
func (this *PayloadExcludeSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayloadExcludeSelector)
	if !ok {
		that2, ok := that.(PayloadExcludeSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if this.Fields[i] != that1.Fields[i] {
			return false
		}
	}
	return true
}
func (this *WithPayloadSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithPayloadSelector)
	if !ok {
		that2, ok := that.(WithPayloadSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SelectorOptions == nil {
		if this.SelectorOptions != nil {
			return false
		}
	} else if this.SelectorOptions == nil {
		return false
	} else if !this.SelectorOptions.Equal(that1.SelectorOptions) {
		return false
	}
	return true
}
func (this *WithPayloadSelector_Enable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithPayloadSelector_Enable)
	if !ok {
		that2, ok := that.(WithPayloadSelector_Enable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enable != that1.Enable {
		return false
	}
	return true
}
func (this *WithPayloadSelector_Include) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithPayloadSelector_Include)
	if !ok {
		that2, ok := that.(WithPayloadSelector_Include)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Include.Equal(that1.Include) {
		return false
	}
	return true
}
func (this *WithPayloadSelector_Exclude) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithPayloadSelector_Exclude)
	if !ok {
		that2, ok := that.(WithPayloadSelector_Exclude)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Exclude.Equal(that1.Exclude) {
		return false
	}
	return true
}
func (this *NamedVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedVectors)
	if !ok {
		that2, ok := that.(NamedVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Vectors) != len(that1.Vectors) {
		return false
	}
	for i := range this.Vectors {
		if !this.Vectors[i].Equal(that1.Vectors[i]) {
			return false
		}
	}
	return true
}
func (this *Vectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vectors)
	if !ok {
		that2, ok := that.(Vectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.VectorsOptions == nil {
		if this.VectorsOptions != nil {
			return false
		}
	} else if this.VectorsOptions == nil {
		return false
	} else if !this.VectorsOptions.Equal(that1.VectorsOptions) {
		return false
	}
	return true
}
func (this *Vectors_Vector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vectors_Vector)
	if !ok {
		that2, ok := that.(Vectors_Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vector.Equal(that1.Vector) {
		return false
	}
	return true
}
func (this *Vectors_Vectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vectors_Vectors)
	if !ok {
		that2, ok := that.(Vectors_Vectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	return true
}
func (this *VectorsSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorsSelector)
	if !ok {
		that2, ok := that.(VectorsSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Names) != len(that1.Names) {
		return false
	}
	for i := range this.Names {
		if this.Names[i] != that1.Names[i] {
			return false
		}
	}
	return true
}
func (this *WithVectorsSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithVectorsSelector)
	if !ok {
		that2, ok := that.(WithVectorsSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SelectorOptions == nil {
		if this.SelectorOptions != nil {
			return false
		}
	} else if this.SelectorOptions == nil {
		return false
	} else if !this.SelectorOptions.Equal(that1.SelectorOptions) {
		return false
	}
	return true
}
func (this *WithVectorsSelector_Enable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithVectorsSelector_Enable)
	if !ok {
		that2, ok := that.(WithVectorsSelector_Enable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enable != that1.Enable {
		return false
	}
	return true
}
func (this *WithVectorsSelector_Include) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithVectorsSelector_Include)
	if !ok {
		that2, ok := that.(WithVectorsSelector_Include)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Include.Equal(that1.Include) {
		return false
	}
	return true
}
func (this *QuantizationSearchParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QuantizationSearchParams)
	if !ok {
		that2, ok := that.(QuantizationSearchParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ignore != that1.Ignore {
		return false
	}
	if this.Rescore != that1.Rescore {
		return false
	}
	if this.Oversampling != that1.Oversampling {
		return false
	}
	return true
}
func (this *SearchParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchParams)
	if !ok {
		that2, ok := that.(SearchParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HnswEf != that1.HnswEf {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	if !this.Quantization.Equal(that1.Quantization) {
		return false
	}
	if this.IndexedOnly != that1.IndexedOnly {
		return false
	}
	return true
}
func (this *SearchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchPoints)
	if !ok {
		that2, ok := that.(SearchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Vector) != len(that1.Vector) {
		return false
	}
	for i := range this.Vector {
		if this.Vector[i] != that1.Vector[i] {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.VectorName != that1.VectorName {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if !this.SparseIndices.Equal(that1.SparseIndices) {
		return false
	}
	return true
}
func (this *SearchBatchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchBatchPoints)
	if !ok {
		that2, ok := that.(SearchBatchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.SearchPoints) != len(that1.SearchPoints) {
		return false
	}
	for i := range this.SearchPoints {
		if !this.SearchPoints[i].Equal(that1.SearchPoints[i]) {
			return false
		}
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *WithLookup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithLookup)
	if !ok {
		that2, ok := that.(WithLookup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Collection != that1.Collection {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	return true
}
func (this *SearchPointGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchPointGroups)
	if !ok {
		that2, ok := that.(SearchPointGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Vector) != len(that1.Vector) {
		return false
	}
	for i := range this.Vector {
		if this.Vector[i] != that1.Vector[i] {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.VectorName != that1.VectorName {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if this.GroupBy != that1.GroupBy {
		return false
	}
	if this.GroupSize != that1.GroupSize {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.WithLookup.Equal(that1.WithLookup) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if !this.SparseIndices.Equal(that1.SparseIndices) {
		return false
	}
	return true
}
func (this *StartFrom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartFrom)
	if !ok {
		that2, ok := that.(StartFrom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *StartFrom_Float) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartFrom_Float)
	if !ok {
		that2, ok := that.(StartFrom_Float)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Float != that1.Float {
		return false
	}
	return true
}
func (this *StartFrom_Integer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartFrom_Integer)
	if !ok {
		that2, ok := that.(StartFrom_Integer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Integer != that1.Integer {
		return false
	}
	return true
}
func (this *StartFrom_Timestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartFrom_Timestamp)
	if !ok {
		that2, ok := that.(StartFrom_Timestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	return true
}
func (this *StartFrom_Datetime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartFrom_Datetime)
	if !ok {
		that2, ok := that.(StartFrom_Datetime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Datetime != that1.Datetime {
		return false
	}
	return true
}
func (this *OrderBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderBy)
	if !ok {
		that2, ok := that.(OrderBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if !this.StartFrom.Equal(that1.StartFrom) {
		return false
	}
	return true
}
func (this *ScrollPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScrollPoints)
	if !ok {
		that2, ok := that.(ScrollPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if !this.OrderBy.Equal(that1.OrderBy) {
		return false
	}
	return true
}
func (this *LookupLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LookupLocation)
	if !ok {
		that2, ok := that.(LookupLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.VectorName != that1.VectorName {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *RecommendPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendPoints)
	if !ok {
		that2, ok := that.(RecommendPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Positive) != len(that1.Positive) {
		return false
	}
	for i := range this.Positive {
		if !this.Positive[i].Equal(that1.Positive[i]) {
			return false
		}
	}
	if len(this.Negative) != len(that1.Negative) {
		return false
	}
	for i := range this.Negative {
		if !this.Negative[i].Equal(that1.Negative[i]) {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Using != that1.Using {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.LookupFrom.Equal(that1.LookupFrom) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	if len(this.PositiveVectors) != len(that1.PositiveVectors) {
		return false
	}
	for i := range this.PositiveVectors {
		if !this.PositiveVectors[i].Equal(that1.PositiveVectors[i]) {
			return false
		}
	}
	if len(this.NegativeVectors) != len(that1.NegativeVectors) {
		return false
	}
	for i := range this.NegativeVectors {
		if !this.NegativeVectors[i].Equal(that1.NegativeVectors[i]) {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *RecommendBatchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendBatchPoints)
	if !ok {
		that2, ok := that.(RecommendBatchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.RecommendPoints) != len(that1.RecommendPoints) {
		return false
	}
	for i := range this.RecommendPoints {
		if !this.RecommendPoints[i].Equal(that1.RecommendPoints[i]) {
			return false
		}
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *RecommendPointGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendPointGroups)
	if !ok {
		that2, ok := that.(RecommendPointGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Positive) != len(that1.Positive) {
		return false
	}
	for i := range this.Positive {
		if !this.Positive[i].Equal(that1.Positive[i]) {
			return false
		}
	}
	if len(this.Negative) != len(that1.Negative) {
		return false
	}
	for i := range this.Negative {
		if !this.Negative[i].Equal(that1.Negative[i]) {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.Using != that1.Using {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.LookupFrom.Equal(that1.LookupFrom) {
		return false
	}
	if this.GroupBy != that1.GroupBy {
		return false
	}
	if this.GroupSize != that1.GroupSize {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.WithLookup.Equal(that1.WithLookup) {
		return false
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	if len(this.PositiveVectors) != len(that1.PositiveVectors) {
		return false
	}
	for i := range this.PositiveVectors {
		if !this.PositiveVectors[i].Equal(that1.PositiveVectors[i]) {
			return false
		}
	}
	if len(this.NegativeVectors) != len(that1.NegativeVectors) {
		return false
	}
	for i := range this.NegativeVectors {
		if !this.NegativeVectors[i].Equal(that1.NegativeVectors[i]) {
			return false
		}
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *TargetVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TargetVector)
	if !ok {
		that2, ok := that.(TargetVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Target == nil {
		if this.Target != nil {
			return false
		}
	} else if this.Target == nil {
		return false
	} else if !this.Target.Equal(that1.Target) {
		return false
	}
	return true
}
func (this *TargetVector_Single) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TargetVector_Single)
	if !ok {
		that2, ok := that.(TargetVector_Single)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Single.Equal(that1.Single) {
		return false
	}
	return true
}
func (this *VectorExample) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorExample)
	if !ok {
		that2, ok := that.(VectorExample)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Example == nil {
		if this.Example != nil {
			return false
		}
	} else if this.Example == nil {
		return false
	} else if !this.Example.Equal(that1.Example) {
		return false
	}
	return true
}
func (this *VectorExample_Id) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorExample_Id)
	if !ok {
		that2, ok := that.(VectorExample_Id)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *VectorExample_Vector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VectorExample_Vector)
	if !ok {
		that2, ok := that.(VectorExample_Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vector.Equal(that1.Vector) {
		return false
	}
	return true
}
func (this *ContextExamplePair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContextExamplePair)
	if !ok {
		that2, ok := that.(ContextExamplePair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Positive.Equal(that1.Positive) {
		return false
	}
	if !this.Negative.Equal(that1.Negative) {
		return false
	}
	return true
}
func (this *DiscoverPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoverPoints)
	if !ok {
		that2, ok := that.(DiscoverPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if len(this.Context) != len(that1.Context) {
		return false
	}
	for i := range this.Context {
		if !this.Context[i].Equal(that1.Context[i]) {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Using != that1.Using {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.LookupFrom.Equal(that1.LookupFrom) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *DiscoverBatchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoverBatchPoints)
	if !ok {
		that2, ok := that.(DiscoverBatchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.DiscoverPoints) != len(that1.DiscoverPoints) {
		return false
	}
	for i := range this.DiscoverPoints {
		if !this.DiscoverPoints[i].Equal(that1.DiscoverPoints[i]) {
			return false
		}
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *CountPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CountPoints)
	if !ok {
		that2, ok := that.(CountPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *RecommendInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendInput)
	if !ok {
		that2, ok := that.(RecommendInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Positive) != len(that1.Positive) {
		return false
	}
	for i := range this.Positive {
		if !this.Positive[i].Equal(that1.Positive[i]) {
			return false
		}
	}
	if len(this.Negative) != len(that1.Negative) {
		return false
	}
	for i := range this.Negative {
		if !this.Negative[i].Equal(that1.Negative[i]) {
			return false
		}
	}
	if this.Strategy != that1.Strategy {
		return false
	}
	return true
}
func (this *ContextInputPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContextInputPair)
	if !ok {
		that2, ok := that.(ContextInputPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Positive.Equal(that1.Positive) {
		return false
	}
	if !this.Negative.Equal(that1.Negative) {
		return false
	}
	return true
}
func (this *DiscoverInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoverInput)
	if !ok {
		that2, ok := that.(DiscoverInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.Context.Equal(that1.Context) {
		return false
	}
	return true
}
func (this *ContextInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContextInput)
	if !ok {
		that2, ok := that.(ContextInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Pairs) != len(that1.Pairs) {
		return false
	}
	for i := range this.Pairs {
		if !this.Pairs[i].Equal(that1.Pairs[i]) {
			return false
		}
	}
	return true
}
func (this *Query) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query)
	if !ok {
		that2, ok := that.(Query)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Variant == nil {
		if this.Variant != nil {
			return false
		}
	} else if this.Variant == nil {
		return false
	} else if !this.Variant.Equal(that1.Variant) {
		return false
	}
	return true
}
func (this *Query_Nearest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_Nearest)
	if !ok {
		that2, ok := that.(Query_Nearest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Nearest.Equal(that1.Nearest) {
		return false
	}
	return true
}
func (this *Query_Recommend) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_Recommend)
	if !ok {
		that2, ok := that.(Query_Recommend)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Recommend.Equal(that1.Recommend) {
		return false
	}
	return true
}
func (this *Query_Discover) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_Discover)
	if !ok {
		that2, ok := that.(Query_Discover)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Discover.Equal(that1.Discover) {
		return false
	}
	return true
}
func (this *Query_Context) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_Context)
	if !ok {
		that2, ok := that.(Query_Context)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Context.Equal(that1.Context) {
		return false
	}
	return true
}
func (this *Query_OrderBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_OrderBy)
	if !ok {
		that2, ok := that.(Query_OrderBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OrderBy.Equal(that1.OrderBy) {
		return false
	}
	return true
}
func (this *Query_Fusion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Query_Fusion)
	if !ok {
		that2, ok := that.(Query_Fusion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Fusion != that1.Fusion {
		return false
	}
	return true
}
func (this *PrefetchQuery) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrefetchQuery)
	if !ok {
		that2, ok := that.(PrefetchQuery)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefetch) != len(that1.Prefetch) {
		return false
	}
	for i := range this.Prefetch {
		if !this.Prefetch[i].Equal(that1.Prefetch[i]) {
			return false
		}
	}
	if !this.Query.Equal(that1.Query) {
		return false
	}
	if this.Using != that1.Using {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.LookupFrom.Equal(that1.LookupFrom) {
		return false
	}
	return true
}
func (this *QueryPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryPoints)
	if !ok {
		that2, ok := that.(QueryPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.Prefetch) != len(that1.Prefetch) {
		return false
	}
	for i := range this.Prefetch {
		if !this.Prefetch[i].Equal(that1.Prefetch[i]) {
			return false
		}
	}
	if !this.Query.Equal(that1.Query) {
		return false
	}
	if this.Using != that1.Using {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if this.ScoreThreshold != that1.ScoreThreshold {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if !this.WithVectors.Equal(that1.WithVectors) {
		return false
	}
	if !this.WithPayload.Equal(that1.WithPayload) {
		return false
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if !this.LookupFrom.Equal(that1.LookupFrom) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *QueryBatchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryBatchPoints)
	if !ok {
		that2, ok := that.(QueryBatchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if len(this.QueryPoints) != len(that1.QueryPoints) {
		return false
	}
	for i := range this.QueryPoints {
		if !this.QueryPoints[i].Equal(that1.QueryPoints[i]) {
			return false
		}
	}
	if !this.ReadConsistency.Equal(that1.ReadConsistency) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *PointsUpdateOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation)
	if !ok {
		that2, ok := that.(PointsUpdateOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Operation == nil {
		if this.Operation != nil {
			return false
		}
	} else if this.Operation == nil {
		return false
	} else if !this.Operation.Equal(that1.Operation) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_Upsert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_Upsert)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_Upsert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Upsert.Equal(that1.Upsert) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeleteDeprecated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeleteDeprecated)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeleteDeprecated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteDeprecated.Equal(that1.DeleteDeprecated) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_SetPayload_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_SetPayload_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_SetPayload_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SetPayload.Equal(that1.SetPayload) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_OverwritePayload_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_OverwritePayload_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_OverwritePayload_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OverwritePayload.Equal(that1.OverwritePayload) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeletePayload_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeletePayload_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeletePayload_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeletePayload.Equal(that1.DeletePayload) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_ClearPayloadDeprecated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_ClearPayloadDeprecated)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_ClearPayloadDeprecated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClearPayloadDeprecated.Equal(that1.ClearPayloadDeprecated) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_UpdateVectors_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_UpdateVectors_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_UpdateVectors_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UpdateVectors.Equal(that1.UpdateVectors) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeleteVectors_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeleteVectors_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeleteVectors_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteVectors.Equal(that1.DeleteVectors) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeletePoints_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeletePoints_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeletePoints_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeletePoints.Equal(that1.DeletePoints) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_ClearPayload_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_ClearPayload_)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_ClearPayload_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClearPayload.Equal(that1.ClearPayload) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_PointStructList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_PointStructList)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_PointStructList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Points) != len(that1.Points) {
		return false
	}
	for i := range this.Points {
		if !this.Points[i].Equal(that1.Points[i]) {
			return false
		}
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_SetPayload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_SetPayload)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_SetPayload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_OverwritePayload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_OverwritePayload)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_OverwritePayload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeletePayload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeletePayload)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeletePayload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_UpdateVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_UpdateVectors)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_UpdateVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Points) != len(that1.Points) {
		return false
	}
	for i := range this.Points {
		if !this.Points[i].Equal(that1.Points[i]) {
			return false
		}
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeleteVectors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeleteVectors)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeleteVectors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PointsSelector.Equal(that1.PointsSelector) {
		return false
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_DeletePoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_DeletePoints)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_DeletePoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Points.Equal(that1.Points) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *PointsUpdateOperation_ClearPayload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsUpdateOperation_ClearPayload)
	if !ok {
		that2, ok := that.(PointsUpdateOperation_ClearPayload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Points.Equal(that1.Points) {
		return false
	}
	if !this.ShardKeySelector.Equal(that1.ShardKeySelector) {
		return false
	}
	return true
}
func (this *UpdateBatchPoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateBatchPoints)
	if !ok {
		that2, ok := that.(UpdateBatchPoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CollectionName != that1.CollectionName {
		return false
	}
	if this.Wait != that1.Wait {
		return false
	}
	if len(this.Operations) != len(that1.Operations) {
		return false
	}
	for i := range this.Operations {
		if !this.Operations[i].Equal(that1.Operations[i]) {
			return false
		}
	}
	if !this.Ordering.Equal(that1.Ordering) {
		return false
	}
	return true
}
func (this *PointsOperationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsOperationResponse)
	if !ok {
		that2, ok := that.(PointsOperationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *UpdateResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateResult)
	if !ok {
		that2, ok := that.(UpdateResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperationId != that1.OperationId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *OrderValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderValue)
	if !ok {
		that2, ok := that.(OrderValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Variant == nil {
		if this.Variant != nil {
			return false
		}
	} else if this.Variant == nil {
		return false
	} else if !this.Variant.Equal(that1.Variant) {
		return false
	}
	return true
}
func (this *OrderValue_Int) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderValue_Int)
	if !ok {
		that2, ok := that.(OrderValue_Int)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int != that1.Int {
		return false
	}
	return true
}
func (this *OrderValue_Float) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderValue_Float)
	if !ok {
		that2, ok := that.(OrderValue_Float)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Float != that1.Float {
		return false
	}
	return true
}
func (this *ScoredPoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScoredPoint)
	if !ok {
		that2, ok := that.(ScoredPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	if !this.OrderValue.Equal(that1.OrderValue) {
		return false
	}
	return true
}
func (this *GroupId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupId)
	if !ok {
		that2, ok := that.(GroupId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *GroupId_UnsignedValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupId_UnsignedValue)
	if !ok {
		that2, ok := that.(GroupId_UnsignedValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UnsignedValue != that1.UnsignedValue {
		return false
	}
	return true
}
func (this *GroupId_IntegerValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupId_IntegerValue)
	if !ok {
		that2, ok := that.(GroupId_IntegerValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IntegerValue != that1.IntegerValue {
		return false
	}
	return true
}
func (this *GroupId_StringValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupId_StringValue)
	if !ok {
		that2, ok := that.(GroupId_StringValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StringValue != that1.StringValue {
		return false
	}
	return true
}
func (this *PointGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointGroup)
	if !ok {
		that2, ok := that.(PointGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Hits) != len(that1.Hits) {
		return false
	}
	for i := range this.Hits {
		if !this.Hits[i].Equal(that1.Hits[i]) {
			return false
		}
	}
	if !this.Lookup.Equal(that1.Lookup) {
		return false
	}
	return true
}
func (this *GroupsResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupsResult)
	if !ok {
		that2, ok := that.(GroupsResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	return true
}
func (this *SearchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchResponse)
	if !ok {
		that2, ok := that.(SearchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *QueryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryResponse)
	if !ok {
		that2, ok := that.(QueryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *QueryBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryBatchResponse)
	if !ok {
		that2, ok := that.(QueryBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *BatchResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BatchResult)
	if !ok {
		that2, ok := that.(BatchResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	return true
}
func (this *SearchBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchBatchResponse)
	if !ok {
		that2, ok := that.(SearchBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *SearchGroupsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchGroupsResponse)
	if !ok {
		that2, ok := that.(SearchGroupsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *CountResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CountResponse)
	if !ok {
		that2, ok := that.(CountResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *ScrollResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScrollResponse)
	if !ok {
		that2, ok := that.(ScrollResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NextPageOffset.Equal(that1.NextPageOffset) {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *CountResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CountResult)
	if !ok {
		that2, ok := that.(CountResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *RetrievedPoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetrievedPoint)
	if !ok {
		that2, ok := that.(RetrievedPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	if !this.ShardKey.Equal(that1.ShardKey) {
		return false
	}
	if !this.OrderValue.Equal(that1.OrderValue) {
		return false
	}
	return true
}
func (this *GetResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetResponse)
	if !ok {
		that2, ok := that.(GetResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *RecommendResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendResponse)
	if !ok {
		that2, ok := that.(RecommendResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *RecommendBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendBatchResponse)
	if !ok {
		that2, ok := that.(RecommendBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *DiscoverResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoverResponse)
	if !ok {
		that2, ok := that.(DiscoverResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *DiscoverBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscoverBatchResponse)
	if !ok {
		that2, ok := that.(DiscoverBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *RecommendGroupsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RecommendGroupsResponse)
	if !ok {
		that2, ok := that.(RecommendGroupsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *UpdateBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateBatchResponse)
	if !ok {
		that2, ok := that.(UpdateBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Result) != len(that1.Result) {
		return false
	}
	for i := range this.Result {
		if !this.Result[i].Equal(that1.Result[i]) {
			return false
		}
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Filter)
	if !ok {
		that2, ok := that.(Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Should) != len(that1.Should) {
		return false
	}
	for i := range this.Should {
		if !this.Should[i].Equal(that1.Should[i]) {
			return false
		}
	}
	if len(this.Must) != len(that1.Must) {
		return false
	}
	for i := range this.Must {
		if !this.Must[i].Equal(that1.Must[i]) {
			return false
		}
	}
	if len(this.MustNot) != len(that1.MustNot) {
		return false
	}
	for i := range this.MustNot {
		if !this.MustNot[i].Equal(that1.MustNot[i]) {
			return false
		}
	}
	if !this.MinShould.Equal(that1.MinShould) {
		return false
	}
	return true
}
func (this *MinShould) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MinShould)
	if !ok {
		that2, ok := that.(MinShould)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Conditions) != len(that1.Conditions) {
		return false
	}
	for i := range this.Conditions {
		if !this.Conditions[i].Equal(that1.Conditions[i]) {
			return false
		}
	}
	if this.MinCount != that1.MinCount {
		return false
	}
	return true
}
func (this *Condition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition)
	if !ok {
		that2, ok := that.(Condition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConditionOneOf == nil {
		if this.ConditionOneOf != nil {
			return false
		}
	} else if this.ConditionOneOf == nil {
		return false
	} else if !this.ConditionOneOf.Equal(that1.ConditionOneOf) {
		return false
	}
	return true
}
func (this *Condition_Field) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_Field)
	if !ok {
		that2, ok := that.(Condition_Field)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Field.Equal(that1.Field) {
		return false
	}
	return true
}
func (this *Condition_IsEmpty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_IsEmpty)
	if !ok {
		that2, ok := that.(Condition_IsEmpty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsEmpty.Equal(that1.IsEmpty) {
		return false
	}
	return true
}
func (this *Condition_HasId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_HasId)
	if !ok {
		that2, ok := that.(Condition_HasId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HasId.Equal(that1.HasId) {
		return false
	}
	return true
}
func (this *Condition_Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_Filter)
	if !ok {
		that2, ok := that.(Condition_Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *Condition_IsNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_IsNull)
	if !ok {
		that2, ok := that.(Condition_IsNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsNull.Equal(that1.IsNull) {
		return false
	}
	return true
}
func (this *Condition_Nested) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Condition_Nested)
	if !ok {
		that2, ok := that.(Condition_Nested)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Nested.Equal(that1.Nested) {
		return false
	}
	return true
}
func (this *IsEmptyCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IsEmptyCondition)
	if !ok {
		that2, ok := that.(IsEmptyCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *IsNullCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IsNullCondition)
	if !ok {
		that2, ok := that.(IsNullCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *HasIdCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HasIdCondition)
	if !ok {
		that2, ok := that.(HasIdCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HasId) != len(that1.HasId) {
		return false
	}
	for i := range this.HasId {
		if !this.HasId[i].Equal(that1.HasId[i]) {
			return false
		}
	}
	return true
}
func (this *NestedCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NestedCondition)
	if !ok {
		that2, ok := that.(NestedCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *FieldCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldCondition)
	if !ok {
		that2, ok := that.(FieldCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !this.Match.Equal(that1.Match) {
		return false
	}
	if !this.Range.Equal(that1.Range) {
		return false
	}
	if !this.GeoBoundingBox.Equal(that1.GeoBoundingBox) {
		return false
	}
	if !this.GeoRadius.Equal(that1.GeoRadius) {
		return false
	}
	if !this.ValuesCount.Equal(that1.ValuesCount) {
		return false
	}
	if !this.GeoPolygon.Equal(that1.GeoPolygon) {
		return false
	}
	if !this.DatetimeRange.Equal(that1.DatetimeRange) {
		return false
	}
	return true
}
func (this *Match) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match)
	if !ok {
		that2, ok := that.(Match)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.MatchValue == nil {
		if this.MatchValue != nil {
			return false
		}
	} else if this.MatchValue == nil {
		return false
	} else if !this.MatchValue.Equal(that1.MatchValue) {
		return false
	}
	return true
}
func (this *Match_Keyword) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Keyword)
	if !ok {
		that2, ok := that.(Match_Keyword)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Keyword != that1.Keyword {
		return false
	}
	return true
}
func (this *Match_Integer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Integer)
	if !ok {
		that2, ok := that.(Match_Integer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Integer != that1.Integer {
		return false
	}
	return true
}
func (this *Match_Boolean) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Boolean)
	if !ok {
		that2, ok := that.(Match_Boolean)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Boolean != that1.Boolean {
		return false
	}
	return true
}
func (this *Match_Text) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Text)
	if !ok {
		that2, ok := that.(Match_Text)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	return true
}
func (this *Match_Keywords) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Keywords)
	if !ok {
		that2, ok := that.(Match_Keywords)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Keywords.Equal(that1.Keywords) {
		return false
	}
	return true
}
func (this *Match_Integers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_Integers)
	if !ok {
		that2, ok := that.(Match_Integers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Integers.Equal(that1.Integers) {
		return false
	}
	return true
}
func (this *Match_ExceptIntegers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_ExceptIntegers)
	if !ok {
		that2, ok := that.(Match_ExceptIntegers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExceptIntegers.Equal(that1.ExceptIntegers) {
		return false
	}
	return true
}
func (this *Match_ExceptKeywords) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Match_ExceptKeywords)
	if !ok {
		that2, ok := that.(Match_ExceptKeywords)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExceptKeywords.Equal(that1.ExceptKeywords) {
		return false
	}
	return true
}
func (this *RepeatedStrings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepeatedStrings)
	if !ok {
		that2, ok := that.(RepeatedStrings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if this.Strings[i] != that1.Strings[i] {
			return false
		}
	}
	return true
}
func (this *RepeatedIntegers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepeatedIntegers)
	if !ok {
		that2, ok := that.(RepeatedIntegers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Integers) != len(that1.Integers) {
		return false
	}
	for i := range this.Integers {
		if this.Integers[i] != that1.Integers[i] {
			return false
		}
	}
	return true
}
func (this *Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Range)
	if !ok {
		that2, ok := that.(Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lt != that1.Lt {
		return false
	}
	if this.Gt != that1.Gt {
		return false
	}
	if this.Gte != that1.Gte {
		return false
	}
	if this.Lte != that1.Lte {
		return false
	}
	return true
}
func (this *DatetimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatetimeRange)
	if !ok {
		that2, ok := that.(DatetimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Lt.Equal(that1.Lt) {
		return false
	}
	if !this.Gt.Equal(that1.Gt) {
		return false
	}
	if !this.Gte.Equal(that1.Gte) {
		return false
	}
	if !this.Lte.Equal(that1.Lte) {
		return false
	}
	return true
}
func (this *GeoBoundingBox) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoBoundingBox)
	if !ok {
		that2, ok := that.(GeoBoundingBox)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TopLeft.Equal(that1.TopLeft) {
		return false
	}
	if !this.BottomRight.Equal(that1.BottomRight) {
		return false
	}
	return true
}
func (this *GeoRadius) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoRadius)
	if !ok {
		that2, ok := that.(GeoRadius)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Center.Equal(that1.Center) {
		return false
	}
	if this.Radius != that1.Radius {
		return false
	}
	return true
}
func (this *GeoLineString) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoLineString)
	if !ok {
		that2, ok := that.(GeoLineString)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Points) != len(that1.Points) {
		return false
	}
	for i := range this.Points {
		if !this.Points[i].Equal(that1.Points[i]) {
			return false
		}
	}
	return true
}
func (this *GeoPolygon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoPolygon)
	if !ok {
		that2, ok := that.(GeoPolygon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Exterior.Equal(that1.Exterior) {
		return false
	}
	if len(this.Interiors) != len(that1.Interiors) {
		return false
	}
	for i := range this.Interiors {
		if !this.Interiors[i].Equal(that1.Interiors[i]) {
			return false
		}
	}
	return true
}
func (this *ValuesCount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValuesCount)
	if !ok {
		that2, ok := that.(ValuesCount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lt != that1.Lt {
		return false
	}
	if this.Gt != that1.Gt {
		return false
	}
	if this.Gte != that1.Gte {
		return false
	}
	if this.Lte != that1.Lte {
		return false
	}
	return true
}
func (this *PointsSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsSelector)
	if !ok {
		that2, ok := that.(PointsSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PointsSelectorOneOf == nil {
		if this.PointsSelectorOneOf != nil {
			return false
		}
	} else if this.PointsSelectorOneOf == nil {
		return false
	} else if !this.PointsSelectorOneOf.Equal(that1.PointsSelectorOneOf) {
		return false
	}
	return true
}
func (this *PointsSelector_Points) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsSelector_Points)
	if !ok {
		that2, ok := that.(PointsSelector_Points)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Points.Equal(that1.Points) {
		return false
	}
	return true
}
func (this *PointsSelector_Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsSelector_Filter)
	if !ok {
		that2, ok := that.(PointsSelector_Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *PointsIdsList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointsIdsList)
	if !ok {
		that2, ok := that.(PointsIdsList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ids) != len(that1.Ids) {
		return false
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(that1.Ids[i]) {
			return false
		}
	}
	return true
}
func (this *PointStruct) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PointStruct)
	if !ok {
		that2, ok := that.(PointStruct)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Payload) != len(that1.Payload) {
		return false
	}
	for i := range this.Payload {
		if !this.Payload[i].Equal(that1.Payload[i]) {
			return false
		}
	}
	if !this.Vectors.Equal(that1.Vectors) {
		return false
	}
	return true
}
func (this *GeoPoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoPoint)
	if !ok {
		that2, ok := that.(GeoPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lon != that1.Lon {
		return false
	}
	if this.Lat != that1.Lat {
		return false
	}
	return true
}
func (this *WriteOrdering) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.WriteOrdering{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadConsistency) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ReadConsistency{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadConsistency_Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.ReadConsistency_Type{` +
		`Type:` + fmt.Sprintf("%#v", this.Type) + `}`}, ", ")
	return s
}
func (this *ReadConsistency_Factor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.ReadConsistency_Factor{` +
		`Factor:` + fmt.Sprintf("%#v", this.Factor) + `}`}, ", ")
	return s
}
func (this *PointId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointId{")
	if this.PointIdOptions != nil {
		s = append(s, "PointIdOptions: "+fmt.Sprintf("%#v", this.PointIdOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointId_Num) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointId_Num{` +
		`Num:` + fmt.Sprintf("%#v", this.Num) + `}`}, ", ")
	return s
}
func (this *PointId_Uuid) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointId_Uuid{` +
		`Uuid:` + fmt.Sprintf("%#v", this.Uuid) + `}`}, ", ")
	return s
}
func (this *SparseIndices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.SparseIndices{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.Vector{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	if this.Indices != nil {
		s = append(s, "Indices: "+fmt.Sprintf("%#v", this.Indices)+",\n")
	}
	s = append(s, "VectorsCount: "+fmt.Sprintf("%#v", this.VectorsCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DenseVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.DenseVector{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.SparseVector{")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "Indices: "+fmt.Sprintf("%#v", this.Indices)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiDenseVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.MultiDenseVector{")
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.VectorInput{")
	if this.Variant != nil {
		s = append(s, "Variant: "+fmt.Sprintf("%#v", this.Variant)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorInput_Id) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorInput_Id{` +
		`Id:` + fmt.Sprintf("%#v", this.Id) + `}`}, ", ")
	return s
}
func (this *VectorInput_Dense) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorInput_Dense{` +
		`Dense:` + fmt.Sprintf("%#v", this.Dense) + `}`}, ", ")
	return s
}
func (this *VectorInput_Sparse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorInput_Sparse{` +
		`Sparse:` + fmt.Sprintf("%#v", this.Sparse) + `}`}, ", ")
	return s
}
func (this *VectorInput_MultiDense) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorInput_MultiDense{` +
		`MultiDense:` + fmt.Sprintf("%#v", this.MultiDense) + `}`}, ", ")
	return s
}
func (this *ShardKeySelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.ShardKeySelector{")
	if this.ShardKeys != nil {
		s = append(s, "ShardKeys: "+fmt.Sprintf("%#v", this.ShardKeys)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpsertPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.UpsertPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeletePoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.DeletePoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.GetPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Ids != nil {
		s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	}
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdatePointVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.UpdatePointVectors{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointVectors{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeletePointVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.DeletePointVectors{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetPayloadPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&qdrant.SetPayloadPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeletePayloadPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.DeletePayloadPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClearPayloadPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.ClearPayloadPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateFieldIndexCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.CreateFieldIndexCollection{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	s = append(s, "FieldName: "+fmt.Sprintf("%#v", this.FieldName)+",\n")
	s = append(s, "FieldType: "+fmt.Sprintf("%#v", this.FieldType)+",\n")
	if this.FieldIndexParams != nil {
		s = append(s, "FieldIndexParams: "+fmt.Sprintf("%#v", this.FieldIndexParams)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteFieldIndexCollection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.DeleteFieldIndexCollection{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	s = append(s, "FieldName: "+fmt.Sprintf("%#v", this.FieldName)+",\n")
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PayloadIncludeSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.PayloadIncludeSelector{")
	s = append(s, "Fields: "+fmt.Sprintf("%#v", this.Fields)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PayloadExcludeSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.PayloadExcludeSelector{")
	s = append(s, "Fields: "+fmt.Sprintf("%#v", this.Fields)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WithPayloadSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.WithPayloadSelector{")
	if this.SelectorOptions != nil {
		s = append(s, "SelectorOptions: "+fmt.Sprintf("%#v", this.SelectorOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WithPayloadSelector_Enable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.WithPayloadSelector_Enable{` +
		`Enable:` + fmt.Sprintf("%#v", this.Enable) + `}`}, ", ")
	return s
}
func (this *WithPayloadSelector_Include) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.WithPayloadSelector_Include{` +
		`Include:` + fmt.Sprintf("%#v", this.Include) + `}`}, ", ")
	return s
}
func (this *WithPayloadSelector_Exclude) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.WithPayloadSelector_Exclude{` +
		`Exclude:` + fmt.Sprintf("%#v", this.Exclude) + `}`}, ", ")
	return s
}
func (this *NamedVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.NamedVectors{")
	keysForVectors := make([]string, 0, len(this.Vectors))
	for k, _ := range this.Vectors {
		keysForVectors = append(keysForVectors, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVectors)
	mapStringForVectors := "map[string]*Vector{"
	for _, k := range keysForVectors {
		mapStringForVectors += fmt.Sprintf("%#v: %#v,", k, this.Vectors[k])
	}
	mapStringForVectors += "}"
	if this.Vectors != nil {
		s = append(s, "Vectors: "+mapStringForVectors+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.Vectors{")
	if this.VectorsOptions != nil {
		s = append(s, "VectorsOptions: "+fmt.Sprintf("%#v", this.VectorsOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vectors_Vector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Vectors_Vector{` +
		`Vector:` + fmt.Sprintf("%#v", this.Vector) + `}`}, ", ")
	return s
}
func (this *Vectors_Vectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Vectors_Vectors{` +
		`Vectors:` + fmt.Sprintf("%#v", this.Vectors) + `}`}, ", ")
	return s
}
func (this *VectorsSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.VectorsSelector{")
	s = append(s, "Names: "+fmt.Sprintf("%#v", this.Names)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WithVectorsSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.WithVectorsSelector{")
	if this.SelectorOptions != nil {
		s = append(s, "SelectorOptions: "+fmt.Sprintf("%#v", this.SelectorOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WithVectorsSelector_Enable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.WithVectorsSelector_Enable{` +
		`Enable:` + fmt.Sprintf("%#v", this.Enable) + `}`}, ", ")
	return s
}
func (this *WithVectorsSelector_Include) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.WithVectorsSelector_Include{` +
		`Include:` + fmt.Sprintf("%#v", this.Include) + `}`}, ", ")
	return s
}
func (this *QuantizationSearchParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.QuantizationSearchParams{")
	s = append(s, "Ignore: "+fmt.Sprintf("%#v", this.Ignore)+",\n")
	s = append(s, "Rescore: "+fmt.Sprintf("%#v", this.Rescore)+",\n")
	s = append(s, "Oversampling: "+fmt.Sprintf("%#v", this.Oversampling)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.SearchParams{")
	s = append(s, "HnswEf: "+fmt.Sprintf("%#v", this.HnswEf)+",\n")
	s = append(s, "Exact: "+fmt.Sprintf("%#v", this.Exact)+",\n")
	if this.Quantization != nil {
		s = append(s, "Quantization: "+fmt.Sprintf("%#v", this.Quantization)+",\n")
	}
	s = append(s, "IndexedOnly: "+fmt.Sprintf("%#v", this.IndexedOnly)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&qdrant.SearchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Vector: "+fmt.Sprintf("%#v", this.Vector)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "VectorName: "+fmt.Sprintf("%#v", this.VectorName)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	if this.SparseIndices != nil {
		s = append(s, "SparseIndices: "+fmt.Sprintf("%#v", this.SparseIndices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchBatchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.SearchBatchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.SearchPoints != nil {
		s = append(s, "SearchPoints: "+fmt.Sprintf("%#v", this.SearchPoints)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WithLookup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.WithLookup{")
	s = append(s, "Collection: "+fmt.Sprintf("%#v", this.Collection)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchPointGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&qdrant.SearchPointGroups{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Vector: "+fmt.Sprintf("%#v", this.Vector)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "VectorName: "+fmt.Sprintf("%#v", this.VectorName)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	s = append(s, "GroupSize: "+fmt.Sprintf("%#v", this.GroupSize)+",\n")
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.WithLookup != nil {
		s = append(s, "WithLookup: "+fmt.Sprintf("%#v", this.WithLookup)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	if this.SparseIndices != nil {
		s = append(s, "SparseIndices: "+fmt.Sprintf("%#v", this.SparseIndices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StartFrom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.StartFrom{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StartFrom_Float) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.StartFrom_Float{` +
		`Float:` + fmt.Sprintf("%#v", this.Float) + `}`}, ", ")
	return s
}
func (this *StartFrom_Integer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.StartFrom_Integer{` +
		`Integer:` + fmt.Sprintf("%#v", this.Integer) + `}`}, ", ")
	return s
}
func (this *StartFrom_Timestamp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.StartFrom_Timestamp{` +
		`Timestamp:` + fmt.Sprintf("%#v", this.Timestamp) + `}`}, ", ")
	return s
}
func (this *StartFrom_Datetime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.StartFrom_Datetime{` +
		`Datetime:` + fmt.Sprintf("%#v", this.Datetime) + `}`}, ", ")
	return s
}
func (this *OrderBy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.OrderBy{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	if this.StartFrom != nil {
		s = append(s, "StartFrom: "+fmt.Sprintf("%#v", this.StartFrom)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScrollPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&qdrant.ScrollPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	if this.Offset != nil {
		s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	if this.OrderBy != nil {
		s = append(s, "OrderBy: "+fmt.Sprintf("%#v", this.OrderBy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LookupLocation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.LookupLocation{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "VectorName: "+fmt.Sprintf("%#v", this.VectorName)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&qdrant.RecommendPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Positive != nil {
		s = append(s, "Positive: "+fmt.Sprintf("%#v", this.Positive)+",\n")
	}
	if this.Negative != nil {
		s = append(s, "Negative: "+fmt.Sprintf("%#v", this.Negative)+",\n")
	}
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Using: "+fmt.Sprintf("%#v", this.Using)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.LookupFrom != nil {
		s = append(s, "LookupFrom: "+fmt.Sprintf("%#v", this.LookupFrom)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Strategy: "+fmt.Sprintf("%#v", this.Strategy)+",\n")
	if this.PositiveVectors != nil {
		s = append(s, "PositiveVectors: "+fmt.Sprintf("%#v", this.PositiveVectors)+",\n")
	}
	if this.NegativeVectors != nil {
		s = append(s, "NegativeVectors: "+fmt.Sprintf("%#v", this.NegativeVectors)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendBatchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.RecommendBatchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.RecommendPoints != nil {
		s = append(s, "RecommendPoints: "+fmt.Sprintf("%#v", this.RecommendPoints)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendPointGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 24)
	s = append(s, "&qdrant.RecommendPointGroups{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Positive != nil {
		s = append(s, "Positive: "+fmt.Sprintf("%#v", this.Positive)+",\n")
	}
	if this.Negative != nil {
		s = append(s, "Negative: "+fmt.Sprintf("%#v", this.Negative)+",\n")
	}
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "Using: "+fmt.Sprintf("%#v", this.Using)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.LookupFrom != nil {
		s = append(s, "LookupFrom: "+fmt.Sprintf("%#v", this.LookupFrom)+",\n")
	}
	s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	s = append(s, "GroupSize: "+fmt.Sprintf("%#v", this.GroupSize)+",\n")
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.WithLookup != nil {
		s = append(s, "WithLookup: "+fmt.Sprintf("%#v", this.WithLookup)+",\n")
	}
	s = append(s, "Strategy: "+fmt.Sprintf("%#v", this.Strategy)+",\n")
	if this.PositiveVectors != nil {
		s = append(s, "PositiveVectors: "+fmt.Sprintf("%#v", this.PositiveVectors)+",\n")
	}
	if this.NegativeVectors != nil {
		s = append(s, "NegativeVectors: "+fmt.Sprintf("%#v", this.NegativeVectors)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TargetVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.TargetVector{")
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TargetVector_Single) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.TargetVector_Single{` +
		`Single:` + fmt.Sprintf("%#v", this.Single) + `}`}, ", ")
	return s
}
func (this *VectorExample) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.VectorExample{")
	if this.Example != nil {
		s = append(s, "Example: "+fmt.Sprintf("%#v", this.Example)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorExample_Id) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorExample_Id{` +
		`Id:` + fmt.Sprintf("%#v", this.Id) + `}`}, ", ")
	return s
}
func (this *VectorExample_Vector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.VectorExample_Vector{` +
		`Vector:` + fmt.Sprintf("%#v", this.Vector) + `}`}, ", ")
	return s
}
func (this *ContextExamplePair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ContextExamplePair{")
	if this.Positive != nil {
		s = append(s, "Positive: "+fmt.Sprintf("%#v", this.Positive)+",\n")
	}
	if this.Negative != nil {
		s = append(s, "Negative: "+fmt.Sprintf("%#v", this.Negative)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoverPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&qdrant.DiscoverPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	if this.Context != nil {
		s = append(s, "Context: "+fmt.Sprintf("%#v", this.Context)+",\n")
	}
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Using: "+fmt.Sprintf("%#v", this.Using)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.LookupFrom != nil {
		s = append(s, "LookupFrom: "+fmt.Sprintf("%#v", this.LookupFrom)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoverBatchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.DiscoverBatchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.DiscoverPoints != nil {
		s = append(s, "DiscoverPoints: "+fmt.Sprintf("%#v", this.DiscoverPoints)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CountPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.CountPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "Exact: "+fmt.Sprintf("%#v", this.Exact)+",\n")
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.RecommendInput{")
	if this.Positive != nil {
		s = append(s, "Positive: "+fmt.Sprintf("%#v", this.Positive)+",\n")
	}
	if this.Negative != nil {
		s = append(s, "Negative: "+fmt.Sprintf("%#v", this.Negative)+",\n")
	}
	s = append(s, "Strategy: "+fmt.Sprintf("%#v", this.Strategy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContextInputPair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.ContextInputPair{")
	if this.Positive != nil {
		s = append(s, "Positive: "+fmt.Sprintf("%#v", this.Positive)+",\n")
	}
	if this.Negative != nil {
		s = append(s, "Negative: "+fmt.Sprintf("%#v", this.Negative)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoverInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.DiscoverInput{")
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	if this.Context != nil {
		s = append(s, "Context: "+fmt.Sprintf("%#v", this.Context)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContextInput) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.ContextInput{")
	if this.Pairs != nil {
		s = append(s, "Pairs: "+fmt.Sprintf("%#v", this.Pairs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Query) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.Query{")
	if this.Variant != nil {
		s = append(s, "Variant: "+fmt.Sprintf("%#v", this.Variant)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Query_Nearest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_Nearest{` +
		`Nearest:` + fmt.Sprintf("%#v", this.Nearest) + `}`}, ", ")
	return s
}
func (this *Query_Recommend) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_Recommend{` +
		`Recommend:` + fmt.Sprintf("%#v", this.Recommend) + `}`}, ", ")
	return s
}
func (this *Query_Discover) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_Discover{` +
		`Discover:` + fmt.Sprintf("%#v", this.Discover) + `}`}, ", ")
	return s
}
func (this *Query_Context) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_Context{` +
		`Context:` + fmt.Sprintf("%#v", this.Context) + `}`}, ", ")
	return s
}
func (this *Query_OrderBy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_OrderBy{` +
		`OrderBy:` + fmt.Sprintf("%#v", this.OrderBy) + `}`}, ", ")
	return s
}
func (this *Query_Fusion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Query_Fusion{` +
		`Fusion:` + fmt.Sprintf("%#v", this.Fusion) + `}`}, ", ")
	return s
}
func (this *PrefetchQuery) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.PrefetchQuery{")
	if this.Prefetch != nil {
		s = append(s, "Prefetch: "+fmt.Sprintf("%#v", this.Prefetch)+",\n")
	}
	if this.Query != nil {
		s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	}
	s = append(s, "Using: "+fmt.Sprintf("%#v", this.Using)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.LookupFrom != nil {
		s = append(s, "LookupFrom: "+fmt.Sprintf("%#v", this.LookupFrom)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&qdrant.QueryPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.Prefetch != nil {
		s = append(s, "Prefetch: "+fmt.Sprintf("%#v", this.Prefetch)+",\n")
	}
	if this.Query != nil {
		s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	}
	s = append(s, "Using: "+fmt.Sprintf("%#v", this.Using)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "ScoreThreshold: "+fmt.Sprintf("%#v", this.ScoreThreshold)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	if this.WithVectors != nil {
		s = append(s, "WithVectors: "+fmt.Sprintf("%#v", this.WithVectors)+",\n")
	}
	if this.WithPayload != nil {
		s = append(s, "WithPayload: "+fmt.Sprintf("%#v", this.WithPayload)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	if this.LookupFrom != nil {
		s = append(s, "LookupFrom: "+fmt.Sprintf("%#v", this.LookupFrom)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryBatchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.QueryBatchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	if this.QueryPoints != nil {
		s = append(s, "QueryPoints: "+fmt.Sprintf("%#v", this.QueryPoints)+",\n")
	}
	if this.ReadConsistency != nil {
		s = append(s, "ReadConsistency: "+fmt.Sprintf("%#v", this.ReadConsistency)+",\n")
	}
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&qdrant.PointsUpdateOperation{")
	if this.Operation != nil {
		s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_Upsert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_Upsert{` +
		`Upsert:` + fmt.Sprintf("%#v", this.Upsert) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_DeleteDeprecated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_DeleteDeprecated{` +
		`DeleteDeprecated:` + fmt.Sprintf("%#v", this.DeleteDeprecated) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_SetPayload_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_SetPayload_{` +
		`SetPayload:` + fmt.Sprintf("%#v", this.SetPayload) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_OverwritePayload_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_OverwritePayload_{` +
		`OverwritePayload:` + fmt.Sprintf("%#v", this.OverwritePayload) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_DeletePayload_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_DeletePayload_{` +
		`DeletePayload:` + fmt.Sprintf("%#v", this.DeletePayload) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_ClearPayloadDeprecated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_ClearPayloadDeprecated{` +
		`ClearPayloadDeprecated:` + fmt.Sprintf("%#v", this.ClearPayloadDeprecated) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_UpdateVectors_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_UpdateVectors_{` +
		`UpdateVectors:` + fmt.Sprintf("%#v", this.UpdateVectors) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_DeleteVectors_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_DeleteVectors_{` +
		`DeleteVectors:` + fmt.Sprintf("%#v", this.DeleteVectors) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_DeletePoints_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_DeletePoints_{` +
		`DeletePoints:` + fmt.Sprintf("%#v", this.DeletePoints) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_ClearPayload_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsUpdateOperation_ClearPayload_{` +
		`ClearPayload:` + fmt.Sprintf("%#v", this.ClearPayload) + `}`}, ", ")
	return s
}
func (this *PointsUpdateOperation_PointStructList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsUpdateOperation_PointStructList{")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_SetPayload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.PointsUpdateOperation_SetPayload{")
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_OverwritePayload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.PointsUpdateOperation_OverwritePayload{")
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_DeletePayload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.PointsUpdateOperation_DeletePayload{")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_UpdateVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsUpdateOperation_UpdateVectors{")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_DeleteVectors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.PointsUpdateOperation_DeleteVectors{")
	if this.PointsSelector != nil {
		s = append(s, "PointsSelector: "+fmt.Sprintf("%#v", this.PointsSelector)+",\n")
	}
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_DeletePoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsUpdateOperation_DeletePoints{")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsUpdateOperation_ClearPayload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsUpdateOperation_ClearPayload{")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	if this.ShardKeySelector != nil {
		s = append(s, "ShardKeySelector: "+fmt.Sprintf("%#v", this.ShardKeySelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateBatchPoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.UpdateBatchPoints{")
	s = append(s, "CollectionName: "+fmt.Sprintf("%#v", this.CollectionName)+",\n")
	s = append(s, "Wait: "+fmt.Sprintf("%#v", this.Wait)+",\n")
	if this.Operations != nil {
		s = append(s, "Operations: "+fmt.Sprintf("%#v", this.Operations)+",\n")
	}
	if this.Ordering != nil {
		s = append(s, "Ordering: "+fmt.Sprintf("%#v", this.Ordering)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsOperationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsOperationResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.UpdateResult{")
	s = append(s, "OperationId: "+fmt.Sprintf("%#v", this.OperationId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.OrderValue{")
	if this.Variant != nil {
		s = append(s, "Variant: "+fmt.Sprintf("%#v", this.Variant)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderValue_Int) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.OrderValue_Int{` +
		`Int:` + fmt.Sprintf("%#v", this.Int) + `}`}, ", ")
	return s
}
func (this *OrderValue_Float) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.OrderValue_Float{` +
		`Float:` + fmt.Sprintf("%#v", this.Float) + `}`}, ", ")
	return s
}
func (this *ScoredPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&qdrant.ScoredPoint{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	if this.OrderValue != nil {
		s = append(s, "OrderValue: "+fmt.Sprintf("%#v", this.OrderValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.GroupId{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupId_UnsignedValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.GroupId_UnsignedValue{` +
		`UnsignedValue:` + fmt.Sprintf("%#v", this.UnsignedValue) + `}`}, ", ")
	return s
}
func (this *GroupId_IntegerValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.GroupId_IntegerValue{` +
		`IntegerValue:` + fmt.Sprintf("%#v", this.IntegerValue) + `}`}, ", ")
	return s
}
func (this *GroupId_StringValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.GroupId_StringValue{` +
		`StringValue:` + fmt.Sprintf("%#v", this.StringValue) + `}`}, ", ")
	return s
}
func (this *PointGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.PointGroup{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Hits != nil {
		s = append(s, "Hits: "+fmt.Sprintf("%#v", this.Hits)+",\n")
	}
	if this.Lookup != nil {
		s = append(s, "Lookup: "+fmt.Sprintf("%#v", this.Lookup)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupsResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.GroupsResult{")
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.SearchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.QueryResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.QueryBatchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BatchResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.BatchResult{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.SearchBatchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchGroupsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.SearchGroupsResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CountResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.CountResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScrollResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.ScrollResponse{")
	if this.NextPageOffset != nil {
		s = append(s, "NextPageOffset: "+fmt.Sprintf("%#v", this.NextPageOffset)+",\n")
	}
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CountResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.CountResult{")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RetrievedPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&qdrant.RetrievedPoint{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	if this.ShardKey != nil {
		s = append(s, "ShardKey: "+fmt.Sprintf("%#v", this.ShardKey)+",\n")
	}
	if this.OrderValue != nil {
		s = append(s, "OrderValue: "+fmt.Sprintf("%#v", this.OrderValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GetResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.RecommendResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.RecommendBatchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoverResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.DiscoverResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoverBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.DiscoverBatchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecommendGroupsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.RecommendGroupsResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.UpdateBatchResponse{")
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.Filter{")
	if this.Should != nil {
		s = append(s, "Should: "+fmt.Sprintf("%#v", this.Should)+",\n")
	}
	if this.Must != nil {
		s = append(s, "Must: "+fmt.Sprintf("%#v", this.Must)+",\n")
	}
	if this.MustNot != nil {
		s = append(s, "MustNot: "+fmt.Sprintf("%#v", this.MustNot)+",\n")
	}
	if this.MinShould != nil {
		s = append(s, "MinShould: "+fmt.Sprintf("%#v", this.MinShould)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MinShould) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.MinShould{")
	if this.Conditions != nil {
		s = append(s, "Conditions: "+fmt.Sprintf("%#v", this.Conditions)+",\n")
	}
	s = append(s, "MinCount: "+fmt.Sprintf("%#v", this.MinCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Condition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&qdrant.Condition{")
	if this.ConditionOneOf != nil {
		s = append(s, "ConditionOneOf: "+fmt.Sprintf("%#v", this.ConditionOneOf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Condition_Field) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_Field{` +
		`Field:` + fmt.Sprintf("%#v", this.Field) + `}`}, ", ")
	return s
}
func (this *Condition_IsEmpty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_IsEmpty{` +
		`IsEmpty:` + fmt.Sprintf("%#v", this.IsEmpty) + `}`}, ", ")
	return s
}
func (this *Condition_HasId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_HasId{` +
		`HasId:` + fmt.Sprintf("%#v", this.HasId) + `}`}, ", ")
	return s
}
func (this *Condition_Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_Filter{` +
		`Filter:` + fmt.Sprintf("%#v", this.Filter) + `}`}, ", ")
	return s
}
func (this *Condition_IsNull) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_IsNull{` +
		`IsNull:` + fmt.Sprintf("%#v", this.IsNull) + `}`}, ", ")
	return s
}
func (this *Condition_Nested) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Condition_Nested{` +
		`Nested:` + fmt.Sprintf("%#v", this.Nested) + `}`}, ", ")
	return s
}
func (this *IsEmptyCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.IsEmptyCondition{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IsNullCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.IsNullCondition{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HasIdCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.HasIdCondition{")
	if this.HasId != nil {
		s = append(s, "HasId: "+fmt.Sprintf("%#v", this.HasId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NestedCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.NestedCondition{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.FieldCondition{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Match != nil {
		s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	}
	if this.Range != nil {
		s = append(s, "Range: "+fmt.Sprintf("%#v", this.Range)+",\n")
	}
	if this.GeoBoundingBox != nil {
		s = append(s, "GeoBoundingBox: "+fmt.Sprintf("%#v", this.GeoBoundingBox)+",\n")
	}
	if this.GeoRadius != nil {
		s = append(s, "GeoRadius: "+fmt.Sprintf("%#v", this.GeoRadius)+",\n")
	}
	if this.ValuesCount != nil {
		s = append(s, "ValuesCount: "+fmt.Sprintf("%#v", this.ValuesCount)+",\n")
	}
	if this.GeoPolygon != nil {
		s = append(s, "GeoPolygon: "+fmt.Sprintf("%#v", this.GeoPolygon)+",\n")
	}
	if this.DatetimeRange != nil {
		s = append(s, "DatetimeRange: "+fmt.Sprintf("%#v", this.DatetimeRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Match) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&qdrant.Match{")
	if this.MatchValue != nil {
		s = append(s, "MatchValue: "+fmt.Sprintf("%#v", this.MatchValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Match_Keyword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Keyword{` +
		`Keyword:` + fmt.Sprintf("%#v", this.Keyword) + `}`}, ", ")
	return s
}
func (this *Match_Integer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Integer{` +
		`Integer:` + fmt.Sprintf("%#v", this.Integer) + `}`}, ", ")
	return s
}
func (this *Match_Boolean) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Boolean{` +
		`Boolean:` + fmt.Sprintf("%#v", this.Boolean) + `}`}, ", ")
	return s
}
func (this *Match_Text) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Text{` +
		`Text:` + fmt.Sprintf("%#v", this.Text) + `}`}, ", ")
	return s
}
func (this *Match_Keywords) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Keywords{` +
		`Keywords:` + fmt.Sprintf("%#v", this.Keywords) + `}`}, ", ")
	return s
}
func (this *Match_Integers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_Integers{` +
		`Integers:` + fmt.Sprintf("%#v", this.Integers) + `}`}, ", ")
	return s
}
func (this *Match_ExceptIntegers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_ExceptIntegers{` +
		`ExceptIntegers:` + fmt.Sprintf("%#v", this.ExceptIntegers) + `}`}, ", ")
	return s
}
func (this *Match_ExceptKeywords) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.Match_ExceptKeywords{` +
		`ExceptKeywords:` + fmt.Sprintf("%#v", this.ExceptKeywords) + `}`}, ", ")
	return s
}
func (this *RepeatedStrings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.RepeatedStrings{")
	s = append(s, "Strings: "+fmt.Sprintf("%#v", this.Strings)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepeatedIntegers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.RepeatedIntegers{")
	s = append(s, "Integers: "+fmt.Sprintf("%#v", this.Integers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.Range{")
	s = append(s, "Lt: "+fmt.Sprintf("%#v", this.Lt)+",\n")
	s = append(s, "Gt: "+fmt.Sprintf("%#v", this.Gt)+",\n")
	s = append(s, "Gte: "+fmt.Sprintf("%#v", this.Gte)+",\n")
	s = append(s, "Lte: "+fmt.Sprintf("%#v", this.Lte)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DatetimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.DatetimeRange{")
	if this.Lt != nil {
		s = append(s, "Lt: "+fmt.Sprintf("%#v", this.Lt)+",\n")
	}
	if this.Gt != nil {
		s = append(s, "Gt: "+fmt.Sprintf("%#v", this.Gt)+",\n")
	}
	if this.Gte != nil {
		s = append(s, "Gte: "+fmt.Sprintf("%#v", this.Gte)+",\n")
	}
	if this.Lte != nil {
		s = append(s, "Lte: "+fmt.Sprintf("%#v", this.Lte)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoBoundingBox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GeoBoundingBox{")
	if this.TopLeft != nil {
		s = append(s, "TopLeft: "+fmt.Sprintf("%#v", this.TopLeft)+",\n")
	}
	if this.BottomRight != nil {
		s = append(s, "BottomRight: "+fmt.Sprintf("%#v", this.BottomRight)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoRadius) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GeoRadius{")
	if this.Center != nil {
		s = append(s, "Center: "+fmt.Sprintf("%#v", this.Center)+",\n")
	}
	s = append(s, "Radius: "+fmt.Sprintf("%#v", this.Radius)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoLineString) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.GeoLineString{")
	if this.Points != nil {
		s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoPolygon) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GeoPolygon{")
	if this.Exterior != nil {
		s = append(s, "Exterior: "+fmt.Sprintf("%#v", this.Exterior)+",\n")
	}
	if this.Interiors != nil {
		s = append(s, "Interiors: "+fmt.Sprintf("%#v", this.Interiors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValuesCount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&qdrant.ValuesCount{")
	s = append(s, "Lt: "+fmt.Sprintf("%#v", this.Lt)+",\n")
	s = append(s, "Gt: "+fmt.Sprintf("%#v", this.Gt)+",\n")
	s = append(s, "Gte: "+fmt.Sprintf("%#v", this.Gte)+",\n")
	s = append(s, "Lte: "+fmt.Sprintf("%#v", this.Lte)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.PointsSelector{")
	if this.PointsSelectorOneOf != nil {
		s = append(s, "PointsSelectorOneOf: "+fmt.Sprintf("%#v", this.PointsSelectorOneOf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointsSelector_Points) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsSelector_Points{` +
		`Points:` + fmt.Sprintf("%#v", this.Points) + `}`}, ", ")
	return s
}
func (this *PointsSelector_Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&qdrant.PointsSelector_Filter{` +
		`Filter:` + fmt.Sprintf("%#v", this.Filter) + `}`}, ", ")
	return s
}
func (this *PointsIdsList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&qdrant.PointsIdsList{")
	if this.Ids != nil {
		s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PointStruct) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&qdrant.PointStruct{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%#v: %#v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	if this.Payload != nil {
		s = append(s, "Payload: "+mapStringForPayload+",\n")
	}
	if this.Vectors != nil {
		s = append(s, "Vectors: "+fmt.Sprintf("%#v", this.Vectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&qdrant.GeoPoint{")
	s = append(s, "Lon: "+fmt.Sprintf("%#v", this.Lon)+",\n")
	s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPoints(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WriteOrdering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteOrdering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteOrdering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadConsistency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadConsistency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadConsistency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadConsistency_Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadConsistency_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ReadConsistency_Factor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadConsistency_Factor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Factor))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *PointId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PointIdOptions != nil {
		{
			size := m.PointIdOptions.Size()
			i -= size
			if _, err := m.PointIdOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointId_Num) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointId_Num) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Num))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *PointId_Uuid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointId_Uuid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Uuid)
	copy(dAtA[i:], m.Uuid)
	i = encodeVarintPoints(dAtA, i, uint64(len(m.Uuid)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *SparseIndices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseIndices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseIndices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA2 := make([]byte, len(m.Data)*10)
		var j1 int
		for _, num := range m.Data {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPoints(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VectorsCount != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.VectorsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Indices != nil {
		{
			size, err := m.Indices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			f4 := math.Float32bits(float32(m.Data[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f4))
		}
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Data)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenseVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			f5 := math.Float32bits(float32(m.Data[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f5))
		}
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Data)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SparseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SparseVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Indices) > 0 {
		dAtA7 := make([]byte, len(m.Indices)*10)
		var j6 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPoints(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			f8 := math.Float32bits(float32(m.Values[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
		}
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Values)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiDenseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiDenseVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiDenseVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for iNdEx := len(m.Vectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Variant != nil {
		{
			size := m.Variant.Size()
			i -= size
			if _, err := m.Variant.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorInput_Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorInput_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VectorInput_Dense) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorInput_Dense) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dense != nil {
		{
			size, err := m.Dense.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VectorInput_Sparse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorInput_Sparse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sparse != nil {
		{
			size, err := m.Sparse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VectorInput_MultiDense) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorInput_MultiDense) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiDense != nil {
		{
			size, err := m.MultiDense.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ShardKeySelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardKeySelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardKeySelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardKeys) > 0 {
		for iNdEx := len(m.ShardKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpsertPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletePoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Points != nil {
		{
			size, err := m.Points.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePointVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePointVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePointVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PointVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletePointVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePointVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePointVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetPayloadPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetPayloadPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetPayloadPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x42
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletePayloadPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePayloadPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePayloadPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearPayloadPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearPayloadPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearPayloadPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Points != nil {
		{
			size, err := m.Points.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateFieldIndexCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFieldIndexCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateFieldIndexCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FieldIndexParams != nil {
		{
			size, err := m.FieldIndexParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FieldType != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.FieldType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FieldName) > 0 {
		i -= len(m.FieldName)
		copy(dAtA[i:], m.FieldName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.FieldName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFieldIndexCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFieldIndexCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFieldIndexCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.FieldName) > 0 {
		i -= len(m.FieldName)
		copy(dAtA[i:], m.FieldName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.FieldName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayloadIncludeSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadIncludeSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadIncludeSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PayloadExcludeSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadExcludeSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadExcludeSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WithPayloadSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithPayloadSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithPayloadSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelectorOptions != nil {
		{
			size := m.SelectorOptions.Size()
			i -= size
			if _, err := m.SelectorOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WithPayloadSelector_Enable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithPayloadSelector_Enable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Enable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *WithPayloadSelector_Include) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithPayloadSelector_Include) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Include != nil {
		{
			size, err := m.Include.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WithPayloadSelector_Exclude) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithPayloadSelector_Exclude) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exclude != nil {
		{
			size, err := m.Exclude.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NamedVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamedVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for k := range m.Vectors {
			v := m.Vectors[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VectorsOptions != nil {
		{
			size := m.VectorsOptions.Size()
			i -= size
			if _, err := m.VectorsOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vectors_Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vectors_Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vector != nil {
		{
			size, err := m.Vector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Vectors_Vectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vectors_Vectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VectorsSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorsSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorsSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WithVectorsSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithVectorsSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithVectorsSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelectorOptions != nil {
		{
			size := m.SelectorOptions.Size()
			i -= size
			if _, err := m.SelectorOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WithVectorsSelector_Enable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithVectorsSelector_Enable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Enable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *WithVectorsSelector_Include) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithVectorsSelector_Include) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Include != nil {
		{
			size, err := m.Include.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QuantizationSearchParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuantizationSearchParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuantizationSearchParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Oversampling != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Oversampling))))
		i--
		dAtA[i] = 0x19
	}
	if m.Rescore {
		i--
		if m.Rescore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ignore {
		i--
		if m.Ignore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexedOnly {
		i--
		if m.IndexedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Quantization != nil {
		{
			size, err := m.Quantization.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Exact {
		i--
		if m.Exact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HnswEf != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.HnswEf))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SparseIndices != nil {
		{
			size, err := m.SparseIndices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x68
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VectorName) > 0 {
		i -= len(m.VectorName)
		copy(dAtA[i:], m.VectorName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.VectorName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Offset != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x48
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vector) > 0 {
		for iNdEx := len(m.Vector) - 1; iNdEx >= 0; iNdEx-- {
			f57 := math.Float32bits(float32(m.Vector[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f57))
		}
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Vector)*4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchBatchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBatchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBatchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SearchPoints) > 0 {
		for iNdEx := len(m.SearchPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SearchPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithLookup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithLookup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithLookup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchPointGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchPointGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchPointGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SparseIndices != nil {
		{
			size, err := m.SparseIndices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x70
	}
	if m.WithLookup != nil {
		{
			size, err := m.WithLookup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.GroupSize != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x58
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x52
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.VectorName) > 0 {
		i -= len(m.VectorName)
		copy(dAtA[i:], m.VectorName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.VectorName)))
		i--
		dAtA[i] = 0x42
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vector) > 0 {
		for iNdEx := len(m.Vector) - 1; iNdEx >= 0; iNdEx-- {
			f69 := math.Float32bits(float32(m.Vector[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f69))
		}
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Vector)*4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StartFrom_Float) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartFrom_Float) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}
func (m *StartFrom_Integer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartFrom_Integer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Integer))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *StartFrom_Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartFrom_Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StartFrom_Datetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartFrom_Datetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Datetime)
	copy(dAtA[i:], m.Datetime)
	i = encodeVarintPoints(dAtA, i, uint64(len(m.Datetime)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *OrderBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartFrom != nil {
		{
			size, err := m.StartFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Direction != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScrollPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScrollPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScrollPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderBy != nil {
		{
			size, err := m.OrderBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LookupLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookupLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LookupLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VectorName) > 0 {
		i -= len(m.VectorName)
		copy(dAtA[i:], m.VectorName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.VectorName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecommendPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.NegativeVectors) > 0 {
		for iNdEx := len(m.NegativeVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NegativeVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.PositiveVectors) > 0 {
		for iNdEx := len(m.PositiveVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositiveVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.Strategy != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.LookupFrom != nil {
		{
			size, err := m.LookupFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Using) > 0 {
		i -= len(m.Using)
		copy(dAtA[i:], m.Using)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Using)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Offset != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x50
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x4d
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Negative) > 0 {
		for iNdEx := len(m.Negative) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Negative[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Positive) > 0 {
		for iNdEx := len(m.Positive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecommendBatchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendBatchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendBatchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RecommendPoints) > 0 {
		for iNdEx := len(m.RecommendPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecommendPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecommendPointGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendPointGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendPointGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.NegativeVectors) > 0 {
		for iNdEx := len(m.NegativeVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NegativeVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.PositiveVectors) > 0 {
		for iNdEx := len(m.PositiveVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositiveVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.Strategy != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.WithLookup != nil {
		{
			size, err := m.WithLookup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.GroupSize != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.GroupSize))
		i--
		dAtA[i] = 0x68
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x62
	}
	if m.LookupFrom != nil {
		{
			size, err := m.LookupFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Using) > 0 {
		i -= len(m.Using)
		copy(dAtA[i:], m.Using)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Using)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Negative) > 0 {
		for iNdEx := len(m.Negative) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Negative[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Positive) > 0 {
		for iNdEx := len(m.Positive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TargetVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TargetVector_Single) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetVector_Single) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Single != nil {
		{
			size, err := m.Single.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VectorExample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorExample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorExample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Example != nil {
		{
			size := m.Example.Size()
			i -= size
			if _, err := m.Example.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VectorExample_Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorExample_Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VectorExample_Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VectorExample_Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vector != nil {
		{
			size, err := m.Vector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ContextExamplePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextExamplePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextExamplePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Negative != nil {
		{
			size, err := m.Negative.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positive != nil {
		{
			size, err := m.Positive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x68
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.LookupFrom != nil {
		{
			size, err := m.LookupFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Using) > 0 {
		i -= len(m.Using)
		copy(dAtA[i:], m.Using)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Using)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Offset != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x40
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Context) > 0 {
		for iNdEx := len(m.Context) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Context[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverBatchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverBatchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverBatchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DiscoverPoints) > 0 {
		for iNdEx := len(m.DiscoverPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DiscoverPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CountPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Exact {
		i--
		if m.Exact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecommendInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Strategy != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Negative) > 0 {
		for iNdEx := len(m.Negative) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Negative[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Positive) > 0 {
		for iNdEx := len(m.Positive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContextInputPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextInputPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextInputPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Negative != nil {
		{
			size, err := m.Negative.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Positive != nil {
		{
			size, err := m.Positive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContextInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for iNdEx := len(m.Pairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Variant != nil {
		{
			size := m.Variant.Size()
			i -= size
			if _, err := m.Variant.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Query_Nearest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_Nearest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nearest != nil {
		{
			size, err := m.Nearest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Query_Recommend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_Recommend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Recommend != nil {
		{
			size, err := m.Recommend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Query_Discover) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_Discover) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Discover != nil {
		{
			size, err := m.Discover.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Query_Context) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_Context) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Query_OrderBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_OrderBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderBy != nil {
		{
			size, err := m.OrderBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Query_Fusion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query_Fusion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Fusion))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *PrefetchQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrefetchQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrefetchQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LookupFrom != nil {
		{
			size, err := m.LookupFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x38
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x35
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Using) > 0 {
		i -= len(m.Using)
		copy(dAtA[i:], m.Using)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Using)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prefetch) > 0 {
		for iNdEx := len(m.Prefetch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prefetch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x78
	}
	if m.LookupFrom != nil {
		{
			size, err := m.LookupFrom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.WithPayload != nil {
		{
			size, err := m.WithPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.WithVectors != nil {
		{
			size, err := m.WithVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Offset != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x48
	}
	if m.Limit != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x40
	}
	if m.ScoreThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ScoreThreshold))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Using) > 0 {
		i -= len(m.Using)
		copy(dAtA[i:], m.Using)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Using)))
		i--
		dAtA[i] = 0x22
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefetch) > 0 {
		for iNdEx := len(m.Prefetch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prefetch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBatchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBatchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBatchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadConsistency != nil {
		{
			size, err := m.ReadConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QueryPoints) > 0 {
		for iNdEx := len(m.QueryPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_Upsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_Upsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Upsert != nil {
		{
			size, err := m.Upsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_DeleteDeprecated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeleteDeprecated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteDeprecated != nil {
		{
			size, err := m.DeleteDeprecated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_SetPayload_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_SetPayload_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetPayload != nil {
		{
			size, err := m.SetPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_OverwritePayload_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_OverwritePayload_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OverwritePayload != nil {
		{
			size, err := m.OverwritePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_DeletePayload_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeletePayload_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeletePayload != nil {
		{
			size, err := m.DeletePayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_ClearPayloadDeprecated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_ClearPayloadDeprecated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearPayloadDeprecated != nil {
		{
			size, err := m.ClearPayloadDeprecated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_UpdateVectors_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_UpdateVectors_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateVectors != nil {
		{
			size, err := m.UpdateVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_DeleteVectors_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeleteVectors_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteVectors != nil {
		{
			size, err := m.DeleteVectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_DeletePoints_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeletePoints_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeletePoints != nil {
		{
			size, err := m.DeletePoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_ClearPayload_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_ClearPayload_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearPayload != nil {
		{
			size, err := m.ClearPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *PointsUpdateOperation_PointStructList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_PointStructList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_PointStructList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_SetPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_SetPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_SetPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x22
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_OverwritePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_OverwritePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_OverwritePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x22
	}
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_DeletePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_DeletePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeletePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_UpdateVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_UpdateVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_UpdateVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_DeleteVectors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_DeleteVectors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeleteVectors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PointsSelector != nil {
		{
			size, err := m.PointsSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_DeletePoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_DeletePoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_DeletePoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Points != nil {
		{
			size, err := m.Points.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PointsUpdateOperation_ClearPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsUpdateOperation_ClearPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsUpdateOperation_ClearPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardKeySelector != nil {
		{
			size, err := m.ShardKeySelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Points != nil {
		{
			size, err := m.Points.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateBatchPoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBatchPoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateBatchPoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ordering != nil {
		{
			size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Operations) > 0 {
		for iNdEx := len(m.Operations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollectionName) > 0 {
		i -= len(m.CollectionName)
		copy(dAtA[i:], m.CollectionName)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.CollectionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PointsOperationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsOperationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsOperationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationId != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.OperationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Variant != nil {
		{
			size := m.Variant.Size()
			i -= size
			if _, err := m.Variant.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderValue_Int) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderValue_Int) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Int))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *OrderValue_Float) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderValue_Float) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *ScoredPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScoredPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScoredPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderValue != nil {
		{
			size, err := m.OrderValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Version != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GroupId_UnsignedValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupId_UnsignedValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.UnsignedValue))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *GroupId_IntegerValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupId_IntegerValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.IntegerValue))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *GroupId_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupId_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintPoints(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *PointGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lookup != nil {
		{
			size, err := m.Lookup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hits) > 0 {
		for iNdEx := len(m.Hits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupsResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupsResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchGroupsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchGroupsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchGroupsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScrollResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScrollResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScrollResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NextPageOffset != nil {
		{
			size, err := m.NextPageOffset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CountResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RetrievedPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetrievedPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetrievedPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderValue != nil {
		{
			size, err := m.OrderValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ShardKey != nil {
		{
			size, err := m.ShardKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecommendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecommendBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DiscoverBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoverBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscoverBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecommendGroupsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendGroupsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecommendGroupsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Time))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinShould != nil {
		{
			size, err := m.MinShould.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MustNot) > 0 {
		for iNdEx := len(m.MustNot) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustNot[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Must) > 0 {
		for iNdEx := len(m.Must) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Must[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Should) > 0 {
		for iNdEx := len(m.Should) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Should[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MinShould) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinShould) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinShould) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinCount != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.MinCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConditionOneOf != nil {
		{
			size := m.ConditionOneOf.Size()
			i -= size
			if _, err := m.ConditionOneOf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Condition_Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Field != nil {
		{
			size, err := m.Field.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Condition_IsEmpty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_IsEmpty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsEmpty != nil {
		{
			size, err := m.IsEmpty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Condition_HasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_HasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HasId != nil {
		{
			size, err := m.HasId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Condition_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Condition_IsNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_IsNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsNull != nil {
		{
			size, err := m.IsNull.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Condition_Nested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition_Nested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nested != nil {
		{
			size, err := m.Nested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *IsEmptyCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsEmptyCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsEmptyCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsNullCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsNullCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsNullCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasIdCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasIdCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasIdCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HasId) > 0 {
		for iNdEx := len(m.HasId) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HasId[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NestedCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NestedCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatetimeRange != nil {
		{
			size, err := m.DatetimeRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.GeoPolygon != nil {
		{
			size, err := m.GeoPolygon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ValuesCount != nil {
		{
			size, err := m.ValuesCount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.GeoRadius != nil {
		{
			size, err := m.GeoRadius.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GeoBoundingBox != nil {
		{
			size, err := m.GeoBoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPoints(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MatchValue != nil {
		{
			size := m.MatchValue.Size()
			i -= size
			if _, err := m.MatchValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Match_Keyword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Keyword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Keyword)
	copy(dAtA[i:], m.Keyword)
	i = encodeVarintPoints(dAtA, i, uint64(len(m.Keyword)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Match_Integer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Integer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPoints(dAtA, i, uint64(m.Integer))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Match_Boolean) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Boolean) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Boolean {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Match_Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintPoints(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *Match_Keywords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Keywords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Keywords != nil {
		{
			size, err := m.Keywords.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Match_Integers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_Integers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Integers != nil {
		{
			size, err := m.Integers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Match_ExceptIntegers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_ExceptIntegers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExceptIntegers != nil {
		{
			size, err := m.ExceptIntegers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Match_ExceptKeywords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Match_ExceptKeywords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExceptKeywords != nil {
		{
			size, err := m.ExceptKeywords.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RepeatedStrings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedStrings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepeatedStrings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintPoints(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RepeatedIntegers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedIntegers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepeatedIntegers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Integers) > 0 {
		dAtA200 := make([]byte, len(m.Integers)*10)
		var j199 int
		for _, num1 := range m.Integers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA200[j199] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j199++
			}
			dAtA200[j199] = uint8(num)
			j199++
		}
		i -= j199
		copy(dAtA[i:], dAtA200[:j199])
		i = encodeVarintPoints(dAtA, i, uint64(j199))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lte != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lte))))
		i--
		dAtA[i] = 0x21
	}
	if m.Gte != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gte))))
		i--
		dAtA[i] = 0x19
	}
	if m.Gt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gt))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lt))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DatetimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatetimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatetimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lte != nil {
		{
			size, err := m.Lte.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Gte != nil {
		{
			size, err := m.Gte.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Gt != nil {
		{
			size, err := m.Gt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Lt != nil {
		{
			size, err := m.Lt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeoBoundingBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoBoundingBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoBoundingBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BottomRight != nil {
		{
			size, err := m.BottomRight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TopLeft != nil {
		{
			size, err := m.TopLeft.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeoRadius) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoRadius) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoRadius) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x15
	}
	if m.Center != nil {
		{
			size, err := m.Center.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeoLineString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoLineString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoLineString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoPolygon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoPolygon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoPolygon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interiors) > 0 {
		for iNdEx := len(m.Interiors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interiors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Exterior != nil {
		{
			size, err := m.Exterior.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValuesCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValuesCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValuesCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lte != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Lte))
		i--
		dAtA[i] = 0x20
	}
	if m.Gte != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Gte))
		i--
		dAtA[i] = 0x18
	}
	if m.Gt != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Gt))
		i--
		dAtA[i] = 0x10
	}
	if m.Lt != 0 {
		i = encodeVarintPoints(dAtA, i, uint64(m.Lt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PointsSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PointsSelectorOneOf != nil {
		{
			size := m.PointsSelectorOneOf.Size()
			i -= size
			if _, err := m.PointsSelectorOneOf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointsSelector_Points) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsSelector_Points) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Points != nil {
		{
			size, err := m.Points.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PointsSelector_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsSelector_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PointsIdsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsIdsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointsIdsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPoints(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PointStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointStruct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PointStruct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vectors != nil {
		{
			size, err := m.Vectors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPoints(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPoints(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPoints(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPoints(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeoPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lon != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lon))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintPoints(dAtA []byte, offset int, v uint64) int {
	offset -= sovPoints(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WriteOrdering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPoints(uint64(m.Type))
	}
	return n
}

func (m *ReadConsistency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ReadConsistency_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Type))
	return n
}
func (m *ReadConsistency_Factor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Factor))
	return n
}
func (m *PointId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PointIdOptions != nil {
		n += m.PointIdOptions.Size()
	}
	return n
}

func (m *PointId_Num) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Num))
	return n
}
func (m *PointId_Uuid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	n += 1 + l + sovPoints(uint64(l))
	return n
}
func (m *SparseIndices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		l = 0
		for _, e := range m.Data {
			l += sovPoints(uint64(e))
		}
		n += 1 + sovPoints(uint64(l)) + l
	}
	return n
}

func (m *Vector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		n += 1 + sovPoints(uint64(len(m.Data)*4)) + len(m.Data)*4
	}
	if m.Indices != nil {
		l = m.Indices.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.VectorsCount != 0 {
		n += 1 + sovPoints(uint64(m.VectorsCount))
	}
	return n
}

func (m *DenseVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		n += 1 + sovPoints(uint64(len(m.Data)*4)) + len(m.Data)*4
	}
	return n
}

func (m *SparseVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		n += 1 + sovPoints(uint64(len(m.Values)*4)) + len(m.Values)*4
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovPoints(uint64(e))
		}
		n += 1 + sovPoints(uint64(l)) + l
	}
	return n
}

func (m *MultiDenseVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for _, e := range m.Vectors {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *VectorInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variant != nil {
		n += m.Variant.Size()
	}
	return n
}

func (m *VectorInput_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorInput_Dense) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dense != nil {
		l = m.Dense.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorInput_Sparse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sparse != nil {
		l = m.Sparse.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorInput_MultiDense) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiDense != nil {
		l = m.MultiDense.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *ShardKeySelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ShardKeys) > 0 {
		for _, e := range m.ShardKeys {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *UpsertPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DeletePoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.Points != nil {
		l = m.Points.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GetPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *UpdatePointVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DeletePointVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *SetPayloadPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DeletePayloadPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *ClearPayloadPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.Points != nil {
		l = m.Points.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *CreateFieldIndexCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	l = len(m.FieldName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.FieldType != 0 {
		n += 1 + sovPoints(uint64(m.FieldType))
	}
	if m.FieldIndexParams != nil {
		l = m.FieldIndexParams.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DeleteFieldIndexCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	l = len(m.FieldName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PayloadIncludeSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *PayloadExcludeSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *WithPayloadSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectorOptions != nil {
		n += m.SelectorOptions.Size()
	}
	return n
}

func (m *WithPayloadSelector_Enable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *WithPayloadSelector_Include) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Include != nil {
		l = m.Include.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *WithPayloadSelector_Exclude) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exclude != nil {
		l = m.Exclude.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *NamedVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vectors) > 0 {
		for k, v := range m.Vectors {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Vectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VectorsOptions != nil {
		n += m.VectorsOptions.Size()
	}
	return n
}

func (m *Vectors_Vector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vector != nil {
		l = m.Vector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Vectors_Vectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorsSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *WithVectorsSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectorOptions != nil {
		n += m.SelectorOptions.Size()
	}
	return n
}

func (m *WithVectorsSelector_Enable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *WithVectorsSelector_Include) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Include != nil {
		l = m.Include.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *QuantizationSearchParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ignore {
		n += 2
	}
	if m.Rescore {
		n += 2
	}
	if m.Oversampling != 0 {
		n += 9
	}
	return n
}

func (m *SearchParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HnswEf != 0 {
		n += 1 + sovPoints(uint64(m.HnswEf))
	}
	if m.Exact {
		n += 2
	}
	if m.Quantization != nil {
		l = m.Quantization.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.IndexedOnly {
		n += 2
	}
	return n
}

func (m *SearchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Vector) > 0 {
		n += 1 + sovPoints(uint64(len(m.Vector)*4)) + len(m.Vector)*4
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	if m.Offset != 0 {
		n += 1 + sovPoints(uint64(m.Offset))
	}
	l = len(m.VectorName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.SparseIndices != nil {
		l = m.SparseIndices.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *SearchBatchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.SearchPoints) > 0 {
		for _, e := range m.SearchPoints {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	return n
}

func (m *WithLookup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *SearchPointGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Vector) > 0 {
		n += 1 + sovPoints(uint64(len(m.Vector)*4)) + len(m.Vector)*4
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	l = len(m.VectorName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.GroupSize != 0 {
		n += 1 + sovPoints(uint64(m.GroupSize))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithLookup != nil {
		l = m.WithLookup.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.SparseIndices != nil {
		l = m.SparseIndices.Size()
		n += 2 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *StartFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *StartFrom_Float) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *StartFrom_Integer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Integer))
	return n
}
func (m *StartFrom_Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *StartFrom_Datetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Datetime)
	n += 1 + l + sovPoints(uint64(l))
	return n
}
func (m *OrderBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovPoints(uint64(m.Direction))
	}
	if m.StartFrom != nil {
		l = m.StartFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *ScrollPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.OrderBy != nil {
		l = m.OrderBy.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *LookupLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.VectorName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *RecommendPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Positive) > 0 {
		for _, e := range m.Positive {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if len(m.Negative) > 0 {
		for _, e := range m.Negative {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	if m.Offset != 0 {
		n += 1 + sovPoints(uint64(m.Offset))
	}
	l = len(m.Using)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.LookupFrom != nil {
		l = m.LookupFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Strategy != 0 {
		n += 2 + sovPoints(uint64(m.Strategy))
	}
	if len(m.PositiveVectors) > 0 {
		for _, e := range m.PositiveVectors {
			l = e.Size()
			n += 2 + l + sovPoints(uint64(l))
		}
	}
	if len(m.NegativeVectors) > 0 {
		for _, e := range m.NegativeVectors {
			l = e.Size()
			n += 2 + l + sovPoints(uint64(l))
		}
	}
	if m.Timeout != 0 {
		n += 2 + sovPoints(uint64(m.Timeout))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 2 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *RecommendBatchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.RecommendPoints) > 0 {
		for _, e := range m.RecommendPoints {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	return n
}

func (m *RecommendPointGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Positive) > 0 {
		for _, e := range m.Positive {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if len(m.Negative) > 0 {
		for _, e := range m.Negative {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	l = len(m.Using)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.LookupFrom != nil {
		l = m.LookupFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.GroupSize != 0 {
		n += 1 + sovPoints(uint64(m.GroupSize))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithLookup != nil {
		l = m.WithLookup.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Strategy != 0 {
		n += 2 + sovPoints(uint64(m.Strategy))
	}
	if len(m.PositiveVectors) > 0 {
		for _, e := range m.PositiveVectors {
			l = e.Size()
			n += 2 + l + sovPoints(uint64(l))
		}
	}
	if len(m.NegativeVectors) > 0 {
		for _, e := range m.NegativeVectors {
			l = e.Size()
			n += 2 + l + sovPoints(uint64(l))
		}
	}
	if m.Timeout != 0 {
		n += 2 + sovPoints(uint64(m.Timeout))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 2 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *TargetVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		n += m.Target.Size()
	}
	return n
}

func (m *TargetVector_Single) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Single != nil {
		l = m.Single.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorExample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Example != nil {
		n += m.Example.Size()
	}
	return n
}

func (m *VectorExample_Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *VectorExample_Vector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vector != nil {
		l = m.Vector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *ContextExamplePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positive != nil {
		l = m.Positive.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Negative != nil {
		l = m.Negative.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DiscoverPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Context) > 0 {
		for _, e := range m.Context {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovPoints(uint64(m.Offset))
	}
	l = len(m.Using)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.LookupFrom != nil {
		l = m.LookupFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DiscoverBatchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.DiscoverPoints) > 0 {
		for _, e := range m.DiscoverPoints {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	return n
}

func (m *CountPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Exact {
		n += 2
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *RecommendInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Positive) > 0 {
		for _, e := range m.Positive {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if len(m.Negative) > 0 {
		for _, e := range m.Negative {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Strategy != 0 {
		n += 1 + sovPoints(uint64(m.Strategy))
	}
	return n
}

func (m *ContextInputPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Positive != nil {
		l = m.Positive.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Negative != nil {
		l = m.Negative.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *DiscoverInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *ContextInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variant != nil {
		n += m.Variant.Size()
	}
	return n
}

func (m *Query_Nearest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nearest != nil {
		l = m.Nearest.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Query_Recommend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Recommend != nil {
		l = m.Recommend.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Query_Discover) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Discover != nil {
		l = m.Discover.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Query_Context) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Query_OrderBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderBy != nil {
		l = m.OrderBy.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Query_Fusion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Fusion))
	return n
}
func (m *PrefetchQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefetch) > 0 {
		for _, e := range m.Prefetch {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.Using)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.LookupFrom != nil {
		l = m.LookupFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *QueryPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Prefetch) > 0 {
		for _, e := range m.Prefetch {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.Using)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ScoreThreshold != 0 {
		n += 5
	}
	if m.Limit != 0 {
		n += 1 + sovPoints(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovPoints(uint64(m.Offset))
	}
	if m.WithVectors != nil {
		l = m.WithVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.WithPayload != nil {
		l = m.WithPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.LookupFrom != nil {
		l = m.LookupFrom.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	return n
}

func (m *QueryBatchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.QueryPoints) > 0 {
		for _, e := range m.QueryPoints {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ReadConsistency != nil {
		l = m.ReadConsistency.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovPoints(uint64(m.Timeout))
	}
	return n
}

func (m *PointsUpdateOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *PointsUpdateOperation_Upsert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upsert != nil {
		l = m.Upsert.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_DeleteDeprecated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteDeprecated != nil {
		l = m.DeleteDeprecated.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_SetPayload_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetPayload != nil {
		l = m.SetPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_OverwritePayload_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverwritePayload != nil {
		l = m.OverwritePayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_DeletePayload_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeletePayload != nil {
		l = m.DeletePayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_ClearPayloadDeprecated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearPayloadDeprecated != nil {
		l = m.ClearPayloadDeprecated.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_UpdateVectors_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateVectors != nil {
		l = m.UpdateVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_DeleteVectors_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteVectors != nil {
		l = m.DeleteVectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_DeletePoints_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeletePoints != nil {
		l = m.DeletePoints.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_ClearPayload_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearPayload != nil {
		l = m.ClearPayload.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsUpdateOperation_PointStructList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_SetPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_OverwritePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_DeletePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_UpdateVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_DeleteVectors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PointsSelector != nil {
		l = m.PointsSelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_DeletePoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Points != nil {
		l = m.Points.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsUpdateOperation_ClearPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Points != nil {
		l = m.Points.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKeySelector != nil {
		l = m.ShardKeySelector.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *UpdateBatchPoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollectionName)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Ordering != nil {
		l = m.Ordering.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *PointsOperationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *UpdateResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationId != 0 {
		n += 1 + sovPoints(uint64(m.OperationId))
	}
	if m.Status != 0 {
		n += 1 + sovPoints(uint64(m.Status))
	}
	return n
}

func (m *OrderValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Variant != nil {
		n += m.Variant.Size()
	}
	return n
}

func (m *OrderValue_Int) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Int))
	return n
}
func (m *OrderValue_Float) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *ScoredPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.Score != 0 {
		n += 5
	}
	if m.Version != 0 {
		n += 1 + sovPoints(uint64(m.Version))
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.OrderValue != nil {
		l = m.OrderValue.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GroupId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *GroupId_UnsignedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.UnsignedValue))
	return n
}
func (m *GroupId_IntegerValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.IntegerValue))
	return n
}
func (m *GroupId_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovPoints(uint64(l))
	return n
}
func (m *PointGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Hits) > 0 {
		for _, e := range m.Hits {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Lookup != nil {
		l = m.Lookup.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GroupsResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *QueryBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *BatchResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *SearchBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *SearchGroupsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *CountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *ScrollResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextPageOffset != nil {
		l = m.NextPageOffset.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *CountResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPoints(uint64(m.Count))
	}
	return n
}

func (m *RetrievedPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ShardKey != nil {
		l = m.ShardKey.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.OrderValue != nil {
		l = m.OrderValue.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *RecommendResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *RecommendBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *DiscoverResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *DiscoverBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *RecommendGroupsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *UpdateBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 9
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Should) > 0 {
		for _, e := range m.Should {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if len(m.Must) > 0 {
		for _, e := range m.Must {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if len(m.MustNot) > 0 {
		for _, e := range m.MustNot {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.MinShould != nil {
		l = m.MinShould.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *MinShould) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	if m.MinCount != 0 {
		n += 1 + sovPoints(uint64(m.MinCount))
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionOneOf != nil {
		n += m.ConditionOneOf.Size()
	}
	return n
}

func (m *Condition_Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Condition_IsEmpty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsEmpty != nil {
		l = m.IsEmpty.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Condition_HasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasId != nil {
		l = m.HasId.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Condition_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Condition_IsNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsNull != nil {
		l = m.IsNull.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Condition_Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *IsEmptyCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *IsNullCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *HasIdCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HasId) > 0 {
		for _, e := range m.HasId {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *NestedCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *FieldCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.GeoBoundingBox != nil {
		l = m.GeoBoundingBox.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.GeoRadius != nil {
		l = m.GeoRadius.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.ValuesCount != nil {
		l = m.ValuesCount.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.GeoPolygon != nil {
		l = m.GeoPolygon.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.DatetimeRange != nil {
		l = m.DatetimeRange.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchValue != nil {
		n += m.MatchValue.Size()
	}
	return n
}

func (m *Match_Keyword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyword)
	n += 1 + l + sovPoints(uint64(l))
	return n
}
func (m *Match_Integer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPoints(uint64(m.Integer))
	return n
}
func (m *Match_Boolean) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Match_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovPoints(uint64(l))
	return n
}
func (m *Match_Keywords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Keywords != nil {
		l = m.Keywords.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Match_Integers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Integers != nil {
		l = m.Integers.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Match_ExceptIntegers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExceptIntegers != nil {
		l = m.ExceptIntegers.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *Match_ExceptKeywords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExceptKeywords != nil {
		l = m.ExceptKeywords.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *RepeatedStrings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *RepeatedIntegers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Integers) > 0 {
		l = 0
		for _, e := range m.Integers {
			l += sovPoints(uint64(e))
		}
		n += 1 + sovPoints(uint64(l)) + l
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lt != 0 {
		n += 9
	}
	if m.Gt != 0 {
		n += 9
	}
	if m.Gte != 0 {
		n += 9
	}
	if m.Lte != 0 {
		n += 9
	}
	return n
}

func (m *DatetimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lt != nil {
		l = m.Lt.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Gt != nil {
		l = m.Gt.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Gte != nil {
		l = m.Gte.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Lte != nil {
		l = m.Lte.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GeoBoundingBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopLeft != nil {
		l = m.TopLeft.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.BottomRight != nil {
		l = m.BottomRight.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GeoRadius) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Center != nil {
		l = m.Center.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	return n
}

func (m *GeoLineString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *GeoPolygon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exterior != nil {
		l = m.Exterior.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Interiors) > 0 {
		for _, e := range m.Interiors {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *ValuesCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lt != 0 {
		n += 1 + sovPoints(uint64(m.Lt))
	}
	if m.Gt != 0 {
		n += 1 + sovPoints(uint64(m.Gt))
	}
	if m.Gte != 0 {
		n += 1 + sovPoints(uint64(m.Gte))
	}
	if m.Lte != 0 {
		n += 1 + sovPoints(uint64(m.Lte))
	}
	return n
}

func (m *PointsSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PointsSelectorOneOf != nil {
		n += m.PointsSelectorOneOf.Size()
	}
	return n
}

func (m *PointsSelector_Points) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Points != nil {
		l = m.Points.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsSelector_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}
func (m *PointsIdsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovPoints(uint64(l))
		}
	}
	return n
}

func (m *PointStruct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPoints(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPoints(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPoints(uint64(mapEntrySize))
		}
	}
	if m.Vectors != nil {
		l = m.Vectors.Size()
		n += 1 + l + sovPoints(uint64(l))
	}
	return n
}

func (m *GeoPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lon != 0 {
		n += 9
	}
	if m.Lat != 0 {
		n += 9
	}
	return n
}

func sovPoints(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPoints(x uint64) (n int) {
	return sovPoints(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WriteOrdering) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteOrdering{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadConsistency) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadConsistency{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadConsistency_Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadConsistency_Type{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadConsistency_Factor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadConsistency_Factor{`,
		`Factor:` + fmt.Sprintf("%v", this.Factor) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointId{`,
		`PointIdOptions:` + fmt.Sprintf("%v", this.PointIdOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointId_Num) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointId_Num{`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointId_Uuid) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointId_Uuid{`,
		`Uuid:` + fmt.Sprintf("%v", this.Uuid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseIndices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseIndices{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vector{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`Indices:` + strings.Replace(this.Indices.String(), "SparseIndices", "SparseIndices", 1) + `,`,
		`VectorsCount:` + fmt.Sprintf("%v", this.VectorsCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenseVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenseVector{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseVector{`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`Indices:` + fmt.Sprintf("%v", this.Indices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiDenseVector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVectors := "[]*DenseVector{"
	for _, f := range this.Vectors {
		repeatedStringForVectors += strings.Replace(f.String(), "DenseVector", "DenseVector", 1) + ","
	}
	repeatedStringForVectors += "}"
	s := strings.Join([]string{`&MultiDenseVector{`,
		`Vectors:` + repeatedStringForVectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorInput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorInput{`,
		`Variant:` + fmt.Sprintf("%v", this.Variant) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorInput_Id) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorInput_Id{`,
		`Id:` + strings.Replace(fmt.Sprintf("%v", this.Id), "PointId", "PointId", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorInput_Dense) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorInput_Dense{`,
		`Dense:` + strings.Replace(fmt.Sprintf("%v", this.Dense), "DenseVector", "DenseVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorInput_Sparse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorInput_Sparse{`,
		`Sparse:` + strings.Replace(fmt.Sprintf("%v", this.Sparse), "SparseVector", "SparseVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorInput_MultiDense) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorInput_MultiDense{`,
		`MultiDense:` + strings.Replace(fmt.Sprintf("%v", this.MultiDense), "MultiDenseVector", "MultiDenseVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardKeySelector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForShardKeys := "[]*ShardKey{"
	for _, f := range this.ShardKeys {
		repeatedStringForShardKeys += strings.Replace(fmt.Sprintf("%v", f), "ShardKey", "ShardKey", 1) + ","
	}
	repeatedStringForShardKeys += "}"
	s := strings.Join([]string{`&ShardKeySelector{`,
		`ShardKeys:` + repeatedStringForShardKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpsertPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPoints := "[]*PointStruct{"
	for _, f := range this.Points {
		repeatedStringForPoints += strings.Replace(f.String(), "PointStruct", "PointStruct", 1) + ","
	}
	repeatedStringForPoints += "}"
	s := strings.Join([]string{`&UpsertPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Points:` + repeatedStringForPoints + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeletePoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeletePoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Points:` + strings.Replace(this.Points.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIds := "[]*PointId{"
	for _, f := range this.Ids {
		repeatedStringForIds += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForIds += "}"
	s := strings.Join([]string{`&GetPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Ids:` + repeatedStringForIds + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdatePointVectors) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPoints := "[]*PointVectors{"
	for _, f := range this.Points {
		repeatedStringForPoints += strings.Replace(f.String(), "PointVectors", "PointVectors", 1) + ","
	}
	repeatedStringForPoints += "}"
	s := strings.Join([]string{`&UpdatePointVectors{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Points:` + repeatedStringForPoints + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointVectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointVectors{`,
		`Id:` + strings.Replace(this.Id.String(), "PointId", "PointId", 1) + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "Vectors", "Vectors", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeletePointVectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeletePointVectors{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "VectorsSelector", "VectorsSelector", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetPayloadPoints) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&SetPayloadPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Payload:` + mapStringForPayload + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeletePayloadPoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeletePayloadPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClearPayloadPoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClearPayloadPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Points:` + strings.Replace(this.Points.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateFieldIndexCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateFieldIndexCollection{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`FieldName:` + fmt.Sprintf("%v", this.FieldName) + `,`,
		`FieldType:` + fmt.Sprintf("%v", this.FieldType) + `,`,
		`FieldIndexParams:` + strings.Replace(fmt.Sprintf("%v", this.FieldIndexParams), "PayloadIndexParams", "PayloadIndexParams", 1) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteFieldIndexCollection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteFieldIndexCollection{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`FieldName:` + fmt.Sprintf("%v", this.FieldName) + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadIncludeSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadIncludeSelector{`,
		`Fields:` + fmt.Sprintf("%v", this.Fields) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayloadExcludeSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayloadExcludeSelector{`,
		`Fields:` + fmt.Sprintf("%v", this.Fields) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithPayloadSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithPayloadSelector{`,
		`SelectorOptions:` + fmt.Sprintf("%v", this.SelectorOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithPayloadSelector_Enable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithPayloadSelector_Enable{`,
		`Enable:` + fmt.Sprintf("%v", this.Enable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithPayloadSelector_Include) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithPayloadSelector_Include{`,
		`Include:` + strings.Replace(fmt.Sprintf("%v", this.Include), "PayloadIncludeSelector", "PayloadIncludeSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithPayloadSelector_Exclude) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithPayloadSelector_Exclude{`,
		`Exclude:` + strings.Replace(fmt.Sprintf("%v", this.Exclude), "PayloadExcludeSelector", "PayloadExcludeSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamedVectors) String() string {
	if this == nil {
		return "nil"
	}
	keysForVectors := make([]string, 0, len(this.Vectors))
	for k, _ := range this.Vectors {
		keysForVectors = append(keysForVectors, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVectors)
	mapStringForVectors := "map[string]*Vector{"
	for _, k := range keysForVectors {
		mapStringForVectors += fmt.Sprintf("%v: %v,", k, this.Vectors[k])
	}
	mapStringForVectors += "}"
	s := strings.Join([]string{`&NamedVectors{`,
		`Vectors:` + mapStringForVectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vectors{`,
		`VectorsOptions:` + fmt.Sprintf("%v", this.VectorsOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vectors_Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vectors_Vector{`,
		`Vector:` + strings.Replace(fmt.Sprintf("%v", this.Vector), "Vector", "Vector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vectors_Vectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vectors_Vectors{`,
		`Vectors:` + strings.Replace(fmt.Sprintf("%v", this.Vectors), "NamedVectors", "NamedVectors", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorsSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorsSelector{`,
		`Names:` + fmt.Sprintf("%v", this.Names) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithVectorsSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithVectorsSelector{`,
		`SelectorOptions:` + fmt.Sprintf("%v", this.SelectorOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithVectorsSelector_Enable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithVectorsSelector_Enable{`,
		`Enable:` + fmt.Sprintf("%v", this.Enable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithVectorsSelector_Include) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithVectorsSelector_Include{`,
		`Include:` + strings.Replace(fmt.Sprintf("%v", this.Include), "VectorsSelector", "VectorsSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuantizationSearchParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuantizationSearchParams{`,
		`Ignore:` + fmt.Sprintf("%v", this.Ignore) + `,`,
		`Rescore:` + fmt.Sprintf("%v", this.Rescore) + `,`,
		`Oversampling:` + fmt.Sprintf("%v", this.Oversampling) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchParams{`,
		`HnswEf:` + fmt.Sprintf("%v", this.HnswEf) + `,`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`Quantization:` + strings.Replace(this.Quantization.String(), "QuantizationSearchParams", "QuantizationSearchParams", 1) + `,`,
		`IndexedOnly:` + fmt.Sprintf("%v", this.IndexedOnly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchPoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Vector:` + fmt.Sprintf("%v", this.Vector) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`VectorName:` + fmt.Sprintf("%v", this.VectorName) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`SparseIndices:` + strings.Replace(this.SparseIndices.String(), "SparseIndices", "SparseIndices", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchBatchPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSearchPoints := "[]*SearchPoints{"
	for _, f := range this.SearchPoints {
		repeatedStringForSearchPoints += strings.Replace(f.String(), "SearchPoints", "SearchPoints", 1) + ","
	}
	repeatedStringForSearchPoints += "}"
	s := strings.Join([]string{`&SearchBatchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`SearchPoints:` + repeatedStringForSearchPoints + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WithLookup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WithLookup{`,
		`Collection:` + fmt.Sprintf("%v", this.Collection) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchPointGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchPointGroups{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Vector:` + fmt.Sprintf("%v", this.Vector) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`VectorName:` + fmt.Sprintf("%v", this.VectorName) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`GroupSize:` + fmt.Sprintf("%v", this.GroupSize) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`WithLookup:` + strings.Replace(this.WithLookup.String(), "WithLookup", "WithLookup", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`SparseIndices:` + strings.Replace(this.SparseIndices.String(), "SparseIndices", "SparseIndices", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartFrom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartFrom{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartFrom_Float) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartFrom_Float{`,
		`Float:` + fmt.Sprintf("%v", this.Float) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartFrom_Integer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartFrom_Integer{`,
		`Integer:` + fmt.Sprintf("%v", this.Integer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartFrom_Timestamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartFrom_Timestamp{`,
		`Timestamp:` + strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartFrom_Datetime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartFrom_Datetime{`,
		`Datetime:` + fmt.Sprintf("%v", this.Datetime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderBy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderBy{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`StartFrom:` + strings.Replace(this.StartFrom.String(), "StartFrom", "StartFrom", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScrollPoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScrollPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Offset:` + strings.Replace(this.Offset.String(), "PointId", "PointId", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`OrderBy:` + strings.Replace(this.OrderBy.String(), "OrderBy", "OrderBy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookupLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupLocation{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`VectorName:` + fmt.Sprintf("%v", this.VectorName) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPositive := "[]*PointId{"
	for _, f := range this.Positive {
		repeatedStringForPositive += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForPositive += "}"
	repeatedStringForNegative := "[]*PointId{"
	for _, f := range this.Negative {
		repeatedStringForNegative += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForNegative += "}"
	repeatedStringForPositiveVectors := "[]*Vector{"
	for _, f := range this.PositiveVectors {
		repeatedStringForPositiveVectors += strings.Replace(f.String(), "Vector", "Vector", 1) + ","
	}
	repeatedStringForPositiveVectors += "}"
	repeatedStringForNegativeVectors := "[]*Vector{"
	for _, f := range this.NegativeVectors {
		repeatedStringForNegativeVectors += strings.Replace(f.String(), "Vector", "Vector", 1) + ","
	}
	repeatedStringForNegativeVectors += "}"
	s := strings.Join([]string{`&RecommendPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Positive:` + repeatedStringForPositive + `,`,
		`Negative:` + repeatedStringForNegative + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Using:` + fmt.Sprintf("%v", this.Using) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`LookupFrom:` + strings.Replace(this.LookupFrom.String(), "LookupLocation", "LookupLocation", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Strategy:` + fmt.Sprintf("%v", this.Strategy) + `,`,
		`PositiveVectors:` + repeatedStringForPositiveVectors + `,`,
		`NegativeVectors:` + repeatedStringForNegativeVectors + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendBatchPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRecommendPoints := "[]*RecommendPoints{"
	for _, f := range this.RecommendPoints {
		repeatedStringForRecommendPoints += strings.Replace(f.String(), "RecommendPoints", "RecommendPoints", 1) + ","
	}
	repeatedStringForRecommendPoints += "}"
	s := strings.Join([]string{`&RecommendBatchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`RecommendPoints:` + repeatedStringForRecommendPoints + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendPointGroups) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPositive := "[]*PointId{"
	for _, f := range this.Positive {
		repeatedStringForPositive += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForPositive += "}"
	repeatedStringForNegative := "[]*PointId{"
	for _, f := range this.Negative {
		repeatedStringForNegative += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForNegative += "}"
	repeatedStringForPositiveVectors := "[]*Vector{"
	for _, f := range this.PositiveVectors {
		repeatedStringForPositiveVectors += strings.Replace(f.String(), "Vector", "Vector", 1) + ","
	}
	repeatedStringForPositiveVectors += "}"
	repeatedStringForNegativeVectors := "[]*Vector{"
	for _, f := range this.NegativeVectors {
		repeatedStringForNegativeVectors += strings.Replace(f.String(), "Vector", "Vector", 1) + ","
	}
	repeatedStringForNegativeVectors += "}"
	s := strings.Join([]string{`&RecommendPointGroups{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Positive:` + repeatedStringForPositive + `,`,
		`Negative:` + repeatedStringForNegative + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`Using:` + fmt.Sprintf("%v", this.Using) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`LookupFrom:` + strings.Replace(this.LookupFrom.String(), "LookupLocation", "LookupLocation", 1) + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`GroupSize:` + fmt.Sprintf("%v", this.GroupSize) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`WithLookup:` + strings.Replace(this.WithLookup.String(), "WithLookup", "WithLookup", 1) + `,`,
		`Strategy:` + fmt.Sprintf("%v", this.Strategy) + `,`,
		`PositiveVectors:` + repeatedStringForPositiveVectors + `,`,
		`NegativeVectors:` + repeatedStringForNegativeVectors + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TargetVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TargetVector{`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TargetVector_Single) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TargetVector_Single{`,
		`Single:` + strings.Replace(fmt.Sprintf("%v", this.Single), "VectorExample", "VectorExample", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorExample) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorExample{`,
		`Example:` + fmt.Sprintf("%v", this.Example) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorExample_Id) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorExample_Id{`,
		`Id:` + strings.Replace(fmt.Sprintf("%v", this.Id), "PointId", "PointId", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VectorExample_Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VectorExample_Vector{`,
		`Vector:` + strings.Replace(fmt.Sprintf("%v", this.Vector), "Vector", "Vector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContextExamplePair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContextExamplePair{`,
		`Positive:` + strings.Replace(this.Positive.String(), "VectorExample", "VectorExample", 1) + `,`,
		`Negative:` + strings.Replace(this.Negative.String(), "VectorExample", "VectorExample", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoverPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContext := "[]*ContextExamplePair{"
	for _, f := range this.Context {
		repeatedStringForContext += strings.Replace(f.String(), "ContextExamplePair", "ContextExamplePair", 1) + ","
	}
	repeatedStringForContext += "}"
	s := strings.Join([]string{`&DiscoverPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Target:` + strings.Replace(this.Target.String(), "TargetVector", "TargetVector", 1) + `,`,
		`Context:` + repeatedStringForContext + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Using:` + fmt.Sprintf("%v", this.Using) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`LookupFrom:` + strings.Replace(this.LookupFrom.String(), "LookupLocation", "LookupLocation", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoverBatchPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDiscoverPoints := "[]*DiscoverPoints{"
	for _, f := range this.DiscoverPoints {
		repeatedStringForDiscoverPoints += strings.Replace(f.String(), "DiscoverPoints", "DiscoverPoints", 1) + ","
	}
	repeatedStringForDiscoverPoints += "}"
	s := strings.Join([]string{`&DiscoverBatchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`DiscoverPoints:` + repeatedStringForDiscoverPoints + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CountPoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CountPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendInput) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPositive := "[]*VectorInput{"
	for _, f := range this.Positive {
		repeatedStringForPositive += strings.Replace(f.String(), "VectorInput", "VectorInput", 1) + ","
	}
	repeatedStringForPositive += "}"
	repeatedStringForNegative := "[]*VectorInput{"
	for _, f := range this.Negative {
		repeatedStringForNegative += strings.Replace(f.String(), "VectorInput", "VectorInput", 1) + ","
	}
	repeatedStringForNegative += "}"
	s := strings.Join([]string{`&RecommendInput{`,
		`Positive:` + repeatedStringForPositive + `,`,
		`Negative:` + repeatedStringForNegative + `,`,
		`Strategy:` + fmt.Sprintf("%v", this.Strategy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContextInputPair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContextInputPair{`,
		`Positive:` + strings.Replace(this.Positive.String(), "VectorInput", "VectorInput", 1) + `,`,
		`Negative:` + strings.Replace(this.Negative.String(), "VectorInput", "VectorInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoverInput) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoverInput{`,
		`Target:` + strings.Replace(this.Target.String(), "VectorInput", "VectorInput", 1) + `,`,
		`Context:` + strings.Replace(this.Context.String(), "ContextInput", "ContextInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContextInput) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPairs := "[]*ContextInputPair{"
	for _, f := range this.Pairs {
		repeatedStringForPairs += strings.Replace(f.String(), "ContextInputPair", "ContextInputPair", 1) + ","
	}
	repeatedStringForPairs += "}"
	s := strings.Join([]string{`&ContextInput{`,
		`Pairs:` + repeatedStringForPairs + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query{`,
		`Variant:` + fmt.Sprintf("%v", this.Variant) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_Nearest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_Nearest{`,
		`Nearest:` + strings.Replace(fmt.Sprintf("%v", this.Nearest), "VectorInput", "VectorInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_Recommend) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_Recommend{`,
		`Recommend:` + strings.Replace(fmt.Sprintf("%v", this.Recommend), "RecommendInput", "RecommendInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_Discover) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_Discover{`,
		`Discover:` + strings.Replace(fmt.Sprintf("%v", this.Discover), "DiscoverInput", "DiscoverInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_Context) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_Context{`,
		`Context:` + strings.Replace(fmt.Sprintf("%v", this.Context), "ContextInput", "ContextInput", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_OrderBy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_OrderBy{`,
		`OrderBy:` + strings.Replace(fmt.Sprintf("%v", this.OrderBy), "OrderBy", "OrderBy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Query_Fusion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Query_Fusion{`,
		`Fusion:` + fmt.Sprintf("%v", this.Fusion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrefetchQuery) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrefetch := "[]*PrefetchQuery{"
	for _, f := range this.Prefetch {
		repeatedStringForPrefetch += strings.Replace(f.String(), "PrefetchQuery", "PrefetchQuery", 1) + ","
	}
	repeatedStringForPrefetch += "}"
	s := strings.Join([]string{`&PrefetchQuery{`,
		`Prefetch:` + repeatedStringForPrefetch + `,`,
		`Query:` + strings.Replace(this.Query.String(), "Query", "Query", 1) + `,`,
		`Using:` + fmt.Sprintf("%v", this.Using) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`LookupFrom:` + strings.Replace(this.LookupFrom.String(), "LookupLocation", "LookupLocation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPrefetch := "[]*PrefetchQuery{"
	for _, f := range this.Prefetch {
		repeatedStringForPrefetch += strings.Replace(f.String(), "PrefetchQuery", "PrefetchQuery", 1) + ","
	}
	repeatedStringForPrefetch += "}"
	s := strings.Join([]string{`&QueryPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Prefetch:` + repeatedStringForPrefetch + `,`,
		`Query:` + strings.Replace(this.Query.String(), "Query", "Query", 1) + `,`,
		`Using:` + fmt.Sprintf("%v", this.Using) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "SearchParams", "SearchParams", 1) + `,`,
		`ScoreThreshold:` + fmt.Sprintf("%v", this.ScoreThreshold) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`WithVectors:` + strings.Replace(this.WithVectors.String(), "WithVectorsSelector", "WithVectorsSelector", 1) + `,`,
		`WithPayload:` + strings.Replace(this.WithPayload.String(), "WithPayloadSelector", "WithPayloadSelector", 1) + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`LookupFrom:` + strings.Replace(this.LookupFrom.String(), "LookupLocation", "LookupLocation", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryBatchPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQueryPoints := "[]*QueryPoints{"
	for _, f := range this.QueryPoints {
		repeatedStringForQueryPoints += strings.Replace(f.String(), "QueryPoints", "QueryPoints", 1) + ","
	}
	repeatedStringForQueryPoints += "}"
	s := strings.Join([]string{`&QueryBatchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`QueryPoints:` + repeatedStringForQueryPoints + `,`,
		`ReadConsistency:` + strings.Replace(this.ReadConsistency.String(), "ReadConsistency", "ReadConsistency", 1) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation{`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_Upsert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_Upsert{`,
		`Upsert:` + strings.Replace(fmt.Sprintf("%v", this.Upsert), "PointsUpdateOperation_PointStructList", "PointsUpdateOperation_PointStructList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeleteDeprecated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeleteDeprecated{`,
		`DeleteDeprecated:` + strings.Replace(fmt.Sprintf("%v", this.DeleteDeprecated), "PointsSelector", "PointsSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_SetPayload_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_SetPayload_{`,
		`SetPayload:` + strings.Replace(fmt.Sprintf("%v", this.SetPayload), "PointsUpdateOperation_SetPayload", "PointsUpdateOperation_SetPayload", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_OverwritePayload_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_OverwritePayload_{`,
		`OverwritePayload:` + strings.Replace(fmt.Sprintf("%v", this.OverwritePayload), "PointsUpdateOperation_OverwritePayload", "PointsUpdateOperation_OverwritePayload", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeletePayload_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeletePayload_{`,
		`DeletePayload:` + strings.Replace(fmt.Sprintf("%v", this.DeletePayload), "PointsUpdateOperation_DeletePayload", "PointsUpdateOperation_DeletePayload", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_ClearPayloadDeprecated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_ClearPayloadDeprecated{`,
		`ClearPayloadDeprecated:` + strings.Replace(fmt.Sprintf("%v", this.ClearPayloadDeprecated), "PointsSelector", "PointsSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_UpdateVectors_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_UpdateVectors_{`,
		`UpdateVectors:` + strings.Replace(fmt.Sprintf("%v", this.UpdateVectors), "PointsUpdateOperation_UpdateVectors", "PointsUpdateOperation_UpdateVectors", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeleteVectors_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeleteVectors_{`,
		`DeleteVectors:` + strings.Replace(fmt.Sprintf("%v", this.DeleteVectors), "PointsUpdateOperation_DeleteVectors", "PointsUpdateOperation_DeleteVectors", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeletePoints_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeletePoints_{`,
		`DeletePoints:` + strings.Replace(fmt.Sprintf("%v", this.DeletePoints), "PointsUpdateOperation_DeletePoints", "PointsUpdateOperation_DeletePoints", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_ClearPayload_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_ClearPayload_{`,
		`ClearPayload:` + strings.Replace(fmt.Sprintf("%v", this.ClearPayload), "PointsUpdateOperation_ClearPayload", "PointsUpdateOperation_ClearPayload", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_PointStructList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPoints := "[]*PointStruct{"
	for _, f := range this.Points {
		repeatedStringForPoints += strings.Replace(f.String(), "PointStruct", "PointStruct", 1) + ","
	}
	repeatedStringForPoints += "}"
	s := strings.Join([]string{`&PointsUpdateOperation_PointStructList{`,
		`Points:` + repeatedStringForPoints + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_SetPayload) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&PointsUpdateOperation_SetPayload{`,
		`Payload:` + mapStringForPayload + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_OverwritePayload) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&PointsUpdateOperation_OverwritePayload{`,
		`Payload:` + mapStringForPayload + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeletePayload) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeletePayload{`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_UpdateVectors) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPoints := "[]*PointVectors{"
	for _, f := range this.Points {
		repeatedStringForPoints += strings.Replace(f.String(), "PointVectors", "PointVectors", 1) + ","
	}
	repeatedStringForPoints += "}"
	s := strings.Join([]string{`&PointsUpdateOperation_UpdateVectors{`,
		`Points:` + repeatedStringForPoints + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeleteVectors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeleteVectors{`,
		`PointsSelector:` + strings.Replace(this.PointsSelector.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "VectorsSelector", "VectorsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_DeletePoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_DeletePoints{`,
		`Points:` + strings.Replace(this.Points.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsUpdateOperation_ClearPayload) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsUpdateOperation_ClearPayload{`,
		`Points:` + strings.Replace(this.Points.String(), "PointsSelector", "PointsSelector", 1) + `,`,
		`ShardKeySelector:` + strings.Replace(this.ShardKeySelector.String(), "ShardKeySelector", "ShardKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateBatchPoints) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOperations := "[]*PointsUpdateOperation{"
	for _, f := range this.Operations {
		repeatedStringForOperations += strings.Replace(f.String(), "PointsUpdateOperation", "PointsUpdateOperation", 1) + ","
	}
	repeatedStringForOperations += "}"
	s := strings.Join([]string{`&UpdateBatchPoints{`,
		`CollectionName:` + fmt.Sprintf("%v", this.CollectionName) + `,`,
		`Wait:` + fmt.Sprintf("%v", this.Wait) + `,`,
		`Operations:` + repeatedStringForOperations + `,`,
		`Ordering:` + strings.Replace(this.Ordering.String(), "WriteOrdering", "WriteOrdering", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsOperationResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsOperationResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "UpdateResult", "UpdateResult", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateResult{`,
		`OperationId:` + fmt.Sprintf("%v", this.OperationId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderValue{`,
		`Variant:` + fmt.Sprintf("%v", this.Variant) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderValue_Int) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderValue_Int{`,
		`Int:` + fmt.Sprintf("%v", this.Int) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderValue_Float) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderValue_Float{`,
		`Float:` + fmt.Sprintf("%v", this.Float) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScoredPoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&ScoredPoint{`,
		`Id:` + strings.Replace(this.Id.String(), "PointId", "PointId", 1) + `,`,
		`Payload:` + mapStringForPayload + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "Vectors", "Vectors", 1) + `,`,
		`ShardKey:` + strings.Replace(fmt.Sprintf("%v", this.ShardKey), "ShardKey", "ShardKey", 1) + `,`,
		`OrderValue:` + strings.Replace(this.OrderValue.String(), "OrderValue", "OrderValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupId{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupId_UnsignedValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupId_UnsignedValue{`,
		`UnsignedValue:` + fmt.Sprintf("%v", this.UnsignedValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupId_IntegerValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupId_IntegerValue{`,
		`IntegerValue:` + fmt.Sprintf("%v", this.IntegerValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupId_StringValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupId_StringValue{`,
		`StringValue:` + fmt.Sprintf("%v", this.StringValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHits := "[]*ScoredPoint{"
	for _, f := range this.Hits {
		repeatedStringForHits += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForHits += "}"
	s := strings.Join([]string{`&PointGroup{`,
		`Id:` + strings.Replace(this.Id.String(), "GroupId", "GroupId", 1) + `,`,
		`Hits:` + repeatedStringForHits + `,`,
		`Lookup:` + strings.Replace(this.Lookup.String(), "RetrievedPoint", "RetrievedPoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupsResult) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroups := "[]*PointGroup{"
	for _, f := range this.Groups {
		repeatedStringForGroups += strings.Replace(f.String(), "PointGroup", "PointGroup", 1) + ","
	}
	repeatedStringForGroups += "}"
	s := strings.Join([]string{`&GroupsResult{`,
		`Groups:` + repeatedStringForGroups + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*ScoredPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&SearchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*ScoredPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&QueryResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*BatchResult{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "BatchResult", "BatchResult", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&QueryBatchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BatchResult) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*ScoredPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&BatchResult{`,
		`Result:` + repeatedStringForResult + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*BatchResult{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "BatchResult", "BatchResult", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&SearchBatchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchGroupsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchGroupsResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "GroupsResult", "GroupsResult", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CountResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CountResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "CountResult", "CountResult", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScrollResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*RetrievedPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "RetrievedPoint", "RetrievedPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&ScrollResponse{`,
		`NextPageOffset:` + strings.Replace(this.NextPageOffset.String(), "PointId", "PointId", 1) + `,`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CountResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CountResult{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetrievedPoint) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&RetrievedPoint{`,
		`Id:` + strings.Replace(this.Id.String(), "PointId", "PointId", 1) + `,`,
		`Payload:` + mapStringForPayload + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "Vectors", "Vectors", 1) + `,`,
		`ShardKey:` + strings.Replace(fmt.Sprintf("%v", this.ShardKey), "ShardKey", "ShardKey", 1) + `,`,
		`OrderValue:` + strings.Replace(this.OrderValue.String(), "OrderValue", "OrderValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*RetrievedPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "RetrievedPoint", "RetrievedPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&GetResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*ScoredPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&RecommendResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*BatchResult{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "BatchResult", "BatchResult", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&RecommendBatchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoverResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*ScoredPoint{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "ScoredPoint", "ScoredPoint", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&DiscoverResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoverBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*BatchResult{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "BatchResult", "BatchResult", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&DiscoverBatchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecommendGroupsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecommendGroupsResponse{`,
		`Result:` + strings.Replace(this.Result.String(), "GroupsResult", "GroupsResult", 1) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResult := "[]*UpdateResult{"
	for _, f := range this.Result {
		repeatedStringForResult += strings.Replace(f.String(), "UpdateResult", "UpdateResult", 1) + ","
	}
	repeatedStringForResult += "}"
	s := strings.Join([]string{`&UpdateBatchResponse{`,
		`Result:` + repeatedStringForResult + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForShould := "[]*Condition{"
	for _, f := range this.Should {
		repeatedStringForShould += strings.Replace(f.String(), "Condition", "Condition", 1) + ","
	}
	repeatedStringForShould += "}"
	repeatedStringForMust := "[]*Condition{"
	for _, f := range this.Must {
		repeatedStringForMust += strings.Replace(f.String(), "Condition", "Condition", 1) + ","
	}
	repeatedStringForMust += "}"
	repeatedStringForMustNot := "[]*Condition{"
	for _, f := range this.MustNot {
		repeatedStringForMustNot += strings.Replace(f.String(), "Condition", "Condition", 1) + ","
	}
	repeatedStringForMustNot += "}"
	s := strings.Join([]string{`&Filter{`,
		`Should:` + repeatedStringForShould + `,`,
		`Must:` + repeatedStringForMust + `,`,
		`MustNot:` + repeatedStringForMustNot + `,`,
		`MinShould:` + strings.Replace(this.MinShould.String(), "MinShould", "MinShould", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MinShould) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConditions := "[]*Condition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(f.String(), "Condition", "Condition", 1) + ","
	}
	repeatedStringForConditions += "}"
	s := strings.Join([]string{`&MinShould{`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`MinCount:` + fmt.Sprintf("%v", this.MinCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition{`,
		`ConditionOneOf:` + fmt.Sprintf("%v", this.ConditionOneOf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_Field) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_Field{`,
		`Field:` + strings.Replace(fmt.Sprintf("%v", this.Field), "FieldCondition", "FieldCondition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_IsEmpty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_IsEmpty{`,
		`IsEmpty:` + strings.Replace(fmt.Sprintf("%v", this.IsEmpty), "IsEmptyCondition", "IsEmptyCondition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_HasId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_HasId{`,
		`HasId:` + strings.Replace(fmt.Sprintf("%v", this.HasId), "HasIdCondition", "HasIdCondition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_Filter{`,
		`Filter:` + strings.Replace(fmt.Sprintf("%v", this.Filter), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_IsNull) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_IsNull{`,
		`IsNull:` + strings.Replace(fmt.Sprintf("%v", this.IsNull), "IsNullCondition", "IsNullCondition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Condition_Nested) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Condition_Nested{`,
		`Nested:` + strings.Replace(fmt.Sprintf("%v", this.Nested), "NestedCondition", "NestedCondition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IsEmptyCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IsEmptyCondition{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IsNullCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IsNullCondition{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HasIdCondition) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHasId := "[]*PointId{"
	for _, f := range this.HasId {
		repeatedStringForHasId += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForHasId += "}"
	s := strings.Join([]string{`&HasIdCondition{`,
		`HasId:` + repeatedStringForHasId + `,`,
		`}`,
	}, "")
	return s
}
func (this *NestedCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NestedCondition{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldCondition{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Match:` + strings.Replace(this.Match.String(), "Match", "Match", 1) + `,`,
		`Range:` + strings.Replace(this.Range.String(), "Range", "Range", 1) + `,`,
		`GeoBoundingBox:` + strings.Replace(this.GeoBoundingBox.String(), "GeoBoundingBox", "GeoBoundingBox", 1) + `,`,
		`GeoRadius:` + strings.Replace(this.GeoRadius.String(), "GeoRadius", "GeoRadius", 1) + `,`,
		`ValuesCount:` + strings.Replace(this.ValuesCount.String(), "ValuesCount", "ValuesCount", 1) + `,`,
		`GeoPolygon:` + strings.Replace(this.GeoPolygon.String(), "GeoPolygon", "GeoPolygon", 1) + `,`,
		`DatetimeRange:` + strings.Replace(this.DatetimeRange.String(), "DatetimeRange", "DatetimeRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match{`,
		`MatchValue:` + fmt.Sprintf("%v", this.MatchValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Keyword) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Keyword{`,
		`Keyword:` + fmt.Sprintf("%v", this.Keyword) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Integer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Integer{`,
		`Integer:` + fmt.Sprintf("%v", this.Integer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Boolean) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Boolean{`,
		`Boolean:` + fmt.Sprintf("%v", this.Boolean) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Text) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Text{`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Keywords) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Keywords{`,
		`Keywords:` + strings.Replace(fmt.Sprintf("%v", this.Keywords), "RepeatedStrings", "RepeatedStrings", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_Integers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_Integers{`,
		`Integers:` + strings.Replace(fmt.Sprintf("%v", this.Integers), "RepeatedIntegers", "RepeatedIntegers", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_ExceptIntegers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_ExceptIntegers{`,
		`ExceptIntegers:` + strings.Replace(fmt.Sprintf("%v", this.ExceptIntegers), "RepeatedIntegers", "RepeatedIntegers", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Match_ExceptKeywords) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Match_ExceptKeywords{`,
		`ExceptKeywords:` + strings.Replace(fmt.Sprintf("%v", this.ExceptKeywords), "RepeatedStrings", "RepeatedStrings", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepeatedStrings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepeatedStrings{`,
		`Strings:` + fmt.Sprintf("%v", this.Strings) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepeatedIntegers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepeatedIntegers{`,
		`Integers:` + fmt.Sprintf("%v", this.Integers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Range{`,
		`Lt:` + fmt.Sprintf("%v", this.Lt) + `,`,
		`Gt:` + fmt.Sprintf("%v", this.Gt) + `,`,
		`Gte:` + fmt.Sprintf("%v", this.Gte) + `,`,
		`Lte:` + fmt.Sprintf("%v", this.Lte) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DatetimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DatetimeRange{`,
		`Lt:` + strings.Replace(fmt.Sprintf("%v", this.Lt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Gt:` + strings.Replace(fmt.Sprintf("%v", this.Gt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Gte:` + strings.Replace(fmt.Sprintf("%v", this.Gte), "Timestamp", "types.Timestamp", 1) + `,`,
		`Lte:` + strings.Replace(fmt.Sprintf("%v", this.Lte), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoBoundingBox) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoBoundingBox{`,
		`TopLeft:` + strings.Replace(this.TopLeft.String(), "GeoPoint", "GeoPoint", 1) + `,`,
		`BottomRight:` + strings.Replace(this.BottomRight.String(), "GeoPoint", "GeoPoint", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoRadius) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoRadius{`,
		`Center:` + strings.Replace(this.Center.String(), "GeoPoint", "GeoPoint", 1) + `,`,
		`Radius:` + fmt.Sprintf("%v", this.Radius) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoLineString) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPoints := "[]*GeoPoint{"
	for _, f := range this.Points {
		repeatedStringForPoints += strings.Replace(f.String(), "GeoPoint", "GeoPoint", 1) + ","
	}
	repeatedStringForPoints += "}"
	s := strings.Join([]string{`&GeoLineString{`,
		`Points:` + repeatedStringForPoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoPolygon) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInteriors := "[]*GeoLineString{"
	for _, f := range this.Interiors {
		repeatedStringForInteriors += strings.Replace(f.String(), "GeoLineString", "GeoLineString", 1) + ","
	}
	repeatedStringForInteriors += "}"
	s := strings.Join([]string{`&GeoPolygon{`,
		`Exterior:` + strings.Replace(this.Exterior.String(), "GeoLineString", "GeoLineString", 1) + `,`,
		`Interiors:` + repeatedStringForInteriors + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValuesCount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValuesCount{`,
		`Lt:` + fmt.Sprintf("%v", this.Lt) + `,`,
		`Gt:` + fmt.Sprintf("%v", this.Gt) + `,`,
		`Gte:` + fmt.Sprintf("%v", this.Gte) + `,`,
		`Lte:` + fmt.Sprintf("%v", this.Lte) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsSelector{`,
		`PointsSelectorOneOf:` + fmt.Sprintf("%v", this.PointsSelectorOneOf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsSelector_Points) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsSelector_Points{`,
		`Points:` + strings.Replace(fmt.Sprintf("%v", this.Points), "PointsIdsList", "PointsIdsList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsSelector_Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PointsSelector_Filter{`,
		`Filter:` + strings.Replace(fmt.Sprintf("%v", this.Filter), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointsIdsList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIds := "[]*PointId{"
	for _, f := range this.Ids {
		repeatedStringForIds += strings.Replace(f.String(), "PointId", "PointId", 1) + ","
	}
	repeatedStringForIds += "}"
	s := strings.Join([]string{`&PointsIdsList{`,
		`Ids:` + repeatedStringForIds + `,`,
		`}`,
	}, "")
	return s
}
func (this *PointStruct) String() string {
	if this == nil {
		return "nil"
	}
	keysForPayload := make([]string, 0, len(this.Payload))
	for k, _ := range this.Payload {
		keysForPayload = append(keysForPayload, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPayload)
	mapStringForPayload := "map[string]*Value{"
	for _, k := range keysForPayload {
		mapStringForPayload += fmt.Sprintf("%v: %v,", k, this.Payload[k])
	}
	mapStringForPayload += "}"
	s := strings.Join([]string{`&PointStruct{`,
		`Id:` + strings.Replace(this.Id.String(), "PointId", "PointId", 1) + `,`,
		`Payload:` + mapStringForPayload + `,`,
		`Vectors:` + strings.Replace(this.Vectors.String(), "Vectors", "Vectors", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoPoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoPoint{`,
		`Lon:` + fmt.Sprintf("%v", this.Lon) + `,`,
		`Lat:` + fmt.Sprintf("%v", this.Lat) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPoints(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WriteOrdering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteOrdering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteOrdering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WriteOrderingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadConsistency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadConsistency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadConsistency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ReadConsistencyType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ReadConsistencyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &ReadConsistency_Type{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &ReadConsistency_Factor{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PointIdOptions = &PointId_Num{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PointIdOptions = &PointId_Uuid{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseIndices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseIndices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseIndices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Data = append(m.Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Data) == 0 {
					m.Data = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Data = append(m.Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Data = append(m.Data, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Data) == 0 {
					m.Data = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Data = append(m.Data, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Indices == nil {
				m.Indices = &SparseIndices{}
			}
			if err := m.Indices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorsCount", wireType)
			}
			m.VectorsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorsCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Data = append(m.Data, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Data) == 0 {
					m.Data = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Data = append(m.Data, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiDenseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiDenseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiDenseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vectors = append(m.Vectors, &DenseVector{})
			if err := m.Vectors[len(m.Vectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &VectorInput_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dense", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DenseVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &VectorInput_Dense{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sparse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &VectorInput_Sparse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiDense", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultiDenseVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &VectorInput_MultiDense{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardKeySelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardKeySelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardKeySelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardKeys = append(m.ShardKeys, &ShardKey{})
			if err := m.ShardKeys[len(m.ShardKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &PointStruct{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Points == nil {
				m.Points = &PointsSelector{}
			}
			if err := m.Points.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &PointId{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePointVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePointVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePointVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &PointVectors{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &PointId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &Vectors{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePointVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePointVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePointVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &VectorsSelector{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetPayloadPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetPayloadPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetPayloadPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePayloadPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePayloadPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePayloadPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearPayloadPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearPayloadPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearPayloadPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Points == nil {
				m.Points = &PointsSelector{}
			}
			if err := m.Points.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFieldIndexCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFieldIndexCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFieldIndexCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldType", wireType)
			}
			m.FieldType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldType |= FieldType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldIndexParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldIndexParams == nil {
				m.FieldIndexParams = &PayloadIndexParams{}
			}
			if err := m.FieldIndexParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFieldIndexCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFieldIndexCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFieldIndexCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadIncludeSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadIncludeSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadIncludeSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadExcludeSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadExcludeSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadExcludeSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithPayloadSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithPayloadSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithPayloadSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SelectorOptions = &WithPayloadSelector_Enable{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PayloadIncludeSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SelectorOptions = &WithPayloadSelector_Include{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PayloadExcludeSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SelectorOptions = &WithPayloadSelector_Exclude{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = make(map[string]*Vector)
			}
			var mapkey string
			var mapvalue *Vector
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Vector{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Vectors[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VectorsOptions = &Vectors_Vector{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NamedVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VectorsOptions = &Vectors_Vectors{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorsSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorsSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorsSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithVectorsSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithVectorsSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithVectorsSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SelectorOptions = &WithVectorsSelector_Enable{b}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorsSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SelectorOptions = &WithVectorsSelector_Include{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuantizationSearchParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuantizationSearchParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuantizationSearchParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ignore = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rescore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rescore = bool(v != 0)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oversampling", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Oversampling = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswEf", wireType)
			}
			m.HnswEf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HnswEf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exact = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quantization == nil {
				m.Quantization = &QuantizationSearchParams{}
			}
			if err := m.Quantization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexedOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Vector = append(m.Vector, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Vector) == 0 {
					m.Vector = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Vector = append(m.Vector, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseIndices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparseIndices == nil {
				m.SparseIndices = &SparseIndices{}
			}
			if err := m.SparseIndices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBatchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBatchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBatchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchPoints = append(m.SearchPoints, &SearchPoints{})
			if err := m.SearchPoints[len(m.SearchPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithLookup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithLookup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithLookup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchPointGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchPointGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchPointGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Vector = append(m.Vector, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Vector) == 0 {
					m.Vector = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Vector = append(m.Vector, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithLookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithLookup == nil {
				m.WithLookup = &WithLookup{}
			}
			if err := m.WithLookup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseIndices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SparseIndices == nil {
				m.SparseIndices = &SparseIndices{}
			}
			if err := m.SparseIndices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &StartFrom_Float{float64(math.Float64frombits(v))}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integer", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &StartFrom_Integer{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &StartFrom_Timestamp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datetime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &StartFrom_Datetime{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartFrom == nil {
				m.StartFrom = &StartFrom{}
			}
			if err := m.StartFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScrollPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScrollPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScrollPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &PointId{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderBy == nil {
				m.OrderBy = &OrderBy{}
			}
			if err := m.OrderBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positive = append(m.Positive, &PointId{})
			if err := m.Positive[len(m.Positive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Negative = append(m.Negative, &PointId{})
			if err := m.Negative[len(m.Negative)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Using", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Using = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupFrom == nil {
				m.LookupFrom = &LookupLocation{}
			}
			if err := m.LookupFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= RecommendStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositiveVectors = append(m.PositiveVectors, &Vector{})
			if err := m.PositiveVectors[len(m.PositiveVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeVectors = append(m.NegativeVectors, &Vector{})
			if err := m.NegativeVectors[len(m.NegativeVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendBatchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendBatchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendBatchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecommendPoints = append(m.RecommendPoints, &RecommendPoints{})
			if err := m.RecommendPoints[len(m.RecommendPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendPointGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendPointGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendPointGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positive = append(m.Positive, &PointId{})
			if err := m.Positive[len(m.Positive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Negative = append(m.Negative, &PointId{})
			if err := m.Negative[len(m.Negative)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Using", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Using = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupFrom == nil {
				m.LookupFrom = &LookupLocation{}
			}
			if err := m.LookupFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithLookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithLookup == nil {
				m.WithLookup = &WithLookup{}
			}
			if err := m.WithLookup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= RecommendStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositiveVectors = append(m.PositiveVectors, &Vector{})
			if err := m.PositiveVectors[len(m.PositiveVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeVectors = append(m.NegativeVectors, &Vector{})
			if err := m.NegativeVectors[len(m.NegativeVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Single", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorExample{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &TargetVector_Single{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorExample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VectorExample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VectorExample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Example = &VectorExample_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Example = &VectorExample_Vector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextExamplePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextExamplePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextExamplePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Positive == nil {
				m.Positive = &VectorExample{}
			}
			if err := m.Positive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Negative == nil {
				m.Negative = &VectorExample{}
			}
			if err := m.Negative.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &TargetVector{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, &ContextExamplePair{})
			if err := m.Context[len(m.Context)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Using", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Using = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupFrom == nil {
				m.LookupFrom = &LookupLocation{}
			}
			if err := m.LookupFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverBatchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverBatchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverBatchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscoverPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscoverPoints = append(m.DiscoverPoints, &DiscoverPoints{})
			if err := m.DiscoverPoints[len(m.DiscoverPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exact = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positive = append(m.Positive, &VectorInput{})
			if err := m.Positive[len(m.Positive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Negative = append(m.Negative, &VectorInput{})
			if err := m.Negative[len(m.Negative)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= RecommendStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextInputPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextInputPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextInputPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Positive == nil {
				m.Positive = &VectorInput{}
			}
			if err := m.Positive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Negative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Negative == nil {
				m.Negative = &VectorInput{}
			}
			if err := m.Negative.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VectorInput{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &ContextInput{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &ContextInputPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nearest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VectorInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &Query_Nearest{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecommendInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &Query_Recommend{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discover", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DiscoverInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &Query_Discover{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContextInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &Query_Context{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderBy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Variant = &Query_OrderBy{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fusion", wireType)
			}
			var v Fusion
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Fusion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Variant = &Query_Fusion{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrefetchQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrefetchQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrefetchQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefetch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefetch = append(m.Prefetch, &PrefetchQuery{})
			if err := m.Prefetch[len(m.Prefetch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Using", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Using = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupFrom == nil {
				m.LookupFrom = &LookupLocation{}
			}
			if err := m.LookupFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefetch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefetch = append(m.Prefetch, &PrefetchQuery{})
			if err := m.Prefetch[len(m.Prefetch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Using", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Using = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &SearchParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ScoreThreshold = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithVectors == nil {
				m.WithVectors = &WithVectorsSelector{}
			}
			if err := m.WithVectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WithPayload == nil {
				m.WithPayload = &WithPayloadSelector{}
			}
			if err := m.WithPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupFrom == nil {
				m.LookupFrom = &LookupLocation{}
			}
			if err := m.LookupFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBatchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBatchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBatchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryPoints = append(m.QueryPoints, &QueryPoints{})
			if err := m.QueryPoints[len(m.QueryPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadConsistency == nil {
				m.ReadConsistency = &ReadConsistency{}
			}
			if err := m.ReadConsistency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsUpdateOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsUpdateOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_PointStructList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_Upsert{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteDeprecated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_DeleteDeprecated{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_SetPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_SetPayload_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverwritePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_OverwritePayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_OverwritePayload_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_DeletePayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_DeletePayload_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearPayloadDeprecated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_ClearPayloadDeprecated{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_UpdateVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_UpdateVectors_{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_DeleteVectors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_DeleteVectors_{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_DeletePoints{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_DeletePoints_{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsUpdateOperation_ClearPayload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &PointsUpdateOperation_ClearPayload_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_PointStructList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointStructList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointStructList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &PointStruct{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_SetPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_OverwritePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverwritePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverwritePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_DeletePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_UpdateVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &PointVectors{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_DeleteVectors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVectors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVectors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PointsSelector == nil {
				m.PointsSelector = &PointsSelector{}
			}
			if err := m.PointsSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &VectorsSelector{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_DeletePoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Points == nil {
				m.Points = &PointsSelector{}
			}
			if err := m.Points.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsUpdateOperation_ClearPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Points == nil {
				m.Points = &PointsSelector{}
			}
			if err := m.Points.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKeySelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKeySelector == nil {
				m.ShardKeySelector = &ShardKeySelector{}
			}
			if err := m.ShardKeySelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBatchPoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBatchPoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBatchPoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operations = append(m.Operations, &PointsUpdateOperation{})
			if err := m.Operations[len(m.Operations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordering == nil {
				m.Ordering = &WriteOrdering{}
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsOperationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsOperationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsOperationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &UpdateResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationId", wireType)
			}
			m.OperationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Variant = &OrderValue_Int{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Variant = &OrderValue_Float{float64(math.Float64frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScoredPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScoredPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScoredPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &PointId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &Vectors{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderValue == nil {
				m.OrderValue = &OrderValue{}
			}
			if err := m.OrderValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &GroupId_UnsignedValue{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &GroupId_IntegerValue{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &GroupId_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &GroupId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hits = append(m.Hits, &ScoredPoint{})
			if err := m.Hits[len(m.Hits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lookup == nil {
				m.Lookup = &RetrievedPoint{}
			}
			if err := m.Lookup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &PointGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ScoredPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ScoredPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &BatchResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ScoredPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &BatchResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchGroupsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchGroupsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchGroupsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &GroupsResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &CountResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScrollResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScrollResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScrollResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageOffset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextPageOffset == nil {
				m.NextPageOffset = &PointId{}
			}
			if err := m.NextPageOffset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &RetrievedPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetrievedPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetrievedPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetrievedPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &PointId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &Vectors{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardKey == nil {
				m.ShardKey = &ShardKey{}
			}
			if err := m.ShardKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderValue == nil {
				m.OrderValue = &OrderValue{}
			}
			if err := m.OrderValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &RetrievedPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ScoredPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &BatchResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ScoredPoint{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoverBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoverBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoverBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &BatchResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendGroupsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendGroupsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendGroupsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &GroupsResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &UpdateResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Time = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Should", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Should = append(m.Should, &Condition{})
			if err := m.Should[len(m.Should)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Must", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Must = append(m.Must, &Condition{})
			if err := m.Must[len(m.Must)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustNot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustNot = append(m.MustNot, &Condition{})
			if err := m.MustNot[len(m.MustNot)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinShould", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinShould == nil {
				m.MinShould = &MinShould{}
			}
			if err := m.MinShould.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinShould) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinShould: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinShould: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
			}
			m.MinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FieldCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_Field{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEmpty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsEmptyCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_IsEmpty{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HasIdCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_HasId{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_Filter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IsNullCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_IsNull{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NestedCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConditionOneOf = &Condition_Nested{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsEmptyCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsEmptyCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsEmptyCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsNullCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsNullCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsNullCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasIdCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasIdCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasIdCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HasId = append(m.HasId, &PointId{})
			if err := m.HasId[len(m.HasId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &Match{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoBoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoBoundingBox == nil {
				m.GeoBoundingBox = &GeoBoundingBox{}
			}
			if err := m.GeoBoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoRadius", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoRadius == nil {
				m.GeoRadius = &GeoRadius{}
			}
			if err := m.GeoRadius.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValuesCount == nil {
				m.ValuesCount = &ValuesCount{}
			}
			if err := m.ValuesCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoPolygon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoPolygon == nil {
				m.GeoPolygon = &GeoPolygon{}
			}
			if err := m.GeoPolygon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatetimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatetimeRange == nil {
				m.DatetimeRange = &DatetimeRange{}
			}
			if err := m.DatetimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchValue = &Match_Keyword{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integer", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchValue = &Match_Integer{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MatchValue = &Match_Boolean{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchValue = &Match_Text{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepeatedStrings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchValue = &Match_Keywords{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepeatedIntegers{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchValue = &Match_Integers{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptIntegers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepeatedIntegers{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchValue = &Match_ExceptIntegers{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptKeywords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RepeatedStrings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MatchValue = &Match_ExceptKeywords{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedStrings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedStrings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedStrings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedIntegers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedIntegers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedIntegers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Integers = append(m.Integers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPoints
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPoints
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Integers) == 0 {
					m.Integers = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Integers = append(m.Integers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Integers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lt = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gt = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gte = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lte = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatetimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatetimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatetimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lt == nil {
				m.Lt = &types.Timestamp{}
			}
			if err := m.Lt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gt == nil {
				m.Gt = &types.Timestamp{}
			}
			if err := m.Gt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gte == nil {
				m.Gte = &types.Timestamp{}
			}
			if err := m.Gte.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lte == nil {
				m.Lte = &types.Timestamp{}
			}
			if err := m.Lte.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoBoundingBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoBoundingBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoBoundingBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopLeft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopLeft == nil {
				m.TopLeft = &GeoPoint{}
			}
			if err := m.TopLeft.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomRight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BottomRight == nil {
				m.BottomRight = &GeoPoint{}
			}
			if err := m.BottomRight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoRadius) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoRadius: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoRadius: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Center == nil {
				m.Center = &GeoPoint{}
			}
			if err := m.Center.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoLineString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoLineString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoLineString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &GeoPoint{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoPolygon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoPolygon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoPolygon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exterior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exterior == nil {
				m.Exterior = &GeoLineString{}
			}
			if err := m.Exterior.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interiors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interiors = append(m.Interiors, &GeoLineString{})
			if err := m.Interiors[len(m.Interiors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValuesCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValuesCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValuesCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			m.Lt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			m.Gt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			m.Gte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gte |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			m.Lte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lte |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PointsIdsList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PointsSelectorOneOf = &PointsSelector_Points{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PointsSelectorOneOf = &PointsSelector_Filter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsIdsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsIdsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsIdsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &PointId{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &PointId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPoints
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPoints
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPoints
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPoints
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPoints
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPoints(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPoints
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPoints
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPoints
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vectors == nil {
				m.Vectors = &Vectors{}
			}
			if err := m.Vectors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lon = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPoints(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPoints
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPoints(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPoints
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPoints
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPoints
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPoints
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPoints
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPoints        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPoints          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPoints = fmt.Errorf("proto: unexpected end of group")
)
