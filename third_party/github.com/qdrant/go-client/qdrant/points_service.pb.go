// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qdrant/points_service.proto

package qdrant

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("qdrant/points_service.proto", fileDescriptor_641df6088eb0bef4) }

var fileDescriptor_641df6088eb0bef4 = []byte{
	// 597 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x6d, 0x21, 0x22, 0x58, 0x1a, 0x28, 0x5b, 0xfe, 0xb4, 0x49, 0xd8, 0x4a, 0xb9, 0x93,
	0x48, 0x20, 0x24, 0x4e, 0x48, 0x34, 0x11, 0x51, 0x0f, 0x34, 0x21, 0x55, 0x11, 0x70, 0x41, 0xae,
	0x3d, 0x6a, 0x2c, 0x39, 0x5e, 0xb3, 0xde, 0x04, 0x7a, 0xe3, 0x11, 0x78, 0x0c, 0x1e, 0x85, 0x13,
	0xca, 0xb1, 0x47, 0xe2, 0x5c, 0x38, 0xf6, 0x11, 0x50, 0x76, 0xd7, 0xf6, 0xae, 0x9d, 0x83, 0x23,
	0x71, 0x9c, 0xef, 0x9b, 0xf9, 0xcd, 0xce, 0x68, 0xbd, 0x46, 0xcd, 0x2f, 0x1e, 0x73, 0x42, 0xde,
	0x8d, 0xa8, 0x1f, 0xf2, 0xf8, 0x73, 0x0c, 0x6c, 0xee, 0xbb, 0xd0, 0x89, 0x18, 0xe5, 0x14, 0xd7,
	0xa4, 0xd9, 0xd8, 0x33, 0x92, 0xa4, 0xf9, 0xec, 0x77, 0x1d, 0xd5, 0x46, 0x42, 0xc0, 0xaf, 0x51,
	0xed, 0x2c, 0x8a, 0x81, 0x71, 0xfc, 0xa0, 0x23, 0x53, 0x3b, 0x32, 0x96, 0x7e, 0xe3, 0x30, 0x55,
	0x65, 0x3c, 0x8c, 0x80, 0x39, 0xdc, 0xa7, 0xe1, 0x18, 0xe2, 0x88, 0x86, 0x31, 0xb4, 0xad, 0x35,
	0xa2, 0x0f, 0x01, 0x70, 0xc8, 0x11, 0x32, 0xae, 0x8e, 0xe8, 0xa2, 0x1b, 0x03, 0xe0, 0xf8, 0x7e,
	0x9a, 0x39, 0x80, 0xb4, 0xff, 0x9e, 0x26, 0x69, 0x05, 0x27, 0xa8, 0x7e, 0x16, 0x79, 0x0e, 0x87,
	0xf7, 0xe0, 0x72, 0xca, 0x62, 0xdc, 0xc8, 0x4f, 0xbf, 0x96, 0x45, 0xb5, 0xf2, 0xaa, 0x1c, 0xe0,
	0x04, 0xd5, 0xe5, 0x99, 0x4b, 0x3c, 0x6d, 0x94, 0x2d, 0x78, 0xc7, 0x08, 0x9d, 0x02, 0x1f, 0x39,
	0x97, 0x01, 0x75, 0x3c, 0xbc, 0x9f, 0x16, 0xe4, 0x5a, 0xf5, 0xdd, 0x0c, 0xd1, 0xee, 0x70, 0x0e,
	0xec, 0x2b, 0xf3, 0x39, 0xfc, 0x27, 0xa0, 0x9a, 0x35, 0xa5, 0x35, 0x0b, 0xb3, 0x6e, 0x0b, 0x7c,
	0x8b, 0x76, 0x7a, 0x01, 0x38, 0x2c, 0xe5, 0x65, 0xbb, 0xd3, 0xd5, 0xea, 0xb8, 0x8f, 0x68, 0xb7,
	0xc7, 0xc0, 0xe1, 0xf0, 0xc6, 0x87, 0xc0, 0x3b, 0x0e, 0x3d, 0xf8, 0x86, 0xdb, 0x19, 0xb2, 0xe0,
	0xf4, 0x68, 0x10, 0x80, 0xbb, 0x26, 0x54, 0x44, 0xcb, 0x19, 0x37, 0xa1, 0x8b, 0xce, 0x76, 0xe8,
	0x97, 0xa8, 0x76, 0x0a, 0x0e, 0x73, 0x27, 0xf9, 0x57, 0x20, 0x63, 0x35, 0xf8, 0x23, 0x53, 0xd5,
	0x2a, 0x07, 0xe8, 0x8e, 0xd4, 0x8e, 0x1c, 0xee, 0x4e, 0xf0, 0x81, 0x99, 0x28, 0x44, 0xc5, 0x68,
	0x6e, 0xb0, 0x8c, 0x4b, 0xb7, 0x23, 0x8d, 0x01, 0xa3, 0xb3, 0x28, 0x2e, 0x92, 0x04, 0x44, 0x5a,
	0x8d, 0x96, 0x69, 0x49, 0xb5, 0x30, 0x8d, 0xcb, 0x68, 0x10, 0x68, 0xd3, 0x88, 0xb8, 0x34, 0x8d,
	0x50, 0x8d, 0xd7, 0xe0, 0xf6, 0x18, 0x5c, 0x3a, 0x9d, 0x42, 0xe8, 0xe1, 0xc7, 0x69, 0x5a, 0x26,
	0xa9, 0xfa, 0x83, 0x92, 0xa1, 0x21, 0x46, 0xe8, 0x6e, 0x26, 0xcb, 0x9d, 0xb4, 0x4a, 0xe9, 0xfa,
	0x5a, 0xc8, 0x66, 0x57, 0x23, 0x8e, 0xd1, 0xbd, 0xcc, 0x53, 0xcb, 0x69, 0x6d, 0x3e, 0x9a, 0xda,
	0xcf, 0x61, 0xc9, 0x2d, 0xad, 0xe8, 0x15, 0xba, 0xd5, 0xf7, 0x63, 0x97, 0xce, 0x81, 0xe1, 0x6c,
	0x1d, 0xa9, 0xa2, 0x4e, 0xb6, 0x5f, 0xd4, 0x8d, 0xaf, 0xa6, 0x9e, 0xaa, 0x72, 0xc8, 0x66, 0x31,
	0x59, 0x9f, 0xf1, 0xc9, 0x46, 0x53, 0xc3, 0xbd, 0x40, 0x37, 0x7b, 0x74, 0x16, 0x72, 0x9c, 0xbd,
	0x98, 0x22, 0x54, 0xe5, 0x0f, 0x0d, 0xd1, 0xbc, 0x7c, 0xf2, 0xc5, 0x2c, 0x5c, 0x3e, 0x4d, 0x2c,
	0x5e, 0x3e, 0xcd, 0x32, 0xfb, 0xbf, 0x9b, 0x01, 0xbb, 0xcc, 0xfb, 0x8b, 0xb0, 0xd8, 0x5f, 0x88,
	0x5a, 0x59, 0x1f, 0x21, 0x21, 0xc9, 0xf6, 0xfb, 0x46, 0x9a, 0xde, 0xbd, 0x51, 0x76, 0x72, 0xca,
	0xd1, 0x87, 0xc5, 0x92, 0x58, 0x57, 0x4b, 0x62, 0x5d, 0x2f, 0x89, 0xfd, 0x3d, 0x21, 0xf6, 0xcf,
	0x84, 0xd8, 0xbf, 0x12, 0x62, 0x2f, 0x12, 0x62, 0xff, 0x49, 0x88, 0xfd, 0x37, 0x21, 0xd6, 0x75,
	0x42, 0xec, 0x1f, 0x2b, 0x62, 0x2d, 0x56, 0xc4, 0xba, 0x5a, 0x11, 0xeb, 0x53, 0xfb, 0xc2, 0xe7,
	0x93, 0xd9, 0x79, 0xc7, 0xa5, 0xd3, 0xae, 0xfa, 0x4d, 0x5e, 0xd0, 0xa7, 0x6e, 0xe0, 0x43, 0xc8,
	0x95, 0x70, 0x5e, 0x13, 0x7f, 0xcc, 0xe7, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xdb, 0x80, 0x23,
	0xa0, 0x6d, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PointsClient is the client API for Points service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PointsClient interface {
	Upsert(ctx context.Context, in *UpsertPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	Delete(ctx context.Context, in *DeletePoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	Get(ctx context.Context, in *GetPoints, opts ...grpc.CallOption) (*GetResponse, error)
	UpdateVectors(ctx context.Context, in *UpdatePointVectors, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	DeleteVectors(ctx context.Context, in *DeletePointVectors, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	SetPayload(ctx context.Context, in *SetPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	OverwritePayload(ctx context.Context, in *SetPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	DeletePayload(ctx context.Context, in *DeletePayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	ClearPayload(ctx context.Context, in *ClearPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	CreateFieldIndex(ctx context.Context, in *CreateFieldIndexCollection, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	DeleteFieldIndex(ctx context.Context, in *DeleteFieldIndexCollection, opts ...grpc.CallOption) (*PointsOperationResponse, error)
	Search(ctx context.Context, in *SearchPoints, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchBatch(ctx context.Context, in *SearchBatchPoints, opts ...grpc.CallOption) (*SearchBatchResponse, error)
	SearchGroups(ctx context.Context, in *SearchPointGroups, opts ...grpc.CallOption) (*SearchGroupsResponse, error)
	Scroll(ctx context.Context, in *ScrollPoints, opts ...grpc.CallOption) (*ScrollResponse, error)
	Recommend(ctx context.Context, in *RecommendPoints, opts ...grpc.CallOption) (*RecommendResponse, error)
	RecommendBatch(ctx context.Context, in *RecommendBatchPoints, opts ...grpc.CallOption) (*RecommendBatchResponse, error)
	RecommendGroups(ctx context.Context, in *RecommendPointGroups, opts ...grpc.CallOption) (*RecommendGroupsResponse, error)
	Discover(ctx context.Context, in *DiscoverPoints, opts ...grpc.CallOption) (*DiscoverResponse, error)
	DiscoverBatch(ctx context.Context, in *DiscoverBatchPoints, opts ...grpc.CallOption) (*DiscoverBatchResponse, error)
	Count(ctx context.Context, in *CountPoints, opts ...grpc.CallOption) (*CountResponse, error)
	UpdateBatch(ctx context.Context, in *UpdateBatchPoints, opts ...grpc.CallOption) (*UpdateBatchResponse, error)
	Query(ctx context.Context, in *QueryPoints, opts ...grpc.CallOption) (*QueryResponse, error)
	QueryBatch(ctx context.Context, in *QueryBatchPoints, opts ...grpc.CallOption) (*QueryBatchResponse, error)
}

type pointsClient struct {
	cc *grpc.ClientConn
}

func NewPointsClient(cc *grpc.ClientConn) PointsClient {
	return &pointsClient{cc}
}

func (c *pointsClient) Upsert(ctx context.Context, in *UpsertPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Upsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Delete(ctx context.Context, in *DeletePoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Get(ctx context.Context, in *GetPoints, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) UpdateVectors(ctx context.Context, in *UpdatePointVectors, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/UpdateVectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) DeleteVectors(ctx context.Context, in *DeletePointVectors, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/DeleteVectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) SetPayload(ctx context.Context, in *SetPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/SetPayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) OverwritePayload(ctx context.Context, in *SetPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/OverwritePayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) DeletePayload(ctx context.Context, in *DeletePayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/DeletePayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) ClearPayload(ctx context.Context, in *ClearPayloadPoints, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/ClearPayload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) CreateFieldIndex(ctx context.Context, in *CreateFieldIndexCollection, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/CreateFieldIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) DeleteFieldIndex(ctx context.Context, in *DeleteFieldIndexCollection, opts ...grpc.CallOption) (*PointsOperationResponse, error) {
	out := new(PointsOperationResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/DeleteFieldIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Search(ctx context.Context, in *SearchPoints, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) SearchBatch(ctx context.Context, in *SearchBatchPoints, opts ...grpc.CallOption) (*SearchBatchResponse, error) {
	out := new(SearchBatchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/SearchBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) SearchGroups(ctx context.Context, in *SearchPointGroups, opts ...grpc.CallOption) (*SearchGroupsResponse, error) {
	out := new(SearchGroupsResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/SearchGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Scroll(ctx context.Context, in *ScrollPoints, opts ...grpc.CallOption) (*ScrollResponse, error) {
	out := new(ScrollResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Scroll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Recommend(ctx context.Context, in *RecommendPoints, opts ...grpc.CallOption) (*RecommendResponse, error) {
	out := new(RecommendResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Recommend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) RecommendBatch(ctx context.Context, in *RecommendBatchPoints, opts ...grpc.CallOption) (*RecommendBatchResponse, error) {
	out := new(RecommendBatchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/RecommendBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) RecommendGroups(ctx context.Context, in *RecommendPointGroups, opts ...grpc.CallOption) (*RecommendGroupsResponse, error) {
	out := new(RecommendGroupsResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/RecommendGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Discover(ctx context.Context, in *DiscoverPoints, opts ...grpc.CallOption) (*DiscoverResponse, error) {
	out := new(DiscoverResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Discover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) DiscoverBatch(ctx context.Context, in *DiscoverBatchPoints, opts ...grpc.CallOption) (*DiscoverBatchResponse, error) {
	out := new(DiscoverBatchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/DiscoverBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Count(ctx context.Context, in *CountPoints, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Count", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) UpdateBatch(ctx context.Context, in *UpdateBatchPoints, opts ...grpc.CallOption) (*UpdateBatchResponse, error) {
	out := new(UpdateBatchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/UpdateBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) Query(ctx context.Context, in *QueryPoints, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointsClient) QueryBatch(ctx context.Context, in *QueryBatchPoints, opts ...grpc.CallOption) (*QueryBatchResponse, error) {
	out := new(QueryBatchResponse)
	err := c.cc.Invoke(ctx, "/qdrant.Points/QueryBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PointsServer is the server API for Points service.
type PointsServer interface {
	Upsert(context.Context, *UpsertPoints) (*PointsOperationResponse, error)
	Delete(context.Context, *DeletePoints) (*PointsOperationResponse, error)
	Get(context.Context, *GetPoints) (*GetResponse, error)
	UpdateVectors(context.Context, *UpdatePointVectors) (*PointsOperationResponse, error)
	DeleteVectors(context.Context, *DeletePointVectors) (*PointsOperationResponse, error)
	SetPayload(context.Context, *SetPayloadPoints) (*PointsOperationResponse, error)
	OverwritePayload(context.Context, *SetPayloadPoints) (*PointsOperationResponse, error)
	DeletePayload(context.Context, *DeletePayloadPoints) (*PointsOperationResponse, error)
	ClearPayload(context.Context, *ClearPayloadPoints) (*PointsOperationResponse, error)
	CreateFieldIndex(context.Context, *CreateFieldIndexCollection) (*PointsOperationResponse, error)
	DeleteFieldIndex(context.Context, *DeleteFieldIndexCollection) (*PointsOperationResponse, error)
	Search(context.Context, *SearchPoints) (*SearchResponse, error)
	SearchBatch(context.Context, *SearchBatchPoints) (*SearchBatchResponse, error)
	SearchGroups(context.Context, *SearchPointGroups) (*SearchGroupsResponse, error)
	Scroll(context.Context, *ScrollPoints) (*ScrollResponse, error)
	Recommend(context.Context, *RecommendPoints) (*RecommendResponse, error)
	RecommendBatch(context.Context, *RecommendBatchPoints) (*RecommendBatchResponse, error)
	RecommendGroups(context.Context, *RecommendPointGroups) (*RecommendGroupsResponse, error)
	Discover(context.Context, *DiscoverPoints) (*DiscoverResponse, error)
	DiscoverBatch(context.Context, *DiscoverBatchPoints) (*DiscoverBatchResponse, error)
	Count(context.Context, *CountPoints) (*CountResponse, error)
	UpdateBatch(context.Context, *UpdateBatchPoints) (*UpdateBatchResponse, error)
	Query(context.Context, *QueryPoints) (*QueryResponse, error)
	QueryBatch(context.Context, *QueryBatchPoints) (*QueryBatchResponse, error)
}

// UnimplementedPointsServer can be embedded to have forward compatible implementations.
type UnimplementedPointsServer struct {
}

func (*UnimplementedPointsServer) Upsert(ctx context.Context, req *UpsertPoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upsert not implemented")
}
func (*UnimplementedPointsServer) Delete(ctx context.Context, req *DeletePoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedPointsServer) Get(ctx context.Context, req *GetPoints) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedPointsServer) UpdateVectors(ctx context.Context, req *UpdatePointVectors) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVectors not implemented")
}
func (*UnimplementedPointsServer) DeleteVectors(ctx context.Context, req *DeletePointVectors) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVectors not implemented")
}
func (*UnimplementedPointsServer) SetPayload(ctx context.Context, req *SetPayloadPoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPayload not implemented")
}
func (*UnimplementedPointsServer) OverwritePayload(ctx context.Context, req *SetPayloadPoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OverwritePayload not implemented")
}
func (*UnimplementedPointsServer) DeletePayload(ctx context.Context, req *DeletePayloadPoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePayload not implemented")
}
func (*UnimplementedPointsServer) ClearPayload(ctx context.Context, req *ClearPayloadPoints) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearPayload not implemented")
}
func (*UnimplementedPointsServer) CreateFieldIndex(ctx context.Context, req *CreateFieldIndexCollection) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFieldIndex not implemented")
}
func (*UnimplementedPointsServer) DeleteFieldIndex(ctx context.Context, req *DeleteFieldIndexCollection) (*PointsOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFieldIndex not implemented")
}
func (*UnimplementedPointsServer) Search(ctx context.Context, req *SearchPoints) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedPointsServer) SearchBatch(ctx context.Context, req *SearchBatchPoints) (*SearchBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchBatch not implemented")
}
func (*UnimplementedPointsServer) SearchGroups(ctx context.Context, req *SearchPointGroups) (*SearchGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchGroups not implemented")
}
func (*UnimplementedPointsServer) Scroll(ctx context.Context, req *ScrollPoints) (*ScrollResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scroll not implemented")
}
func (*UnimplementedPointsServer) Recommend(ctx context.Context, req *RecommendPoints) (*RecommendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recommend not implemented")
}
func (*UnimplementedPointsServer) RecommendBatch(ctx context.Context, req *RecommendBatchPoints) (*RecommendBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecommendBatch not implemented")
}
func (*UnimplementedPointsServer) RecommendGroups(ctx context.Context, req *RecommendPointGroups) (*RecommendGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecommendGroups not implemented")
}
func (*UnimplementedPointsServer) Discover(ctx context.Context, req *DiscoverPoints) (*DiscoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Discover not implemented")
}
func (*UnimplementedPointsServer) DiscoverBatch(ctx context.Context, req *DiscoverBatchPoints) (*DiscoverBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverBatch not implemented")
}
func (*UnimplementedPointsServer) Count(ctx context.Context, req *CountPoints) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (*UnimplementedPointsServer) UpdateBatch(ctx context.Context, req *UpdateBatchPoints) (*UpdateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBatch not implemented")
}
func (*UnimplementedPointsServer) Query(ctx context.Context, req *QueryPoints) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedPointsServer) QueryBatch(ctx context.Context, req *QueryBatchPoints) (*QueryBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryBatch not implemented")
}

func RegisterPointsServer(s *grpc.Server, srv PointsServer) {
	s.RegisterService(&_Points_serviceDesc, srv)
}

func _Points_Upsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Upsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Upsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Upsert(ctx, req.(*UpsertPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Delete(ctx, req.(*DeletePoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Get(ctx, req.(*GetPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_UpdateVectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePointVectors)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).UpdateVectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/UpdateVectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).UpdateVectors(ctx, req.(*UpdatePointVectors))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_DeleteVectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePointVectors)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).DeleteVectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/DeleteVectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).DeleteVectors(ctx, req.(*DeletePointVectors))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_SetPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPayloadPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).SetPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/SetPayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).SetPayload(ctx, req.(*SetPayloadPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_OverwritePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPayloadPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).OverwritePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/OverwritePayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).OverwritePayload(ctx, req.(*SetPayloadPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_DeletePayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePayloadPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).DeletePayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/DeletePayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).DeletePayload(ctx, req.(*DeletePayloadPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_ClearPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearPayloadPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).ClearPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/ClearPayload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).ClearPayload(ctx, req.(*ClearPayloadPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_CreateFieldIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFieldIndexCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).CreateFieldIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/CreateFieldIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).CreateFieldIndex(ctx, req.(*CreateFieldIndexCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_DeleteFieldIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFieldIndexCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).DeleteFieldIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/DeleteFieldIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).DeleteFieldIndex(ctx, req.(*DeleteFieldIndexCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Search(ctx, req.(*SearchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_SearchBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchBatchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).SearchBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/SearchBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).SearchBatch(ctx, req.(*SearchBatchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_SearchGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchPointGroups)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).SearchGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/SearchGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).SearchGroups(ctx, req.(*SearchPointGroups))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Scroll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScrollPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Scroll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Scroll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Scroll(ctx, req.(*ScrollPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Recommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Recommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Recommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Recommend(ctx, req.(*RecommendPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_RecommendBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendBatchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).RecommendBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/RecommendBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).RecommendBatch(ctx, req.(*RecommendBatchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_RecommendGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendPointGroups)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).RecommendGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/RecommendGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).RecommendGroups(ctx, req.(*RecommendPointGroups))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Discover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Discover(ctx, req.(*DiscoverPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_DiscoverBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverBatchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).DiscoverBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/DiscoverBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).DiscoverBatch(ctx, req.(*DiscoverBatchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Count",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Count(ctx, req.(*CountPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_UpdateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBatchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).UpdateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/UpdateBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).UpdateBatch(ctx, req.(*UpdateBatchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).Query(ctx, req.(*QueryPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Points_QueryBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBatchPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointsServer).QueryBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qdrant.Points/QueryBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointsServer).QueryBatch(ctx, req.(*QueryBatchPoints))
	}
	return interceptor(ctx, in, info, handler)
}

var _Points_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qdrant.Points",
	HandlerType: (*PointsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upsert",
			Handler:    _Points_Upsert_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Points_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Points_Get_Handler,
		},
		{
			MethodName: "UpdateVectors",
			Handler:    _Points_UpdateVectors_Handler,
		},
		{
			MethodName: "DeleteVectors",
			Handler:    _Points_DeleteVectors_Handler,
		},
		{
			MethodName: "SetPayload",
			Handler:    _Points_SetPayload_Handler,
		},
		{
			MethodName: "OverwritePayload",
			Handler:    _Points_OverwritePayload_Handler,
		},
		{
			MethodName: "DeletePayload",
			Handler:    _Points_DeletePayload_Handler,
		},
		{
			MethodName: "ClearPayload",
			Handler:    _Points_ClearPayload_Handler,
		},
		{
			MethodName: "CreateFieldIndex",
			Handler:    _Points_CreateFieldIndex_Handler,
		},
		{
			MethodName: "DeleteFieldIndex",
			Handler:    _Points_DeleteFieldIndex_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Points_Search_Handler,
		},
		{
			MethodName: "SearchBatch",
			Handler:    _Points_SearchBatch_Handler,
		},
		{
			MethodName: "SearchGroups",
			Handler:    _Points_SearchGroups_Handler,
		},
		{
			MethodName: "Scroll",
			Handler:    _Points_Scroll_Handler,
		},
		{
			MethodName: "Recommend",
			Handler:    _Points_Recommend_Handler,
		},
		{
			MethodName: "RecommendBatch",
			Handler:    _Points_RecommendBatch_Handler,
		},
		{
			MethodName: "RecommendGroups",
			Handler:    _Points_RecommendGroups_Handler,
		},
		{
			MethodName: "Discover",
			Handler:    _Points_Discover_Handler,
		},
		{
			MethodName: "DiscoverBatch",
			Handler:    _Points_DiscoverBatch_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Points_Count_Handler,
		},
		{
			MethodName: "UpdateBatch",
			Handler:    _Points_UpdateBatch_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _Points_Query_Handler,
		},
		{
			MethodName: "QueryBatch",
			Handler:    _Points_QueryBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qdrant/points_service.proto",
}
